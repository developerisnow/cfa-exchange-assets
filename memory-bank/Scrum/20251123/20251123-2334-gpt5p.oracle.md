1. SESSION_EVAL
   (эпик Swagger / AsyncAPI / Kafka на ветке `codex/fix-cfa1-regressions`, агент 019aa5f8‑8c38 + хвост работы из d792)

* **completeness_score:** **65/100**
* **accuracy_score:** **80/100**
* **progress_pct:** **70%**

**summary_by_phase**

* **Phase 0 – Setup & контекст**

  * Репозиторий `ois-cfa` синхронизирован, рабочая ветка `codex/fix-cfa1-regressions` активна, найдено текущее состояние Swagger/AsyncAPI и Kafka на CFA1, просмотрены Program/appsettings для сервисов и контракты.
  * Оценка: ~100%.

* **Phase 1 – Swagger inventory & docs**

  * Создан и заполнен `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md` с таблицей по всем ключевым сервисам (gateway, identity, issuance, registry, settlement, compliance, bank-nominal), отдельно dev и CFA1, плюс политика защиты (internal/basic auth), описана веточная политика (`develop` vs `infra.defis.deploy`).
  * Оценка: ~90% (инвентарь есть, но ещё не отражает финальное Prod+Kafka состояние).

* **Phase 2 – Swagger runtime + e2e**

  * В код добавлен флаг `Swagger:Enabled` для identity/issuance/registry/settlement/compliance, по умолчанию включён в `appsettings` для демо; gateway уже умел.
  * На CFA1 все сервисы поднимались в Dev-режиме с отключённой Kafka (или с костылём `Kafka__Enabled=false`), Swagger возвращал 200 по портам 55001/05/06/07/08; создан/запущен Playwright сценарий `swagger-all-services.spec.ts`.
  * Но попытка перейти к более “правильному” режиму (Production + Swagger__Enabled=true + Kafka on) ломала запуск `issuance-service`/`compliance-service` из-за `MassTransit.IBus` (DI/конфиг), пришлось откатиться.
  * Оценка: ~70% (Swagger работает, но на Dev+Kafka off, финальный сценарий ещё не закреплён).

* **Phase 3 – AsyncAPI & spec-пайплайн**

  * `packages/contracts/asyncapi.yaml` провалидирован через `@asyncapi/cli`, предупреждения только про id/tags/messageId.
  * Есть общий `scripts/spec-validate.sh`-подход: Spectral для OpenAPI, AsyncAPI CLI, AJV для JSON Schemas.
  * Но нет полного e2e: “есть событие → попадает в брокер → соответствует AsyncAPI” в автоматизированных тестах.
  * Оценка: ~75% по tooling, ~50% по фактическому покрытию → условно ~60%.

* **Phase 4 – Kafka / MassTransit / events**

  * Код домена уже генерит события (например, `ois.issuance.published`/`ois.issuance.closed` через outbox).
  * При попытке включить Kafka/Bus на CFA1 сервисы (`issuance`, `compliance`) падали на стадии DI из‑за отсутствия корректного `IBus`/конфига.
  * Временное решение — отключать Kafka на рантайме, чтобы хотя бы Swagger и HTTP работали. Финальный дизайн включения Kafka (без крашей) и привязка к AsyncAPI явно не доведены до DoD. 
  * Оценка: ~40%.

* **Phase 5 – DoD/tasks/CHANGELOG**

  * Обновлён CHANGELOG: зафиксированы Swagger-флаги, зелёные Swagger e2e (в Dev‑режиме), AsyncAPI validation, ссылки на NX‑05..08/Playwright.
  * tasks/NX‑05..08 и docs по NX‑07/08 уже неплохо отражают состояние CFA1 (KYC, audit, payout schedule, Swagger/AsyncAPI), но Kafka‑часть и “честное” состояние Prod+Kafka не финализированы.
  * Оценка: ~70%.

**Итого по эпику Swagger/AsyncAPI/Kafka:**

* Объективно сделано много (флаг Swagger, инвентарь, e2e Swagger, AsyncAPI tooling, обновлённые docs), но:

  * финальный режим “Prod + Swagger:Enabled=true + Kafka on (или хотя бы корректно off по флагу) + зелёные e2e” не доведён;
  * Kafka/IBus остаётся основным блокером;
  * develop-ветка с изменениями Ильи пока не учтена (ребейз/мердж явно отменён и отдан на Илью).

Поэтому твоя реплика “эпик доделать остаётся, swagger/asyncapi он не может нормально доделать и поднять” — по сути точна: эпик закрыт процентов на 65–70, но не на 100.

---

2. REQUIREMENTS_FROM_VOICE

(фокус — твои новые голосовые/чат‑инструкции про merge, Kafka и новый агент)

**explicit_requirements**

* **“Как бы мерджить не будем”**

  * Ветка работы остаётся `codex/fix-cfa1-regressions`.
  * Любые `git rebase/merge` с `develop` (где работает Илья и “всё чинит/унифицирует UI”) **запрещены** для Codex‑агента в этом эпике. Конфликты и финальное слияние — зона ответственности Ильи. 

* **Эпик Swagger/AsyncAPI надо довести до ума новым агентом**

  * Текущий результат по Swagger/AsyncAPI/Kafka — недостаточен; нужен свежий цикл на новом агенте с явным контрактом и фокусом на завершение.

* **Kafka: “я хз, стоит ли, сможем доделать; дай инструкции”**

  * Ты не уверен, насколько реально дожать Kafka сейчас; агент должен:

    * либо вывести Kafka в работоспособный и некрашащийся режим,
    * либо честно сформулировать ограничения и финальные инструкции “как доделать” (для тебя/Ильи/следующего агента), а не прятать проблему.

* **Высокая автономия для агента**

  * “Сделай всё наилучшим образом как считаешь нужным … может и Kafka сделай, если считаешь ничего такого там нет”.
  * Т.е. агент имеет право принимать технические решения в рамках Dev/Staging среды без постоянных запросов к тебе, пока не нарушает контракт по ветке/безопасности.

* **Контекст агента ограничен (~33%)**

  * Новый Codex‑агент не может держать весь прошлый контекст; нужно работать по “сжатому” снапшоту `memory-bank/context-snapshots-composed/sessions-agents/eywa1-p-cfa-w16.p1-20251123-2311.session.txt` и минимальному набору ключевых файлов (swagger‑доки, Program.cs, AsyncAPI, тесты).

---

**implicit_requirements**

* Финальное состояние по Swagger должно быть **конфигурационным**, а не завязанным на Dev‑режим:

  * `Swagger:Enabled=true` + защита через nginx/basic auth/IP;
  * возможность держать Kafka включённой (или честно выключенной через флаг), не ломая сервисы.

* Kafka не должна ломать запуск сервисов по DI (`MassTransit.IBus`), даже если брокер временно недоступен. Нужен либо корректный bus‑конфиг, либо флаг/ветка кода, отключающая Kafka‑зависимые фоновые воркеры.

* AsyncAPI должен быть не просто “валиден”, а **не лгать**: ключевые события (`ois.issuance.published`, audit, KYC) в коде/Outbox должны соответствовать описанным в AsyncAPI топикам/сообщениям, хотя бы для одного end‑to‑end сценария.

* E2E‑тесты по Swagger должны быть зелёными в режиме, который максимально похож на будущий Prod (а не только на Dev+Kafka off).

* Рефакторинг UI/SDK, сделанный Ильёй в `develop`, считается “истиной будущего”, но:

  * текущий агент его **не мержит**;
  * максимум — читает как reference при изменении контрактов/Swagger/AsyncAPI, чтобы не сломать концептуальное согласование.

---

**corrections**

* **Коррекция JTBD по Git:**

  * Ранее у агента был job/JTBD про “разрулить ребейз/мердж на develop”. Сейчас это **убрано из scope**:

    * любые rebase/merge — отданы Илье;
    * агент должен явно считать это внешним блокером и не трогать историю ветки. 

* **Коррекция ожиданий по Kafka:**

  * Первичный план “Prod + Kafka on + Swagger on + зелёные e2e сейчас же” оказался слишком оптимистичным.
  * Новый план: минимально стабильный путь (Swagger через флаг, Kafka не крашит сервисы, хотя бы один рабочий event‑флоу), а не идеальная прод‑топология любой ценой.

---

**suggestions**

(то, что логично добавить в спецификацию для нового агента)

* Ввести/использовать **единый флаг** `Kafka:Enabled` (или уже существующий `Kafka__Enabled`) как “источник правды” для:

  * регистрации MassTransit bus’а,
  * регистрации OutboxPublisher/consumer’ов,
  * health‑checks.
    Если `Kafka:Enabled=false` — сервис стартует, HTTP+Swagger работают, события складываются в outbox, но не публикуются.

* В AsyncAPI зафиксировать **минимальный набор событий**, который реально существует в коде (issuance published/closed, KYC decision, audit event), и привязать CLI‑валидацию к CI, чтобы рассинхрон ловился автоматически.

* В `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md` поднять версию до 1.0.x и добавить секции:

  * “Runtime modes matrix” (Dev/Staging/Prod: Swagger/Kafka/Mocks on/off),
  * “How to switch Swagger/Kafka safely on CFA1” — со списком docker/env команд.

* При ограниченном контексте для агента явно отдавать ему **только ключевые файлы**:

  * `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md`
  * `packages/contracts/asyncapi.yaml` + spec-validate script
  * `services/*/Program.cs` и `appsettings*.json` для compliance/issuance/settlement/registry/identity
  * Playwright tests: `swagger-availability.spec.ts`, `swagger-all-services.spec.ts`
  * задачи NX‑05..08 (как источник требований).

---

3. UPDATED_JTBD_CONTRACT

(обновлённый контракт именно под новый раунд по Swagger/AsyncAPI/Kafka, с учётом “мерджить не будем” и ограниченного контекста)

**jobs**

* **J0: Sanity‑check предыдущих фиксов на ветке `codex/fix-cfa1-regressions`**

  * Убедиться, что текущие изменения Swagger/AsyncAPI/NX‑05..08 из предыдущих сессий собираются и проходят тесты локально (`dotnet test services/compliance`, базовые Playwright‑спеки).

* **J1: Swagger epic (REST‑сервисы)**

  * Довести флаг `Swagger:Enabled` во всех ключевых сервисах до рабочего состояния: gateway, identity, issuance, registry, settlement, compliance.
  * Добиться стабильных 200 по `/swagger/index.html` на Dev и CFA1 **без** принудительного Dev‑режима (используя `Swagger__Enabled=true` и при необходимости `DisableHttpsRedirection=true`).
  * Обновить Playwright‑тесты по Swagger так, чтобы:

    * `swagger-availability.spec.ts` проверял gateway,
    * `swagger-all-services.spec.ts` проверял все сервисы,
    * и они были зелёными в целевом режиме (не только Dev+Kafka off).

* **J2: Kafka & AsyncAPI baseline**

  * Стабилизировать запуск сервисов с Kafka с точки зрения DI/MassTransit:

    * никакого `Unable to resolve service for type 'MassTransit.IBus'`,
    * ввод/использование флага `Kafka:Enabled` / `Kafka__Enabled` для управления регистрацией шины и воркеров.
  * Для **минимум одного** доменного события (предпочтительно `ois.issuance.published` или KYC decision):

    * убедиться, что оно попадает в outbox,
    * при включённой Kafka — реально уходит в брокер (на уровне логов/топиков),
    * обновить AsyncAPI так, чтобы топик и payload соответствовали реальному событию.
  * Обновить инструментальную часть (spec‑validate скрипт/CI), чтобы AsyncAPI проверялся так же строго, как OpenAPI.

* **J3: Docs / DoD / задачи**

  * Обновить `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md` до версии 1.0.x:

    * зафиксировать финальное состояние Swagger/AsyncAPI на dev и CFA1,
    * описать Runtime modes matrix (Dev/Staging/Prod),
    * добавить раздел “Kafka & events status”.
  * В `tasks/NX-05..08-*.md` и CHANGELOG:

    * честно зафиксировать состояние по Swagger/AsyncAPI/Kafka (что реально работает на CFA1, а что нет),
    * добавить команды тестов (`dotnet test`, `npx playwright test ...`),
    * добавить ссылки на артефакты (скрины Playwright, логи спеки/деплоя).

*(Git‑align с `develop` специально **не включён** в jobs — это отдельная работа Ильи.)*

---

**DoD (cross‑JTBD)**

* Для каждого J* минимум **один осмысленный коммит** вида:
  `{code-change} + {code-test} + {test-artifacts/output} + {update-docs-DoD-Kickoff-checkboxes}`.
* Все модифицированные сервисы (.NET) собираются и стартуют без красных ошибок (как минимум `services/compliance`, а также те, где меняются Swagger/Kafka).
* Тесты:

  * min. один `dotnet test` по backend (сейчас — `services/compliance`; опционально ещё issuance/settlement при изменениях там). 
  * min. один e2e/Playwright прогон по Swagger и один — по бизнес‑флоу (из уже существующих NX‑спек).
* `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md`, `tasks/NX-05..08-*.md`, CHANGELOG содержат:

  * актуальные URL/HTTP‑коды по dev и CFA1,
  * матрицу режимов (Swagger/Kafka для Dev/Staging/Prod),
  * команды тестов и ссылки на артефакты,
  * честные “Verified/Blocked” по Kafka/AsyncAPI.

---

**constraints**

* Ветка: **только** `codex/fix-cfa1-regressions`.

  * Никаких `git rebase/merge` с `develop`.
  * `develop` можно только читать как reference. Конфликты — ответственность Ильи. 

* Envs:

  * `uk1` — **read‑only**, не трогать.
  * Рабочая среда — `cfa1` (допускается перезапуск контейнеров, изменение env‑переменных и т.п., но не разрушать то, что явно нужно демо). 

* Kafka:

  * Нельзя оставлять сервисы в состоянии, когда они не стартуют из‑за DI/IBus.
  * Если полноценная Kafka‑интеграция не успевает — допускается режим `Kafka__Enabled=false` с честным описанием и TODO в docs/DoD (но не скрывать проблему).

* Контекст агента:

  * не более ~33% промпта;
  * в первую очередь нужно подгружать:

    * `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md`,
    * `packages/contracts/asyncapi.yaml`, spec‑validate‑скрипты,
    * `services/*/Program.cs` + `appsettings*.json` для затронутых сервисов,
    * Swagger‑Playwright‑тесты,
    * релевантные tasks NX‑05..08,
    * твой consolidated snapshot `...2311.session.txt` как контекст прошлых решений.

---

4. AGENT_PROMPT (for Codex‑Cli)

<<<скопируй текст ниже в нового Codex‑агента>>>

You are a Senior .NET 9 + Next.js + Playwright + DevOps engineer and my "digital twin".

**Project:** OIS‑CFA (multi‑service: issuer / investor / backoffice, contracts‑first with OpenAPI/AsyncAPI, YARP gateway).
**Target envs:**

* Reference: **uk1** – DO NOT TOUCH (read‑only, for comparison only).
* Working demo: **cfa1** (`*.cfa1.llmneighbors.com`: issuer/investor/backoffice/auth/api).

**Branch policy:**

* Your working branch: `codex/fix-cfa1-regressions`.
* Integration branch: `develop` (lives its own life, Ilya is working there).
* **Forbidden:** any `git merge` / `git rebase` of `develop` into `codex/fix-cfa1-regressions`.

  * You may **read** `develop` as reference, but not modify history of your branch.
  * Conflicts with `develop` will be resolved later by humans (primarily Ilya).

---

### JTBD CONTRACT (this session)

**J0 – Sanity‑check existing work**

* Confirm current state of `codex/fix-cfa1-regressions` is buildable and tests are not obviously broken:

  * `PATH=$HOME/.dotnet:$PATH dotnet test services/compliance/compliance.csproj`
  * At least one existing Playwright spec (e.g. one NX‑flow or Swagger spec) passes.

**J1 – Swagger epic (REST services)**

Goal: all core services expose Swagger via config **without** hard‑wiring Dev environment.

* Services:

  * `apps/api-gateway`
  * `services/identity`
  * `services/issuance`
  * `services/registry`
  * `services/settlement`
  * `services/compliance`
* Code:

  * Use existing `Swagger:Enabled` flag in Program/appsettings; add it where missing.
  * Ensure that when `Swagger:Enabled=true`, each service serves `/swagger/index.html` with HTTP 200, even in `ASPNETCORE_ENVIRONMENT=Production`.
* Envs:

  * Dev/local: HTTP 200 on `http://localhost:{port}/swagger/index.html`.
  * CFA1: HTTP 200 on:

    * gateway: `https://api.cfa1.llmneighbors.com/swagger/index.html`
    * core services via IP: `http://87.249.49.56:{55001,55005,55006,55007,55008}/swagger/index.html`.
* Tests:

  * Keep/adjust Playwright specs:

    * `tests/e2e-playwright/tests/swagger-availability.spec.ts` – checks gateway swagger.
    * `tests/e2e-playwright/tests/swagger-all-services.spec.ts` – checks all core services.
  * Target: those specs are **green** in your final configuration (no Dev‑only hacks).

**J2 – Kafka & AsyncAPI baseline**

Goal: Kafka does not crash services, and at least one real event flow matches AsyncAPI.

* Services: focus on at least `services/issuance` and `services/compliance`.
* Config:

  * Introduce/use a clear flag (e.g. `Kafka:Enabled` / `Kafka__Enabled`) to control:

    * MassTransit bus registration;
    * background publishers/consumers (e.g. OutboxPublisher).
  * When `Kafka:Enabled=false`:

    * service must start cleanly (no `Unable to resolve service for type 'MassTransit.IBus'`);
    * HTTP+Swagger keep working;
    * outbox may collect events without actually publishing.
* Minimal event flow (pick one and implement end‑to‑end):

  * Example candidate: `ois.issuance.published` (when an issuance is published).
  * Requirements:

    * Event is written to outbox with clear payload structure.
    * When Kafka is enabled and broker is reachable, event is actually published (verify via logs/console or Kafka tooling).
    * `packages/contracts/asyncapi.yaml` describes the exact topic and payload of that event.
* Tooling:

  * Reuse/extend existing `spec-validate` script (Spectral + AsyncAPI CLI + AJV) so that AsyncAPI is validated in the same way as OpenAPI/JSON Schemas.

**J3 – Docs / DoD / tasks**

Goal: close the Swagger/AsyncAPI/Kafka epic from docs/DoD perspective.

* `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md`:

  * Upgrade to version `1.0.x`.
  * For each service: dev & CFA1 Swagger URLs + HTTP codes + protection (VPN/SSH tunnel / nginx basic auth / IP allowlist).
  * Add “Runtime modes matrix” (Dev/Staging/Prod vs Swagger/Kafka/mocks).
  * Add a short “Kafka & events status” section (what works, what is disabled and why).
* `tasks/NX-05..08-*.md`:

  * Update “Current status on CFA1” with dates and HTTP codes.
  * Explicitly mention which Swagger endpoints and AsyncAPI topics are verified.
  * Mark important items as `Verified` / `Blocked` with one‑line reasons.
* `CHANGELOG.md`:

  * Architecture/QA section:

    * mention Swagger flags and inventory doc,
    * mention AsyncAPI validation and minimal event flow,
    * list test commands run (`dotnet test`, `npx playwright test ...`) and links to artifacts (screenshots/logs).

---

### WORKFLOW CONTRACT (loop you must follow)

1. **PLAN**

   * Compare current state with this JTBD & DoD.
   * Draft a mini‑plan for the next 1–3 actions in the form:
     `{code-change} → {tests} → {docs/DoD-update} → {commit}`.

2. **EXECUTE**

   * Implement code changes (small, focused).
   * Run relevant tests:

     * `dotnet test` for affected backend projects;
     * Playwright specs for Swagger and one business flow (from existing NX specs).
   * Update docs/tasks/DoD:

     * `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md`
     * relevant `tasks/NX-*.md`
     * `CHANGELOG.md`.

3. **AUDIT SELF**

   * Explicitly check the “Common Agentic Problems” list:

     * Did you actually run relevant tests (including e2e/Playwright)?
     * Did you verify against **real** or close-to-real env (cfa1, not just mocks)?
     * Did you avoid silent fallbacks?
     * Are blockers explained honestly?

4. **CONTINUE OR STOP**

   * If DoD is not fully closed and no hard blockers exist — **repeat another loop** without asking the user.
   * If DoD is closed or you hit a hard blocker you cannot bypass (e.g. infra limitation) — stop and produce a detailed report:

     * what changed (files, commits),
     * which tests ran and their results,
     * current state on CFA1 (URLs/HTTP codes),
     * clear blockers and suggested next steps.

---

### CONSTRAINTS & ASSUMPTIONS

* **Git:**

  * Work **only** on `codex/fix-cfa1-regressions`.
  * NO `git merge` / `git rebase` with `develop`.
  * You may `git log`/`git diff` against `develop` just to see what changed, but do not alter history.

* **Environments:**

  * `uk1` is read‑only (for comparison only).
  * `cfa1` is your playground for Swagger/Kafka validation:

    * You are allowed to restart containers and change env vars, as long as you keep system usable for demo.
    * If you change envs (Dev/Prod, flags), document exactly what you did.

* **Kafka:**

  * Do NOT leave services broken due to MassTransit/IBus DI issues.
  * It is acceptable for this epic to end with Kafka disabled via a config flag on CFA1, as long as:

    * the code supports Kafka properly,
    * AsyncAPI is aligned with the code,
    * docs clearly state that Kafka is currently off in this env and what is needed to enable it.

* **Context limitation (~33%)**
  Prioritize loading:

  * `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md`
  * `packages/contracts/asyncapi.yaml` + spec‑validation scripts
  * `services/*/Program.cs` + `appsettings*.json` for compliance/issuance/settlement/registry/identity
  * Swagger Playwright specs
  * relevant `tasks/NX-05..08-*.md`
  * the compressed session snapshot `memory-bank/context-snapshots-composed/sessions-agents/eywa1-p-cfa-w16.p1-20251123-2311.session.txt`.

If something is underspecified, make a **reasonable assumption**, write it down in a small `ASSUMPTIONS` block in the relevant task/doc, and continue implementation without asking the user (unless you hit a hard blocker).

---

### EXPECTED CLI BEHAVIOUR

For almost every meaningful action, show:

* what you read/ran (e.g. `cat`, `grep`, `curl`, `dotnet test`, `npx playwright test ...`),
* what you changed (short `git diff --stat`),
* how you verified (URLs, HTTP codes, test output, screenshot paths).

On errors (build/test/deploy):

* capture the exact error output,
* either fix it or clearly document it as a blocking issue in tasks/docs/DoD,
* NEVER silently comment out important code; if you must, leave a clear `// TODO: FIX BUILD (reason)` and mention it in the task/CHANGELOG.

---

At the end of the session, produce:

* A bullet list of steps completed for each JTBD (J0–J3).
* A list of demo URLs on `*.cfa1.llmneighbors.com` and their HTTP codes.
* A list of commands you actually ran (with env vars) for tests (`dotnet`, `npm`, `npx playwright`).
* A short list of changed files and commits per JTBD.

And include the following block **as-is** in your final message:

```markdown
FINAL SELF-CHECK (обязателен перед завершением сессии)

- [ ] QA: все изменения покрыты тестами (unit/e2e/Playwright, если применимо)
- [ ] Тесты прогнаны на реальных/приближенных к реальным данным
- [ ] Падения/регрессии явно зафиксированы, нет «тихого» фоллбэка
- [ ] Честно описаны блокеры ("невозможно реализовать, потому что …")
- [ ] Git: сделан(ы) осмысленный(е) commit(ы) формата:
      {code-change} + {code-test} + {test-artifacts/output} + {update-docs-DoD-Kickoff-checkboxes}
```

Do NOT consider your work done until you can honestly tick all boxes (or explicitly explain why a box cannot be ticked due to a hard external blocker).

<<<конец AGENT_PROMPT>>>

---

5. NEXT_STEPS_FOR_HUMAN

Что тебе, как оркестратору, сделать до запуска нового агента и после:

**До запуска**

* [ ] Убедиться, что в рабочем каталоге выбран `codex/fix-cfa1-regressions`, а не `develop`.
* [ ] Подготовить для Codex‑агента “узкий” контекст:

  * `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md`
  * `packages/contracts/asyncapi.yaml` + скрипт spec‑валидации
  * `services/*/Program.cs` и `appsettings*.json` для затрагиваемых сервисов
  * Playwright‑спеки по Swagger
  * tasks `NX-05..08-*.md`
  * snapshot `...2311.session.txt` (как summary прошлых сессий).
* [ ] В Codex‑CLI создать новый агент и скопировать туда блок **AGENT_PROMPT** целиком.

**После работы агента**

* [ ] Проверить `git status` и `git log` – что именно он поменял, нет ли случайных мерджей/ребейзов с `develop`.
* [ ] Просмотреть `docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md`, `CHANGELOG.md` и tasks/NX‑05..08 – действительно ли там отражено текущее состояние Swagger/AsyncAPI/Kafka.
* [ ] На CFA1 руками проверить:

  * gateway: `https://api.cfa1.llmneighbors.com/swagger/index.html`
  * IP: `http://87.249.49.56:{55001,55005,55006,55007,55008}/swagger/index.html`
  * что они дают (200/404/301) и совпадает ли с тем, что написал агент.
* [ ] Прогнать хотя бы раз те же команды тестов, которые агент указал (1× `dotnet test`, 1× Playwright по Swagger).
* [ ] Если Kafka в итоге оставлена выключенной флагом, убедиться, что это явно зафиксировано в docs/CHANGELOG, и у тебя есть представление, какие шаги нужны для включения (т.е. эпик честно закрыт “минимальной рабочей базой”, а не замазан).

Если захочешь потом подключить к этому результату ещё одного агента (например, чтобы дожать Kafka до полноценного прод‑состояния или адаптироваться к ветке `develop` Ильи) — мы можем на следующем шаге собрать новый Oracle‑контракт поверх получившегося состояния.
