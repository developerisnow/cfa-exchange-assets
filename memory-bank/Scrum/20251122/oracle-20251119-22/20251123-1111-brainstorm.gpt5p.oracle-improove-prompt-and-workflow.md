## Phase 1: PARSE

**Что ты просишь (разбивка на атомы)**

1. Разобрать твой кейс Oracle + Codex-Cli:

   * Oracle = сверх-умная deepthinking модель (15–45 минут),
   * Codex-Cli = код-агент, который реально правит код, гоняет тесты, коммитит и т.п.
2. **Проанализировать, как добиться автономности и непрерывности до уровня JTBD**:

   * чтобы агент работал не “одним маленьким шагом”, а серией фаз, пока реально не закрыт Job-To-Be-Done;
   * чтобы он **не скашивал углы**: тесты, QA, реальные данные, дока, Git-коммиты.
3. Ответить: **“вообще правильным ли путем я иду?”**
4. Дать **конкретные советы, как улучшить oracle.prompt.md** (твой промпт для Oracle). 
5. На примере **NX-05-08 CFA1 project**:

   * оценить, что было сделано верно;
   * что можно улучшить;
   * оценить **твои навыки и стиль работы**, и где тебе полезно подрасти.
6. **Продекларировать твои цели** — чтобы ты мог проверить, правильно ли я тебя понял.
7. Всё это оформить через **MANDATORY 5-PHASE PROCESS** (PARSE → DECOMPOSE → PROCESS → AUDIT → COMPOSE).

**Неявные требования**

* Oracle должен стать **реальным “оркестратором”**, а ты — в режиме “Orchestrator/Copypaster + learner”, минимально вмешивающийся.
* Ты хочешь, чтобы:

  * Oracle **системно** учитывал DoD, Kickoff tasks, Phases;
  * Codex работал **долго и автономно** (20–30+ минут на сессию, цепочкой до нескольких часов).
* Важная боль: текущие агенты по дефолту оптимизированы под:

  * короткие задачи;
  * безопасные маленькие шаги;
  * “сделать минимум и спросить пользователя”.
    Ты хочешь **сломать этот паттерн для “продвинутого пользователя”**.

**Неясности / потенциальные вопросы (я не буду ими тебя мучить, просто фиксирую)**

* Конкретные лимиты/ограничения среды Codex (max steps / max time / auto-stop).
* Насколько сейчас у тебя автоматизирована связка Oracle → Codex,
  или это пока: ты → (копипаст в Oracle) → (копипаст в Codex) → ты.

---

## Phase 2: DECOMPOSE

Разложу задачу на компоненты и зависимости.

### A. Архитектура автономности / непрерывности до JTBD

A1. **Модель взаимодействия**:

* Роли: Human ↔ Oracle ↔ Codex ↔ Repo/Infra.

A2. **Механизм непрерывности**:

* Как переносить контекст между сессиями.
* Как понимать “где мы сейчас” по отношению к JTBD.

A3. **Механизм автономности**:

* Как явно сказать агенту: “ты имеешь карт-бланш, не спрашивай меня”.
* Как задать **критерии остановки**: DoD, тесты, чеклисты.

A4. **Механизм QA**:

* Тесты (unit, e2e, Playwright).
* Проверка на реальных данных (не mock).
* Документация + DoD → синхронизированы с реальностью.

A5. **Git-ритуалы и атомарность**:

* {code-change} + {code-test} + {test-artifacts} + {update-docs-DoD} в одном коммите.
* Частые, осмысленные инкременты.

### B. Оценка “правильности пути”

B1. Анализ текущего oracle.prompt.md. 
B2. Анализ по кейсу NX-05-08 (по тому, что Oracle уже делает в последнем ответе в jsonl):

* как он оценивал ветку `codex/fix-cfa1-regressions`,
* как расписывал фазы, DoD, действия для Codex.

### C. Улучшение oracle.prompt.md

C1. Структура промпта для Oracle:

* Input / Output, режимы, чеклисты.
  C2. Встроенная “долгоживущая” логика:
* непрерывность между сессиями, DoD-scoreboard.

### D. Оценка NX-05-08 CFA1 и твоих навыков

D1. Что в этом примере было:

* сделано хорошо;
* рискованно / тяжеловесно;
* можно сделать стабильнее.
  D2. Оценка твоего уровня:
* сильные стороны;
* зоны роста.

### E. Формализация твоих целей

E1. Сформулировать твои цели на уровне:

* “Что я хочу от Oracle+Codex-системы?”
* “Кем я хочу быть в этой системе?”

---

## Phase 3: PROCESS

Теперь по компонентам.

---

### A. Как добиться автономности и непрерывности до JTBD

#### A1. Правильная архитектура ролей

**Три уровня:**

1. **Human (ты)**

   * формулируешь JTBD и высокоуровневый контекст (бизнес-сценарий, ограничения);
   * смотришь только на крупные контрольные точки.

2. **Oracle (deepthinking)**

   * читает репо/логи/сессию Codex;
   * оценивает состояние относительно JTBD (DoD, completeness, риски);
   * планирует **мультифазный маршрут** до JTBD;
   * генерирует **конкретный копипаст-промпт для Codex** на ближайшую порцию работы;
   * поддерживает **“scoreboard” состояния**.

3. **Codex (CLI-агент)**

   * выполняет реальную работу в репо:

     * меняет код,
     * запускает тесты,
     * собирает артефакты,
     * обновляет документацию / DoD чеклисты,
     * делает коммиты.

> Ключ: **Oracle = планирование + оценка + контроль; Codex = “руки”**.
> Ты = “надзор + постановка JTBD”.

---

#### A2. Непрерывность: как удерживать маршрут до JTBD

Супер-важная мысль:
**Непрерывность должна жить не в “сессии”, а в артефактах в репозитории.**

Предлагаю паттерн:

1. **JTBD-статус-файл**

   * например: `docs/jtbd/NX-05-08-cfa1-status.md` или `tasks/NX-05-08-status.md`;
   * внутри:

     * список фаз (Phase 1..5) и подзадач,
     * чекбоксы DoD (тесты, e2e, данные, дока, urls, команды),
     * ссылки на коммиты/PR,
     * список известных рисков/блокеров.
   * **Каждый запуск Codex обязан обновить этот файл.**
   * Oracle при каждом новом запуске начинает с чтения этого файла и сверки с реальностью (git diff, файлы, тесты).

2. **“Session-independent” план**

   * Oracle не думает “в рамках сессии чата”,
     он думает в рамках **JTBD-артефакта**:

     * “что уже сделано по статус-файлу”,
     * “что реально подтверждено тестами и кодом”,
     * “что осталось”.

3. **Цикл непрерывности**:

   * Шаг 1. Oracle:

     * читает repo + статус-файл;
     * оценивает completeness/accuracy;
     * решает: JTBD закрыт или нет;
     * если нет — формирует **следующий chunk плана** для Codex (на 20–40 минут работы).
   * Шаг 2. Codex:

     * выполняет chunk (2–5 подзадач);
     * обновляет код, тесты, артефакты, статус-файл;
     * делает несколько атомарных коммитов.
   * Шаг 3. Новый цикл:

     * Oracle снова читает repo + статус-файл;
     * переоценка completeness/accuracy,
     * новый chunk или финальный отчёт.

Таким образом, непрерывность обеспечивается **через файловое состояние**, а не через “длинную сессию агента”.

---

#### A3. Автономность: как реально дать карт-бланш

Ты уже говоришь: “даю approve/картбланш на полную автономию”.

Чтобы модель это **поняла и реально использовала**, нужно:

1. **Развести режимы работы Oracle** в oracle.prompt.md: 

   * `mode = "audit-only"` — короткий разбор, рекомендации.
   * `mode = "jtbd-run"` — ты даёшь полномочия запускать цепочку Oracle→Codex до закрытия JTBD.
   * Из human-ввода: `mode=jtbd-run`, `max_iterations`, `max_risk_level` и т.д.

2. В `jtbd-run` режиме Oracle должен:

   * **НЕ** просить подтвердить каждый шаг;
   * сам:

     * формировать агентский промпт,
     * указывать “work until”:

       * “считай, что у тебя есть N действий / M минут и полные права менять код, пока не выполнены DoD X/Y/Z”;
     * явно прописывать: “Не задавай пользователю дополнительные вопросы, кроме критических блокеров (например, нет доступа к X)”.

3. Для Codex промпта нужно зашить чёткий контракт:

   * “Считай, что у тебя есть **полный доступ к ветке и времени**.
     Не останавливаться после первого ‘кажется, готово’.
     Алгоритм:

     1. Сделал изменения.
     2. Запустил тесты / e2e / проверки.
     3. Убедился, что всё зелёное.
     4. Обновил доку / статус-файл.
     5. Сделал коммит.
     6. Только после этого заканчивай сессию и печатай отчёт.”

4. **Критерий остановки**

   * вместо “сделай что-то по NX-05-08” →
     “**Работай, пока:**

     * все чекбоксы в `tasks/NX-05-08-*.md` и `NX-05-08-status.md` не будут отмечены как Done,
     * все описанные тесты не будут зелёными,
     * не будет открытых блокеров, требующих человека.”

---

#### A4. QA и “не скашивать углы”

Ты уже очень чётко фиксируешь “Common Agentic Problems” в oracle.prompt.md:
про e2e, Playwright, реальные данные, запрет на fallback, честное обозначение блокеров. 

Чтобы агент реально это соблюдал:

1. В **Codex-промпте** нужно прямо зашить:

   * Список **обязательных тестовых команд**, которые должны быть выполнены.
   * Например:

     * `dotnet test ois-backend.sln`;
     * `npm test` в нескольких приложениях;
     * `npm run test:e2e` / `npx playwright test` и т.д.
   * И написать:
     “Если не запустишь эти команды и не опишешь результат => работа считается **не завершённой**, даже если код компилируется.”

2. В статус-файле / DoD:

   * обязательно иметь раздел:

     * “Тесты, которые были фактически запущены (команды + результаты)”.
   * И Oracle в оценке completeness должен **снижать балл**, если:

     * тесты не упомянуты;
     * команда указана, но нет логов/описания результата.

3. Для “реальных данных”:

   * отдельный чекбокс:

     * “Проверено на sandbox/real-like env (описать конкретный сценарий, URL, юзера, шаги).”
   * Codex обязан добавить мини-сценарий: шаги, скриншоты (или хотя бы путь к ним), результаты.

---

#### A5. Git и атомарность

Ты отлично сформулировал целевую форму коммита:

> `{code-change} + {code-test} + {test-artefacts/output} + {update-docs-DoD-Kickoff-checkboxes}`

Чтобы агент реально так делал:

1. В промпте Codex:

   * явно прописать стратегию:

     * “Для каждой логической подзадачи:

       * сделай изменения в коде;
       * добавь/обнови тесты;
       * запусти тесты;
       * обнови документацию/DoD/статус-файл;
       * сделай **один** коммит с понятным сообщением:
         `NX-07: implement KYC flow + tests + docs`.”

2. Наложить запрет:

   * “Не делай один огромный коммит для нескольких Phase/Tasks.
     Максимум — 1 JTBD-подзадача на коммит.”

3. Опционально:

   * попросить Codex в отчёте выводить список коммитов, которые он сделал:

     * SHA (короткий), message, краткое содержание.

---

### B. Правильный ли путь?

Коротко: **да, путь правильный, но можно сделать его устойчивее и чуть менее “перегруженным”.**

**Что видно по твоим артефактам (oracle.prompt.md и NX-05-08):**

* Ты уже используешь:

  * spec-first и DoD;
  * фазную структуру (Phase 1–5);
  * явную фиксацию проблем: QA, git, непрерывность;
  * Oracle как “мета-аналитика” поверх Codex, а не как ещё один кодер. 
* В NX-05-08-примере Oracle:

  * аккуратно оценил completeness/accuracy ветки `codex/fix-cfa1-regressions`;
  * заметил отсутствие коммитов, тестов, недоведённые таски;
  * предложил **очень конкретный, пофазный промпт** для Codex с указанием файлов, сервисов, ветки, запрета на новые ветки и т.п.;
  * дал тебе “что сделать руками до следующего запуска агента”.
    Это всё — сильные, “senior-level” практики.

**Где есть риски/перегруз:**

* Промпты местами очень длинные и насыщенные:

  * есть риск “расфокусировки” модели;
  * часть требований может конфликтовать или тонуть в объёме.
* Ты стремишься зашить **ВСЁ** в один промпт:

  * и методологию,
  * и checklists,
  * и контекст,
  * и конкретный план.
* Лучше чуть сильнее разделить:

  * **Oracle.prompt — “мета-рамка”** (что Oracle должен делать, как мыслить, какие артефакты выдавать);
  * **Per-JTBD oracle-session prompt** — конкретные цели, контекст, ограничения;
  * **Codex prompt** — максимально конкретное ТЗ агенту с планом и командами.

Но направление — очень зрелое:
ты по сути строишь свою **узкоспециализированную “DevOps+Product” агентную платформу**, а не просто “чатики”.

---

### C. Что улучшить в oracle.prompt.md

Опираясь на текущий вариант. 

#### C1. Чётко описать входы и выходы Oracle

Добавь в начало oracle.prompt.md:

```text
[Role]
Ты — Oracle, deepthinking модель-оркестратор поверх Codex-агента.

[Inputs]
- (опционально) прошлые сессии Oracle/Codex (лог / session.jsonl)
- текущий git-статус (ветка, изменённые файлы)
- JTBD-задача + DoD (из tasks/*.md или docs/jtbd/*.md)
- (опционально) голосовые заметки / текст пользователя

[Outputs]
В каждом ответе Oracle должен выдать:
- Оценку состояния (Completeness, Accuracy, риски).
- Обновлённый/уточнённый DoD / статус по фазам.
- Конкретный копипаст-промпт для Codex (если нужна следующая итерация).
- Kickoff tasks (что делать человеку / что делать следующему агенту).
```

Это уменьшит “размазанность” роли.

#### C2. Формализовать режимы

Введи конструкцию типа:

```text
Mode: {audit-only | jtbd-run}

Если Mode = audit-only:
  - делай только оценку + рекомендации, не формируй длинный план.

Если Mode = jtbd-run:
  - обязательно:
    - определи Phases до JTBD,
    - выдай промпт для Codex на ближайшую фазу,
    - обнови DoD/статус,
    - оцени необходимость следующих итераций.
```

Так ты сможешь гибко использовать Oracle как лёгкого критика или как тяжёлый оркестратор.

#### C3. Вшить “JTBD-status-file” как обязательный артефакт

В oracle.prompt.md явно опиши:

* “Oracle должен **требовать от Codex**:

  * обновлять статус-файл JTBD при каждой итерации,
  * и сам Oracle всегда опирается на него при оценке состояния.”

Это заведёт **единый источник правды**, а не “в голове модели”.

#### C4. Упростить иерархию “Common Agentic Problems”

Сейчас список есть, но он как бы “рядом с текстом”, а не встроен в процесс. 

Предлагаю для Oracle:

* в конце каждого ответа добавлять секцию:

```text
[Agentic Risks Detected]
- QA: ok / missing tests / missing real-data check / fallback spotted
- Git: ok / no commits / giant commit / mixed concerns
- Continuity: ok / status-file not updated / phases inconsistent
- Docs: ok / outdated / missing commands / missing URLs
```

И учить Oracle **подсвечивать** эти проблемы и в промпте для Codex, и для тебя.

---

### D. NX-05-08 CFA1: что хорошо / что улучшить / ты как специалист

#### D1. Что было сделано хорошо

По последнему большому ответу Oracle в jsonl явно видно:

* **Глубокая оценка ветки `codex/fix-cfa1-regressions`**:

  * поймал, что изменений много (фронт, бэкенд, контракты, SDK, таски), но:

    * 0 коммитов,
    * нет явных прогонов .NET и e2e,
    * таски NX-05..08 обновлены, но DoD не завершён,
    * KYC/backoffice в подвешенном состоянии.
* **Адекватная шкала completeness/accuracy**:

  * не 0 и не 90, а довольно реалистичные 35–40% и 50–55%.
* **Хороший блок “что сделать руками до запуска нового агента”**:

  * почистить ветку,
  * заархивировать текущее состояние,
  * сохранить логи/скриншоты/артефакты.
* **Очень сильный копипаст-промпт для Codex**:

  * чётко указаны:

    * рабочая директория и ветка,
    * запрет на новые ветки / rebase / force-push,
    * цели по NX-05..08,
    * структуру фаз (аудит → backend/contracts → фронты → e2e → docs/DoD → финальный отчёт),
    * файлы, которые обязательно нужно трогать / проверять.

Это выглядит как работа **опытного тимлида / архитектора**, который пишет ТЗ middle/senior разработчику.

#### D2. Что можно улучшить в этом кейсе

1. **Объём промпта для Codex**

   * Он очень подробный (что в целом хорошо), но:

     * риск, что часть требований просто потеряется;
     * агент может “срезать” самые тяжёлые куски (QA, реальная проверка) первым.
   * Можно сделать:

     * “Phase 1–2” в одном промпте,
     * “Phase 3–5” — в следующем, после отчёта агента.
     * Oracle сам разбивает.

2. **Меньше “инфраструктурных деталей” в одном месте**

   * Например, часть инструкций по git/архивации/cleanup можно вынести:

     * в отдельный “git-workflow.md”,
     * а в промпте просто сослаться: “следуй git-workflow.md, раздел ‘agent commits’”.

3. **Явная интеграция со статус-файлом**

   * В этом кейсе Oracle много говорит про DoD и таски, но нет **одного явного файла**, который был бы “single source of truth”.
   * Добавление такого файла сделает цикл “Oracle → Codex → Oracle” намного стабильнее.

#### D3. Оценка тебя и твоих навыков

Из того, что видно:

**Сильные стороны:**

* Мышление **системно-процессное**:

  * Spec, Workflow, Prompt, DoD, Kickoff — всё связано.
* Понимание **modern fullstack-ландшафта**:

  * .NET + Next.js + SDK + OpenAPI + e2e.
* Очень здравый **инженерный перфекционизм**:

  * QA, реальные данные, не делать fallback, честно обозначать блокеры.
* Ты умеешь мыслить в категориях:

  * JTBD,
  * мультифазные проекты,
  * branch/commit hygiene.

**Зоны роста:**

1. **Баланс между глубиной и простотой**

   * Иногда ты стремишься зашить слишком много уровней абстракции в один промпт.
   * Это тяжело даже для сильной модели.
   * Навык, который стоит прокачивать:
     “Как сделать **минимальный набор инструкций**, который даёт 80% результата, а остальное вынести в отдельные артефакты/файлы”.

2. **Автоматизация оркестрации**

   * Сейчас ты в роли “ручного оркестратора/копипастера”.
   * Следующий уровень — написать:

     * простой скрипт (CLI или small service), который:

       * вызывает Oracle,
       * берёт его промпт,
       * запускает Codex,
       * собирает отчёты,
       * обновляет лог.
   * Тебе это явно по силам, и это радикально снизит “человеческий overhead”.

3. **Метрики и обратная связь**

   * Было бы круто, если бы каждый цикл Oracle:

     * сохранял оценку `Completeness`, `Accuracy`, `Risk` в файл/таблицу;
     * ты бы видел прогресс по итерациям,
     * а не только финальное “сделано/не сделано”.

В общем, по уровню мышления и постановки задач
ты уже **не “просто инженер”, а системный дизайнер процессов**.
Дальше — дело техники/автоматизации.

---

## Phase 4: AUDIT

**Что я мог упустить / какие допущения сделал:**

* Я предполагаю, что:

  * ты можешь хранить вспомогательные файлы (status.md, logs) в репо;
  * ты можешь чуть доработать свой tooling вокруг Codex (скрипты, wrapper’ы).
* Я не знаю:

  * точные лимиты и поведение твоего конкретного Codex-Cli (max steps, timeouts, проверки безопасности).
    Поэтому я предлагаю архитектуру, которая **не полагается** на одну сверх-длинную сессию,
    а строится вокруг **итеративных, но взаимосвязанных сессий** с общим статус-файлом.
* Я не видел полностью содержимое oracle.prompt.md (часть в файле сжата “...”);
  поэтому советы по структуре — концептуальные, а не посимвольный рефактор. 

**Что ещё релевантно, но ты прямо не спрашивал:**

* Логирование:

  * отдельный `oracle-history.jsonl`, куда Oracle пишет:

    * timestamp,
    * оценку completeness/accuracy,
    * краткий summary изменений.
* Safety-ограничения:

  * иногда полезно ограничить то, что агент НЕ может делать (например, не трогать определённые сервисы/секреты).

---

## Phase 5: COMPOSE

### 5.1. Как я вижу твои цели (декларация)

1. **Построить связку Oracle + Codex**, которая:

   * умеет **автономно и непрерывно** вести работу до реального завершения JTBD;
   * не срезает углы:

     * всегда делает тесты,
     * проверяет на реальных данных,
     * обновляет документацию и DoD,
     * делает аккуратные коммиты.

2. **Свести твой человеческий вклад** к:

   * постановке JTBD и ограничений;
   * редким проверкам/ревью на фазовых границах;
   * обучению на выводах Oracle.

3. **Использовать Oracle как “мета-ментор”**:

   * чтобы он:

     * анализировал Codex-сессии,
     * разруливал проблемы и риски,
     * объяснял тебе свои решения в структурированном виде (как в 5-phase процессе).

4. **Стандартизировать промпты и артефакты**:

   * oracle.prompt.md → единая рамка для thinking;
   * стандартный шаблон промпта для Codex;
   * статус-файлы JTBD, DoD и Kickoff чеклисты как часть репо.

Если это совпадает с тем, что у тебя в голове — мы на одной волне. Если что-то не так — скажи, скорректируем картину.

---

### 5.2. Definition of Done для твоей системы Oracle+Codex

Система можно считать “достаточно зрелой”, если:

* [ ] Для каждой JTBD-задачи есть **статус-файл в репозитории** (DoD + Phases + тесты + URLs).
* [ ] Oracle в своём ответе **всегда**:

  * даёт оценку completeness/accuracy,
  * обновляет/уточняет DoD/статус,
  * формирует промпт для Codex (если нужна следующая итерация),
  * выдаёт Kickoff tasks (для человека/следующего агента).
* [ ] Codex:

  * [ ] Всегда запускает обязательные тесты (и описывает результат).
  * [ ] Проверяет ключевые флоу на реалистичной среде.
  * [ ] Обновляет статус-файл JTBD.
  * [ ] Делает атомарные коммиты в форме `{code-change}+{tests}+{artifacts}+{docs/DoD}`.
* [ ] Непрерывность:

  * [ ] Любой новый запуск Oracle может по репо + статус-файлу восстановить, где мы находимся относительно JTBD, без ручной памяти.
* [ ] Ты:

  * [ ] Вмешиваешься только на фазовых границах или по блокерам,
  * [ ] Получаешь от Oracle понятные, обучающие отчёты.

---

### 5.3. Kickoff tasks (что можно сделать уже сейчас)

**KT1. Ввести JTBD-статус-файл для NX-05-08 CFA1**

* Создай, например, `tasks/NX-05-08-status.md` и:

  * заведи там:

    * список фаз (Phase 1–5),
    * DoD-чеклисты (тесты, URLs, реальные сценарии),
    * секцию “Known Issues / Risks”.

**KT2. Обновить oracle.prompt.md с учётом:**

* Добавить блоки:

  * Role / Inputs / Outputs,
  * Mode: {audit-only | jtbd-run},
  * Обязательный “Agentic Risks Detected”.
* Вшить правило:

  * “Oracle всегда опирается на JTBD-статус-файл и обновляет его”.

**KT3. Стандартизировать Codex-промпт**

* Выдели отдельный шаблон:

  * рабочая директория и ветка,
  * явный список целей (по таскам),
  * чёткий алгоритм (аудит → изменения → тесты → docs/DoD → коммиты → отчёт),
  * список обязательных тестовых команд.

**KT4. Начать логировать Oracle-оценки**

* Делать `oracle-session-log.jsonl` на проект:

  * timestamp,
  * JTBD-id (например, NX-05-08),
  * completeness, accuracy,
  * ключевые риски,
  * ссылка на статус-файл.

**KT5. Подумать над мини-оркестратором**

* Маленький скрипт (bash/python):

  * `run_oracle_once → get codex_prompt → run_codex → commit logs → repeat until Oracle says “Done”`.
    Первую версию можно сделать даже полу-ручной, с минимумом автоматизации.

---

Если хочешь, следующим шагом могу:

* набросать **черновой рефактор oracle.prompt.md** с новой структурой (Role/Mode/Inputs/Outputs/5-Phase);
* или сделать **конкретный шаблон статус-файла JTBD** под NX-05-08, чтобы просто копировать его на другие проекты.
