Project Path: tests

Source Tree:

```txt
tests
├── contracts
│   ├── pact-consumer
│   │   ├── gateway-to-issuance.test.ts
│   │   ├── gateway-to-registry.test.ts
│   │   └── package.json
│   └── pact-provider
│       └── registry-provider-verification.cs
├── e2e
│   ├── README.md
│   ├── helpers
│   │   └── test-data.ts
│   ├── package.json
│   ├── playwright.config.ts
│   └── tests
│       ├── backoffice-journey.spec.ts
│       ├── investor-journey.spec.ts
│       ├── investor.catalog_buy_history.spec.ts
│       ├── issuer-journey.spec.ts
│       ├── ledger-integration.spec.ts
│       └── lifecycle.spec.ts
├── e2e-playwright
│   ├── README.md
│   ├── package.json
│   ├── playwright.config.ts
│   └── tests
│       ├── backoffice-auth.spec.ts
│       ├── public-auth.spec.ts
│       └── self-registration.spec.ts
├── issuance.Tests
│   ├── IssuanceApiTests.cs
│   ├── IssuanceServiceTests.cs
│   ├── TestResults
│   │   └── issuance.trx
│   └── issuance.Tests.csproj
├── k6
│   ├── gateway-critical-paths.js
│   └── payouts-report.js
└── load
    └── README.md

```

`tests/contracts/pact-consumer/gateway-to-issuance.test.ts`:

```ts
import { Pact } from '@pact-foundation/pact';
import path from 'path';

const provider = new Pact({
  consumer: 'api-gateway',
  provider: 'issuance-service',
  port: 1234,
  log: path.resolve(process.cwd(), 'pacts', 'logs', 'gateway-issuance.log'),
  dir: path.resolve(process.cwd(), 'pacts'),
  logLevel: 'INFO',
  spec: 2,
});

describe('API Gateway -> Issuance Service', () => {
  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());

  describe('POST /v1/issuances', () => {
    const createIssuanceRequest = {
      assetId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
      issuerId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
      totalAmount: 1000000,
      nominal: 1000,
      issueDate: '2025-01-01',
      maturityDate: '2026-01-01',
    };

    const createIssuanceResponse = {
      id: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
      assetId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
      issuerId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
      totalAmount: 1000000,
      nominal: 1000,
      issueDate: '2025-01-01',
      maturityDate: '2026-01-01',
      status: 'draft',
      createdAt: '2025-01-01T00:00:00Z',
    };

    it('creates an issuance', async () => {
      await provider.addInteraction({
        state: 'no existing issuance',
        uponReceiving: 'a request to create an issuance',
        withRequest: {
          method: 'POST',
          path: '/v1/issuances',
          headers: { 'Content-Type': 'application/json' },
          body: createIssuanceRequest,
        },
        willRespondWith: {
          status: 201,
          headers: { 'Content-Type': 'application/json' },
          body: createIssuanceResponse,
        },
      });

      // Consumer test would call gateway API here
      // const response = await fetch('http://localhost:5000/v1/issuances', { ... });
    });
  });
});


```

`tests/contracts/pact-consumer/gateway-to-registry.test.ts`:

```ts
import { Pact } from '@pact-foundation/pact';
import path from 'path';

const provider = new Pact({
  consumer: 'api-gateway',
  provider: 'registry-service',
  port: 1235,
  log: path.resolve(process.cwd(), 'pacts', 'logs', 'gateway-registry.log'),
  dir: path.resolve(process.cwd(), 'pacts'),
  logLevel: 'INFO',
  spec: 2,
});

describe('API Gateway -> Registry Service', () => {
  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());

  describe('POST /v1/orders', () => {
    it('places an order successfully', async () => {
      const idemKey = '550e8400-e29b-41d4-a716-446655440000';
      const request = {
        investorId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
        issuanceId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
        amount: 50000,
      };

      await provider.addInteraction({
        state: 'investor has passed KYC and qualification check',
        uponReceiving: 'a request to place an order',
        withRequest: {
          method: 'POST',
          path: '/v1/orders',
          headers: {
            'Content-Type': 'application/json',
            'Idempotency-Key': idemKey,
          },
          body: request,
        },
        willRespondWith: {
          status: 202,
          headers: { 'Content-Type': 'application/json' },
          body: {
            id: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
            investorId: request.investorId,
            issuanceId: request.issuanceId,
            amount: request.amount,
            status: 'pending',
            createdAt: '2025-01-01T00:00:00Z',
          },
        },
      });
    });

    it('handles idempotent request', async () => {
      const idemKey = '550e8400-e29b-41d4-a716-446655440001';
      
      await provider.addInteraction({
        state: 'order with idempotency key already exists',
        uponReceiving: 'a duplicate request to place an order',
        withRequest: {
          method: 'POST',
          path: '/v1/orders',
          headers: {
            'Content-Type': 'application/json',
            'Idempotency-Key': idemKey,
          },
          body: {
            investorId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
            issuanceId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
            amount: 50000,
          },
        },
        willRespondWith: {
          status: 202,
          headers: { 'Content-Type': 'application/json' },
          body: {
            id: 'existing-order-id',
            status: 'pending',
          },
        },
      });
    });
  });
});


```

`tests/contracts/pact-consumer/package.json`:

```json
{
  "name": "@ois/pact-consumer",
  "version": "1.0.0",
  "scripts": {
    "test": "jest",
    "publish": "pact-broker publish pacts --consumer-app-version=$npm_package_version"
  },
  "devDependencies": {
    "@pact-foundation/pact": "^13.0.0",
    "@types/jest": "^29.5.0",
    "jest": "^29.7.0",
    "typescript": "^5.3.0"
  }
}


```

`tests/contracts/pact-provider/registry-provider-verification.cs`:

```cs
using System.Net.Http;
using System.Threading.Tasks;
using Xunit;
using PactNet;
using PactNet.Matchers;
using PactNet.Mocks.MockHttpService;
using PactNet.Mocks.MockHttpService.Models;

namespace OIS.Registry.Tests.Contracts;

public class RegistryProviderVerification : IClassFixture<RegistryProviderState>
{
    private readonly IMockProviderService _mockProvider;
    private readonly string _mockProviderServiceBaseUri;

    public RegistryProviderVerification(RegistryProviderState state)
    {
        _mockProvider = state.MockProviderService;
        _mockProviderServiceBaseUri = state.MockProviderServiceBaseUri;
        _mockProvider.ClearInteractions();
    }

    [Fact]
    public async Task PlaceOrder_WhenInvestorHasPassedKYC_Returns202()
    {
        _mockProvider
            .Given("investor has passed KYC and qualification check")
            .UponReceiving("a request to place an order")
            .With(new ProviderServiceRequest
            {
                Method = HttpVerb.Post,
                Path = "/v1/orders",
                Headers = new Dictionary<string, object>
                {
                    { "Content-Type", "application/json" },
                    { "Idempotency-Key", Match.Type("550e8400-e29b-41d4-a716-446655440000") }
                },
                Body = new
                {
                    investorId = Match.Type("3fa85f64-5717-4562-b3fc-2c963f66afa6"),
                    issuanceId = Match.Type("3fa85f64-5717-4562-b3fc-2c963f66afa6"),
                    amount = Match.Type(50000)
                }
            })
            .WillRespondWith(new ProviderServiceResponse
            {
                Status = 202,
                Headers = new Dictionary<string, object>
                {
                    { "Content-Type", "application/json" }
                },
                Body = new
                {
                    id = Match.Type("3fa85f64-5717-4562-b3fc-2c963f66afa6"),
                    investorId = Match.Type("3fa85f64-5717-4562-b3fc-2c963f66afa6"),
                    issuanceId = Match.Type("3fa85f64-5717-4562-b3fc-2c963f66afa6"),
                    amount = Match.Type(50000),
                    status = Match.Regex("pending|completed|failed", "pending"),
                    createdAt = Match.Type("2025-01-01T00:00:00Z")
                }
            });

        // Verify provider implementation
        using var client = new HttpClient { BaseAddress = new Uri(_mockProviderServiceBaseUri) };
        var response = await client.PostAsync("/v1/orders", new StringContent("{}"));
        
        Assert.Equal(202, (int)response.StatusCode);
    }
}


```

`tests/e2e-playwright/README.md`:

```md
# Public ingress smoke tests

Набор Playwright-тестов, проверяющих, что публичные домены (`issuer`, `investor`) действительно отдают Next.js портал и завершают Keycloak OAuth-флоу.

## Требования

- Node.js ≥ 18
- `npm install` в текущей директории (устанавливает `@playwright/test`).
- Chromium браузер для Playwright (`npx playwright install chromium`).

## Запуск

```bash
cd tests/e2e-playwright
npm install
npx playwright install chromium  # первый запуск
npm test
```

### Переменные окружения

| Env                     | Default                                 | Назначение |
|-------------------------|-----------------------------------------|-----------|
| `ISSUER_BASE_URL`       | `https://issuer.cfa.llmneighbors.com`   | URL портала эмитента |
| `INVESTOR_BASE_URL`     | `https://investor.cfa.llmneighbors.com` | URL портала инвестора |
| `ISSUER_USER`           | `issuer@test.com`                       | Пользователь для входа |
| `ISSUER_PASS`           | `password123`                           | Пароль |
| `INVESTOR_USER`         | `investor@test.com`                     | Пользователь инвестора |
| `INVESTOR_PASS`         | `password123`                           | Пароль |

Переменные нужны только если вы хотите использовать иные креды/домены.

## Структура

- `playwright.config.ts` – настройки раннера.
- `tests/public-auth.spec.ts` – главный сценарий (Keycloak OAuth → ожидаемая страница).

Результаты тестов по умолчанию доступны в `playwright-report/` и `test-results/` после завершения.

```

`tests/e2e-playwright/package.json`:

```json
{
  "name": "@ois/e2e-playwright-public",
  "version": "1.0.0",
  "description": "Public ingress smoke tests for issuer/investor portals",
  "main": "index.js",
  "directories": {
    "test": "tests"
  },
  "scripts": {
    "test": "playwright test",
    "test:report": "playwright show-report"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@playwright/test": "^1.56.1"
  },
  "private": true
}
```

`tests/e2e-playwright/playwright.config.ts`:

```ts
import { defineConfig } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  timeout: 120_000,
  expect: {
    timeout: 30_000,
  },
  use: {
    headless: true,
    trace: 'retain-on-failure',
    screenshot: 'only-on-failure',
  },
  reporter: [['list'], ['html', { open: 'never' }]],
});

```

`tests/e2e-playwright/tests/backoffice-auth.spec.ts`:

```ts
import { test, expect } from '@playwright/test';

test('backoffice admin authenticates via Keycloak', async ({ page }) => {
  const baseUrl = process.env.BACKOFFICE_BASE_URL ?? 'https://backoffice.cfa.llmneighbors.com';
  const username = process.env.BACKOFFICE_USER ?? 'admin@test.com';
  const password = process.env.BACKOFFICE_PASS ?? 'password123';

  await page.goto(baseUrl, { waitUntil: 'networkidle' });
  const signInButton = page.getByRole('button', { name: /keycloak/i });
  await expect(signInButton).toBeVisible();
  await signInButton.click();

  await page.waitForSelector('#username', { timeout: 30_000 });
  await page.fill('#username', username);
  await page.fill('#password', password);
  await page.click('#kc-login');

  await page.waitForURL(/backoffice/, { timeout: 60_000 });
  await expect(page).toHaveURL(new RegExp(`${baseUrl}`));
});

```

`tests/e2e-playwright/tests/public-auth.spec.ts`:

```ts
import { test, expect } from '@playwright/test';

interface PortalConfig {
  name: string;
  baseUrl: string;
  username: string;
  password: string;
  expectedPath: string;
}

const portals: PortalConfig[] = [
  {
    name: 'issuer',
    baseUrl: process.env.ISSUER_BASE_URL ?? 'https://issuer.cfa.llmneighbors.com',
    username: process.env.ISSUER_USER ?? 'issuer@test.com',
    password: process.env.ISSUER_PASS ?? 'password123',
    expectedPath: '/dashboard',
  },
  {
    name: 'investor',
    baseUrl: process.env.INVESTOR_BASE_URL ?? 'https://investor.cfa.llmneighbors.com',
    username: process.env.INVESTOR_USER ?? 'investor@test.com',
    password: process.env.INVESTOR_PASS ?? 'password123',
    expectedPath: '/portfolio',
  },
];

for (const portal of portals) {
  test(`${portal.name} portal authenticates via Keycloak`, async ({ page }) => {
    test.info().annotations.push({ type: 'portal', description: portal.name });

    await page.goto(portal.baseUrl, { waitUntil: 'networkidle' });

    const signInButton = page.getByRole('button', { name: /keycloak/i });
    await expect(signInButton).toBeVisible();
    await signInButton.first().click();

    await page.waitForSelector('#username', { timeout: 30_000 });
    await page.fill('#username', portal.username);
    await page.fill('#password', portal.password);
    await page.click('#kc-login');

    await page.waitForURL(`${portal.baseUrl}${portal.expectedPath}*`, { timeout: 60_000 });
    await expect(page).toHaveURL(new RegExp(`${portal.baseUrl}${portal.expectedPath}`));

    // Убеждаемся, что финальный URL соответствует ожидаемому разделу.
    await expect(page).toHaveURL(new RegExp(`${portal.baseUrl}${portal.expectedPath}`));
  });
}

```

`tests/e2e-playwright/tests/self-registration.spec.ts`:

```ts
import { test, expect, APIRequestContext } from '@playwright/test';

const MAIL_TM_BASE = 'https://api.mail.tm';
const INVESTOR_BASE_URL =
  process.env.INVESTOR_BASE_URL ?? 'https://investor.cfa.llmneighbors.com';

interface DisposableMailbox {
  address: string;
  password: string;
  token: string;
}

const randomSuffix = () => Math.floor(Math.random() * 10_000);

async function resolveMailDomain(request: APIRequestContext): Promise<string> {
  const response = await request.get(`${MAIL_TM_BASE}/domains`);
  expect(response.ok()).toBeTruthy();
  const payload = await response.json();
  const domains: Array<{ domain: string; isActive: boolean }> =
    payload['hydra:member'] ?? [];
  const active = domains.find((domain) => domain.isActive);
  if (!active) {
    throw new Error('mail.tm does not expose any active domains right now');
  }
  return active.domain;
}

async function createMailbox(request: APIRequestContext): Promise<DisposableMailbox> {
  const domain = await resolveMailDomain(request);
  const address = `cfa-${Date.now()}-${randomSuffix()}@${domain}`;
  const password = `Passw0rd!${randomSuffix()}`;

  const createResp = await request.post(`${MAIL_TM_BASE}/accounts`, {
    data: { address, password },
    headers: { 'Content-Type': 'application/json' },
  });
  expect(createResp.ok()).toBeTruthy();

  const tokenResp = await request.post(`${MAIL_TM_BASE}/token`, {
    data: { address, password },
    headers: { 'Content-Type': 'application/json' },
  });
  expect(tokenResp.ok()).toBeTruthy();
  const tokenJson = await tokenResp.json();

  return {
    address,
    password,
    token: tokenJson.token as string,
  };
}

async function waitForVerificationLink(
  mailbox: DisposableMailbox,
  request: APIRequestContext,
): Promise<string> {
  const headers = {
    Authorization: `Bearer ${mailbox.token}`,
    'Content-Type': 'application/json',
  };

  for (let attempt = 0; attempt < 24; attempt += 1) {
    const messagesResp = await request.get(`${MAIL_TM_BASE}/messages`, { headers });
    expect(messagesResp.ok()).toBeTruthy();
    const data = await messagesResp.json();
    const messages = (data['hydra:member'] ?? []) as Array<Record<string, string>>;
    const candidate = messages.find((message) =>
      /verify/i.test(message.subject ?? ''),
    );
    if (candidate) {
      const detailResp = await request.get(`${MAIL_TM_BASE}${candidate['@id']}`, {
        headers,
      });
      expect(detailResp.ok()).toBeTruthy();
      const detail = await detailResp.json();
      const chunks: string[] = [];
      if (detail.text) {
        if (Array.isArray(detail.text)) {
          chunks.push(...detail.text);
        } else {
          chunks.push(detail.text as string);
        }
      }
      if (detail.html) {
        if (Array.isArray(detail.html)) {
          chunks.push(...detail.html);
        } else {
          chunks.push(detail.html as string);
        }
      }
      const normalized = chunks.join('\n');
      const match = normalized.match(
        /https:\/\/auth\.cfa\.llmneighbors\.com[^\s">]+/i,
      );
      if (!match) {
        throw new Error('Verification email received but activation link missing');
      }
      return match[0].replace(/&amp;/g, '&');
    }

    await new Promise((resolve) => setTimeout(resolve, 5000));
  }

  throw new Error('Verification email not received within 120s');
}

test('investor self-registration verifies email and logs in', async ({
  page,
  request,
}) => {
  test.setTimeout(240_000);
  const mailbox = await createMailbox(request);
  const password = `Passw0rd!${randomSuffix()}`;

  await page.goto(INVESTOR_BASE_URL, { waitUntil: 'domcontentloaded' });
  await page.getByRole('button', { name: /keycloak/i }).click();
  if (!/auth\.cfa\.llmneighbors\.com/.test(page.url())) {
    await page.waitForURL(/\/auth\/signin/, { timeout: 30_000 });
    await page.getByRole('button', { name: /keycloak/i }).click();
  }
  await page.waitForURL(/auth\.cfa\.llmneighbors\.com/, { timeout: 30_000 });

  const registerLink = page
    .locator('#kc-registration a, a#kc-registration, a[href*=\"login-actions/registration\"]')
    .first();
  await expect(registerLink).toBeVisible();
  await registerLink.click();
  await page.fill('#username', mailbox.address);
  await page.fill('#email', mailbox.address);
  await page.fill('#firstName', 'Playwright');
  await page.fill('#lastName', 'Investor');
  await page.fill('#password', password);
  await page.fill('#password-confirm', password);
  await page.getByRole('button', { name: /register/i }).click();

  await expect(page.locator('body')).toContainText(/verify/i);

  const verificationLink = await waitForVerificationLink(mailbox, request);
  await page.goto(verificationLink, { waitUntil: 'networkidle' });
  const verificationBody = await page.locator('body').innerText();
  if (/email/i.test(verificationBody) && /verified/i.test(verificationBody)) {
    await expect(page.locator('body')).toContainText(/email/i);
    await expect(page.locator('body')).toContainText(/verified/i);
  } else {
    await expect(page).toHaveURL(new RegExp(`${INVESTOR_BASE_URL}|auth\\.cfa`));
  }

  await page.goto(INVESTOR_BASE_URL, { waitUntil: 'domcontentloaded' });
  const loginButton = page.getByRole('button', { name: /keycloak/i });
  if ((await loginButton.count()) > 0) {
    await expect(loginButton).toBeVisible();
    await loginButton.click();
    await page.fill('#username', mailbox.address);
    await page.fill('#password', password);
    await page.click('#kc-login');
    await page.waitForURL(
      new RegExp(`${INVESTOR_BASE_URL}/(portfolio|catalog).*`),
      { timeout: 60_000 },
    );
  } else {
    await page.waitForURL(
      new RegExp(`${INVESTOR_BASE_URL}/(portfolio|catalog).*`),
      { timeout: 60_000 },
    );
  }
  await expect(page).toHaveURL(new RegExp(`${INVESTOR_BASE_URL}/(portfolio|catalog)`));
});

```

`tests/e2e/README.md`:

```md
# E2E Tests (Playwright)

End-to-end тесты для полного жизненного цикла ЦФА.

## Scenarios

- `issue→buy→payout→redeem` - Полный цикл

## TODO

- [ ] Setup Playwright
- [ ] Implement test scenarios
- [ ] CI/CD integration

## Run

```bash
npm test
```


```

`tests/e2e/helpers/test-data.ts`:

```ts
// Test data seeding and cleanup helpers

export async function seedTestData() {
  // Seed test issuances, investors, etc.
  // This would call API endpoints or directly insert into test DB
  console.log('Seeding test data...');
}

export async function cleanupTestData() {
  // Cleanup test data after tests
  console.log('Cleaning up test data...');
}


```

`tests/e2e/package.json`:

```json
{
  "name": "@ois/e2e-tests",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "test": "playwright test",
    "test:ui": "playwright test --ui",
    "test:report": "playwright show-report"
  },
  "devDependencies": {
    "@playwright/test": "^1.40.0",
    "@types/node": "^20.10.0"
  }
}


```

`tests/e2e/playwright.config.ts`:

```ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html', { outputFolder: 'playwright-report' }],
    ['json', { outputFile: 'playwright-results.json' }],
  ],
  use: {
    baseURL: 'http://localhost:3001',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: [
    {
      command: 'cd ../../apps/portal-issuer && npm run dev',
      port: 3001,
      reuseExistingServer: !process.env.CI,
    },
    {
      command: 'cd ../../apps/portal-investor && npm run dev',
      port: 3002,
      reuseExistingServer: !process.env.CI,
    },
    {
      command: 'cd ../../apps/backoffice && npm run dev',
      port: 3003,
      reuseExistingServer: !process.env.CI,
    },
  ],
});


```

`tests/e2e/tests/backoffice-journey.spec.ts`:

```ts
import { test, expect } from '@playwright/test';

const fakeSession = {
  user: {
    name: 'Boris Backoffice',
    email: 'backoffice@example.com',
    roles: ['backoffice'],
    id: '33333333-3333-4333-8333-333333333333',
  },
  accessToken: 'backoffice-token',
  expires: new Date(Date.now() + 60 * 60 * 1000).toISOString(),
};

test.describe('Backoffice: KYC approve/reject → audit appears', () => {
  test('approve KYC and see audit entry', async ({ page }) => {
    await page.route('**/api/auth/session**', (route) =>
      route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify(fakeSession) })
    );

    const investorId = '123e4567-e89b-12d3-a456-426614174000';

    // KYC decision endpoint
    await page.route(`**/v1/kyc/${investorId}/decision`, (route) =>
      route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          id: 'dec1',
          investorId,
          status: 'approved',
          comment: 'OK',
          decisionBy: fakeSession.user.id,
          decisionAt: new Date().toISOString(),
        }),
      })
    );

    // KYC documents list
    await page.route(`**/v1/kyc/${investorId}/documents`, (route) =>
      route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify({ items: [], total: 0 }) })
    );

    // Investor status
    await page.route(`**/v1/compliance/investors/${investorId}/status`, (route) =>
      route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify({ kyc: 'pending' }) })
    );

    // Audit endpoint
    await page.route('**/v1/audit**', (route) =>
      route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          items: [
            {
              id: 'aud1',
              actor: fakeSession.user.id,
              actorName: fakeSession.user.name,
              action: 'kyc_decision',
              entity: 'kyc',
              entityId: investorId,
              timestamp: new Date().toISOString(),
              result: 'success',
            },
          ],
          total: 1,
          limit: 20,
          offset: 0,
        }),
      })
    );

    await page.goto('http://localhost:3003/kyc');
    await expect(page.getByText('KYC Management')).toBeVisible();

    // Open the single mocked application row
    await page.getByRole('button', { name: 'View' }).click();
    await expect(page.getByText('Compliance Status')).toBeVisible();

    // Fill comment and approve
    await page.locator('textarea').first().fill('OK');
    await page.getByRole('button', { name: 'Approve' }).click();

    // Go to audit
    await page.goto('http://localhost:3003/audit');
    await expect(page.getByText('Audit Log')).toBeVisible();
    await expect(page.getByText('kyc_decision')).toBeVisible();
  });
});


```

`tests/e2e/tests/investor-journey.spec.ts`:

```ts
import { test, expect } from '@playwright/test';

const fakeSession = {
  user: {
    name: 'Ivan Investor',
    email: 'ivan@example.com',
    roles: ['investor'],
    id: '11111111-1111-4111-8111-111111111111',
  },
  accessToken: 'test-token',
  expires: new Date(Date.now() + 60 * 60 * 1000).toISOString(),
};

test.describe('Investor: catalog → detail → buy → history', () => {
  test('browse catalog, buy, see in history', async ({ page }) => {
    // Authenticate via NextAuth session stub
    await page.route('**/api/auth/session**', (route) => {
      return route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify(fakeSession) });
    });

    // Mock catalog list
    await page.route('**/v1/market/issuances**', (route) => {
      const url = new URL(route.request().url());
      if (url.pathname.endsWith('/v1/market/issuances') && !/\/v1\/market\/issuances\/[\w-]+$/.test(url.pathname)) {
        return route.fulfill({
          status: 200,
          contentType: 'application/json',
          body: JSON.stringify({
            items: [
              {
                id: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
                assetCode: 'CFA001',
                assetName: 'CFA Bond 001',
                issuerName: 'Issuer LLC',
                totalAmount: 1000000,
                nominal: 1000,
                availableAmount: 900000,
                issueDate: '2025-01-01',
                maturityDate: '2026-01-01',
                yield: 12.5,
                status: 'open',
              },
            ],
            total: 1,
            limit: 20,
            offset: 0,
          }),
        });
      }
      return route.fallback();
    });

    // Mock detail
    await page.route('**/v1/market/issuances/aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa', (route) => {
      return route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          id: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
          assetCode: 'CFA001',
          assetName: 'CFA Bond 001',
          issuerName: 'Issuer LLC',
          totalAmount: 1000000,
          nominal: 1000,
          availableAmount: 900000,
          issueDate: '2025-01-01',
          maturityDate: '2026-01-01',
          yield: 12.5,
          status: 'open',
          scheduleJson: { '2025-03-01': 50000 },
        }),
      });
    });

    // Mock order placement
    await page.route('**/v1/orders', async (route) => {
      const headers = route.request().headers();
      expect(headers['idempotency-key']).toBeTruthy();
      return route.fulfill({
        status: 202,
        contentType: 'application/json',
        body: JSON.stringify({
          id: 'order-1',
          investorId: fakeSession.user.id,
          issuanceId: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
          amount: 10000,
          status: 'pending',
          dltTxHash: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
          createdAt: new Date().toISOString(),
        }),
      });
    });

    // Mock wallet for portfolio page
    await page.route(`**/v1/wallets/${fakeSession.user.id}`, (route) => {
      return route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ id: 'w1', ownerType: 'individual', ownerId: fakeSession.user.id, balance: 100000, blocked: 0, holdings: [] }),
      });
    });

    // Mock history endpoints
    await page.route(`**/v1/investors/${fakeSession.user.id}/transactions**`, (route) => {
      return route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          items: [
            {
              id: 'tx1',
              type: 'issue',
              issuanceId: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
              issuanceCode: 'CFA001',
              amount: 10000,
              status: 'confirmed',
              dltTxHash: 'abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789',
              createdAt: new Date().toISOString(),
            },
          ],
          total: 1,
        }),
      });
    });
    await page.route(`**/v1/investors/${fakeSession.user.id}/payouts**`, (route) => {
      return route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ items: [], total: 0, totalAmount: 0 }),
      });
    });

    // Run journey
    await page.goto('http://localhost:3002/catalog');
    await expect(page.getByText('Market Catalog')).toBeVisible();
    await page.getByRole('link', { name: /CFA Bond 001/ }).click();
    await expect(page.getByText('Place Order')).toBeVisible();
    await page.fill('input#amount', '10000');
    await page.getByRole('button', { name: 'Buy Now' }).click();
    await page.waitForURL('**/portfolio');

    // History
    await page.goto('http://localhost:3002/history');
    await expect(page.getByText('Transaction History')).toBeVisible();
    await expect(page.getByText('issue')).toBeVisible();
  });
});


```

`tests/e2e/tests/investor.catalog_buy_history.spec.ts`:

```ts
import { test, expect } from '@playwright/test';

const investorId = '11111111-1111-4111-8111-111111111111';
const fakeSession = {
  user: {
    name: 'Ivan Investor',
    email: 'ivan@example.com',
    roles: ['investor'],
    id: investorId,
  },
  accessToken: 'test-token',
  expires: new Date(Date.now() + 60 * 60 * 1000).toISOString(),
};

test.describe('Investor catalog → detail → buy → history', () => {
  test('end-to-end journey with CSV export', async ({ page }) => {
    // Session
    await page.route('**/api/auth/session**', (route) =>
      route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify(fakeSession) })
    );

    // Catalog list and detail
    await page.route('**/v1/market/issuances**', (route) => {
      const url = new URL(route.request().url());
      if (url.pathname.endsWith('/v1/market/issuances') && !/\/v1\/market\/issuances\/[\w-]+$/.test(url.pathname)) {
        return route.fulfill({
          status: 200,
          contentType: 'application/json',
          body: JSON.stringify({
            items: [
              {
                id: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
                assetCode: 'CFA001',
                assetName: 'CFA Bond 001',
                issuerName: 'Issuer LLC',
                totalAmount: 1000000,
                nominal: 1000,
                availableAmount: 900000,
                issueDate: '2025-01-01',
                maturityDate: '2026-01-01',
                yield: 12.5,
                status: 'open',
              },
            ],
            total: 1,
            limit: 20,
            offset: 0,
          }),
        });
      }
      return route.fallback();
    });
    await page.route('**/v1/market/issuances/aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa', (route) =>
      route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          id: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
          assetCode: 'CFA001',
          assetName: 'CFA Bond 001',
          issuerName: 'Issuer LLC',
          totalAmount: 1000000,
          nominal: 1000,
          availableAmount: 900000,
          issueDate: '2025-01-01',
          maturityDate: '2026-01-01',
          yield: 12.5,
          status: 'open',
          scheduleJson: { '2025-03-01': 50000 },
        }),
      })
    );

    // Orders
    await page.route('**/v1/orders', (route) =>
      route.fulfill({
        status: 202,
        contentType: 'application/json',
        body: JSON.stringify({
          id: 'order-1',
          investorId,
          issuanceId: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
          amount: 10000,
          status: 'pending',
          dltTxHash: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
          createdAt: new Date().toISOString(),
        }),
      })
    );

    // Wallet for portfolio redirect
    await page.route(`**/v1/wallets/${investorId}`, (route) =>
      route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify({ id: 'w1', ownerType: 'individual', ownerId: investorId, balance: 100000, blocked: 0, holdings: [] }) })
    );

    // Transactions handler with type filter
    await page.route(`**/v1/investors/${investorId}/transactions**`, (route) => {
      const url = new URL(route.request().url());
      const type = url.searchParams.get('type');
      const txBase = {
        id: 'tx-1',
        issuanceId: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
        issuanceCode: 'CFA001',
        amount: 10000,
        status: 'confirmed',
        dltTxHash: 'abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789',
        createdAt: new Date().toISOString(),
      };
      const item =
        type === 'redeem'
          ? { ...txBase, id: 'tx-r', type: 'redeem' }
          : { ...txBase, id: 'tx-t', type: 'transfer' };
      return route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify({ items: [item], total: 1 }) });
    });

    // Payouts
    await page.route(`**/v1/investors/${investorId}/payouts**`, (route) =>
      route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify({ items: [], total: 0, totalAmount: 0 }) })
    );

    // Go to catalog
    await page.goto('http://localhost:3002/catalog');
    await expect(page.getByText('Market Catalog')).toBeVisible();

    // Go to detail and buy
    await page.getByRole('link', { name: /CFA Bond 001/ }).click();
    await expect(page.getByText('Place Order')).toBeVisible();
    await page.fill('input#amount', '10000');
    await page.getByRole('button', { name: 'Buy Now' }).click();
    await page.waitForURL('**/portfolio');

    // History: Orders tab
    await page.goto('http://localhost:3002/history');
    await expect(page.getByText('History')).toBeVisible();
    await page.getByRole('button', { name: /Orders/ }).click();
    await expect(page.getByText('transfer')).toBeVisible();

    // Payouts tab
    await page.getByRole('button', { name: /Payouts/ }).click();
    await expect(page.getByText('No payouts found')).toBeVisible();

    // Redemptions tab
    await page.getByRole('button', { name: /Redemptions/ }).click();
    await expect(page.getByText('redeem')).toBeVisible();
  });
});


```

`tests/e2e/tests/issuer-journey.spec.ts`:

```ts
import { test, expect } from '@playwright/test';

const fakeSession = {
  user: {
    name: 'Irina Issuer',
    email: 'issuer@example.com',
    roles: ['issuer'],
    id: '22222222-2222-4222-8222-222222222222',
    issuerId: '22222222-2222-4222-8222-222222222222',
  },
  accessToken: 'issuer-token',
  expires: new Date(Date.now() + 60 * 60 * 1000).toISOString(),
};

test.describe('Issuer: reports export', () => {
  test('view reports and export', async ({ page }) => {
    await page.route('**/api/auth/session**', (route) =>
      route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify(fakeSession) })
    );

    await page.route('**/v1/reports/issuances**', (route) => {
      return route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          issuerId: fakeSession.user.issuerId,
          period: { from: '2025-01-01', to: '2025-03-31' },
          items: [
            {
              issuanceId: 'aaaaaaaa-aaaa-4aaa-8aaa-aaaaaaaaaaaa',
              assetCode: 'CFA001',
              assetName: 'CFA Bond 001',
              totalAmount: 1000000,
              soldAmount: 250000,
              investorsCount: 12,
              status: 'published',
              issueDate: '2025-01-01',
              maturityDate: '2026-01-01',
              publishedAt: '2025-01-02T00:00:00Z',
            },
          ],
          summary: { totalIssuances: 1, totalAmount: 1000000, totalSold: 250000, totalInvestors: 12 },
        }),
      });
    });

    await page.route('**/v1/reports/payouts**', (route) => {
      return route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          issuerId: fakeSession.user.issuerId,
          period: { from: '2025-01-01', to: '2025-03-31' },
          granularity: 'month',
          items: [
            { period: '2025-02', totalAmount: 50000, payoutCount: 3, investorsCount: 10 },
            { period: '2025-03', totalAmount: 70000, payoutCount: 4, investorsCount: 12 },
          ],
          summary: { totalAmount: 120000, totalPayouts: 7, totalInvestors: 22 },
        }),
      });
    });

    await page.goto('http://localhost:3001/reports');
    await expect(page.getByText('Reports')).toBeVisible();
    // Export buttons enabled
    await expect(page.getByRole('button', { name: 'Export CSV' })).toBeEnabled();
    await expect(page.getByRole('button', { name: 'Export XLSX' })).toBeEnabled();

    // Switch to payouts and ensure rendered
    await page.getByRole('button', { name: 'Payouts' }).click();
    await expect(page.getByText('Payouts Over Time')).toBeVisible();
  });
});


```

`tests/e2e/tests/ledger-integration.spec.ts`:

```ts
import { test, expect } from '@playwright/test';

/**
 * E2E тест для проверки интеграции с Hyperledger Fabric dev-сетью
 * 
 * Требования:
 * 1. Fabric сеть запущена: cd ops/fabric && ./dev-up.sh && ./scripts/create-channel.sh && ./scripts/install-chaincode.sh && ./scripts/approve-chaincode.sh
 * 2. Сервисы запущены с Ledger:UseMock=false
 * 3. Chaincode Gateway доступен на http://localhost:8080 (или настроен endpoint)
 */
test.describe('Ledger Integration E2E', () => {
  test.beforeAll(async () => {
    // Проверка доступности Fabric сети
    // Можно добавить health-check через API или docker exec
  });

  test('Publish issuance → Verify txHash returned', async ({ request }) => {
    // 1. Создать issuance (draft)
    const createResponse = await request.post('http://localhost:5001/v1/issuances', {
      data: {
        assetId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
        issuerId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
        totalAmount: 1000000,
        nominal: 1000,
        issueDate: '2025-01-01',
        maturityDate: '2026-01-01',
      },
    });

    expect(createResponse.ok()).toBeTruthy();
    const issuance = await createResponse.json();
    const issuanceId = issuance.id;

    // 2. Publish issuance (должен вызвать ledger Issue)
    const publishResponse = await request.post(
      `http://localhost:5001/v1/issuances/${issuanceId}/publish`
    );

    expect(publishResponse.ok()).toBeTruthy();
    const publishResult = await publishResponse.json();

    // 3. Verify txHash returned
    expect(publishResult).toHaveProperty('dltTxHash');
    expect(publishResult.dltTxHash).toBeTruthy();
    expect(typeof publishResult.dltTxHash).toBe('string');
    expect(publishResult.dltTxHash.length).toBeGreaterThan(0);

    // 4. Query issuance from ledger (optional - через chaincode query)
    const getResponse = await request.get(`http://localhost:5001/v1/issuances/${issuanceId}`);
    expect(getResponse.ok()).toBeTruthy();
    const issuanceData = await getResponse.json();
    expect(issuanceData.dltTxHash).toBe(publishResult.dltTxHash);
  });

  test('Place order → Transfer on ledger → Verify txHash', async ({ request }) => {
    // Предполагаем, что issuance уже опубликован (из предыдущего теста или setup)
    const issuanceId = '3fa85f64-5717-4562-b3fc-2c963f66afa6'; // TODO: использовать реальный ID
    const investorId = '3fa85f64-5717-4562-b3fc-2c963f66afa7';

    // 1. Place order (должен вызвать ledger Transfer)
    const orderResponse = await request.post('http://localhost:5002/v1/orders', {
      headers: {
        'Idempotency-Key': crypto.randomUUID(),
      },
      data: {
        investorId,
        issuanceId,
        amount: 10000,
      },
    });

    expect(orderResponse.ok() || orderResponse.status() === 202).toBeTruthy();
    const order = await orderResponse.json();

    // 2. Verify txHash returned
    expect(order).toHaveProperty('dltTxHash');
    expect(order.dltTxHash).toBeTruthy();
    expect(typeof order.dltTxHash).toBe('string');

    // 3. Verify order status
    const orderId = order.id;
    const getOrderResponse = await request.get(`http://localhost:5002/v1/orders/${orderId}`);
    expect(getOrderResponse.ok()).toBeTruthy();
    const orderData = await getOrderResponse.json();
    expect(orderData.dltTxHash).toBe(order.dltTxHash);
  });

  test('Redeem → Verify txHash returned', async ({ request }) => {
    const issuanceId = '3fa85f64-5717-4562-b3fc-2c963f66afa6'; // TODO: использовать реальный ID
    const holderId = '3fa85f64-5717-4562-b3fc-2c963f66afa7';

    // 1. Redeem (должен вызвать ledger Redeem)
    const redeemResponse = await request.post(
      `http://localhost:5002/v1/issuances/${issuanceId}/redeem`,
      {
        data: {
          amount: 5000,
        },
      }
    );

    expect(redeemResponse.ok()).toBeTruthy();
    const redeemResult = await redeemResponse.json();

    // 2. Verify txHash returned
    expect(redeemResult).toHaveProperty('dltTxHash');
    expect(redeemResult.dltTxHash).toBeTruthy();
    expect(typeof redeemResult.dltTxHash).toBe('string');
  });

  test('Full lifecycle: Issue → Transfer → Redeem', async ({ request }) => {
    // 1. Create and publish issuance
    const createResponse = await request.post('http://localhost:5001/v1/issuances', {
      data: {
        assetId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
        issuerId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
        totalAmount: 1000000,
        nominal: 1000,
        issueDate: '2025-01-01',
        maturityDate: '2026-01-01',
      },
    });

    const issuance = await createResponse.json();
    const issuanceId = issuance.id;

    const publishResponse = await request.post(
      `http://localhost:5001/v1/issuances/${issuanceId}/publish`
    );
    const publishResult = await publishResponse.json();
    const issueTxHash = publishResult.dltTxHash;

    expect(issueTxHash).toBeTruthy();
    console.log(`Issuance published with txHash: ${issueTxHash}`);

    // 2. Place order (Transfer)
    const investorId = '3fa85f64-5717-4562-b3fc-2c963f66afa7';
    const orderResponse = await request.post('http://localhost:5002/v1/orders', {
      headers: {
        'Idempotency-Key': crypto.randomUUID(),
      },
      data: {
        investorId,
        issuanceId,
        amount: 50000,
      },
    });

    const order = await orderResponse.json();
    const transferTxHash = order.dltTxHash;

    expect(transferTxHash).toBeTruthy();
    expect(transferTxHash).not.toBe(issueTxHash);
    console.log(`Transfer executed with txHash: ${transferTxHash}`);

    // 3. Redeem
    const redeemResponse = await request.post(
      `http://localhost:5002/v1/issuances/${issuanceId}/redeem`,
      {
        data: {
          amount: 10000,
        },
      }
    );

    const redeemResult = await redeemResponse.json();
    const redeemTxHash = redeemResult.dltTxHash;

    expect(redeemTxHash).toBeTruthy();
    expect(redeemTxHash).not.toBe(issueTxHash);
    expect(redeemTxHash).not.toBe(transferTxHash);
    console.log(`Redeem executed with txHash: ${redeemTxHash}`);

    // 4. Verify all txHash are unique
    expect(issueTxHash).not.toBe(transferTxHash);
    expect(transferTxHash).not.toBe(redeemTxHash);
    expect(issueTxHash).not.toBe(redeemTxHash);
  });
});


```

`tests/e2e/tests/lifecycle.spec.ts`:

```ts
import { test, expect } from '@playwright/test';
import { seedTestData, cleanupTestData } from '../helpers/test-data';

test.describe('Full Lifecycle E2E', () => {
  test.beforeEach(async ({ page }) => {
    // Seed test data if needed
    await seedTestData();
  });

  test.afterEach(async () => {
    // Cleanup test data
    await cleanupTestData();
  });

  test('should complete issuance lifecycle', async ({ page }) => {
    // Navigate to issuer portal
    await page.goto('http://localhost:3001');
    
    // Wait for page load
    await page.waitForLoadState('networkidle');
    
    // TODO: Authenticate with Keycloak (mock for now)
    // await page.click('text=Sign in with Keycloak');
    
    // Navigate to create issuance
    await page.goto('http://localhost:3001/issuances/create', { waitUntil: 'networkidle' });
    
    // Fill form with explicit waits
    await page.fill('input[name="assetId"]', '3fa85f64-5717-4562-b3fc-2c963f66afa6', { timeout: 5000 });
    await page.fill('input[name="issuerId"]', '3fa85f64-5717-4562-b3fc-2c963f66afa6');
    await page.fill('input[name="totalAmount"]', '1000000');
    await page.fill('input[name="nominal"]', '1000');
    await page.fill('input[name="issueDate"]', '2025-01-01');
    await page.fill('input[name="maturityDate"]', '2026-01-01');
    
    // Submit form with wait for navigation
    await Promise.all([
      page.waitForResponse(response => 
        response.url().includes('/v1/issuances') && response.status() === 201,
        { timeout: 10000 }
      ),
      page.click('button[type="submit"]'),
    ]);
    
    // Wait for success message or navigation
    await page.waitForTimeout(2000);
    
    // Verify navigation or success message
    expect(page.url()).toContain('/issuances');
  });

  test('should place buy order', async ({ page }) => {
    // Navigate to investor portal
    await page.goto('http://localhost:3002/orders/new', { waitUntil: 'networkidle' });
    
    // Fill order form with explicit waits
    await page.fill('input[name="issuanceId"]', '3fa85f64-5717-4562-b3fc-2c963f66afa6', { timeout: 5000 });
    await page.fill('input[name="amount"]', '50000');
    
    // Submit with wait for response
    await Promise.all([
      page.waitForResponse(response => 
        response.url().includes('/v1/orders') && (response.status() === 202 || response.status() === 429),
        { timeout: 10000 }
      ),
      page.click('button[type="submit"]'),
    ]);
    
    // Wait for navigation or success
    await page.waitForTimeout(2000);
    
    // Verify navigation to portfolio or success message
    const currentUrl = page.url();
    expect(currentUrl).toMatch(/\/portfolio|\/orders/);
  });

  test('should handle rate limiting', async ({ page }) => {
    // Make multiple rapid requests to trigger rate limit
    const requests = Array(10).fill(null).map(() => 
      page.request.post('http://localhost:5000/v1/orders', {
        data: {
          investorId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
          issuanceId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
          amount: 50000,
        },
        headers: {
          'Idempotency-Key': `test-${Date.now()}-${Math.random()}`,
        },
      })
    );

    const responses = await Promise.all(requests);
    
    // At least one should be rate limited (429)
    const rateLimited = responses.some(r => r.status() === 429);
    expect(rateLimited).toBeTruthy();
  });
});

```

`tests/issuance.Tests/IssuanceApiTests.cs`:

```cs
using System.Net;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Security.Claims;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.AspNetCore.TestHost;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using OIS.Issuance;
using OIS.Issuance.DTOs;
using Xunit;

namespace OIS.Issuance.Tests;

public class IssuanceApiTests : IClassFixture<CustomWebApplicationFactory>
{
    private readonly CustomWebApplicationFactory _factory;

    public IssuanceApiTests(CustomWebApplicationFactory factory)
    {
        _factory = factory;
    }

    private HttpClient CreateClient()
    {
        var client = _factory.CreateClient(new WebApplicationFactoryClientOptions { AllowAutoRedirect = false });
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "test-token");
        return client;
    }

    [Fact]
    public async Task Publish_NonExistent_Should_Return_404()
    {
        var client = CreateClient();
        var res = await client.PostAsync($"/v1/issuances/{Guid.NewGuid()}/publish", content: null);
        Assert.Equal(HttpStatusCode.NotFound, res.StatusCode);
    }
}

public class CustomWebApplicationFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.UseSetting("Kafka:Enabled", "false");
        builder.ConfigureAppConfiguration((ctx, cfg) =>
        {
            cfg.AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Kafka:Enabled"] = "false",
                ["RunMigrations"] = "false",
                ["DisableHttpsRedirection"] = "true",
                ["Ledger:UseMock"] = "true",
                ["Ledger:ChaincodeEndpoint"] = ""
            });
        });

        builder.ConfigureTestServices(services =>
        {
            var descriptor = services.SingleOrDefault(d => d.ServiceType == typeof(DbContextOptions<IssuanceDbContext>));
            if (descriptor != null) services.Remove(descriptor);
            services.AddDbContext<IssuanceDbContext>(options => options.UseInMemoryDatabase("IssuanceTestsDb"));

            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = "Test";
                options.DefaultChallengeScheme = "Test";
            }).AddScheme<AuthenticationSchemeOptions, TestAuthHandler>("Test", options => { });
        });
    }
}

public class TestAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    public TestAuthHandler(IOptionsMonitor<AuthenticationSchemeOptions> options, ILoggerFactory logger, System.Text.Encodings.Web.UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock) { }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, Guid.NewGuid().ToString()),
            new Claim(ClaimTypes.Role, "issuer")
        };
        var identity = new ClaimsIdentity(claims, Scheme.Name);
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, Scheme.Name);
        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}


```

`tests/issuance.Tests/IssuanceServiceTests.cs`:

```cs
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Domain;
using OIS.Issuance.DTOs;
using OIS.Issuance.Services;
using Xunit;

namespace OIS.Issuance.Tests;

public class IssuanceServiceTests
{
    private readonly IssuanceDbContext _db;
    private readonly Mock<ILogger<IssuanceService>> _logger;
    private readonly Mock<IOutboxService> _outbox;
    private readonly IssuanceService _service;
    private readonly Mock<ILedgerIssuance> _ledger;

    public IssuanceServiceTests()
    {
        var options = new DbContextOptionsBuilder<IssuanceDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        _db = new IssuanceDbContext(options);
        _logger = new Mock<ILogger<IssuanceService>>();
        _outbox = new Mock<IOutboxService>();
        _ledger = new Mock<ILedgerIssuance>();
        _ledger.Setup(l => l.IssueAsync(It.IsAny<Guid>(), It.IsAny<Guid>(), It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<decimal>(), It.IsAny<DateOnly>(), It.IsAny<DateOnly>(), It.IsAny<string?>(), It.IsAny<CancellationToken>()))
               .ReturnsAsync("txhash-issue");
        _ledger.Setup(l => l.CloseAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
               .ReturnsAsync("txhash-close");
        _service = new IssuanceService(_db, _logger.Object, _outbox.Object, _ledger.Object);
    }

    [Fact]
    public async Task CreateAsync_ShouldCreateDraftIssuance()
    {
        var request = new CreateIssuanceRequest
        {
            AssetId = Guid.NewGuid(),
            IssuerId = Guid.NewGuid(),
            TotalAmount = 1000000m,
            Nominal = 1000m,
            IssueDate = DateOnly.FromDateTime(DateTime.UtcNow),
            MaturityDate = DateOnly.FromDateTime(DateTime.UtcNow.AddYears(1))
        };

        var result = await _service.CreateAsync(request, CancellationToken.None);

        result.Should().NotBeNull();
        result.Status.Should().Be("draft");
        result.AssetId.Should().Be(request.AssetId);
        result.IssuerId.Should().Be(request.IssuerId);
    }
}


```

`tests/issuance.Tests/TestResults/issuance.trx`:

```trx
<?xml version="1.0" encoding="utf-8"?>
<TestRun id="b29f05a9-ec09-42d0-b7b5-a3a1cb2519b1" name="@god 2025-11-12 23:04:38" xmlns="http://microsoft.com/schemas/VisualStudio/TeamTest/2010">
  <Times creation="2025-11-12T23:04:38.2146963+03:00" queuing="2025-11-12T23:04:38.2146964+03:00" start="2025-11-12T23:04:35.9528598+03:00" finish="2025-11-12T23:04:40.1415178+03:00" />
  <TestSettings name="default" id="cc02bc47-792f-409f-9a00-690429400f65">
    <Deployment runDeploymentRoot="_god_2025-11-12_23_04_38" />
  </TestSettings>
  <Results>
    <UnitTestResult executionId="23e417d4-3730-44cd-88b1-83ce810d0d58" testId="bf851f9a-f7ba-90b7-6ecb-9870f2fd56ec" testName="OIS.Issuance.Tests.IssuanceServiceTests.CreateAsync_ShouldCreateDraftIssuance" computerName="god" duration="00:00:00.8824920" startTime="2025-11-12T23:04:37.8700265+03:00" endTime="2025-11-12T23:04:37.8700594+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Passed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="23e417d4-3730-44cd-88b1-83ce810d0d58" />
    <UnitTestResult executionId="30dbc4a8-66d7-4181-a79d-555044766c66" testId="6a93f21e-872c-d16b-a12b-55f7ab85847f" testName="OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404" computerName="god" duration="00:00:02.9668718" startTime="2025-11-12T23:04:39.9760835+03:00" endTime="2025-11-12T23:04:39.9760837+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Failed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="30dbc4a8-66d7-4181-a79d-555044766c66">
      <Output>
        <ErrorInfo>
          <Message>Assert.Equal() Failure: Values differ
Expected: NotFound
Actual:   InternalServerError</Message>
          <StackTrace>   at OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404() in /mnt/w/development/ois-cfa/tests/issuance.Tests/IssuanceApiTests.cs:line 42
--- End of stack trace from previous location ---</StackTrace>
        </ErrorInfo>
      </Output>
    </UnitTestResult>
  </Results>
  <TestDefinitions>
    <UnitTest name="OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404" storage="/mnt/w/development/ois-cfa/tests/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="6a93f21e-872c-d16b-a12b-55f7ab85847f">
      <Execution id="30dbc4a8-66d7-4181-a79d-555044766c66" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/tests/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceApiTests" name="Publish_NonExistent_Should_Return_404" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceServiceTests.CreateAsync_ShouldCreateDraftIssuance" storage="/mnt/w/development/ois-cfa/tests/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="bf851f9a-f7ba-90b7-6ecb-9870f2fd56ec">
      <Execution id="23e417d4-3730-44cd-88b1-83ce810d0d58" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/tests/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceServiceTests" name="CreateAsync_ShouldCreateDraftIssuance" />
    </UnitTest>
  </TestDefinitions>
  <TestEntries>
    <TestEntry testId="bf851f9a-f7ba-90b7-6ecb-9870f2fd56ec" executionId="23e417d4-3730-44cd-88b1-83ce810d0d58" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="6a93f21e-872c-d16b-a12b-55f7ab85847f" executionId="30dbc4a8-66d7-4181-a79d-555044766c66" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
  </TestEntries>
  <TestLists>
    <TestList name="Results Not in a List" id="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestList name="All Loaded Results" id="19431567-8539-422a-85d7-44ee4e166bda" />
  </TestLists>
  <ResultSummary outcome="Failed">
    <Counters total="2" executed="2" passed="1" failed="1" error="0" timeout="0" aborted="0" inconclusive="0" passedButRunAborted="0" notRunnable="0" notExecuted="0" disconnected="0" warning="0" completed="0" inProgress="0" pending="0" />
    <Output>
      <StdOut>[xUnit.net 00:00:00.00] xUnit.net VSTest Adapter v2.8.2+699d445a1a (64-bit .NET 9.0.11)
[xUnit.net 00:00:00.17]   Discovering: issuance.Tests
[xUnit.net 00:00:00.23]   Discovered:  issuance.Tests
[xUnit.net 00:00:00.24]   Starting:    issuance.Tests
2025-11-12 23:04:39.888 +03:00 [WRN] Ledger adapter running in MOCK mode
{"Timestamp":"2025-11-12T23:04:39.8887466+03:00","Level":"Warning","MessageTemplate":"Ledger adapter running in MOCK mode","TraceId":"4a8f072f156f3c07f89490e5feaaf988","SpanId":"0b47146b4c8deb31","Properties":{"SourceContext":"OIS.Issuance.Services.LedgerIssuanceAdapter","RequestId":"0HNH24QR6MLPB","RequestPath":"/v1/issuances/a2033239-085f-432f-bae5-1ffa619f1bd7/publish"}}
2025-11-12 23:04:39.917 +03:00 [ERR] An unhandled exception has occurred while executing the request.
System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.
   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)
   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()
   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()
   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11
   at OIS.Issuance.Services.IssuanceService.GetByIdAsync(Guid id, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 64
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_11&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 233
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)
{"Timestamp":"2025-11-12T23:04:39.9177878+03:00","Level":"Error","MessageTemplate":"An unhandled exception has occurred while executing the request.","TraceId":"4a8f072f156f3c07f89490e5feaaf988","SpanId":"0b47146b4c8deb31","Exception":"System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.\n   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)\n   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()\n   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()\n   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()\n   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()\n   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11\n   at OIS.Issuance.Services.IssuanceService.GetByIdAsync(Guid id, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 64\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_11&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 233\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\n   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\n   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)","Properties":{"EventId":{"Id":1,"Name":"UnhandledException"},"SourceContext":"Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware","RequestId":"0HNH24QR6MLPB","RequestPath":"/v1/issuances/a2033239-085f-432f-bae5-1ffa619f1bd7/publish"}}
[xUnit.net 00:00:03.28]       Assert.Equal() Failure: Values differ
[xUnit.net 00:00:03.28]       Expected: NotFound
[xUnit.net 00:00:03.28]       Actual:   InternalServerError
[xUnit.net 00:00:03.28]       Stack Trace:
[xUnit.net 00:00:03.28]         /mnt/w/development/ois-cfa/tests/issuance.Tests/IssuanceApiTests.cs(42,0): at OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404()
[xUnit.net 00:00:03.28]         --- End of stack trace from previous location ---
[xUnit.net 00:00:03.29]   Finished:    issuance.Tests
</StdOut>
    </Output>
    <RunInfos>
      <RunInfo computerName="god" outcome="Error" timestamp="2025-11-12T23:04:39.9731328+03:00">
        <Text>[xUnit.net 00:00:03.28]     OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404 [FAIL]</Text>
      </RunInfo>
    </RunInfos>
  </ResultSummary>
</TestRun>
```

`tests/issuance.Tests/issuance.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="FluentAssertions" Version="6.12.1" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="Moq" Version="4.20.70" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="9.0.1" />
    <PackageReference Include="coverlet.collector" Version="6.0.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\services\issuance\issuance.csproj" />
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>

</Project>


```

`tests/k6/gateway-critical-paths.js`:

```js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

const errorRate = new Rate('errors');
const orderLatency = new Trend('order_latency');
const settlementReportLatency = new Trend('settlement_report_latency');

export const options = {
  stages: [
    { duration: '30s', target: 50 },  // Ramp up
    { duration: '1m', target: 100 },  // Stay at 100 RPS
    { duration: '30s', target: 0 },   // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<300', 'p(99)<500'],
    http_req_failed: ['rate<0.01'],
    errors: ['rate<0.01'],
    order_latency: ['p(95)<300'],
    settlement_report_latency: ['p(95)<300'],
  },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:5000';
const TOKEN = __ENV.TOKEN; // optional JWT

export default function () {
  // Test critical path: Place Order
  const orderPayload = JSON.stringify({
    investorId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
    issuanceId: '3fa85f64-5717-4562-b3fc-2c963f66afa6',
    amount: 50000,
  });

  const orderHeaders = {
    'Content-Type': 'application/json',
    'Idempotency-Key': `test-${Date.now()}-${Math.random()}`,
    ...(TOKEN ? { Authorization: `Bearer ${TOKEN}` } : {}),
  };

  const orderRes = http.post(
    `${BASE_URL}/v1/orders`,
    orderPayload,
    { headers: orderHeaders }
  );

  const orderSuccess = check(orderRes, {
    'order status is 202': (r) => r.status === 202 || r.status === 429, // 429 is rate limit, acceptable
    'order response time < 500ms': (r) => r.timings.duration < 500,
  });

  errorRate.add(!orderSuccess);
  orderLatency.add(orderRes.timings.duration);

  sleep(1);

  // Test critical path: Settlement Report
  const reportRes = http.get(
    `${BASE_URL}/v1/reports/payouts?from=2025-01-01&to=2025-12-31`,
    { headers: { 'Content-Type': 'application/json', ...(TOKEN ? { Authorization: `Bearer ${TOKEN}` } : {}) } }
  );

  const reportSuccess = check(reportRes, {
    'report status is 200': (r) => r.status === 200 || r.status === 429,
    'report response time < 500ms': (r) => r.timings.duration < 500,
  });

  errorRate.add(!reportSuccess);
  settlementReportLatency.add(reportRes.timings.duration);

  sleep(1);
}

export function handleSummary(data) {
  return {
    'stdout': textSummary(data, { indent: ' ', enableColors: true }),
    'k6-report.json': JSON.stringify(data),
    'k6-report.html': htmlReport(data),
  };
}

function textSummary(data, options) {
  const thresholds = data.metrics.http_req_duration?.values?.['p(95)'] || 0;
  return `\n✅ p95 latency: ${thresholds.toFixed(2)}ms (threshold: <300ms)\n`;
}

function htmlReport(data) {
  return '<html><body><h1>k6 Load Test Report</h1></body></html>';
}


```

`tests/k6/payouts-report.js`:

```js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

const errorRate = new Rate('errors');

export const options = {
  stages: [
    { duration: '30s', target: 50 },
    { duration: '1m', target: 100 },
    { duration: '30s', target: 0 },
  ],
  thresholds: {
    http_req_duration: ['p(95)<300'],
    errors: ['rate<0.01'],
  },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:5000';
const TOKEN = __ENV.TOKEN; // optional JWT

export default function () {
  const today = new Date();
  const from = new Date(today);
  from.setDate(from.getDate() - 30);
  
  const toDate = today.toISOString().split('T')[0];
  const fromDate = from.toISOString().split('T')[0];

  const url = `${BASE_URL}/v1/reports/payouts?from=${fromDate}&to=${toDate}`;
  
  const params = {
    headers: {
      'Content-Type': 'application/json',
      ...(TOKEN ? { Authorization: `Bearer ${TOKEN}` } : {}),
    },
  };

  const res = http.get(url, params);
  
  const success = check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 300ms': (r) => r.timings.duration < 300,
    'has totalBatches field': (r) => JSON.parse(r.body).totalBatches !== undefined,
  });

  errorRate.add(!success);
  
  sleep(0.1);
}


```

`tests/load/README.md`:

```md
# Load Tests (k6)

Нагрузочные тесты для проверки производительности.

## Targets

- 100 RPS sanity check
- p95 < 300ms

## TODO

- [ ] Create k6 scripts
- [ ] Setup load test scenarios
- [ ] CI/CD integration

## Run

```bash
k6 run load-test.js
```


```