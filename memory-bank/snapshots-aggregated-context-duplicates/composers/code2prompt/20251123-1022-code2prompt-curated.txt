Context generated for curated CFA stack (services/apps/contracts/deploy scripts).

---
# apps/api-gateway/Program.cs
```cs
using Serilog;
using Yarp.ReverseProxy.Configuration;
using System.Threading.RateLimiting;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter())
    .ReadFrom.Configuration(ctx.Configuration));

// Services
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks();
builder.Services.AddCors();

// Rate Limiting (Token Bucket)
builder.Services.AddRateLimiter(options =>
{
    options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(context =>
        RateLimitPartition.GetTokenBucketLimiter(
            partitionKey: context.Connection.RemoteIpAddress?.ToString() ?? "unknown",
            factory: _ => new TokenBucketRateLimiterOptions
            {
                TokenLimit = 100,
                QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
                QueueLimit = 10,
                ReplenishmentPeriod = TimeSpan.FromSeconds(1),
                TokensPerPeriod = 10,
                AutoReplenishment = true
            }));
    
    options.OnRejected = async (context, cancellationToken) =>
    {
        context.HttpContext.Response.StatusCode = 429;
        await context.HttpContext.Response.WriteAsync("Rate limit exceeded. Please retry later.", cancellationToken);
    };
});

// Request Size Limits
builder.Services.Configure<Microsoft.AspNetCore.Http.Features.FormOptions>(options =>
{
    options.MultipartBodyLengthLimit = 10485760; // 10 MB
    options.ValueLengthLimit = 10485760;
});

// YARP Reverse Proxy
builder.Services.AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// Security Headers Middleware
app.Use(async (context, next) =>
{
    context.Response.Headers.Append("X-Content-Type-Options", "nosniff");
    context.Response.Headers.Append("X-Frame-Options", "DENY");
    context.Response.Headers.Append("X-XSS-Protection", "1; mode=block");
    context.Response.Headers.Append("Referrer-Policy", "strict-origin-when-cross-origin");
    context.Response.Headers.Append("Content-Security-Policy", "default-src 'self'");
    await next();
});

// CORS
app.UseCors(policy =>
{
    var allowedOrigins = builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>() 
        ?? new[] { "http://localhost:3001", "http://localhost:3002", "http://localhost:3003" };
    
    policy.WithOrigins(allowedOrigins)
        .AllowAnyMethod()
        .AllowAnyHeader()
        .AllowCredentials();
});

// Request Size Limit
app.Use(async (context, next) =>
{
    context.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature>()!
        .MaxRequestBodySize = 10485760; // 10 MB
    await next();
});

app.UseHttpsRedirection();
app.UseRouting();

// Rate Limiting
app.UseRateLimiter();

// Health checks
app.MapHealthChecks("/health");
app.MapGet("/", () => Results.Redirect("/swagger"));

// API endpoints (proxied)
app.MapReverseProxy();

app.Run();


```
---
# apps/api-gateway/appsettings.json
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Cors": {
    "AllowedOrigins": [
      "http://87.249.49.56:3001",
      "http://87.249.49.56:3002",
      "http://87.249.49.56:3003",
      "http://87.249.49.56:53001",
      "http://87.249.49.56:53002",
      "http://87.249.49.56:53003",
      "http://localhost:155101",
      "http://localhost:155102",
      "http://localhost:155103"
    ]
  },
  "ReverseProxy": {
    "Routes": {
      "identity": {
        "ClusterId": "identity",
        "Match": {
          "Path": "/identity/{**catch-all}"
        }
      },
      "identity-v1": {
        "ClusterId": "identity",
        "Match": {
          "Path": "/v1/identity/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/identity/{**catch-all}"
          }
        ]
      },
      "issuances": {
        "ClusterId": "issuance",
        "Match": {
          "Path": "/issuances/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/issuances/{**catch-all}"
          }
        ]
      },
      "orders": {
        "ClusterId": "registry",
        "Match": {
          "Path": "/v1/orders/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/orders/{**catch-all}"
          }
        ]
      },
      "wallets": {
        "ClusterId": "registry",
        "Match": {
          "Path": "/v1/wallets/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/wallets/{**catch-all}"
          }
        ]
      },
      "settlement": {
        "ClusterId": "settlement",
        "Match": {
          "Path": "/v1/settlement/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/settlement/{**catch-all}"
          }
        ]
      },
      "compliance": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/compliance/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/compliance/{**catch-all}"
          }
        ]
      },
      "kyc-tasks": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/kyc/tasks/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/kyc/tasks/{**catch-all}"
          }
        ]
      },
      "audit": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/audit/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/audit/{**catch-all}"
          }
        ]
      },
      "complaints": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/complaints/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/complaints/{**catch-all}"
          }
        ]
      },
      "reports-issuances": {
        "ClusterId": "issuance",
        "Match": {
          "Path": "/v1/reports/issuances"
        },
        "Transforms": [
          {
            "PathSet": "/v1/reports/issuances"
          }
        ]
      },
      "reports": {
        "ClusterId": "settlement",
        "Match": {
          "Path": "/v1/reports/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/reports/{**catch-all}"
          }
        ]
      }
    },
    "Clusters": {
      "identity": {
        "Destinations": {
          "default": {
            "Address": "http://identity-service:8080"
          }
        }
      },
      "issuance": {
        "Destinations": {
          "default": {
            "Address": "http://issuance-service:8080"
          }
        }
      },
      "registry": {
        "Destinations": {
          "default": {
            "Address": "http://registry-service:8080"
          }
        }
      },
      "settlement": {
        "Destinations": {
          "default": {
            "Address": "http://settlement-service:8080"
          }
        }
      },
      "compliance": {
        "Destinations": {
          "default": {
            "Address": "http://compliance-service:8080"
          }
        }
      }
    }
  }
}

```
---
# apps/backoffice/src/app/api/auth/[...nextauth]/route.ts
```ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


```
---
# apps/backoffice/src/app/audit/[id]/page.tsx
```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { getAuditEvent } from '@/lib/api/audit';
import type { AuditEvent } from '@/lib/api/audit';
import { AppShell, PageHeader, EmptyState, Skeleton } from '../../../../../shared-ui/src';
import { useSession } from 'next-auth/react';
import { useRouter, useParams } from 'next/navigation';
import { useEffect } from 'react';
import Link from 'next/link';
import { ArrowLeft } from 'lucide-react';

export default function AuditEventDetailPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const params = useParams();
  const eventId = params.id as string;

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: event, isLoading } = useQuery<AuditEvent | null>({
    queryKey: ['audit-event', eventId],
    queryFn: () => getAuditEvent(eventId),
    enabled: !!eventId && status === 'authenticated',
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  if (isLoading) {
    return (
      <AppShell
        user={session.user}
        sidebar={{
          items: [
            { label: 'Dashboard', href: '/' },
            { label: 'KYC', href: '/kyc' },
            { label: 'Qualification', href: '/qualification' },
            { label: 'Audit', href: '/audit' },
            { label: 'Payouts', href: '/payouts' },
          ],
        }}
      >
        <Skeleton className="h-64 w-full" variant="rectangular" />
      </AppShell>
    );
  }

  if (!event) {
    return (
      <AppShell
        user={session.user}
        sidebar={{
          items: [
            { label: 'Dashboard', href: '/' },
            { label: 'KYC', href: '/kyc' },
            { label: 'Qualification', href: '/qualification' },
            { label: 'Audit', href: '/audit' },
            { label: 'Payouts', href: '/payouts' },
          ],
        }}
      >
        <EmptyState
          title="Audit event not found"
          description="The audit event you're looking for doesn't exist"
        />
      </AppShell>
    );
  }

  return (
    <AppShell
      user={session.user}
      sidebar={{
        items: [
          { label: 'Dashboard', href: '/' },
          { label: 'KYC', href: '/kyc' },
          { label: 'Qualification', href: '/qualification' },
          { label: 'Audit', href: '/audit' },
          { label: 'Payouts', href: '/payouts' },
        ],
      }}
    >
      <PageHeader
        title={`Audit Event ${eventId.slice(0, 8)}`}
        description="Audit event details"
        breadcrumbs={[
          { label: 'Audit', href: '/audit' },
          { label: eventId.slice(0, 8) },
        ]}
        actions={
          <Link
            href="/audit"
            className="flex items-center gap-2 px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover"
          >
            <ArrowLeft className="h-4 w-4" />
            Back
          </Link>
        }
      />

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-surface border border-border rounded-lg p-6">
          <h2 className="text-lg font-semibold text-text-primary mb-4">Event Information</h2>
          <div className="space-y-3 text-sm">
            <div className="flex justify-between">
              <span className="text-text-secondary">ID:</span>
              <span className="text-text-primary font-mono">{event.id}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-text-secondary">Timestamp:</span>
              <span className="text-text-primary">
                {new Date(event.timestamp).toLocaleString()}
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-text-secondary">Actor:</span>
              <span className="text-text-primary">{event.actorName || event.actor}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-text-secondary">Action:</span>
              <span className="text-text-primary font-medium">{event.action}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-text-secondary">Entity:</span>
              <span className="text-text-primary">{event.entity}</span>
            </div>
            {event.entityId && (
              <div className="flex justify-between">
                <span className="text-text-secondary">Entity ID:</span>
                <span className="text-text-primary font-mono">{event.entityId}</span>
              </div>
            )}
            {event.result && (
              <div className="flex justify-between">
                <span className="text-text-secondary">Result:</span>
                <span className="text-text-primary">{event.result}</span>
              </div>
            )}
          </div>
        </div>

        <div className="bg-surface border border-border rounded-lg p-6">
          <h2 className="text-lg font-semibold text-text-primary mb-4">Request Details</h2>
          <div className="space-y-3 text-sm">
            {event.ip && (
              <div className="flex justify-between">
                <span className="text-text-secondary">IP Address:</span>
                <span className="text-text-primary font-mono">{event.ip}</span>
              </div>
            )}
            {event.userAgent && (
              <div className="flex flex-col">
                <span className="text-text-secondary mb-1">User Agent:</span>
                <span className="text-text-primary text-xs break-all">{event.userAgent}</span>
              </div>
            )}
          </div>
        </div>
      </div>

      {event.payload && Object.keys(event.payload).length > 0 && (
        <div className="mt-6 bg-surface border border-border rounded-lg p-6">
          <h2 className="text-lg font-semibold text-text-primary mb-4">Payload</h2>
          <pre className="bg-background p-4 rounded-md overflow-auto text-sm text-text-primary font-mono">
            {JSON.stringify(event.payload, null, 2)}
          </pre>
        </div>
      )}
    </AppShell>
  );
}

```
---
# apps/backoffice/src/app/audit/page.tsx
```tsx
'use client';

import { useMemo, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import Link from 'next/link';
import { getAuditLogs } from '@/lib/api/audit';
import type { AuditEvent, AuditFilters } from '@/lib/api/audit';

const actionOptions = [
  { label: 'All actions', value: '' },
  { label: 'KYC', value: 'kyc' },
  { label: 'Auth', value: 'login' },
  { label: 'Issuance', value: 'issuance' },
];

export default function AuditPage() {
  const [from, setFrom] = useState('');
  const [to, setTo] = useState('');
  const [action, setAction] = useState('');
  const [actor, setActor] = useState('');
  const [selectedEvent, setSelectedEvent] = useState<AuditEvent | null>(null);

  const filters = useMemo<AuditFilters>(
    () => ({
      from: from || undefined,
      to: to || undefined,
      action: action || undefined,
      actor: actor || undefined,
    }),
    [from, to, action, actor],
  );

  const {
    data: events = [],
    isLoading,
    refetch,
  } = useQuery({
    queryKey: ['audit-logs', filters],
    queryFn: () => getAuditLogs(filters),
  });

  const resetFilters = () => {
    setFrom('');
    setTo('');
    setAction('');
    setActor('');
    setSelectedEvent(null);
    refetch();
  };

  return (
    <main className="mx-auto max-w-6xl space-y-8 px-6 py-10">
      <header className="space-y-2">
        <p className="text-sm text-gray-500">Audit Explorer</p>
        <h1 className="text-3xl font-semibold text-gray-900">Audit Log</h1>
        <p className="text-sm text-gray-600">
          Inspect issuer/backoffice actions. Filters are applied at API level with mock fallback when backend недоступен.
        </p>
      </header>

      <section className="rounded-xl border border-gray-200 bg-white p-5 shadow-sm">
        <div className="grid gap-4 md:grid-cols-4">
          <label className="flex flex-col gap-1 text-sm text-gray-600">
            From
            <input
              type="date"
              value={from}
              onChange={(event) => setFrom(event.target.value)}
              className="rounded-md border border-gray-300 px-3 py-2 text-gray-900 focus:border-blue-500 focus:outline-none"
            />
          </label>
          <label className="flex flex-col gap-1 text-sm text-gray-600">
            To
            <input
              type="date"
              value={to}
              onChange={(event) => setTo(event.target.value)}
              className="rounded-md border border-gray-300 px-3 py-2 text-gray-900 focus:border-blue-500 focus:outline-none"
            />
          </label>
          <label className="flex flex-col gap-1 text-sm text-gray-600">
            Action
            <select
              value={action}
              onChange={(event) => setAction(event.target.value)}
              className="rounded-md border border-gray-300 px-3 py-2 text-gray-900 focus:border-blue-500 focus:outline-none"
            >
              {actionOptions.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </label>
          <label className="flex flex-col gap-1 text-sm text-gray-600">
            Actor
            <input
              type="text"
              value={actor}
              placeholder="issuer.portal"
              onChange={(event) => setActor(event.target.value)}
              className="rounded-md border border-gray-300 px-3 py-2 text-gray-900 focus:border-blue-500 focus:outline-none"
            />
          </label>
        </div>
        <div className="mt-4 flex items-center gap-3">
          <button
            type="button"
            onClick={() => refetch()}
            className="rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50"
            disabled={isLoading}
          >
            Apply Filters
          </button>
          <button
            type="button"
            onClick={resetFilters}
            className="rounded-md border border-gray-300 px-4 py-2 text-sm text-gray-600 hover:bg-gray-50"
          >
            Reset
          </button>
        </div>
      </section>

      <section className="rounded-xl border border-gray-200 bg-white shadow-sm">
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200 text-sm">
            <thead className="bg-gray-50 text-left text-xs font-semibold uppercase tracking-wider text-gray-500">
              <tr>
                <th className="px-4 py-3">Timestamp</th>
                <th className="px-4 py-3">Actor</th>
                <th className="px-4 py-3">Action</th>
                <th className="px-4 py-3">Entity</th>
                <th className="px-4 py-3 text-right">Status</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-100">
              {isLoading && (
                <tr>
                  <td colSpan={5} className="px-4 py-6 text-center text-gray-500">
                    Loading audit events…
                  </td>
                </tr>
              )}
              {!isLoading && events.length === 0 && (
                <tr>
                  <td colSpan={5} className="px-4 py-6 text-center text-gray-400">
                    No events for selected filters.
                  </td>
                </tr>
              )}
              {events.map((event) => (
                <tr key={event.id} className="hover:bg-gray-50">
                  <td className="px-4 py-3 align-top text-sm text-gray-900">
                    {new Date(event.timestamp).toLocaleString()}
                  </td>
                  <td className="px-4 py-3">
                    <div className="font-medium text-gray-900">{event.actorName ?? event.actor}</div>
                    {event.ip && <div className="text-xs text-gray-500">{event.ip}</div>}
                  </td>
                  <td className="px-4 py-3 text-gray-800">
                    <div className="font-medium">{event.action}</div>
                    {event.payload && (
                      <button
                        type="button"
                        className="text-xs text-blue-600 hover:underline"
                        onClick={() => setSelectedEvent(event)}
                      >
                        View payload
                      </button>
                    )}
                  </td>
                  <td className="px-4 py-3 text-gray-700">
                    <div>{event.entity}</div>
                    {event.entityId && <div className="text-xs text-gray-500">{event.entityId}</div>}
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex flex-col items-end gap-2 text-sm">
                      <span className="rounded-full bg-gray-100 px-2 py-0.5 text-xs capitalize text-gray-700">
                        {event.result ?? 'pending'}
                      </span>
                      <Link href={`/audit/${event.id}`} className="text-xs font-medium text-blue-600 hover:underline">
                        Details
                      </Link>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </section>

      {selectedEvent && (
        <section className="rounded-xl border border-blue-200 bg-white p-5 shadow-sm">
          <div className="flex items-start justify-between">
            <div>
              <p className="text-sm text-gray-500">Payload preview</p>
              <h2 className="text-xl font-semibold text-gray-900">{selectedEvent.action}</h2>
              <p className="text-sm text-gray-600">
                Event ID: <span className="font-mono">{selectedEvent.id}</span>
              </p>
            </div>
            <button
              type="button"
              className="text-sm text-gray-500 hover:text-gray-700"
              onClick={() => setSelectedEvent(null)}
            >
              Close
            </button>
          </div>
          <pre className="mt-4 max-h-64 overflow-auto rounded-lg bg-gray-900 p-4 text-xs text-green-200">
            {JSON.stringify(selectedEvent.payload ?? {}, null, 2)}
          </pre>
        </section>
      )}
    </main>
  );
}

```
---
# apps/backoffice/src/app/auth/signin/page.tsx
```tsx
'use client';

import { signIn } from 'next-auth/react';
import { useSearchParams } from 'next/navigation';
import { Suspense } from 'react';

function SignInButton() {
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get('callbackUrl') || '/kyc';

  return (
    <button
      onClick={() => signIn('keycloak', { callbackUrl })}
      className="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-white bg-blue-600 hover:bg-blue-700"
    >
      Sign in with Keycloak
    </button>
  );
}

export default function SignInPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
        <div>
          <h2 className="text-3xl font-bold text-center">OIS Backoffice</h2>
          <p className="mt-2 text-center text-gray-600">Sign in to continue</p>
        </div>
        <Suspense fallback={<div>Loading...</div>}>
          <SignInButton />
        </Suspense>
      </div>
    </div>
  );
}


```
---
# apps/backoffice/src/app/globals.css
```css
@import '../../../_theme/tokens.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-background text-text-primary;
    font-family: var(--font-sans);
  }
}

```
---
# apps/backoffice/src/app/kyc/page.tsx
```tsx
'use client';

import { useState } from 'react';
import { useQuery, useMutation } from '@tanstack/react-query';
import { listKycRequests, submitKycDecision, KycRequest } from '@/lib/api/compliance';

export default function KycPage() {
  const [activeStatus, setActiveStatus] = useState<'pending' | 'approved' | 'rejected'>('pending');
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const [comment, setComment] = useState('');

  const {
    data: requests,
    isLoading,
    refetch,
  } = useQuery({
    queryKey: ['kyc-requests', activeStatus],
    queryFn: () => listKycRequests(activeStatus),
  });

  const decisionMutation = useMutation({
    mutationFn: ({ id, decision }: { id: string; decision: 'approved' | 'rejected' }) =>
      submitKycDecision(id, decision, comment),
    onSuccess: () => {
      setComment('');
      setSelectedId(null);
      refetch();
    },
  });

  const selected = requests?.find((req) => req.id === selectedId);

  return (
    <main className="mx-auto max-w-5xl px-6 py-10 space-y-8">
      <header>
        <h1 className="text-3xl font-semibold">KYC Applications</h1>
        <p className="text-sm text-gray-500">
          Review investor applications and record decisions. Data is loaded from Compliance API
          (temporarily mocked if backend недоступен).
        </p>
      </header>

      <section className="flex items-center gap-2">
        {(['pending', 'approved', 'rejected'] as const).map((status) => (
          <button
            key={status}
            onClick={() => setActiveStatus(status)}
            className={`rounded-md border px-4 py-2 text-sm ${
              activeStatus === status ? 'border-blue-600 text-blue-600' : 'border-gray-300 text-gray-600'
            }`}
          >
            {status.toUpperCase()}
          </button>
        ))}
      </section>

      <section className="overflow-x-auto rounded-lg border border-gray-200 bg-white">
        <table className="min-w-full divide-y divide-gray-200 text-sm">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Investor</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Status</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Created</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Actions</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-100">
            {isLoading && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-center text-gray-500">
                  Loading applications…
                </td>
              </tr>
            )}
            {!isLoading && (requests?.length ?? 0) === 0 && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-center text-gray-400">
                  No applications for this filter.
                </td>
              </tr>
            )}
            {requests?.map((request: KycRequest) => (
              <tr key={request.id} className={selectedId === request.id ? 'bg-blue-50' : undefined}>
                <td className="px-4 py-2">
                  <div className="font-medium">{request.investorId}</div>
                  {request.amlFlags && (
                    <div className="text-xs text-red-600">AML flags: {request.amlFlags.join(', ')}</div>
                  )}
                </td>
                <td className="px-4 py-2 capitalize">{request.status}</td>
                <td className="px-4 py-2">{new Date(request.createdAt).toLocaleString()}</td>
                <td className="px-4 py-2 space-x-2">
                  <button
                    className="text-sm text-blue-600 underline"
                    onClick={() => setSelectedId(request.id)}
                  >
                    Details
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </section>

      {selected && (
        <section className="rounded-lg border border-gray-200 bg-white p-4 space-y-3">
          <h2 className="text-lg font-semibold">Decision for {selected.investorId}</h2>
          <p className="text-sm text-gray-500">
            Status: <span className="font-medium">{selected.status}</span>
          </p>
          {selected.reason && (
            <p className="text-sm text-gray-500">
              Reason: <span className="font-medium">{selected.reason}</span>
            </p>
          )}
          {selected.resolvedAt && (
            <p className="text-xs text-gray-400">
              Resolved at: {new Date(selected.resolvedAt).toLocaleString()}
            </p>
          )}
          <textarea
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm"
            placeholder="Decision comment"
            value={comment}
            onChange={(e) => setComment(e.target.value)}
          />
          <div className="flex gap-2">
            <button
              className="rounded-md bg-green-600 px-4 py-2 text-sm text-white disabled:opacity-40"
              disabled={decisionMutation.isPending}
              onClick={() => decisionMutation.mutate({ id: selected.id, decision: 'approved' })}
            >
              Approve
            </button>
            <button
              className="rounded-md bg-red-600 px-4 py-2 text-sm text-white disabled:opacity-40"
              disabled={decisionMutation.isPending}
              onClick={() => decisionMutation.mutate({ id: selected.id, decision: 'rejected' })}
            >
              Reject
            </button>
          </div>
        </section>
      )}
    </main>
  );
}

```
---
# apps/backoffice/src/app/layout.tsx
```tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { Providers } from './providers';
import { Toaster } from 'sonner';

const inter = Inter({ subsets: ['latin', 'cyrillic'] });

export const metadata: Metadata = {
  title: 'OIS Backoffice',
  description: 'Administrative portal',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ru">
      <body className={inter.className}>
        <Providers>
          {children}
          <Toaster />
        </Providers>
      </body>
    </html>
  );
}

```
---
# apps/backoffice/src/app/page.tsx
```tsx
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export default async function Home() {
  const session = await getServerSession(authOptions);
  
  if (!session) {
    redirect('/auth/signin');
  }

  redirect('/kyc');
}


```
---
# apps/backoffice/src/app/payouts/page.tsx
```tsx
'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import { getPayoutsReport, runSettlement } from '@/lib/api/reports';
import type { PayoutReport } from '@/lib/api/reports';

export default function PayoutsPage() {
  const queryClient = useQueryClient();

  const { data: report, isLoading } = useQuery<PayoutReport>({
    queryKey: ['payouts-report'],
    queryFn: async () => {
      const to = new Date();
      const from = new Date();
      from.setDate(from.getDate() - 30);
      return getPayoutsReport({
        from: from.toISOString().slice(0, 10),
        to: to.toISOString().slice(0, 10),
      });
    },
  });

  const runSettlementMutation = useMutation({
    mutationFn: (date?: string) => runSettlement(date ? { date } : undefined),
    onSuccess: () => {
      toast.success('Settlement started');
      queryClient.invalidateQueries({ queryKey: ['payouts-report'] });
    },
    onError: (error: unknown) => {
      const message = error instanceof Error ? error.message : 'Failed to run settlement';
      toast.error(message);
    },
  });

  const summary: PayoutReport =
    report ?? {
      totalAmount: 0,
      totalItems: 0,
      items: [],
    };

  return (
    <div className="container mx-auto p-8 space-y-6">
      <div className="flex flex-wrap items-center justify-between gap-4">
        <div>
          <p className="text-sm text-gray-500">Issuer Settlement</p>
          <h1 className="text-3xl font-bold text-gray-900">Payouts</h1>
        </div>
        <button
          onClick={() => runSettlementMutation.mutate(undefined)}
          disabled={runSettlementMutation.isPending}
          className="rounded-lg bg-blue-600 px-6 py-3 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50"
        >
          {runSettlementMutation.isPending ? 'Running…' : 'Run Settlement'}
        </button>
      </div>

      {isLoading && <div>Loading report…</div>}

      {!isLoading && (
        <div className="rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <h2 className="text-xl font-semibold mb-4 text-gray-900">Last 30 days</h2>
          <div className="grid gap-4 sm:grid-cols-2">
            <div>
              <p className="text-sm text-gray-500">Total Amount</p>
              <p className="text-2xl font-bold text-gray-900">{summary.totalAmount.toLocaleString()}</p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Items Count</p>
              <p className="text-2xl font-bold text-gray-900">{summary.totalItems}</p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Executed</p>
              <p className="text-2xl font-semibold text-emerald-600">
                {summary.items.filter((item) => item.status === 'executed').length}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Failed</p>
              <p className="text-2xl font-semibold text-red-600">
                {summary.items.filter((item) => item.status === 'failed').length}
              </p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

```
---
# apps/backoffice/src/app/providers.tsx
```tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from '../../../shared-ui/src';
import { initWebVitals } from '../../../shared-ui/src/utils/webVitals';
import { useState } from 'react';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <ThemeProvider defaultTheme="light">
      <SessionProvider>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </SessionProvider>
    </ThemeProvider>
  );
}

if (typeof window !== 'undefined') {
  initWebVitals();
}


```
---
# apps/backoffice/src/app/qualification/page.tsx
```tsx
'use client';

export default function QualificationPage() {
  return (
    <div className="container mx-auto p-8">
      <h1 className="text-3xl font-bold mb-6">Qualification Management</h1>
      <p className="text-gray-600">Qualification management coming soon...</p>
    </div>
  );
}


```
---
# apps/backoffice/src/app/users/page.tsx
```tsx
'use client';

import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { listUsers, UserRecord } from '@/lib/api/compliance';

export default function UsersPage() {
  const [query, setQuery] = useState('');

  const { data: users, isLoading } = useQuery({
    queryKey: ['backoffice-users', query],
    queryFn: () => listUsers(query),
  });

  return (
    <main className="mx-auto max-w-5xl px-6 py-10 space-y-6">
      <header className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
        <div>
          <h1 className="text-3xl font-semibold">User Registry</h1>
          <p className="text-sm text-gray-500">Search and review platform users.</p>
        </div>
        <input
          className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm sm:w-64"
          placeholder="Search by email or ID"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
      </header>

      <section className="overflow-x-auto rounded-lg border border-gray-200 bg-white">
        <table className="min-w-full divide-y divide-gray-200 text-sm">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-4 py-2 text-left font-medium text-gray-600">User</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Roles</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Status</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Created</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-100">
            {isLoading && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-center text-gray-500">
                  Loading users…
                </td>
              </tr>
            )}
            {!isLoading && (users?.length ?? 0) === 0 && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-center text-gray-400">
                  No users found.
                </td>
              </tr>
            )}
            {users?.map((user: UserRecord) => (
              <tr key={user.id}>
                <td className="px-4 py-2">
                  <div className="font-medium">{user.email ?? user.id}</div>
                  <div className="text-xs text-gray-500">{user.id}</div>
                </td>
                <td className="px-4 py-2 text-sm text-gray-700">{user.roles.join(', ')}</td>
                <td className="px-4 py-2 capitalize">{user.status}</td>
                <td className="px-4 py-2">{new Date(user.createdAt).toLocaleDateString()}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </section>
    </main>
  );
}

```
---
# apps/backoffice/src/lib/api-client.ts
```ts
'use server';

import type { AuditEvent, AuditFilters } from './api/audit';
import { getAuditEvent as fetchAuditEvent, getAuditLogs } from './api/audit';
import type { PayoutReport, SettlementJob } from './api/reports';
import { getPayoutsReport as fetchPayoutsReport, runSettlement as triggerSettlement } from './api/reports';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

async function request<T>(path: string, init?: RequestInit): Promise<T> {
  const res = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!res.ok) {
    throw new Error(`API error ${res.status}`);
  }

  if (res.status === 204) {
    return undefined as T;
  }

  return (await res.json()) as T;
}

type KycDocument = {
  id: string;
  name: string;
  status: string;
};

type KycDecisionPayload = {
  decision: 'approved' | 'rejected';
  comment?: string;
};

type InvestorStatus = {
  kyc: 'pending' | 'approved' | 'rejected';
};

export const apiClient = {
  async getAuditEvents(filters?: AuditFilters): Promise<{ data: AuditEvent[] }> {
    const data = await getAuditLogs(filters);
    return { data };
  },
  async getAuditEvent(id: string): Promise<{ data: AuditEvent | null }> {
    const data = await fetchAuditEvent(id);
    return { data };
  },
  async getKycDocuments(investorId: string): Promise<{ data: KycDocument[] }> {
    return {
      data: [
        {
          id: 'doc-demo',
          name: `Document for ${investorId}`,
          status: 'uploaded',
        },
      ],
    };
  },
  async makeKycDecision(investorId: string, payload: KycDecisionPayload): Promise<{ data: { ok: boolean } }> {
    await request(`/v1/kyc/${investorId}/decision`, {
      method: 'POST',
      body: JSON.stringify(payload),
    });
    return { data: { ok: true } };
  },
  async uploadKycDocuments(): Promise<{ data: { ok: boolean } }> {
    return { data: { ok: true } };
  },
  async getInvestorStatus(): Promise<{ data: InvestorStatus }> {
    return { data: { kyc: 'pending' } };
  },
  async getPayoutsReport(params: { from: string; to: string }): Promise<{ data: PayoutReport }> {
    const data = await fetchPayoutsReport(params);
    return { data };
  },
  async runSettlement(params?: { date?: string }): Promise<{ data: SettlementJob }> {
    const data = await triggerSettlement(params);
    return { data };
  },
};

export const legacyApiClient = apiClient;

export type { AuditEvent } from './api/audit';
export type { PayoutReport, PayoutReportItem, SettlementJob } from './api/reports';
export { getAuditLogs, getAuditEvent } from './api/audit';
export { getPayoutsReport, runSettlement } from './api/reports';

```
---
# apps/backoffice/src/lib/api/audit.ts
```ts
const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

export type AuditEvent = {
  id: string;
  actor: string;
  actorName?: string;
  action: string;
  entity: string;
  entityId?: string;
  payload?: Record<string, unknown>;
  ip?: string;
  userAgent?: string;
  timestamp: string;
  result?: 'success' | 'failure' | 'pending';
};

export type AuditFilters = {
  from?: string;
  to?: string;
  action?: string;
  actor?: string;
};

const fallbackEvents: AuditEvent[] = [
  {
    id: 'audit-mock-1',
    actor: 'issuer.portal',
    actorName: 'Issuer Portal',
    action: 'kyc.approve',
    entity: 'investor#001',
    timestamp: new Date().toISOString(),
    result: 'success',
    payload: { note: 'Auto-approved for pilot' },
  },
  {
    id: 'audit-mock-2',
    actor: 'backoffice.admin',
    action: 'login.failure',
    entity: 'session',
    timestamp: new Date(Date.now() - 3600 * 1000).toISOString(),
    result: 'failure',
    payload: { reason: 'MFA timeout' },
  },
];

async function callAudit<T>(path: string, init?: RequestInit): Promise<T> {
  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    throw new Error(`Audit API error ${response.status}`);
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return (await response.json()) as T;
}

function filterFallback(events: AuditEvent[], filters?: AuditFilters): AuditEvent[] {
  if (!filters) {
    return events;
  }

  return events.filter((event) => {
    if (filters.action && !event.action.includes(filters.action)) {
      return false;
    }
    if (filters.actor && !event.actor.includes(filters.actor)) {
      return false;
    }
    if (filters.from && new Date(event.timestamp) < new Date(filters.from)) {
      return false;
    }
    if (filters.to && new Date(event.timestamp) > new Date(filters.to)) {
      return false;
    }
    return true;
  });
}

export async function getAuditLogs(filters?: AuditFilters): Promise<AuditEvent[]> {
  const params = new URLSearchParams();
  if (filters?.from) params.set('from', filters.from);
  if (filters?.to) params.set('to', filters.to);
  if (filters?.action) params.set('action', filters.action);
  if (filters?.actor) params.set('actor', filters.actor);
  const search = params.toString() ? `?${params.toString()}` : '';

  const data = await callAudit<AuditEvent[]>(`/v1/audit${search}`).catch((err) => {
    if (AUDIT_MOCK_MODE) {
      return filterFallback(fallbackEvents, filters);
    }
    throw err;
  });
  return data;
}

export async function getAuditEvent(id: string): Promise<AuditEvent | null> {
  const event = await callAudit<AuditEvent>(`/v1/audit/${id}`).catch(async (err) => {
    if (AUDIT_MOCK_MODE) {
      const logs = await getAuditLogs();
      return logs.find((e) => e.id === id) ?? null;
    }
    throw err;
  });
  return event;
}
const AUDIT_MOCK_MODE = process.env.NEXT_PUBLIC_AUDIT_MOCK_MODE === 'true';

```
---
# apps/backoffice/src/lib/api/compliance.ts
```ts
const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';
const COMPLIANCE_MOCK_MODE = process.env.NEXT_PUBLIC_COMPLIANCE_MOCK_MODE === 'true';

export type KycRequest = {
  id: string;
  investorId: string;
  status: 'pending' | 'approved' | 'rejected';
  createdAt: string;
  resolvedAt?: string;
  reason?: string | null;
  amlFlags?: string[];
  documents?: Array<{ id: string; name: string; url?: string }>;
};

export type UserRecord = {
  id: string;
  email: string;
  roles: string[];
  status: 'active' | 'blocked' | 'invited';
  createdAt: string;
};

async function call<T>(path: string, init?: RequestInit): Promise<T> {
  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    throw new Error(`Compliance API error: ${response.status}`);
  }

  return (await response.json()) as T;
}

export async function listKycRequests(status?: string): Promise<KycRequest[]> {
  const query = status ? `?status=${status}` : '';
  return await call<KycRequest[]>(`/v1/compliance/kyc${query}`).catch(() => {
    if (!COMPLIANCE_MOCK_MODE) throw new Error('KYC list unavailable');
    return [
      {
        id: 'mock-kyc-1',
        investorId: 'investor-001',
        status: 'pending',
        createdAt: new Date().toISOString(),
        reason: 'mock application',
        amlFlags: ['PEP'],
      },
    ];
  });
}

export async function submitKycDecision(
  id: string,
  decision: 'approved' | 'rejected',
  comment?: string,
): Promise<void> {
  await call(`/v1/compliance/kyc/${id}/decision`, {
    method: 'POST',
    body: JSON.stringify({ decision, comment }),
  });
}

export async function listUsers(query?: string): Promise<UserRecord[]> {
  const search = query ? `?query=${encodeURIComponent(query)}` : '';
  return await call<UserRecord[]>(`/v1/identity/users${search}`).catch(() => {
    if (!COMPLIANCE_MOCK_MODE) throw new Error('Users listing unavailable');
    return [
      {
        id: 'user-mock-1',
        email: 'demo@example.com',
        roles: ['issuer'],
        status: 'active',
        createdAt: new Date().toISOString(),
      },
    ];
  });
}

```
---
# apps/backoffice/src/lib/api/reports.ts
```ts
const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

export type PayoutReportItem = {
  id: string;
  dueDate?: string;
  amount: number;
  currency?: string;
  status: 'scheduled' | 'executed' | 'failed';
};

export type PayoutReport = {
  totalAmount: number;
  totalItems: number;
  items: PayoutReportItem[];
};

export type SettlementJob = {
  status: 'queued' | 'started' | 'failed';
  scheduledFor?: string;
  referenceId?: string;
};

const FALLBACK_REPORT: PayoutReport = {
  totalAmount: 0,
  totalItems: 0,
  items: [],
};

async function callReports<T>(path: string, init?: RequestInit): Promise<T> {
  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    throw new Error(`Reports API error ${response.status}`);
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return (await response.json()) as T;
}

export async function getPayoutsReport(params: { from: string; to: string }): Promise<PayoutReport> {
  const search = new URLSearchParams({ from: params.from, to: params.to });

  try {
    const data = await callReports<PayoutReport>(`/v1/reports/payouts?${search.toString()}`);
    return {
      totalAmount: data.totalAmount ?? data.items?.reduce((sum, item) => sum + (item.amount ?? 0), 0) ?? 0,
      totalItems: data.totalItems ?? data.items?.length ?? 0,
      items: data.items ?? [],
    };
  } catch {
    return FALLBACK_REPORT;
  }
}

export async function runSettlement(params?: { date?: string }): Promise<SettlementJob> {
  const search = params?.date ? `?date=${encodeURIComponent(params.date)}` : '';

  try {
    return await callReports<SettlementJob>(`/v1/settlement/run${search}`, {
      method: 'POST',
    });
  } catch {
    return { status: 'queued', referenceId: 'mock-job' };
  }
}

```
---
# apps/backoffice/src/lib/auth.ts
```ts
import { NextAuthOptions, DefaultSession } from 'next-auth';
import KeycloakProvider from 'next-auth/providers/keycloak';

export const authOptions: NextAuthOptions = {
  secret: process.env.NEXTAUTH_SECRET || 'dev-secret-cfa1',
  providers: [
    KeycloakProvider({
      clientId: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'backoffice',
      // Keycloak client is public on CFA1; use secret only when provided
      clientSecret: process.env.KEYCLOAK_CLIENT_SECRET || '',
      issuer: `${process.env.NEXT_PUBLIC_KEYCLOAK_URL || 'http://localhost:8080'}/realms/${process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'ois-dev'}`,
    }),
  ],
  callbacks: {
    async jwt({ token, account }) {
      if (account) {
        token.accessToken = account.access_token;
        token.roles = account.access_token ? JSON.parse(Buffer.from((account.access_token as string).split('.')[1], 'base64').toString()).realm_access?.roles : [];
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.roles = token.roles as string[];
        session.accessToken = token.accessToken as string;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
};

```
---
# apps/backoffice/src/middleware.ts
```ts
import { withAuth } from 'next-auth/middleware';

export default withAuth({
  callbacks: {
    authorized: ({ token }) => {
      const roles = (token?.roles as string[]) || [];
      if (!roles.includes('admin') && !roles.includes('backoffice')) {
        return false;
      }
      return !!token;
    },
  },
});

export const config = {
  matcher: ['/kyc/:path*', '/qualification/:path*', '/payouts/:path*', '/audit/:path*'],
};


```
---
# apps/backoffice/src/types/next-auth.d.ts
```ts
import 'next-auth';
import 'next-auth/jwt';
import { DefaultSession } from 'next-auth';

declare module 'next-auth' {
  interface Session {
    user: {
      roles?: string[];
    } & DefaultSession['user'];
    accessToken?: string;
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    roles?: string[];
    accessToken?: string;
  }
}


```
---
# apps/portal-investor/src/app/api/auth/[...nextauth]/route.ts
```ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


```
---
# apps/portal-investor/src/app/auth/signin/page.tsx
```tsx
'use client';

import { signIn } from 'next-auth/react';
import { useSearchParams } from 'next/navigation';
import { Suspense } from 'react';

function SignInButton() {
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get('callbackUrl') || '/portfolio';

  return (
    <button
      onClick={() => signIn('keycloak', { callbackUrl })}
      className="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-white bg-blue-600 hover:bg-blue-700"
    >
      Sign in with Keycloak
    </button>
  );
}

export default function SignInPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
        <div>
          <h2 className="text-3xl font-bold text-center">OIS Portal - Investor</h2>
          <p className="mt-2 text-center text-gray-600">Sign in to continue</p>
        </div>
        <Suspense fallback={<div>Loading...</div>}>
          <SignInButton />
        </Suspense>
      </div>
    </div>
  );
}


```
---
# apps/portal-investor/src/app/catalog/page.tsx
```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { AppShell, PageHeader, EmptyState, Skeleton } from '../../../../shared-ui/src';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';
import Link from 'next/link';
import { TrendingUp, Calendar, DollarSign } from 'lucide-react';
import { investorNav } from '@/lib/nav';

export default function CatalogPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [filters, setFilters] = useState({
    status: 'open' as 'open' | 'closed' | 'all',
    sort: '-yield' as string,
    limit: 20,
    offset: 0,
  });

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data, isLoading, error } = useQuery({
    queryKey: ['market-issuances', filters],
    queryFn: async () => {
      const response = await apiClient.getMarketIssuances(filters);
      return response.data;
    },
    enabled: status === 'authenticated' && !!session,
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: investorNav }}
    >
      <PageHeader
        title="Market Catalog"
        description="Browse available CFA issuances"
      />

      {/* Filters */}
      <div className="mb-6 flex flex-wrap gap-4">
        <select
          value={filters.status}
          onChange={(e) =>
            setFilters({ ...filters, status: e.target.value as any, offset: 0 })
          }
          className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
        >
          <option value="open">Open</option>
          <option value="closed">Closed</option>
          <option value="all">All</option>
        </select>

        <select
          value={filters.sort}
          onChange={(e) =>
            setFilters({ ...filters, sort: e.target.value, offset: 0 })
          }
          className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
        >
          <option value="-yield">Yield: High to Low</option>
          <option value="yield">Yield: Low to High</option>
          <option value="-maturityDate">Maturity: Latest</option>
          <option value="maturityDate">Maturity: Earliest</option>
          <option value="-totalAmount">Amount: Largest</option>
          <option value="totalAmount">Amount: Smallest</option>
        </select>
      </div>

      {/* Results */}
      {isLoading && (
        <div className="space-y-4">
          {[1, 2, 3].map((i) => (
            <Skeleton key={i} className="h-32 w-full" variant="rectangular" />
          ))}
        </div>
      )}

      {error && (
        <div className="text-danger-600">Error loading issuances</div>
      )}

      {data && data.items && data.items.length === 0 && (
        <EmptyState
          title="No issuances found"
          description="Try adjusting your filters"
        />
      )}

      {data && data.items && data.items.length > 0 && (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
            {data.items.map((issuance: any) => (
              <Link
                key={issuance.id}
                href={`/issuances/${issuance.id}`}
                className="bg-surface border border-border rounded-lg p-6 shadow-sm hover:shadow-md transition-shadow focus:outline-none focus:ring-2 focus:ring-primary-500"
              >
                <div className="flex items-start justify-between mb-4">
                  <div>
                    <h3 className="text-lg font-semibold text-text-primary">
                      {issuance.assetName}
                    </h3>
                    <p className="text-sm text-text-secondary">
                      {issuance.issuerName}
                    </p>
                  </div>
                  <span
                    className={`px-2 py-1 text-xs font-medium rounded ${
                      issuance.status === 'open'
                        ? 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300'
                        : 'bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300'
                    }`}
                  >
                    {issuance.status}
                  </span>
                </div>

                <div className="space-y-2 mb-4">
                  <div className="flex items-center gap-2 text-sm">
                    <TrendingUp className="h-4 w-4 text-success-600" />
                    <span className="text-text-primary font-medium">
                      {issuance.yield}% yield
                    </span>
                  </div>
                  <div className="flex items-center gap-2 text-sm">
                    <DollarSign className="h-4 w-4 text-text-tertiary" />
                    <span className="text-text-secondary">
                      {issuance.availableAmount.toLocaleString()} available
                    </span>
                  </div>
                  <div className="flex items-center gap-2 text-sm">
                    <Calendar className="h-4 w-4 text-text-tertiary" />
                    <span className="text-text-secondary">
                      Matures: {new Date(issuance.maturityDate).toLocaleDateString()}
                    </span>
                  </div>
                </div>

                <div className="text-sm text-text-secondary">
                  Nominal: ₽{issuance.nominal.toLocaleString()}
                </div>
              </Link>
            ))}
          </div>

          {/* Pagination */}
          {data.total > filters.limit && (
            <div className="flex items-center justify-between">
              <div className="text-sm text-text-secondary">
                Showing {filters.offset + 1} to{' '}
                {Math.min(filters.offset + filters.limit, data.total)} of{' '}
                {data.total} results
              </div>
              <div className="flex gap-2">
                <button
                  onClick={() =>
                    setFilters({
                      ...filters,
                      offset: Math.max(0, filters.offset - filters.limit),
                    })
                  }
                  disabled={filters.offset === 0}
                  className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary disabled:opacity-50 disabled:cursor-not-allowed hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
                >
                  Previous
                </button>
                <button
                  onClick={() =>
                    setFilters({
                      ...filters,
                      offset: filters.offset + filters.limit,
                    })
                  }
                  disabled={filters.offset + filters.limit >= data.total}
                  className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary disabled:opacity-50 disabled:cursor-not-allowed hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
                >
                  Next
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </AppShell>
  );
}

```
---
# apps/portal-investor/src/app/globals.css
```css
@import '../../../_theme/tokens.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-background text-text-primary;
    font-family: var(--font-sans);
  }
}

```
---
# apps/portal-investor/src/app/history/page.tsx
```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { AppShell, PageHeader, DataTable, EmptyState, Skeleton } from '../../../../shared-ui/src';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';
import { ColumnDef } from '@tanstack/react-table';
import { Download } from 'lucide-react';
import { investorNav } from '@/lib/nav';

// Import types from SDK instead of defining locally
import type { TxHistoryItem, PayoutItem } from '@ois/api-client';


export default function HistoryPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<'orders' | 'payouts' | 'redemptions'>('orders');
  const [dateRange, setDateRange] = useState({
    from: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    to: new Date().toISOString().split('T')[0],
  });

  const investorId = (session?.user as any)?.id || '';

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: ordersTx, isLoading: ordersLoading } = useQuery({
    queryKey: ['investor-orders', investorId, dateRange],
    queryFn: async () => {
      const response = await apiClient.getInvestorTransactions(investorId, {
        from: dateRange.from,
        to: dateRange.to,
        type: 'transfer',
      });
      return response.data;
    },
    enabled: activeTab === 'orders' && !!investorId && status === 'authenticated',
  });

  const { data: redemptionsTx, isLoading: redemptionsLoading } = useQuery({
    queryKey: ['investor-redemptions', investorId, dateRange],
    queryFn: async () => {
      const response = await apiClient.getInvestorTransactions(investorId, {
        from: dateRange.from,
        to: dateRange.to,
        type: 'redeem',
      });
      return response.data;
    },
    enabled: activeTab === 'redemptions' && !!investorId && status === 'authenticated',
  });

  const { data: payouts, isLoading: payoutsLoading } = useQuery({
    queryKey: ['investor-payouts', investorId, dateRange],
    queryFn: async () => {
      const response = await apiClient.getInvestorPayouts(investorId, {
        from: dateRange.from,
        to: dateRange.to,
      });
      return response.data;
    },
    enabled: activeTab === 'payouts' && !!investorId && status === 'authenticated',
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  const txColumns: ColumnDef<TxHistoryItem>[] = [
    {
      accessorKey: 'createdAt',
      header: 'Date',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">
          {new Date(row.original.createdAt).toLocaleDateString('ru-RU', {
            dateStyle: 'medium',
            timeStyle: 'short',
          })}
        </span>
      ),
    },
    {
      accessorKey: 'type',
      header: 'Type',
      cell: ({ row }) => {
        const type = row.original.type;
        const colors: Record<string, string> = {
          issue: 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300',
          transfer: 'bg-info-100 text-info-700 dark:bg-info-900 dark:text-info-300',
          redeem: 'bg-warning-100 text-warning-700 dark:bg-warning-900 dark:text-warning-300',
        };
        return (
          <span
            className={`px-2 py-1 text-xs font-medium rounded ${colors[type] || ''}`}
          >
            {type}
          </span>
        );
      },
    },
    {
      accessorKey: 'issuanceCode',
      header: 'Issuance',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.issuanceCode}</span>
      ),
    },
    {
      accessorKey: 'amount',
      header: 'Amount',
      cell: ({ row }) => (
        <span className="text-sm font-medium text-text-primary">
          ₽{row.original.amount.toLocaleString()}
        </span>
      ),
    },
    {
      accessorKey: 'status',
      header: 'Status',
      cell: ({ row }) => {
        const status = row.original.status;
        const colors: Record<string, string> = {
          confirmed: 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300',
          pending: 'bg-warning-100 text-warning-700 dark:bg-warning-900 dark:text-warning-300',
          failed: 'bg-danger-100 text-danger-700 dark:bg-danger-900 dark:text-danger-300',
        };
        return (
          <span
            className={`px-2 py-1 text-xs font-medium rounded ${colors[status] || ''}`}
          >
            {status}
          </span>
        );
      },
    },
    {
      accessorKey: 'dltTxHash',
      header: 'DLT Hash',
      cell: ({ row }) => (
        <span className="text-xs text-text-tertiary font-mono">
          {row.original.dltTxHash
            ? `${row.original.dltTxHash.substring(0, 8)}...`
            : '-'}
        </span>
      ),
    },
  ];

  const payoutColumns: ColumnDef<PayoutItem>[] = [
    {
      accessorKey: 'executedAt',
      header: 'Date',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">
          {row.original.executedAt
            ? new Date(row.original.executedAt).toLocaleDateString('ru-RU', {
                dateStyle: 'medium',
                timeStyle: 'short',
              })
            : '-'}
        </span>
      ),
    },
    {
      accessorKey: 'issuanceId',
      header: 'Issuance ID',
      cell: ({ row }) => (
        <span className="text-xs text-text-tertiary font-mono">
          {row.original.issuanceId.substring(0, 8)}...
        </span>
      ),
    },
    {
      accessorKey: 'amount',
      header: 'Amount',
      cell: ({ row }) => (
        <span className="text-sm font-medium text-text-primary">
          ₽{row.original.amount.toLocaleString()}
        </span>
      ),
    },
    {
      accessorKey: 'status',
      header: 'Status',
      cell: ({ row }) => {
        const status = row.original.status;
        const colors: Record<string, string> = {
          executed: 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300',
          pending: 'bg-warning-100 text-warning-700 dark:bg-warning-900 dark:text-warning-300',
          failed: 'bg-danger-100 text-danger-700 dark:bg-danger-900 dark:text-danger-300',
        };
        return (
          <span
            className={`px-2 py-1 text-xs font-medium rounded ${colors[status] || ''}`}
          >
            {status}
          </span>
        );
      },
    },
  ];

  const exportToCSV = (data: any[], filename: string) => {
    if (!data || data.length === 0) return;

    const headers =
      activeTab === 'payouts'
        ? ['Date', 'Issuance ID', 'Amount', 'Status']
        : ['Date', 'Type', 'Issuance', 'Amount', 'Status', 'DLT Hash'];

    const rows = data.map((item) => {
      if (activeTab !== 'payouts') {
        return [
          new Date(item.createdAt).toLocaleDateString(),
          item.type,
          item.issuanceCode,
          item.amount,
          item.status,
          item.dltTxHash || '-',
        ];
      } else {
        return [
          item.executedAt ? new Date(item.executedAt).toLocaleDateString() : '-',
          item.issuanceId,
          item.amount,
          item.status,
        ];
      }
    });

    const csv = [headers, ...rows]
      .map((row) => row.map((cell) => `"${cell}"`).join(','))
      .join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: investorNav }}
    >
      <PageHeader
        title="History"
        description="View your orders, payouts and redemptions"
        actions={
          <button
            onClick={() =>
              exportToCSV(
                activeTab === 'payouts'
                  ? payouts?.items || []
                  : activeTab === 'orders'
                  ? ordersTx?.items || []
                  : redemptionsTx?.items || [],
                activeTab
              )
            }
            className="flex items-center gap-2 px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
            disabled={
              activeTab === 'payouts'
                ? !payouts?.items?.length
                : activeTab === 'orders'
                ? !ordersTx?.items?.length
                : !redemptionsTx?.items?.length
            }
          >
            <Download className="h-4 w-4" />
            Export CSV
          </button>
        }
      />

      {/* Date Range Filter */}
      <div className="mb-6 flex gap-4 items-end">
        <div>
          <label
            htmlFor="from"
            className="block text-sm font-medium text-text-primary mb-1"
          >
            From
          </label>
          <input
            id="from"
            type="date"
            value={dateRange.from}
            onChange={(e) =>
              setDateRange({ ...dateRange, from: e.target.value })
            }
            className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
          />
        </div>
        <div>
          <label
            htmlFor="to"
            className="block text-sm font-medium text-text-primary mb-1"
          >
            To
          </label>
          <input
            id="to"
            type="date"
            value={dateRange.to}
            onChange={(e) =>
              setDateRange({ ...dateRange, to: e.target.value })
            }
            className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
          />
        </div>
      </div>

      {/* Tabs */}
      <div className="mb-6 border-b border-border">
        <div className="flex gap-4">
          <button
            onClick={() => setActiveTab('orders')}
            className={`px-4 py-2 font-medium border-b-2 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 rounded-t ${
              activeTab === 'orders'
                ? 'border-primary-600 text-primary-600'
                : 'border-transparent text-text-secondary hover:text-text-primary'
            }`}
          >
            Orders ({ordersTx?.total || 0})
          </button>
          <button
            onClick={() => setActiveTab('payouts')}
            className={`px-4 py-2 font-medium border-b-2 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 rounded-t ${
              activeTab === 'payouts'
                ? 'border-primary-600 text-primary-600'
                : 'border-transparent text-text-secondary hover:text-text-primary'
            }`}
          >
            Payouts ({payouts?.total || 0})
          </button>
          <button
            onClick={() => setActiveTab('redemptions')}
            className={`px-4 py-2 font-medium border-b-2 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 rounded-t ${
              activeTab === 'redemptions'
                ? 'border-primary-600 text-primary-600'
                : 'border-transparent text-text-secondary hover:text-text-primary'
            }`}
          >
            Redemptions ({redemptionsTx?.total || 0})
          </button>
        </div>
      </div>

      {/* Content */}
      {activeTab === 'orders' && (
        <>
          {ordersLoading && <Skeleton className="h-64 w-full" variant="rectangular" />}
          {!ordersLoading && ordersTx && (
            <DataTable
              columns={txColumns}
              data={ordersTx.items || []}
              searchable
              searchPlaceholder="Search orders..."
              pageSize={10}
            />
          )}
          {!ordersLoading && (!ordersTx || ordersTx.items?.length === 0) && (
            <EmptyState
              title="No orders found"
              description="Your orders will appear here"
            />
          )}
        </>
      )}

      {activeTab === 'payouts' && (
        <>
          {payoutsLoading && (
            <Skeleton className="h-64 w-full" variant="rectangular" />
          )}
          {!payoutsLoading && payouts && (
            <>
              {payouts.totalAmount && (
                <div className="mb-4 p-4 bg-surface-alt rounded-lg">
                  <p className="text-sm text-text-secondary">
                    Total Payouts: ₽{payouts.totalAmount.toLocaleString()}
                  </p>
                </div>
              )}
              <DataTable
                columns={payoutColumns}
                data={payouts.items || []}
                searchable
                searchPlaceholder="Search payouts..."
                pageSize={10}
              />
            </>
          )}
          {!payoutsLoading && (!payouts || payouts.items?.length === 0) && (
            <EmptyState
              title="No payouts found"
              description="Your payout history will appear here"
            />
          )}
        </>
      )}

      {activeTab === 'redemptions' && (
        <>
          {redemptionsLoading && <Skeleton className="h-64 w-full" variant="rectangular" />}
          {!redemptionsLoading && redemptionsTx && (
            <DataTable
              columns={txColumns}
              data={redemptionsTx.items || []}
              searchable
              searchPlaceholder="Search redemptions..."
              pageSize={10}
            />
          )}
          {!redemptionsLoading && (!redemptionsTx || redemptionsTx.items?.length === 0) && (
            <EmptyState
              title="No redemptions found"
              description="Your redemptions will appear here"
            />
          )}
        </>
      )}
    </AppShell>
  );
}

```
---
# apps/portal-investor/src/app/issuances/[id]/page.tsx
```tsx
'use client';

import { useQuery, useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { AppShell, PageHeader, ChartContainer, LineChart, EmptyState, Skeleton } from '../../../../../shared-ui/src';
import { useSession } from 'next-auth/react';
import { useParams, useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';
import Link from 'next/link';
import { TrendingUp, Calendar, DollarSign, FileText, ArrowLeft } from 'lucide-react';
import { toast } from 'sonner';
import { investorNav } from '@/lib/nav';

export default function IssuanceDetailPage() {
  const { data: session, status } = useSession();
  const params = useParams();
  const router = useRouter();
  const id = params.id as string;
  const [orderAmount, setOrderAmount] = useState('');

  const investorId = (session?.user as any)?.id || '';

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: issuance, isLoading } = useQuery({
    queryKey: ['market-issuance', id],
    queryFn: async () => {
      const response = await apiClient.getMarketIssuance(id);
      return response.data;
    },
    enabled: !!id && status === 'authenticated' && !!session,
  });

  const orderMutation = useMutation({
    mutationFn: async (amount: number) => {
      const response = await apiClient.createOrder(
        {
          investorId,
          issuanceId: id,
          amount,
        },
        {
          headers: {
            'Idempotency-Key': crypto.randomUUID(),
          },
        }
      );
      return response.data;
    },
    onSuccess: () => {
      toast.success('Order placed successfully');
      router.push('/portfolio');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to place order');
    },
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  const handleBuy = () => {
    const amount = parseFloat(orderAmount);
    if (!amount || amount <= 0) {
      toast.error('Please enter a valid amount');
      return;
    }
    if (issuance && amount > issuance.availableAmount) {
      toast.error('Amount exceeds available');
      return;
    }
    orderMutation.mutate(amount);
  };

  // Generate mock yield chart data
  const yieldChartData = issuance
    ? Array.from({ length: 12 }, (_, i) => {
        const date = new Date();
        date.setMonth(date.getMonth() - (11 - i));
        return {
          name: date.toLocaleDateString('ru-RU', { month: 'short', year: 'numeric' }),
          yield: issuance.yield + (Math.random() * 2 - 1),
        };
      })
    : [];

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: investorNav }}
    >
      {isLoading && (
        <div className="space-y-6">
          <Skeleton className="h-8 w-64" variant="text" />
          <Skeleton className="h-64 w-full" variant="rectangular" />
        </div>
      )}

      {!isLoading && !issuance && (
        <EmptyState
          title="Issuance not found"
          description="The issuance you're looking for doesn't exist or has been removed"
          action={
            <Link
              href="/catalog"
              className="px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              Back to Catalog
            </Link>
          }
        />
      )}

      {!isLoading && issuance && (
        <>
          <PageHeader
            title={issuance.assetName}
            description={`Issued by ${issuance.issuerName}`}
            breadcrumbs={[
              { label: 'Catalog', href: '/catalog' },
              { label: issuance.assetName },
            ]}
            actions={
              <Link
                href="/catalog"
                className="flex items-center gap-2 px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
              >
                <ArrowLeft className="h-4 w-4" />
                Back
              </Link>
            }
          />

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            {/* Main Info */}
            <div className="lg:col-span-2 space-y-6">
              {/* Key Metrics */}
              <div className="bg-surface border border-border rounded-lg p-6">
                <h2 className="text-xl font-semibold text-text-primary mb-4">
                  Key Information
                </h2>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <p className="text-sm text-text-secondary mb-1">Total Amount</p>
                    <p className="text-lg font-semibold text-text-primary">
                      ₽{issuance.totalAmount.toLocaleString()}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-text-secondary mb-1">Available</p>
                    <p className="text-lg font-semibold text-text-primary">
                      ₽{issuance.availableAmount.toLocaleString()}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-text-secondary mb-1">Nominal</p>
                    <p className="text-lg font-semibold text-text-primary">
                      ₽{issuance.nominal.toLocaleString()}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-text-secondary mb-1">Annual Yield</p>
                    <p className="text-lg font-semibold text-success-600">
                      {issuance.yield}%
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-text-secondary mb-1">Issue Date</p>
                    <p className="text-lg font-semibold text-text-primary">
                      {new Date(issuance.issueDate).toLocaleDateString()}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-text-secondary mb-1">Maturity Date</p>
                    <p className="text-lg font-semibold text-text-primary">
                      {new Date(issuance.maturityDate).toLocaleDateString()}
                    </p>
                  </div>
                </div>
              </div>

              {/* Yield Chart */}
              <ChartContainer
                title="Historical Yield"
                description="Yield performance over time"
              >
                <LineChart
                  data={yieldChartData}
                  lines={[
                    {
                      dataKey: 'yield',
                      name: 'Yield %',
                      color: '#22c55e',
                    },
                  ]}
                  height={200}
                />
              </ChartContainer>

              {/* Schedule */}
              {issuance.scheduleJson && (
                <div className="bg-surface border border-border rounded-lg p-6">
                  <h2 className="text-xl font-semibold text-text-primary mb-4">
                    Payout Schedule
                  </h2>
                  <div className="space-y-2">
                    {Object.entries(issuance.scheduleJson as Record<string, any>).map(
                      ([date, amount]: [string, any]) => (
                        <div
                          key={date}
                          className="flex items-center justify-between py-2 border-b border-border last:border-0"
                        >
                          <span className="text-text-primary">
                            {new Date(date).toLocaleDateString()}
                          </span>
                          <span className="font-semibold text-text-primary">
                            ₽{parseFloat(amount).toLocaleString()}
                          </span>
                        </div>
                      )
                    )}
                  </div>
                </div>
              )}

              {/* Documents */}
              <div className="bg-surface border border-border rounded-lg p-6">
                <h2 className="text-xl font-semibold text-text-primary mb-4">
                  Documents
                </h2>
                <p className="text-text-secondary">
                  No documents available at this time.
                </p>
              </div>
            </div>

            {/* Order Panel */}
            <div className="lg:col-span-1">
              <div className="bg-surface border border-border rounded-lg p-6 sticky top-24">
                <h2 className="text-xl font-semibold text-text-primary mb-4">
                  Place Order
                </h2>

                <div className="space-y-4">
                  <div>
                    <label
                      htmlFor="amount"
                      className="block text-sm font-medium text-text-primary mb-2"
                    >
                      Amount (₽)
                    </label>
                    <input
                      id="amount"
                      type="number"
                      step="0.01"
                      min="0"
                      max={issuance.availableAmount}
                      value={orderAmount}
                      onChange={(e) => setOrderAmount(e.target.value)}
                      className="w-full px-4 py-2 border border-border rounded-md bg-surface text-text-primary placeholder:text-text-tertiary focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                      placeholder="0.00"
                      aria-label="Order amount"
                    />
                    <p className="text-xs text-text-tertiary mt-1">
                      Available: ₽{issuance.availableAmount.toLocaleString()}
                    </p>
                  </div>

                  {orderAmount && parseFloat(orderAmount) > 0 && (
                    <div className="bg-surface-alt rounded-md p-4 space-y-2">
                      <div className="flex justify-between text-sm">
                        <span className="text-text-secondary">Amount:</span>
                        <span className="text-text-primary font-medium">
                          ₽{parseFloat(orderAmount || '0').toLocaleString()}
                        </span>
                      </div>
                      <div className="flex justify-between text-sm">
                        <span className="text-text-secondary">Estimated yield:</span>
                        <span className="text-success-600 font-medium">
                          ₽
                          {(
                            (parseFloat(orderAmount || '0') * issuance.yield) /
                            100
                          ).toLocaleString()}
                        </span>
                      </div>
                    </div>
                  )}

                  <button
                    onClick={handleBuy}
                    disabled={
                      orderMutation.isPending ||
                      !orderAmount ||
                      parseFloat(orderAmount) <= 0 ||
                      parseFloat(orderAmount) > issuance.availableAmount
                    }
                    className="w-full px-6 py-3 bg-primary-600 text-white rounded-md hover:bg-primary-700 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
                  >
                    {orderMutation.isPending ? 'Placing...' : 'Buy Now'}
                  </button>

                  <p className="text-xs text-text-tertiary text-center">
                    By placing an order, you agree to the terms and conditions.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </>
      )}
    </AppShell>
  );
}

```
---
# apps/portal-investor/src/app/kyc/page.tsx
```tsx
'use client';

import { useEffect, useState } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useQuery, useMutation } from '@tanstack/react-query';
import { AppShell, PageHeader, Skeleton, EmptyState } from '../../../../shared-ui/src';
import { investorNav } from '@/lib/nav';
import { fetchKycStatus, submitKycApplication } from '@/lib/api/compliance';
import { toast } from 'sonner';

export default function InvestorKycPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [form, setForm] = useState({
    fullName: '',
    documentType: 'passport',
    documentNumber: '',
    comment: '',
  });

  const investorId = (session?.user as any)?.id || '';

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const {
    data: kycStatus,
    isLoading: statusLoading,
    refetch,
  } = useQuery({
    queryKey: ['investor-kyc-status', investorId],
    queryFn: () => fetchKycStatus(investorId),
    enabled: status === 'authenticated' && !!investorId,
  });

  const submitMutation = useMutation({
    mutationFn: async () =>
      submitKycApplication({
        investorId,
        ...form,
      }),
    onSuccess: () => {
      toast.success('KYC application submitted');
      refetch();
    },
    onError: (error: any) => {
      toast.error(error?.message ?? 'Failed to submit KYC');
    },
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) return null;

  const statusLabel = kycStatus?.kyc ?? 'not-submitted';
  const isSubmitted = statusLabel !== 'not-submitted';

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: investorNav }}
    >
      <PageHeader
        title="KYC verification"
        description="Submit your KYC details for compliance review"
      />

      <section className="grid gap-6 lg:grid-cols-2">
        <div className="rounded-lg border border-border bg-surface p-6 space-y-4">
          <h2 className="text-lg font-semibold text-text-primary">Current status</h2>
          {statusLoading ? (
            <Skeleton className="h-20 w-full" variant="rectangular" />
          ) : isSubmitted ? (
            <div className="space-y-2">
              <div className="text-sm text-text-secondary">Status</div>
              <div className="text-2xl font-bold text-text-primary capitalize">
                {statusLabel}
              </div>
              <div className="text-sm text-text-secondary">
                Updated at:{' '}
                {kycStatus?.updatedAt
                  ? new Date(kycStatus.updatedAt).toLocaleString()
                  : '—'}
              </div>
            </div>
          ) : (
            <EmptyState
              title="No KYC on file"
              description="Submit your details to start verification."
            />
          )}
        </div>

        <div className="rounded-lg border border-border bg-surface p-6 space-y-4">
          <h2 className="text-lg font-semibold text-text-primary">Submit application</h2>
          <form
            className="space-y-4"
            onSubmit={(e) => {
              e.preventDefault();
              submitMutation.mutate();
            }}
          >
            <div className="space-y-2">
              <label className="text-sm text-text-secondary">Full name</label>
              <input
                type="text"
                value={form.fullName}
                onChange={(e) => setForm({ ...form, fullName: e.target.value })}
                className="w-full rounded-md border border-border px-3 py-2"
                placeholder="Ivan Ivanov"
              />
            </div>

            <div className="grid gap-4 sm:grid-cols-2">
              <div className="space-y-2">
                <label className="text-sm text-text-secondary">Document type</label>
                <select
                  value={form.documentType}
                  onChange={(e) => setForm({ ...form, documentType: e.target.value })}
                  className="w-full rounded-md border border-border px-3 py-2"
                >
                  <option value="passport">Passport</option>
                  <option value="inn">INN</option>
                  <option value="snils">SNILS</option>
                  <option value="other">Other</option>
                </select>
              </div>
              <div className="space-y-2">
                <label className="text-sm text-text-secondary">Document number</label>
                <input
                  type="text"
                  value={form.documentNumber}
                  onChange={(e) => setForm({ ...form, documentNumber: e.target.value })}
                  className="w-full rounded-md border border-border px-3 py-2"
                  placeholder="00 00 000000"
                />
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-sm text-text-secondary">Comment</label>
              <textarea
                value={form.comment}
                onChange={(e) => setForm({ ...form, comment: e.target.value })}
                className="w-full rounded-md border border-border px-3 py-2"
                rows={3}
                placeholder="Any additional info for backoffice"
              />
            </div>

            <button
              type="submit"
              className="rounded-md bg-primary-600 px-4 py-2 text-sm font-medium text-white hover:bg-primary-700 disabled:opacity-50"
              disabled={submitMutation.isPending || !investorId}
            >
              {submitMutation.isPending ? 'Submitting…' : 'Submit KYC'}
            </button>
            {!investorId && (
              <p className="text-xs text-danger-600">
                Missing investor id in session; cannot submit.
              </p>
            )}
          </form>
        </div>
      </section>
    </AppShell>
  );
}

```
---
# apps/portal-investor/src/app/layout.tsx
```tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { Providers } from './providers';
import { ErrorBoundary } from '../../../shared-ui/src';
import { Toaster } from 'sonner';

const inter = Inter({ subsets: ['latin', 'cyrillic'] });

export const metadata: Metadata = {
  title: 'OIS Portal - Investor',
  description: 'Portal for CFA investors',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ru">
      <body className={inter.className}>
        <Providers>
          <ErrorBoundary>
            {children}
            <Toaster />
          </ErrorBoundary>
        </Providers>
      </body>
    </html>
  );
}


```
---
# apps/portal-investor/src/app/orders/new/page.tsx
```tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { z } from 'zod';
import { toast } from 'sonner';

const createOrderSchema = z.object({
  investorId: z.string().uuid(),
  issuanceId: z.string().uuid(),
  amount: z.number().positive(),
});

export default function NewOrderPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    investorId: '3fa85f64-5717-4562-b3fc-2c963f66afa6', // TODO: Get from session
    issuanceId: '',
    amount: '',
  });
  const [idemKey] = useState(() => crypto.randomUUID());

  const mutation = useMutation({
    mutationFn: async (data: any) => {
      const response = await apiClient.createOrder(
        {
          investorId: data.investorId,
          issuanceId: data.issuanceId,
          amount: parseFloat(data.amount),
        },
        {
          headers: {
            'Idempotency-Key': idemKey,
          },
        }
      );
      return response.data;
    },
    onSuccess: () => {
      toast.success('Order placed successfully');
      router.push('/portfolio');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to place order');
    },
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      const validated = createOrderSchema.parse({
        ...formData,
        amount: parseFloat(formData.amount),
      });
      
      mutation.mutate(validated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        toast.error(error.errors[0].message);
      }
    }
  };

  return (
    <div className="container mx-auto p-8 max-w-2xl">
      <h1 className="text-3xl font-bold mb-6">Place Buy Order</h1>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">Issuance ID</label>
          <input
            type="text"
            value={formData.issuanceId}
            onChange={(e) => setFormData({ ...formData, issuanceId: e.target.value })}
            className="w-full px-4 py-2 border rounded-lg"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">Amount</label>
          <input
            type="number"
            step="0.01"
            value={formData.amount}
            onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
            className="w-full px-4 py-2 border rounded-lg"
            required
          />
        </div>

        <div className="flex space-x-4">
          <button
            type="submit"
            disabled={mutation.isPending}
            className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 disabled:opacity-50"
          >
            {mutation.isPending ? 'Placing...' : 'Place Order'}
          </button>
          <button
            type="button"
            onClick={() => router.back()}
            className="bg-gray-200 text-gray-800 px-6 py-3 rounded-lg hover:bg-gray-300"
          >
            Cancel
          </button>
        </div>
      </form>
    </div>
  );
}


```
---
# apps/portal-investor/src/app/page.tsx
```tsx
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export default async function Home() {
  const session = await getServerSession(authOptions);
  
  if (!session) {
    redirect('/auth/signin');
  }

  redirect('/catalog');
}


```
---
# apps/portal-investor/src/app/portfolio/page.tsx
```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';

export default function PortfolioPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [investorId] = useState('3fa85f64-5717-4562-b3fc-2c963f66afa6'); // TODO: Get from session

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: wallet, isLoading } = useQuery({
    queryKey: ['wallet', investorId],
    queryFn: async () => {
      const response = await apiClient.getWallet(investorId);
      return response.data;
    },
    enabled: !!investorId && status === 'authenticated' && !!session,
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  return (
    <div className="container mx-auto p-8">
      <h1 className="text-3xl font-bold mb-6">Portfolio</h1>

      {isLoading && <div>Loading portfolio...</div>}

      {wallet && (
        <div className="space-y-6">
          <div className="bg-white p-6 rounded-lg shadow">
            <h2 className="text-xl font-semibold mb-4">Wallet</h2>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-gray-600">Balance</p>
                <p className="text-2xl font-bold">{wallet.balance || 0}</p>
              </div>
              <div>
                <p className="text-gray-600">Blocked</p>
                <p className="text-2xl font-bold">{wallet.blocked || 0}</p>
              </div>
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow">
            <h2 className="text-xl font-semibold mb-4">Holdings</h2>
            {wallet.holdings && wallet.holdings.length > 0 ? (
              <div className="space-y-4">
                {wallet.holdings.map((holding: any) => (
                  <div key={holding.issuanceId} className="border-b pb-4">
                    <p className="font-semibold">Issuance: {holding.issuanceId}</p>
                    <p className="text-gray-600">Quantity: {holding.quantity}</p>
                  </div>
                ))}
              </div>
            ) : (
              <p className="text-gray-500">No holdings yet</p>
            )}
          </div>
        </div>
      )}
    </div>
  );
}


```
---
# apps/portal-investor/src/app/providers.tsx
```tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from '../../../shared-ui/src';
import { initWebVitals } from '../../../shared-ui/src/utils/webVitals';
import { useState } from 'react';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <ThemeProvider defaultTheme="light">
      <SessionProvider>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </SessionProvider>
    </ThemeProvider>
  );
}

// Initialize web-vitals once in module scope for CSR
if (typeof window !== 'undefined') {
  initWebVitals();
}


```
---
# apps/portal-investor/src/lib/api-client.ts
```ts
import { getSession } from 'next-auth/react';
import { OisApiClient } from '@ois/api-client';

const baseURL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

// Helper to create client with token
async function getClient() {
  const session = await getSession();
  const token = (session?.accessToken as string) || undefined;
  return new OisApiClient({ baseURL, accessToken: token });
}

// SDK wrapper with NextAuth integration
export const apiClient = {
  // Market
  async getMarketIssuances(params?: any) {
    const client = await getClient();
    const data = await client.getMarketIssuances(params);
    return { data };
  },

  async getMarketIssuance(id: string) {
    const client = await getClient();
    const data = await client.getMarketIssuance(id);
    return { data };
  },

  // Orders
  async createOrder(
    data: any,
    options?: { headers?: Record<string, string> }
  ) {
    const client = await getClient();
    const orderData = await client.createOrder(data, {
      headers: options?.headers,
    });
    return { data: orderData };
  },

  // Wallet
  async getWallet(investorId: string) {
    const client = await getClient();
    const wallet = await client.getWallet(investorId);
    return { data: wallet };
  },

  // Investor
  async getInvestorTransactions(investorId: string, params?: any) {
    const client = await getClient();
    const transactions = await client.getInvestorTransactions(investorId, params);
    return { data: transactions };
  },

  async getInvestorPayouts(investorId: string, params?: any) {
    const client = await getClient();
    const payouts = await client.getInvestorPayouts(investorId, params);
    return { data: payouts };
  },

  // Legacy compatibility methods
  placeOrder: async (data: any, options?: { headers?: Record<string, string> }) => {
    return apiClient.createOrder(data, options);
  },
};

```
---
# apps/portal-investor/src/lib/api/compliance.ts
```ts
import { getSession } from 'next-auth/react';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

type FetchError = Error & { status?: number };

async function authFetch<T>(path: string, init?: RequestInit): Promise<T> {
  const session = await getSession();
  const token = (session?.accessToken as string) || undefined;

  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    const err: FetchError = new Error(`Compliance API error: ${response.status}`);
    err.status = response.status;
    throw err;
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return (await response.json()) as T;
}

export type KycStatusResponse = {
  investorId: string;
  kyc: string;
  qualificationTier: string;
  qualificationLimit?: number;
  qualificationUsed?: number;
  updatedAt: string;
};

export type KycApplicationPayload = {
  investorId?: string;
  fullName?: string;
  documentType?: string;
  documentNumber?: string;
  comment?: string;
};

export async function fetchKycStatus(investorId: string): Promise<KycStatusResponse | null> {
  try {
    return await authFetch<KycStatusResponse>(`/v1/compliance/investors/${investorId}/status`);
  } catch (err) {
    const status = (err as FetchError).status;
    if (status === 404) return null;
    throw err;
  }
}

export async function submitKycApplication(payload: KycApplicationPayload) {
  return authFetch(`/v1/compliance/kyc`, {
    method: 'POST',
    body: JSON.stringify(payload),
  });
}


```
---
# apps/portal-investor/src/lib/auth.ts
```ts
import { NextAuthOptions, DefaultSession } from 'next-auth';
import KeycloakProvider from 'next-auth/providers/keycloak';

export const authOptions: NextAuthOptions = {
  providers: [
    KeycloakProvider({
      clientId: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'portal-investor',
      clientSecret: process.env.KEYCLOAK_CLIENT_SECRET || 'secret',
      issuer: `${process.env.NEXT_PUBLIC_KEYCLOAK_URL || 'http://localhost:8080'}/realms/${process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'ois-dev'}`,
    }),
  ],
  callbacks: {
    async jwt({ token, account }) {
      if (account) {
        token.accessToken = account.access_token;
        token.roles = account.access_token ? JSON.parse(Buffer.from((account.access_token as string).split('.')[1], 'base64').toString()).realm_access?.roles : [];
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.roles = token.roles as string[];
        session.accessToken = token.accessToken as string;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
};


```
---
# apps/portal-investor/src/lib/nav.ts
```ts
export const investorNav = [
  { label: 'Portfolio', href: '/portfolio' },
  { label: 'Catalog', href: '/catalog' },
  { label: 'Orders', href: '/orders/new' },
  { label: 'History', href: '/history' },
  { label: 'KYC', href: '/kyc' },
];


```
---
# apps/portal-investor/src/middleware.ts
```ts
import { withAuth } from 'next-auth/middleware';

export default withAuth({
  callbacks: {
    authorized: ({ token }) => {
      const roles = (token?.roles as string[]) || [];
      if (!roles.includes('investor')) {
        return false;
      }
      return !!token;
    },
  },
});

export const config = {
  matcher: ['/portfolio/:path*', '/orders/:path*', '/history/:path*'],
};


```
---
# apps/portal-investor/src/types/next-auth.d.ts
```ts
import 'next-auth';
import 'next-auth/jwt';
import { DefaultSession } from 'next-auth';

declare module 'next-auth' {
  interface Session {
    user: {
      roles?: string[];
    } & DefaultSession['user'];
    accessToken?: string;
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    roles?: string[];
    accessToken?: string;
  }
}


```
---
# apps/portal-issuer/src/app/api/auth/[...nextauth]/route.ts
```ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


```
---
# apps/portal-issuer/src/app/auth/signin/page.tsx
```tsx
'use client';

import { signIn } from 'next-auth/react';
import { useSearchParams } from 'next/navigation';
import { Suspense } from 'react';

function SignInButton() {
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get('callbackUrl') || '/dashboard';

  return (
    <button
      onClick={() => signIn('keycloak', { callbackUrl })}
      className="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-white bg-blue-600 hover:bg-blue-700"
    >
      Sign in with Keycloak
    </button>
  );
}

export default function SignInPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
        <div>
          <h2 className="text-3xl font-bold text-center">OIS Portal - Issuer</h2>
          <p className="mt-2 text-center text-gray-600">Sign in to continue</p>
        </div>
        <Suspense fallback={<div>Loading...</div>}>
          <SignInButton />
        </Suspense>
      </div>
    </div>
  );
}


```
---
# apps/portal-issuer/src/app/dashboard/page.tsx
```tsx
'use client';

import { useSession } from 'next-auth/react';
import { redirect } from 'next/navigation';
import { AppShell, PageHeader, KPIGrid, Skeleton } from '@ois/shared-ui';
import { FileText, DollarSign, Users } from 'lucide-react';
import Link from 'next/link';
import { useQuery } from '@tanstack/react-query';
import { getIssuerReports } from '@/lib/api/issuances';
import { issuerNav } from '@/lib/nav';

export default function DashboardPage() {
  const { data: session, status } = useSession();

  const issuerId =
    (session?.user as any)?.issuerId || (session?.user as any)?.id || '';

  const {
    data: issuancesReport,
    isLoading: reportLoading,
    isError: reportError,
    error,
  } = useQuery({
    queryKey: ['issuer-dashboard-report', issuerId],
    queryFn: async () => getIssuerReports(issuerId),
    enabled: status === 'authenticated' && !!issuerId,
    retry: 0,
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    redirect('/auth/signin');
  }

  const roles = (session.user as any)?.roles || [];
  if (!roles.includes('issuer')) {
    return <div className="p-8">Access denied. Issuer role required.</div>;
  }

  const summary = issuancesReport?.summary;
  const formatCurrency = (value?: number) =>
    typeof value === 'number'
      ? new Intl.NumberFormat('ru-RU', {
          style: 'currency',
          currency: 'RUB',
          maximumFractionDigits: 0,
        }).format(value)
      : '-';

  const kpiData = [
    {
      title: 'Total Issuances',
      value: summary ? summary.totalIssuances.toString() : '-',
      description: 'All issuances for this issuer',
      icon: FileText,
    },
    {
      title: 'Total Amount',
      value: formatCurrency(summary?.totalAmount),
      description: 'Aggregated nominal',
      icon: DollarSign,
    },
    {
      title: 'Investors',
      value: summary ? summary.totalInvestors.toString() : '-',
      description: 'Investors across issuances',
      icon: Users,
    },
  ];

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: issuerNav }}
    >
      <PageHeader
        title="Dashboard"
        description="Overview of your issuances and activity"
      />

      {reportLoading ? (
        <div className="grid grid-cols-1 gap-4 mb-8 md:grid-cols-3">
          {[0, 1, 2].map((i) => (
            <Skeleton key={i} className="h-32 w-full rounded-xl" />
          ))}
        </div>
      ) : (
        <KPIGrid items={kpiData} columns={3} className="mb-8" />
      )}

      {reportError && (
        <div className="mb-4 rounded-md border border-red-200 bg-red-50 p-4 text-sm text-red-800">
          Failed to load dashboard data: {(error as Error)?.message ?? 'Unknown error'}
        </div>
      )}

      <div className="space-y-4">
        <Link
          href="/issuances"
          className="inline-block bg-primary-600 text-white px-6 py-3 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
        >
          View Issuances
        </Link>
        <Link
          href="/issuances/create"
          className="inline-block bg-success-600 text-white px-6 py-3 rounded-md hover:bg-success-700 focus:outline-none focus:ring-2 focus:ring-success-500 focus:ring-offset-2 ml-4"
        >
          Create New Issuance
        </Link>
      </div>
    </AppShell>
  );
}

```
---
# apps/portal-issuer/src/app/globals.css
```css
@import '../../../_theme/tokens.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-background text-text-primary;
    font-family: var(--font-sans);
  }
}


```
---
# apps/portal-issuer/src/app/issuances/[id]/page.tsx
```tsx
'use client';

import { useQuery, useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { extractScheduleItems, PayoutScheduleItem } from '@/lib/api/issuances';
import { useParams, useRouter } from 'next/navigation';
import { toast } from 'sonner';

export default function IssuanceDetailPage() {
  const params = useParams();
  const router = useRouter();
  const id = params.id as string;

  const { data: issuance, isLoading } = useQuery({
    queryKey: ['issuance', id],
    queryFn: async () => {
      const response = await apiClient.getIssuance(id);
      return response.data;
    },
    enabled: !!id,
  });

  const publishMutation = useMutation({
    mutationFn: async () => {
      await apiClient.publishIssuance(id);
    },
    onSuccess: () => {
      toast.success('Issuance published');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to publish');
    },
  });

  const closeMutation = useMutation({
    mutationFn: async () => {
      await apiClient.closeIssuance(id);
    },
    onSuccess: () => {
      toast.success('Issuance closed');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to close');
    },
  });

  if (isLoading) {
    return <div className="p-8">Loading...</div>;
  }

  if (!issuance) {
    return <div className="p-8">Issuance not found</div>;
  }

  const scheduleItems = extractScheduleItems(issuance.scheduleJson);

  return (
    <div className="container mx-auto p-8 space-y-6">
      <h1 className="text-3xl font-bold">Issuance {id}</h1>
      
      <div className="bg-white p-6 rounded-lg shadow">
        <div className="space-y-2">
          <p><strong>Status:</strong> {issuance.status}</p>
          <p><strong>Total Amount:</strong> {issuance.totalAmount}</p>
          <p><strong>Nominal:</strong> {issuance.nominal}</p>
          <p><strong>Issue Date:</strong> {issuance.issueDate}</p>
          <p><strong>Maturity Date:</strong> {issuance.maturityDate}</p>
        </div>
      </div>

      <section className="bg-white p-6 rounded-lg shadow space-y-4">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold">Payout Schedule</h2>
            <p className="text-sm text-gray-500">
              Read-only view, powered by <code>scheduleJson</code>. API from NX-06 SPEC is pending.
            </p>
          </div>
          <button
            type="button"
            disabled
            title="Coming soon (Backend API pending)"
            className="px-4 py-2 rounded-md bg-gray-200 text-gray-500 cursor-not-allowed"
          >
            Manage Schedule
          </button>
        </div>

        {scheduleItems.length > 0 ? (
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200 text-sm">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-4 py-2 text-left font-medium text-gray-600">Date</th>
                  <th className="px-4 py-2 text-left font-medium text-gray-600">Amount</th>
                  <th className="px-4 py-2 text-left font-medium text-gray-600">Status</th>
                  <th className="px-4 py-2 text-left font-medium text-gray-600">Note</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-100 bg-white">
                {scheduleItems.map((item: PayoutScheduleItem) => (
                  <tr key={item.id}>
                    <td className="px-4 py-2">{new Date(item.date).toLocaleDateString()}</td>
                    <td className="px-4 py-2">
                      ₽{item.amount.toLocaleString(undefined, { maximumFractionDigits: 2 })}
                    </td>
                    <td className="px-4 py-2 capitalize">{item.status}</td>
                    <td className="px-4 py-2 text-gray-500">{item.note ?? '—'}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ) : (
          <div className="rounded-md border border-dashed border-gray-300 p-4 text-sm text-gray-500">
            No payout schedule defined yet. Use “Manage Schedule” when NX-06 backend endpoints are available.
          </div>
        )}
      </section>

      <div className="space-x-4">
        {issuance.status === 'draft' && (
          <button
            onClick={() => publishMutation.mutate()}
            disabled={publishMutation.isPending}
            className="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 disabled:opacity-50"
          >
            {publishMutation.isPending ? 'Publishing...' : 'Publish'}
          </button>
        )}
        {issuance.status === 'published' && (
          <button
            onClick={() => closeMutation.mutate()}
            disabled={closeMutation.isPending}
            className="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 disabled:opacity-50"
          >
            {closeMutation.isPending ? 'Closing...' : 'Close'}
          </button>
        )}
        <button
          onClick={() => router.back()}
          className="bg-gray-200 text-gray-800 px-6 py-3 rounded-lg hover:bg-gray-300"
        >
          Back
        </button>
      </div>
    </div>
  );
}

```
---
# apps/portal-issuer/src/app/issuances/create/page.tsx
```tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { z } from 'zod';
import { toast } from 'sonner';

const createIssuanceSchema = z.object({
  assetId: z.string().uuid(),
  issuerId: z.string().uuid(),
  totalAmount: z.number().positive(),
  nominal: z.number().positive(),
  issueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
});

export default function CreateIssuancePage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    assetId: '',
    issuerId: '',
    totalAmount: '',
    nominal: '',
    issueDate: '',
    maturityDate: '',
  });

  const mutation = useMutation({
    mutationFn: async (data: any) => {
      const response = await apiClient.createIssuance({
        assetId: data.assetId,
        issuerId: data.issuerId,
        totalAmount: parseFloat(data.totalAmount),
        nominal: parseFloat(data.nominal),
        issueDate: data.issueDate,
        maturityDate: data.maturityDate,
      });
      return response.data;
    },
    onSuccess: (data) => {
      toast.success('Issuance created successfully');
      router.push(`/issuances/${data?.id}`);
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to create issuance');
    },
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      const validated = createIssuanceSchema.parse({
        ...formData,
        totalAmount: parseFloat(formData.totalAmount),
        nominal: parseFloat(formData.nominal),
      });
      
      mutation.mutate(validated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        toast.error(error.errors[0].message);
      }
    }
  };

  return (
    <div className="container mx-auto p-8 max-w-2xl">
      <h1 className="text-3xl font-bold mb-6">Create Issuance</h1>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">Asset ID</label>
          <input
            type="text"
            value={formData.assetId}
            onChange={(e) => setFormData({ ...formData, assetId: e.target.value })}
            className="w-full px-4 py-2 border rounded-lg"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">Issuer ID</label>
          <input
            type="text"
            value={formData.issuerId}
            onChange={(e) => setFormData({ ...formData, issuerId: e.target.value })}
            className="w-full px-4 py-2 border rounded-lg"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">Total Amount</label>
          <input
            type="number"
            step="0.01"
            value={formData.totalAmount}
            onChange={(e) => setFormData({ ...formData, totalAmount: e.target.value })}
            className="w-full px-4 py-2 border rounded-lg"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">Nominal</label>
          <input
            type="number"
            step="0.01"
            value={formData.nominal}
            onChange={(e) => setFormData({ ...formData, nominal: e.target.value })}
            className="w-full px-4 py-2 border rounded-lg"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">Issue Date</label>
          <input
            type="date"
            value={formData.issueDate}
            onChange={(e) => setFormData({ ...formData, issueDate: e.target.value })}
            className="w-full px-4 py-2 border rounded-lg"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">Maturity Date</label>
          <input
            type="date"
            value={formData.maturityDate}
            onChange={(e) => setFormData({ ...formData, maturityDate: e.target.value })}
            className="w-full px-4 py-2 border rounded-lg"
            required
          />
        </div>

        <div className="flex space-x-4">
          <button
            type="submit"
            disabled={mutation.isPending}
            className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 disabled:opacity-50"
          >
            {mutation.isPending ? 'Creating...' : 'Create'}
          </button>
          <button
            type="button"
            onClick={() => router.back()}
            className="bg-gray-200 text-gray-800 px-6 py-3 rounded-lg hover:bg-gray-300"
          >
            Cancel
          </button>
        </div>
      </form>
    </div>
  );
}


```
---
# apps/portal-issuer/src/app/issuances/page.tsx
```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import Link from 'next/link';
import { useSession } from 'next-auth/react';
import { redirect } from 'next/navigation';

export default function IssuancesPage() {
  const { data: session, status } = useSession();

  const { data: issuances, isLoading, error } = useQuery({
    queryKey: ['issuances'],
    queryFn: async () => {
      // TODO: Add endpoint to list issuances
      return [];
    },
    enabled: status === 'authenticated',
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    redirect('/auth/signin');
  }

  return (
    <div className="container mx-auto p-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Issuances</h1>
        <Link
          href="/issuances/create"
          className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700"
        >
          Create New
        </Link>
      </div>

      {isLoading && <div>Loading issuances...</div>}
      {error && <div className="text-red-600">Error loading issuances</div>}
      
      {issuances && issuances.length === 0 && (
        <div className="text-gray-500">No issuances found. Create your first issuance.</div>
      )}

      {issuances && issuances.length > 0 && (
        <div className="space-y-4">
          {issuances.map((issuance: any) => (
            <div key={issuance.id} className="bg-white p-6 rounded-lg shadow">
              <div className="flex justify-between items-center">
                <div>
                  <h2 className="text-xl font-semibold">Issuance {issuance.id}</h2>
                  <p className="text-gray-600">Status: {issuance.status}</p>
                  <p className="text-gray-600">Amount: {issuance.totalAmount}</p>
                </div>
                <div className="space-x-2">
                  <Link
                    href={`/issuances/${issuance.id}`}
                    className="bg-gray-200 text-gray-800 px-4 py-2 rounded hover:bg-gray-300"
                  >
                    View
                  </Link>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

```
---
# apps/portal-issuer/src/app/kyc/page.tsx
```tsx
'use client';

import { useEffect, useState } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useQuery, useMutation } from '@tanstack/react-query';
import { AppShell, PageHeader, Skeleton, EmptyState } from '@ois/shared-ui';
import { issuerNav } from '@/lib/nav';
import { fetchKycStatus, submitKycApplication } from '@/lib/api/compliance';
import { toast } from 'sonner';

export default function IssuerKycPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [form, setForm] = useState({
    fullName: '',
    documentType: 'passport',
    documentNumber: '',
    comment: '',
  });

  const issuerId = (session?.user as any)?.issuerId || (session?.user as any)?.id || '';

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const {
    data: kycStatus,
    isLoading: statusLoading,
    refetch,
  } = useQuery({
    queryKey: ['issuer-kyc-status', issuerId],
    queryFn: () => fetchKycStatus(issuerId),
    enabled: status === 'authenticated' && !!issuerId,
  });

  const submitMutation = useMutation({
    mutationFn: async () =>
      submitKycApplication({
        investorId: issuerId,
        ...form,
      }),
    onSuccess: () => {
      toast.success('KYC application submitted');
      refetch();
    },
    onError: (error: any) => {
      toast.error(error?.message ?? 'Failed to submit KYC');
    },
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) return null;

  const statusLabel = kycStatus?.kyc ?? 'not-submitted';
  const isSubmitted = statusLabel !== 'not-submitted';

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: issuerNav }}
    >
      <PageHeader
        title="Issuer KYC"
        description="Provide issuer verification details for compliance review"
      />

      <section className="grid gap-6 lg:grid-cols-2">
        <div className="rounded-lg border border-border bg-surface p-6 space-y-4">
          <h2 className="text-lg font-semibold text-text-primary">Current status</h2>
          {statusLoading ? (
            <Skeleton className="h-20 w-full" variant="rectangular" />
          ) : isSubmitted ? (
            <div className="space-y-2">
              <div className="text-sm text-text-secondary">Status</div>
              <div className="text-2xl font-bold text-text-primary capitalize">
                {statusLabel}
              </div>
              <div className="text-sm text-text-secondary">
                Updated at:{' '}
                {kycStatus?.updatedAt
                  ? new Date(kycStatus.updatedAt).toLocaleString()
                  : '—'}
              </div>
            </div>
          ) : (
            <EmptyState
              title="No KYC on file"
              description="Submit issuer details to start verification."
            />
          )}
        </div>

        <div className="rounded-lg border border-border bg-surface p-6 space-y-4">
          <h2 className="text-lg font-semibold text-text-primary">Submit application</h2>
          <form
            className="space-y-4"
            onSubmit={(e) => {
              e.preventDefault();
              submitMutation.mutate();
            }}
          >
            <div className="space-y-2">
              <label className="text-sm text-text-secondary">Full name / Company name</label>
              <input
                type="text"
                value={form.fullName}
                onChange={(e) => setForm({ ...form, fullName: e.target.value })}
                className="w-full rounded-md border border-border px-3 py-2"
                placeholder="Issuer representative"
              />
            </div>

            <div className="grid gap-4 sm:grid-cols-2">
              <div className="space-y-2">
                <label className="text-sm text-text-secondary">Document type</label>
                <select
                  value={form.documentType}
                  onChange={(e) => setForm({ ...form, documentType: e.target.value })}
                  className="w-full rounded-md border border-border px-3 py-2"
                >
                  <option value="passport">Passport</option>
                  <option value="inn">INN</option>
                  <option value="ogrn">OGRN</option>
                  <option value="other">Other</option>
                </select>
              </div>
              <div className="space-y-2">
                <label className="text-sm text-text-secondary">Document number</label>
                <input
                  type="text"
                  value={form.documentNumber}
                  onChange={(e) => setForm({ ...form, documentNumber: e.target.value })}
                  className="w-full rounded-md border border-border px-3 py-2"
                  placeholder="00 00 000000"
                />
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-sm text-text-secondary">Comment</label>
              <textarea
                value={form.comment}
                onChange={(e) => setForm({ ...form, comment: e.target.value })}
                className="w-full rounded-md border border-border px-3 py-2"
                rows={3}
                placeholder="Additional issuer info"
              />
            </div>

            <button
              type="submit"
              className="rounded-md bg-primary-600 px-4 py-2 text-sm font-medium text-white hover:bg-primary-700 disabled:opacity-50"
              disabled={submitMutation.isPending || !issuerId}
            >
              {submitMutation.isPending ? 'Submitting…' : 'Submit KYC'}
            </button>
            {!issuerId && (
              <p className="text-xs text-danger-600">
                Missing issuer id in session; cannot submit.
              </p>
            )}
          </form>
        </div>
      </section>
    </AppShell>
  );
}

```
---
# apps/portal-issuer/src/app/layout.tsx
```tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { Providers } from './providers';
import { Toaster } from 'sonner';

const inter = Inter({ subsets: ['latin', 'cyrillic'] });

export const metadata: Metadata = {
  title: 'OIS Portal - Issuer',
  description: 'Portal for CFA issuers',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ru">
      <body className={inter.className}>
        <Providers>
          {children}
          <Toaster />
        </Providers>
      </body>
    </html>
  );
}

```
---
# apps/portal-issuer/src/app/page.tsx
```tsx
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export default async function Home() {
  const session = await getServerSession(authOptions);
  
  if (!session) {
    redirect('/auth/signin');
  }

  redirect('/dashboard');
}


```
---
# apps/portal-issuer/src/app/payouts/schedule/page.tsx
```tsx
'use client';

import { useState } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { AppShell, PageHeader, EmptyState } from '@ois/shared-ui';
import { issuerNav } from '@/lib/nav';

type Item = { id: string; date: string; amount: string; status: 'planned' | 'executing' | 'done' | 'cancelled' };

export default function PayoutsSchedulePage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [issuanceId, setIssuanceId] = useState('');
  const [items, setItems] = useState<Item[]>([]);

  if (status === 'loading') return <div className="p-8">Loading...</div>;
  if (!session) return null;

  const addItem = () => {
    setItems((prev) => [
      ...prev,
      { id: crypto.randomUUID(), date: new Date().toISOString().split('T')[0], amount: '0', status: 'planned' },
    ]);
  };

  const removeItem = (id: string) => setItems((prev) => prev.filter((i) => i.id !== id));

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: issuerNav }}
    >
      <PageHeader
        title="Payouts Schedule"
        description="Draft payout schedule for an issuance (read-only stub)"
      />

      <div className="space-y-6">
        <div className="flex gap-4 items-end">
          <div>
            <label htmlFor="issuanceId" className="block text-sm font-medium text-text-primary mb-1">Issuance ID</label>
            <input
              id="issuanceId"
              placeholder="00000000-0000-4000-8000-000000000000"
              className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary"
              value={issuanceId}
              onChange={(e) => setIssuanceId(e.target.value)}
            />
          </div>
          <button
            onClick={addItem}
            className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover"
          >
            Add Item
          </button>
          <button
            title="Endpoints missing in spec. See docs/frontend/MVP-impl.md"
            disabled
            className="px-4 py-2 rounded-md bg-gray-200 text-gray-600 cursor-not-allowed"
          >
            Save Schedule
          </button>
        </div>

        {items.length === 0 ? (
          <EmptyState title="No schedule items" description="Add items to draft a schedule (not persisted)" />
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead>
                <tr className="text-left text-text-secondary">
                  <th className="py-2 pr-4">Date</th>
                  <th className="py-2 pr-4">Amount</th>
                  <th className="py-2 pr-4">Status</th>
                  <th className="py-2 pr-4">Actions</th>
                </tr>
              </thead>
              <tbody>
                {items.map((i) => (
                  <tr key={i.id} className="border-t border-border">
                    <td className="py-2 pr-4">
                      <input type="date" value={i.date} onChange={(e) => setItems((prev) => prev.map((x) => x.id === i.id ? { ...x, date: e.target.value } : x))} className="px-2 py-1 border border-border rounded" />
                    </td>
                    <td className="py-2 pr-4">
                      <input type="number" step="0.01" value={i.amount} onChange={(e) => setItems((prev) => prev.map((x) => x.id === i.id ? { ...x, amount: e.target.value } : x))} className="px-2 py-1 border border-border rounded" />
                    </td>
                    <td className="py-2 pr-4">
                      <select value={i.status} onChange={(e) => setItems((prev) => prev.map((x) => x.id === i.id ? { ...x, status: e.target.value as Item['status'] } : x))} className="px-2 py-1 border border-border rounded">
                        <option value="planned">planned</option>
                        <option value="executing">executing</option>
                        <option value="done">done</option>
                        <option value="cancelled">cancelled</option>
                      </select>
                    </td>
                    <td className="py-2 pr-4">
                      <button onClick={() => removeItem(i.id)} className="text-danger-600 hover:underline">Remove</button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </AppShell>
  );
}

```
---
# apps/portal-issuer/src/app/providers.tsx
```tsx
'use client';

import { SessionProvider } from 'next-auth/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ThemeProvider } from '@ois/shared-ui';
import { initWebVitals } from '@ois/shared-ui/src/utils/webVitals';
import { useState } from 'react';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <ThemeProvider defaultTheme="light">
      <SessionProvider>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </SessionProvider>
    </ThemeProvider>
  );
}

if (typeof window !== 'undefined') {
  initWebVitals();
}

```
---
# apps/portal-issuer/src/app/reports/page.tsx
```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { getIssuerReports } from '@/lib/api/issuances';
import type { IssuerReportRow, IssuerPayoutsReportResponse } from '@ois/api-client';
import {
  AppShell,
  PageHeader,
  DataTable,
  BarChart,
  LineChart,
  ChartContainer,
  EmptyState,
  Skeleton,
} from '@ois/shared-ui';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';
import { ColumnDef } from '@tanstack/react-table';
import { Download } from 'lucide-react';
import { toast } from 'sonner';
import * as XLSX from 'xlsx';
import { issuerNav } from '@/lib/nav';

// Using types from SDK

export default function ReportsPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<'issuances' | 'payouts'>('issuances');
  const [dateRange, setDateRange] = useState({
    from: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    to: new Date().toISOString().split('T')[0],
  });
  const [granularity, setGranularity] = useState<'day' | 'week' | 'month' | 'year'>('month');

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const issuerId =
    (session?.user as any)?.issuerId || (session?.user as any)?.id || '';

  const { data: issuancesReport, isLoading: issuancesLoading } = useQuery({
    queryKey: ['issuer-issuances-report', issuerId, dateRange.from, dateRange.to],
    queryFn: async () => getIssuerReports(issuerId, dateRange),
    enabled: status === 'authenticated' && activeTab === 'issuances' && !!issuerId,
    retry: 0,
  });

  const { data: payoutsReport, isLoading: payoutsLoading } = useQuery({
    queryKey: ['issuer-payouts-report', issuerId, dateRange.from, dateRange.to, granularity],
    queryFn: async () => {
      const response = await apiClient.getIssuerPayoutsReport({
        issuerId,
        from: dateRange.from,
        to: dateRange.to,
        granularity,
      });
      return response.data;
    },
    enabled: status === 'authenticated' && activeTab === 'payouts' && !!issuerId,
    retry: 0,
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  const issuancesColumns: ColumnDef<IssuerReportRow>[] = [
    {
      accessorKey: 'assetCode',
      header: 'Asset Code',
      cell: ({ row }) => (
        <span className="text-sm font-medium text-text-primary">
          {row.original.assetCode}
        </span>
      ),
    },
    {
      accessorKey: 'assetName',
      header: 'Asset Name',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.assetName}</span>
      ),
    },
    {
      accessorKey: 'totalAmount',
      header: 'Total Amount',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">
          ₽{row.original.totalAmount.toLocaleString()}
        </span>
      ),
    },
    {
      accessorKey: 'soldAmount',
      header: 'Sold Amount',
      cell: ({ row }) => (
        <span className="text-sm font-medium text-text-primary">
          ₽{row.original.soldAmount.toLocaleString()}
        </span>
      ),
    },
    {
      accessorKey: 'investorsCount',
      header: 'Investors',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">
          {row.original.investorsCount}
        </span>
      ),
    },
    {
      accessorKey: 'status',
      header: 'Status',
      cell: ({ row }) => {
        const status = row.original.status;
        const colors: Record<string, string> = {
          published: 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300',
          draft: 'bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300',
          closed: 'bg-warning-100 text-warning-700 dark:bg-warning-900 dark:text-warning-300',
          redeemed: 'bg-info-100 text-info-700 dark:bg-info-900 dark:text-info-300',
        };
        return (
          <span
            className={`px-2 py-1 text-xs font-medium rounded ${colors[status] || ''}`}
          >
            {status}
          </span>
        );
      },
    },
    {
      accessorKey: 'publishedAt',
      header: 'Published',
      cell: ({ row }) => (
        <span className="text-xs text-text-tertiary">
          {row.original.publishedAt
            ? new Date(row.original.publishedAt).toLocaleDateString()
            : '-'}
        </span>
      ),
    },
  ];

  type PayoutReportRow = IssuerPayoutsReportResponse['items'][number];

  const payoutColumns: ColumnDef<PayoutReportRow>[] = [
    {
      accessorKey: 'period',
      header: 'Period',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.period}</span>
      ),
    },
    {
      accessorKey: 'totalAmount',
      header: 'Total Amount',
      cell: ({ row }) => (
        <span className="text-sm font-medium text-text-primary">
          ₽{row.original.totalAmount.toLocaleString()}
        </span>
      ),
    },
    {
      accessorKey: 'payoutCount',
      header: 'Payout Count',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.payoutCount}</span>
      ),
    },
    {
      accessorKey: 'investorsCount',
      header: 'Investors',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.investorsCount}</span>
      ),
    },
  ];

  const exportToCSV = (data: any[], filename: string) => {
    if (!data || data.length === 0) return;

    const headers = activeTab === 'issuances'
      ? ['Asset Code', 'Asset Name', 'Total Amount', 'Sold Amount', 'Investors', 'Status', 'Published']
      : ['Period', 'Total Amount', 'Payout Count', 'Investors Count'];

    const rows = data.map((item) => {
      if (activeTab === 'issuances') {
        return [
          item.assetCode,
          item.assetName,
          item.totalAmount,
          item.soldAmount,
          item.investorsCount,
          item.status,
          item.publishedAt ? new Date(item.publishedAt).toLocaleDateString() : '-',
        ];
      } else {
        return [
          item.period,
          item.totalAmount,
          item.payoutCount,
          item.investorsCount,
        ];
      }
    });

    const csv = [headers, ...rows]
      .map((row) => row.map((cell) => `"${cell}"`).join(','))
      .join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const exportToXLSX = () => {
    const data = activeTab === 'issuances'
      ? issuancesReport?.items || []
      : payoutsReport?.items || [];

    if (data.length === 0) {
      toast.error('No data to export');
      return;
    }

    try {
      const headers = activeTab === 'issuances'
        ? ['Issuance ID', 'Asset Code', 'Asset Name', 'Total Amount', 'Sold Amount', 'Investors', 'Status', 'Issue Date', 'Maturity Date']
        : ['Period', 'Total Amount', 'Payout Count', 'Investors Count'];

      const rows = data.map((item: any) => {
        if (activeTab === 'issuances') {
          return [
            item.issuanceId,
            item.assetCode,
            item.assetName,
            item.totalAmount,
            item.soldAmount,
            item.investorsCount,
            item.status,
            new Date(item.issueDate).toLocaleDateString(),
            new Date(item.maturityDate).toLocaleDateString(),
          ];
        } else {
          return [
            item.period,
            item.totalAmount,
            item.payoutCount,
            item.investorsCount,
          ];
        }
      });

      const worksheet = XLSX.utils.aoa_to_sheet([headers, ...rows]);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, activeTab === 'issuances' ? 'Issuances' : 'Payouts');
      XLSX.writeFile(workbook, `${activeTab}-report-${new Date().toISOString().split('T')[0]}.xlsx`);
      toast.success('XLSX exported successfully');
    } catch (error: any) {
      toast.error(`Export failed: ${error.message}`);
    }
  };

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: issuerNav }}
    >
      <PageHeader
        title="Reports"
        description="Issuances and payouts analytics"
        actions={
          <div className="flex gap-2">
            <button
              onClick={() =>
                exportToCSV(
                  activeTab === 'issuances'
                    ? issuancesReport?.items || []
                    : payoutsReport?.items || [],
                  activeTab === 'issuances' ? 'issuances-report' : 'payouts-report'
                )
              }
              className="flex items-center gap-2 px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
              disabled={
                activeTab === 'issuances'
                  ? !issuancesReport?.items?.length
                  : !payoutsReport?.items?.length
              }
            >
              <Download className="h-4 w-4" />
              Export CSV
            </button>
            <button
              onClick={exportToXLSX}
              className="flex items-center gap-2 px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
              disabled={
                activeTab === 'issuances'
                  ? !issuancesReport?.items?.length
                  : !payoutsReport?.items?.length
              }
            >
              <Download className="h-4 w-4" />
              Export XLSX
            </button>
          </div>
        }
      />

      {/* Filters */}
      <div className="mb-6 flex flex-wrap gap-4 items-end">
        <div>
          <label
            htmlFor="from"
            className="block text-sm font-medium text-text-primary mb-1"
          >
            From
          </label>
          <input
            id="from"
            type="date"
            value={dateRange.from}
            onChange={(e) =>
              setDateRange({ ...dateRange, from: e.target.value })
            }
            className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
          />
        </div>
        <div>
          <label
            htmlFor="to"
            className="block text-sm font-medium text-text-primary mb-1"
          >
            To
          </label>
          <input
            id="to"
            type="date"
            value={dateRange.to}
            onChange={(e) =>
              setDateRange({ ...dateRange, to: e.target.value })
            }
            className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
          />
        </div>
        {activeTab === 'payouts' && (
          <div>
            <label
              htmlFor="granularity"
              className="block text-sm font-medium text-text-primary mb-1"
            >
              Granularity
            </label>
            <select
              id="granularity"
              value={granularity}
              onChange={(e) =>
                setGranularity(e.target.value as 'day' | 'week' | 'month' | 'year')
              }
              className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              <option value="day">Day</option>
              <option value="week">Week</option>
              <option value="month">Month</option>
              <option value="year">Year</option>
            </select>
          </div>
        )}
      </div>

      {/* Tabs */}
      <div className="mb-6 border-b border-border">
        <div className="flex gap-4">
          <button
            onClick={() => setActiveTab('issuances')}
            className={`px-4 py-2 font-medium border-b-2 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 rounded-t ${
              activeTab === 'issuances'
                ? 'border-primary-600 text-primary-600'
                : 'border-transparent text-text-secondary hover:text-text-primary'
            }`}
          >
            Issuances
          </button>
          <button
            onClick={() => setActiveTab('payouts')}
            className={`px-4 py-2 font-medium border-b-2 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 rounded-t ${
              activeTab === 'payouts'
                ? 'border-primary-600 text-primary-600'
                : 'border-transparent text-text-secondary hover:text-text-primary'
            }`}
          >
            Payouts
          </button>
        </div>
      </div>

      {/* Issuances Tab */}
      {activeTab === 'issuances' && (
        <>
          {issuancesLoading && (
            <Skeleton className="h-64 w-full" variant="rectangular" />
          )}
          {!issuancesLoading && issuancesReport && (
            <>
              {/* Summary Cards */}
              {issuancesReport.summary && (
                <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Issuances</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {issuancesReport.summary.totalIssuances}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Amount</p>
                    <p className="text-2xl font-bold text-text-primary">
                      ₽{issuancesReport.summary.totalAmount.toLocaleString()}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Sold</p>
                    <p className="text-2xl font-bold text-text-primary">
                      ₽{issuancesReport.summary.totalSold.toLocaleString()}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Investors</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {issuancesReport.summary.totalInvestors}
                    </p>
                  </div>
                </div>
              )}

              {/* Chart */}
              {issuancesReport.items && issuancesReport.items.length > 0 && (
                <div className="mb-6">
                  <ChartContainer title="Sold vs Total Amount">
                    <BarChart
                      data={issuancesReport.items.map((item: IssuerReportRow) => ({
                        name: item.assetCode,
                        total: item.totalAmount,
                        sold: item.soldAmount,
                      }))}
                      bars={[
                        { dataKey: 'total', name: 'Total', color: '#3b82f6' },
                        { dataKey: 'sold', name: 'Sold', color: '#22c55e' },
                      ]}
                      height={300}
                    />
                  </ChartContainer>
                </div>
              )}

              {/* Table */}
              <DataTable
                columns={issuancesColumns}
                data={issuancesReport.items || []}
                searchable
                searchPlaceholder="Search issuances..."
                pageSize={10}
              />
            </>
          )}
          {!issuancesLoading && (!issuancesReport || issuancesReport.items?.length === 0) && (
            <EmptyState
              title="No issuances found"
              description="Your issuances will appear here"
            />
          )}
        </>
      )}

      {/* Payouts Tab */}
      {activeTab === 'payouts' && (
        <>
          {payoutsLoading && (
            <Skeleton className="h-64 w-full" variant="rectangular" />
          )}
          {!payoutsLoading && payoutsReport && (
            <>
              {/* Summary */}
              {payoutsReport.summary && (
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Amount</p>
                    <p className="text-2xl font-bold text-text-primary">
                      ₽{payoutsReport.summary.totalAmount.toLocaleString()}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Payouts</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {payoutsReport.summary.totalPayouts}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Investors</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {payoutsReport.summary.totalInvestors}
                    </p>
                  </div>
                </div>
              )}

              {/* Chart */}
              {payoutsReport.items && payoutsReport.items.length > 0 && (
                <div className="mb-6">
                  <ChartContainer
                    title={`Payouts Over Time (${granularity})`}
                    description="Payout amounts by period"
                  >
                    <LineChart
                      data={(payoutsReport.items as PayoutReportRow[]).map((item) => ({
                        name: item.period,
                        amount: item.totalAmount,
                        count: item.payoutCount,
                      }))}
                      lines={[
                        {
                          dataKey: 'amount',
                          name: 'Amount',
                          color: '#3b82f6',
                        },
                        {
                          dataKey: 'count',
                          name: 'Count',
                          color: '#22c55e',
                        },
                      ]}
                      height={300}
                    />
                  </ChartContainer>
                </div>
              )}

              {/* Table */}
              {payoutsReport.items && payoutsReport.items.length > 0 && (
                <DataTable
                  columns={payoutColumns}
                  data={payoutsReport.items as PayoutReportRow[]}
                  searchable={false}
                  pageSize={10}
                />
              )}

              {(!payoutsReport.items || payoutsReport.items.length === 0) && (
                <EmptyState
                  title="No payouts found"
                  description="Your payout history will appear here"
                />
              )}
            </>
          )}
        </>
      )}
    </AppShell>
  );
}

```
---
# apps/portal-issuer/src/lib/api-client.ts
```ts
import { getSession } from 'next-auth/react';
import { OisApiClient } from '@ois/api-client';

const baseURL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

// Helper to create client with token
async function getClient() {
  const session = await getSession();
  const token = (session?.accessToken as string) || undefined;
  return new OisApiClient({ baseURL, accessToken: token });
}

// SDK wrapper with NextAuth integration
export const apiClient = {
  // Issuances
  async createIssuance(data: any) {
    const client = await getClient();
    const issuance = await client.createIssuance(data);
    return { data: issuance };
  },

  async getIssuance(id: string) {
    const client = await getClient();
    const issuance = await client.getIssuance(id);
    return { data: issuance };
  },

  async publishIssuance(id: string) {
    const client = await getClient();
    const issuance = await client.publishIssuance(id);
    return { data: issuance };
  },

  async closeIssuance(id: string) {
    const client = await getClient();
    const issuance = await client.closeIssuance(id);
    return { data: issuance };
  },

  // Reports
  async getIssuerIssuancesReport(params: { issuerId: string; from?: string; to?: string }) {
    const client = await getClient();
    const { issuerId, from, to } = params;
    // SDK requires non-optional dates; fall back to empty strings to satisfy type
    const report = await client.getIssuerIssuancesReport({
      issuerId,
      from: from ?? '',
      to: to ?? '',
    });
    return { data: report };
  },

  async getIssuerPayoutsReport(params: { issuerId: string; from: string; to: string; granularity?: 'day' | 'week' | 'month' | 'year' }) {
    const client = await getClient();
    const report = await client.getIssuerPayoutsReport(params);
    return { data: report };
  },

  // Settlement
  async runSettlement(params?: { date?: string }) {
    const client = await getClient();
    const result = await client.runSettlement(params);
    return { data: result };
  },

  // Legacy compatibility
  getPayoutsReport: async (params: { from: string; to: string }) => {
    const client = await getClient();
    const report = await client.getPayoutsReport(params);
    return { data: report };
  },
};

```
---
# apps/portal-issuer/src/lib/api/compliance.ts
```ts
import { getSession } from 'next-auth/react';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

type FetchError = Error & { status?: number };

async function authFetch<T>(path: string, init?: RequestInit): Promise<T> {
  const session = await getSession();
  const token = (session?.accessToken as string) || undefined;

  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    const err: FetchError = new Error(`Compliance API error: ${response.status}`);
    err.status = response.status;
    throw err;
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return (await response.json()) as T;
}

export type KycStatusResponse = {
  investorId: string;
  kyc: string;
  qualificationTier: string;
  qualificationLimit?: number;
  qualificationUsed?: number;
  updatedAt: string;
};

export type KycApplicationPayload = {
  investorId?: string;
  fullName?: string;
  documentType?: string;
  documentNumber?: string;
  comment?: string;
};

export async function fetchKycStatus(investorId: string): Promise<KycStatusResponse | null> {
  try {
    return await authFetch<KycStatusResponse>(`/v1/compliance/investors/${investorId}/status`);
  } catch (err) {
    const status = (err as FetchError).status;
    if (status === 404) return null;
    throw err;
  }
}

export async function submitKycApplication(payload: KycApplicationPayload) {
  return authFetch(`/v1/compliance/kyc`, {
    method: 'POST',
    body: JSON.stringify(payload),
  });
}


```
---
# apps/portal-issuer/src/lib/api/issuances.ts
```ts
import { apiClient } from '@/lib/api-client';
import type { IssuerIssuancesReportResponse } from '@ois/api-client';

export type IssuerReportsParams = {
  from?: string;
  to?: string;
};

export async function getIssuerReports(
  issuerId: string,
  params?: IssuerReportsParams,
): Promise<IssuerIssuancesReportResponse> {
  const { data } = await apiClient.getIssuerIssuancesReport({
    issuerId,
    ...(params?.from ? { from: params.from } : {}),
    ...(params?.to ? { to: params.to } : {}),
  });

  return data;
}

export type PayoutScheduleItem = {
  id: string;
  date: string;
  amount: number;
  status: 'planned' | 'paid' | 'cancelled' | string;
  note?: string;
};

export function extractScheduleItems(raw: unknown): PayoutScheduleItem[] {
  if (!raw) return [];

  const getList = (): unknown[] => {
    if (Array.isArray(raw)) {
      return raw;
    }

    if (typeof raw === 'object') {
      const obj = raw as Record<string, unknown>;
      if (Array.isArray(obj.items)) {
        return obj.items;
      }
      return Object.values(obj);
    }

    return [];
  };

  const normalized = getList()
    .filter((item) => typeof item === 'object' && item !== null)
    .map((item, idx) => {
      const entry = item as Record<string, unknown>;
      return {
        id: String(entry.id ?? entry.slug ?? idx),
        date: typeof entry.date === 'string' ? entry.date : '',
        amount:
          typeof entry.amount === 'number'
            ? entry.amount
            : Number(entry.amount ?? 0),
        status:
          typeof entry.status === 'string'
            ? entry.status
            : 'planned',
        note: typeof entry.note === 'string' ? entry.note : undefined,
      };
    })
    .filter((item) => Boolean(item.date));

  return normalized;
}

```
---
# apps/portal-issuer/src/lib/auth.ts
```ts
import { NextAuthOptions, DefaultSession } from 'next-auth';
import KeycloakProvider from 'next-auth/providers/keycloak';

export const authOptions: NextAuthOptions = {
  providers: [
    KeycloakProvider({
      clientId: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'portal-issuer',
      clientSecret: process.env.KEYCLOAK_CLIENT_SECRET || 'secret',
      issuer: `${process.env.NEXT_PUBLIC_KEYCLOAK_URL || 'http://localhost:8080'}/realms/${process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'ois-dev'}`,
    }),
  ],
  callbacks: {
    async jwt({ token, account }) {
      if (account) {
        token.accessToken = account.access_token;
        token.roles = account.access_token ? JSON.parse(Buffer.from((account.access_token as string).split('.')[1], 'base64').toString()).realm_access?.roles : [];
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.roles = token.roles as string[];
        session.accessToken = token.accessToken as string;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
};


```
---
# apps/portal-issuer/src/lib/nav.ts
```ts
export const issuerNav = [
  { label: 'Dashboard', href: '/dashboard' },
  { label: 'Issuances', href: '/issuances' },
  { label: 'Reports', href: '/reports' },
  { label: 'Payouts Schedule', href: '/payouts/schedule' },
  { label: 'KYC', href: '/kyc' },
];


```
---
# apps/portal-issuer/src/middleware.ts
```ts
import { withAuth } from 'next-auth/middleware';

export default withAuth({
  callbacks: {
    authorized: ({ token, req }) => {
      // Check if user has issuer role
      const roles = (token?.roles as string[]) || [];
      if (!roles.includes('issuer')) {
        return false;
      }
      return !!token;
    },
  },
});

export const config = {
  matcher: ['/dashboard/:path*', '/issuances/:path*', '/reports/:path*', '/payouts/:path*'],
};


```
---
# apps/portal-issuer/src/types/next-auth.d.ts
```ts
import 'next-auth';
import 'next-auth/jwt';

declare module 'next-auth' {
  interface Session {
    user: {
      roles?: string[];
    } & DefaultSession['user'];
    accessToken?: string;
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    roles?: string[];
    accessToken?: string;
  }
}

```
---
# docs/deploy/20251113-cloudflare-ingress.md
```md
created: 2025-11-13 13:45
updated: 2025-11-13 17:05
type: operations-runbook
sphere: devops
topic: uk1 cloudflare ingress
author: Alex (co-76ca)
agentID: co-76ca
partAgentID: [co-76ca]
version: 0.2.0
tags: [cloudflare, nginx, keycloak, demo, smtp]
---

# Goal
Обеспечить публичный доступ к UK1-стенду (Keycloak + порталы + API) по доменам `*.cfa.llmneighbors.com`, используя Cloudflare (DNS + TLS), системный nginx и docker-compose override для Keycloak.

# Scope
- Сервера UK1 (`185.168.192.214`, Ubuntu, `/opt/ois-cfa`).
- Cloudflare аккаунт `llmneighbors.com` (CLI/Token уже лежит в `/home/user/__Repositories/cloudflare__developerisnow/.env`).
- Keycloak + порталы (pm2) + API gateway, без модификации .NET compose.

- # Checklist
- [x] Cloudflare DNS: A-записи `auth|issuer|investor|backoffice|api.cfa.llmneighbors.com → 185.168.192.214` (DNS only).
- [x] Cloudflare SSL Mode = `Full`.
- [x] Wildcard LE-сертификат `*.cfa.llmneighbors.com` выпущен в `/etc/letsencrypt/live/cfa.llmneighbors.com/`.
- [x] `/etc/nginx/sites-available/cfa-portals.conf` развернут и nginx перезапущен.
- [x] Docker override `ops/infra/uk1/docker-compose.keycloak-proxy.yml` активирован (`KEYCLOAK_PUBLIC_URL=https://auth.cfa.llmneighbors.com`).
- [x] `.env.local` порталов обновлены, pm2 перезапущен.
- [x] Keycloak clients/realm откорректированы (redirects, webOrigins, self-registration ON, verifyEmail ON).
- [x] Playwright e2e (issuer/investor + self-registration + backoffice admin) проходит, отчёты в `tests/e2e-playwright/test-results/`.
- [x] VPN `x-ui` выключен (порт 443 свободен).
- [x] SMTP стек (Postfix + OpenDKIM) + SPF/DKIM/DMARC настроены; Keycloak использует локальный relay.
- [x] Postfix слушает только `127.0.0.1` и `172.18.0.1` (docker bridge); внешний 25 порт закрыт.

# Why → What → How → Result

## Why
- Демки должны открываться из браузера без SSH-туннелей.
- Клиенты хотят использовать собственный домен (`*.cfa.llmneighbors.com`).
- Надо иметь повторяемый чеклист для второго DevOps (Саша О.).

## What
- Cloudflare управляет DNS и выпускает wildcard сертификат (через DNS challenge).
- Nginx на UK1 выполняет offload TLS + проксирует на локальные порты (Keycloak 8081, pm2 порталы 300x, API 5000).
- docker-compose override поднимает Keycloak с правильным `KC_HOSTNAME_URL`.
- `.env.local` порталов и Keycloak clients должны ссылаться на публичные URL.

## How
1. **DNS + SSL (Cloudflare CLI):**
   ```bash
   cd /home/user/__Repositories/cloudflare__developerisnow
   source .env  # экспортирует CLOUDFLARE_API_TOKEN
   CF_API_TOKEN="$CLOUDFLARE_API_TOKEN" flarectl dns create-or-update --zone llmneighbors.com --name auth.cfa --type A --content 185.168.192.214 --ttl 1
   # повторить для issuer / investor / backoffice / api (DNS only)
   # SSL mode
   curl -sX PATCH "https://api.cloudflare.com/client/v4/zones/2f4591aa91796b09311095cfee03d817/settings/ssl" \
     -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" -H "Content-Type: application/json" \
     --data '{"value":"full"}'
   ```
2. **Wildcard сертификат:**
   ```bash
   ssh -p 51821 root@185.168.192.214
   mkdir -p /root/.secrets && chmod 700 /root/.secrets
   cat > /root/.secrets/cloudflare.ini <<'EOF'
   dns_cloudflare_api_token = ${CLOUDFLARE_API_TOKEN}
   EOF
   chmod 600 /root/.secrets/cloudflare.ini
   certbot certonly --dns-cloudflare --dns-cloudflare-credentials /root/.secrets/cloudflare.ini \
     --dns-cloudflare-propagation-seconds 45 \
     -d "*.cfa.llmneighbors.com" -d "cfa.llmneighbors.com" \
     --agree-tos --email <ops@developerisnow.com> --non-interactive
   ```
3. **nginx:**
   ```bash
   apt-get install -y nginx
   systemctl stop x-ui && systemctl disable x-ui   # освободить 443 (пересадим позже)
   cd /opt/ois-cfa
   env CFA_BASE_DOMAIN=cfa.llmneighbors.com \
       AUTH_HOST=auth.cfa.llmneighbors.com \
       ISSUER_HOST=issuer.cfa.llmneighbors.com \
       INVESTOR_HOST=investor.cfa.llmneighbors.com \
       BACKOFFICE_HOST=backoffice.cfa.llmneighbors.com \
       API_HOST=api.cfa.llmneighbors.com \
       envsubst < ops/infra/uk1/nginx-cfa-portals.conf > /etc/nginx/sites-available/cfa-portals.conf
   ln -sf /etc/nginx/sites-available/cfa-portals.conf /etc/nginx/sites-enabled/cfa-portals.conf
   rm -f /etc/nginx/sites-enabled/default
   nginx -t && systemctl reload nginx
   ```
4. **docker-compose override:**
   ```bash
   cd /opt/ois-cfa
   KEYCLOAK_PUBLIC_URL=https://auth.cfa.llmneighbors.com \
   docker compose -f docker-compose.yml -f docker-compose.override.yml \
     -f ops/infra/uk1/docker-compose.keycloak-proxy.yml up -d keycloak keycloak-proxy
   ```
5. **Клиенты + пользователи:**
   ```bash
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh config credentials --server http://localhost:8080 --realm master --user admin --password admin123
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh update clients/<id> -r ois-dev -s "redirectUris=[\"https://issuer.cfa.llmneighbors.com/*\"]" -s "webOrigins=[\"https://issuer.cfa.llmneighbors.com\"]"
   # повторить для investor/backoffice
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh update realms/ois-dev/authentication/required-actions/VERIFY_PROFILE -s enabled=false -s defaultAction=false
   ```
6. **Порталы:**
   ```bash
   cat > /opt/ois-cfa/apps/portal-issuer/.env.local <<'EOF'
   NEXT_PUBLIC_API_BASE_URL=https://api.cfa.llmneighbors.com
   NEXT_PUBLIC_KEYCLOAK_URL=https://auth.cfa.llmneighbors.com
   NEXT_PUBLIC_KEYCLOAK_REALM=ois-dev
   NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=portal-issuer
   NEXTAUTH_URL=https://issuer.cfa.llmneighbors.com
   NEXTAUTH_SECRET=...
   KEYCLOAK_CLIENT_SECRET=...
   EOF
   # аналогично для investor/backoffice
   source /root/.nvm/nvm.sh && pm2 restart portal-issuer portal-investor portal-backoffice --update-env
   ```
7. **Проверка:**
   ```bash
   curl -I https://auth.cfa.llmneighbors.com
   curl https://api.cfa.llmneighbors.com/health
   cd tests/e2e-playwright && npm test
   ```

## Result
- Пользовательские порталы и Keycloak доступны по HTTPS без SSH-туннелей.
- Playwright обеспечивает «доказательство» логина (issuer/investor + self-registration).
- SMTP цепочка (Postfix + OpenDKIM) выдаёт проверочные письма; Keycloak self-registration завершает flow без ручных действий.
- Вся конфигурация задокументирована и может быть переиспользована для других VPS.

## Email / SMTP / DKIM
1. **Postfix + OpenDKIM**
   ```bash
   apt-get install -y postfix mailutils opendkim opendkim-tools
   postconf -e 'inet_interfaces = all'
   postconf -e 'mynetworks = 127.0.0.0/8 172.17.0.0/16 172.18.0.0/16'
   postconf -e 'smtpd_recipient_restrictions = permit_mynetworks, reject_unauth_destination'
   postconf -e 'smtpd_relay_restrictions = permit_mynetworks, reject_unauth_destination'
   systemctl enable --now opendkim postfix
   ```

   `/etc/opendkim.conf` (основное):
   ```conf
   UserID                  opendkim:opendkim
   Socket                  inet:8891@127.0.0.1
   KeyTable                refile:/etc/opendkim/KeyTable
   SigningTable            refile:/etc/opendkim/SigningTable
   InternalHosts           /etc/opendkim/TrustedHosts
   ```
   Ключ `mail._domainkey.cfa.llmneighbors.com` → TXT (см. Cloudflare ниже).

2. **Cloudflare DNS для почты**
   ```bash
   # A-запись
   curl -sX POST ... --data '{"type":"A","name":"mail.cfa.llmneighbors.com","content":"185.168.192.214","proxied":false}'
   # MX
   curl -sX POST ... --data '{"type":"MX","name":"cfa.llmneighbors.com","content":"mail.cfa.llmneighbors.com","priority":10}'
   # SPF
   curl -sX POST ... --data '{"type":"TXT","name":"cfa.llmneighbors.com","content":"v=spf1 ip4:185.168.192.214 ~all"}'
   # DKIM
   curl -sX POST ... --data '{"type":"TXT","name":"mail._domainkey.cfa.llmneighbors.com","content":"v=DKIM1; ..."}'
   # DMARC
   curl -sX POST ... --data '{"type":"TXT","name":"_dmarc.cfa.llmneighbors.com","content":"v=DMARC1; p=none; rua=mailto:ops@llmneighbors.com; fo=1"}'
   ```

3. **Keycloak realm SMTP**
   ```bash
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh config credentials --server http://localhost:8080 --realm master --user admin --password admin123
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh update realms/ois-dev \
     -s verifyEmail=true -s registrationAllowed=true \
     -s "smtpServer.host=172.18.0.1" \
     -s "smtpServer.port=25" \
     -s "smtpServer.from=no-reply@cfa.llmneighbors.com" \
     -s "smtpServer.replyTo=ops@llmneighbors.com" \
     -s "smtpServer.envelopeFrom=no-reply@cfa.llmneighbors.com" \
     -s "smtpServer.starttls=false" -s "smtpServer.ssl=false" -s "smtpServer.auth=false"
   ```

4. **Smoke**
   ```bash
   echo "SMTP ok" | mail -s "Test" cfa+demo@2200freefonts.com
   tail -f /var/log/mail.log  # подтверждаем delivery
   TOKEN=$(curl -s -X POST https://api.mail.tm/token ...)
   curl -H "Authorization: Bearer $TOKEN" https://api.mail.tm/messages
   ```
   Playwright self-registration (`tests/e2e-playwright/tests/self-registration.spec.ts`) и backoffice spec (`tests/e2e-playwright/tests/backoffice-auth.spec.ts`) используют те же домены/SMTP.

# Notes
- `x-ui` (VPN) был отключён из-за конфликтов порта 443. При переносе на другой порт добавьте `sudo sed -i 's/:443/:<new_port>/' /etc/systemd/system/x-ui.service` и перезапустите nginx.
- IaC артефакты: `ops/infra/uk1/nginx-cfa-portals.conf` и `ops/infra/uk1/docker-compose.keycloak-proxy.yml`.
- Инструменты: `flarectl`, `wrangler`, `certbot-dns-cloudflare`, `pm2`, `playwright`, `mail.tm`.

```
---
# docs/deploy/MULTI_ACCOUNT_SETUP.md
```md
---
created: 2025-11-19 21:05
updated: 2025-11-19 21:05
type: runbook
sphere: [devops]
topic: [cloudflare, multi-account, domains]
author: alex-a
agentID: co-76ca
partAgentID: [co-76ca, co-7b1b]
version: 0.1.0
tags: [cloudflare, dns, tls, zones, eywa1]
---

# Multi‑Account Cloudflare / Domains Setup (eywa1 Control Plane)

Цель: позволить `eywa1` управлять несколькими Cloudflare‑аккаунтами и доменами (например, `*.cfa.llmneighbors.com` для UK1/cfa1 и отдельный домен/аккаунт для fin2/cfa2 или `*.cfa{n}.telex.global`) без жёсткого хардкода токенов и zone id.

## 1. Где сейчас зашиты домены и токены

- `docs/deploy/20251113-cloudflare-ingress.md`
  - Жёстко использует зону `llmneighbors.com` и конкретный `zone_id` + `CLOUDFLARE_API_TOKEN` из `/home/user/__Repositories/cloudflare__developerisnow/.env`.
- `docs/deploy/docker-compose-at-vps/10-eywa1-control-plane-runbook.md`
  - Описывает DNS/TLS для `*.cfa.llmneighbors.com` и `*.cfa{1,2,3}.llmneighbors.com` как основной сценарий.
- Скрипты `ops/scripts/deploy/provision-node.sh` и `ops/scripts/deploy/deploy-node.sh`
  - **Не** содержат Cloudflare‑логики и доменов; работают только с SSH, Docker, tmux и git.
- Практические команды на `eywa1`
  - В текущих сессиях использовались одноразовые `curl`/`certbot` команды, где токен/zone id подтягивались из `.env` в репо `cloudflare__developerisnow`.

Вывод: на данный момент Cloudflare‑детали находятся только в документации и ad‑hoc командах, что позволяет относительно безболезненно параметризовать их. Для новых зон (например, `telex.global`) используем отдельные `.env.*` с нужными `ACCOUNT_ID/ZONE_ID/TOKEN`.

## 2. Принцип: конфигурируемость per‑node

Для поддержки разных аккаунтов/доменов для разных нод (например, `cfa1.llmneighbors.com` в одном CF‑аккаунте и `cfa2.otherdomain.com` в другом) вводим явный конфиг на `eywa1`:

- Отдельный `.env`/config per домен/аккаунт:
  - Пример: `/home/user/__Repositories/cloudflare__developerisnow/.env.cfa1`
  - Пример: `/home/user/__Repositories/cloudflare__developerisnow/.env.cfa2`
- В них явным образом задаются:
  - `CF_ZONE_NAME`
  - `CF_ZONE_ID`
  - `CF_API_TOKEN`
  - (опционально) набор префиксов/хостов (`CF_HOST_PREFIXES=auth,issuer,investor,backoffice,api`).

Эти файлы **не** коммитятся в репозиторий и живут только на `eywa1` (как и сейчас `.env` для llmneighbors).

## 3. Пример: два разных домена/аккаунта (llmneighbors + telex.global)

```bash
# /home/user/__Repositories/cloudflare__developerisnow/.env.cfa1
CF_ZONE_NAME=llmneighbors.com
CF_ZONE_ID=<zone-id-cfa1>
CF_API_TOKEN=<token-for-llmneighbors-account>
CF_HOST_PREFIXES=auth,issuer,investor,backoffice,api
CF_BASE_LABEL=cfa1

# /home/user/__Repositories/cloudflare__developerisnow/.env.cfa2.telex
CF_ZONE_NAME=telex.global
CF_ZONE_ID=<zone-id-telex>
CF_API_TOKEN=<token-for-telex-account>
CF_ACCOUNT_ID=<account-id-telex>
CF_HOST_PREFIXES=auth,issuer,investor,backoffice,api
CF_BASE_LABEL=cfa2
```

Тогда сценарий на `eywa1` для cfa1:

```bash
cd /home/user/__Repositories/cloudflare__developerisnow
set -a && source .env.cfa1 && set +a

for host in ${CF_HOST_PREFIXES//,/ }; do
  NAME=\"${host}.${CF_BASE_LABEL}\"
  # auth.cfa1.llmneighbors.com, issuer.cfa1.llmneighbors.com, ...
  # используем CF_ZONE_NAME/CF_ZONE_ID/CF_API_TOKEN для upsert
done
```

А для fin2/cfa2:

```bash
set -a && source .env.cfa2.telex && set +a

for host in ${CF_HOST_PREFIXES//,/ }; do
  NAME=\"${host}.${CF_BASE_LABEL}\"
  # auth.cfa2.telex.global, issuer.cfa2.telex.global, ...
done
```

## 4. Интеграция с runbook’ами и скриптами

- Runbook `20251113-cloudflare-ingress.md`
  - Оставляем как UK1‑специализированный (llmneighbors), но добавляем ссылку на этот документ как на общий план для других зон.
- Runbook `10-eywa1-control-plane-runbook.md`
  - Подразумевает, что DNS/TLS можно поднять не только для `*.cfa{N}.llmneighbors.com`, но и для других доменов, если заданы соответствующие `.env.*` файлы.
- Скрипты `provision-node.sh`/`deploy-node.sh`
  - Осознанно **не** привязываем к Cloudflare, чтобы не шить в них секреты и zone id.
  - DNS/TLS остаются шагами уровня runbook/оператора, а не «автоматической магией» в скриптах.

### 4.1 Cloudflare helper script

Для унификации работы с Cloudflare добавлен вспомогательный скрипт:

- `ops/scripts/cloudflare-dns-upsert.sh`
  - Аргументы:
    - `$1` — путь к env‑файлу (`.env.cfa1`, `.env.cfa2`, …).
    - `$2` — IP‑адрес целевого узла.
  - Использует переменные из env‑файла:
    - `CF_ZONE_NAME`, `CF_ZONE_ID`, `CF_API_TOKEN`
    - `CF_HOST_PREFIXES` (например, `auth,issuer,investor,backoffice,api`)
    - `CF_BASE_LABEL` (например, `cfa1` / `demo`).
  - Для каждого префикса upsert‑ит A‑запись вида `<prefix>.<CF_BASE_LABEL>.<CF_ZONE_NAME>`.

Примеры:

```bash
# cfa1 (llmneighbors)
./ops/scripts/cloudflare-dns-upsert.sh \
  /home/user/__Repositories/cloudflare__developerisnow/.env.cfa1 \
  87.249.49.56

# fin2 / cfa2 (telex.global)
./ops/scripts/cloudflare-dns-upsert.sh \
  /home/user/__Repositories/cloudflare__developerisnow/.env.cfa2.telex \
  65.109.171.138
```

## 5. DoD для multi‑account Cloudflare

- Для каждого окружения (`cfa1`, `cfa2/fin2`, будущие us1/germ1):
  - Есть отдельный `.env.<env>` с `CF_ZONE_NAME`, `CF_ZONE_ID`, `CF_API_TOKEN`.
  - Документация (этот файл и `10-eywa1-control-plane-runbook.md`) описывает, как выбирать нужный `.env.<env>` перед запуском DNS/TLS шагов.
  - Нет жёстко зашитых zone id/token’ов в коде скриптов; все секреты подтягиваются из локальных `.env` на `eywa1`.

```
---
# docs/deploy/docker-compose-at-vps/00-overview.md
```md
---
created: 2025-11-11 15:20
updated: 2025-11-11 15:20
type: runbook
sphere: [devops]
topic: [deploy, docker-compose, vps]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [compose, linux, dotnet, keycloak]
---

# OIS‑CFA · Deploy на VPS (Docker Compose) — Обзор

Цель: поднять полный dev‑контур на VPS с Docker Compose: инфраструктура, .NET‑сервисы, API‑шлюз, Keycloak, и (опционально) веб‑клиенты.

Ключевые принципы
- [ ] Используем non‑standard порты, чтобы не конфликтовать с окружением
- [ ] Сборка выполняется поэтапно (низкая RAM) — «infra → services → gateway → web»
- [ ] Миграции БД включаем флагом `MIGRATE_ON_STARTUP=true` (по умолчанию off)
- [ ] Логи читаем через `docker logs`, готовность через `/health`

Состав контура (порты по умолчанию)
- API Gateway: `55000`
- Identity: `55001`
- Issuance: `55005`
- Registry: `55006`
- Settlement: `55007`
- Compliance: `55008`
- PostgreSQL: `55432`
- Kafka: `59092`, ZooKeeper: `52181`
- Keycloak: `58080`
- Minio: `59000` (S3), `59001` (Console)

Структура документации
- 01 — Подготовка VPS и Docker
- 02 — Настройка `.env` и Compose
- 03 — Инфраструктура
- 04 — .NET‑сервисы
- 05 — API‑шлюз
- 06 — Keycloak (realm/clients)
- 07 — Веб‑клиенты (Next.js)
- 08 — Smoke‑тесты
- 09 — Траблшутинг


```
---
# docs/deploy/docker-compose-at-vps/01-prereqs-and-host-prep.md
```md
---
created: 2025-11-11 15:20
updated: 2025-11-11 15:20
type: runbook
sphere: [devops]
topic: [prereqs, host-prep]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [linux, docker, swap]
---

# 01 — Подготовка VPS (Ubuntu) и Docker

Аппаратные требования (dev)
- [ ] CPU 2 vCPU+
- [ ] RAM 2–4 ГБ (на 2 ГБ добавить swap, см. ниже)
- [ ] Диск 20+ ГБ

Проверка ОС и ресурсов
- [ ] `uname -a`
- [ ] `df -hT`
- [ ] `free -m`

Установка Docker + Compose
- [ ] ```bash
  curl -fsSL https://get.docker.com | sh
  ```
- [ ] Проверка версий: `docker --version && docker compose version`

Swap 2 ГБ (для стабильной сборки .NET/Node)
- [ ] ```bash
  sudo fallocate -l 2G /swapfile || sudo dd if=/dev/zero of=/swapfile bs=1M count=2048
  sudo chmod 600 /swapfile
  sudo mkswap /swapfile
  sudo swapon /swapfile
  echo "/swapfile none swap sw 0 0" | sudo tee -a /etc/fstab
  free -m
  ```

Сетевые порты (если нужен внешний доступ)
- [ ] На сервере UFW может быть выключен (ок): `sudo ufw status`
- [ ] Часто блок на стороне провайдера: открыть TCP 55000/1/5/6/7/8, 58080, 59000/59001, 55432, 59092, 52181
- [ ] Альтернатива — SSH‑туннели (см. раздел 07 и 09)


```
---
# docs/deploy/docker-compose-at-vps/02-env-and-compose.md
```md
---
created: 2025-11-11 15:21
updated: 2025-11-11 15:21
type: runbook
sphere: [devops]
topic: [env, compose]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [compose, env]
---

# 02 — Настройка `.env` и Compose файлов

Репозиторий и путь
- [ ] Код расположен в `/opt/ois-cfa`
- [ ] Файлы Compose:
  - `docker-compose.yml` (инфраструктура)
  - `docker-compose.override.yml` (порты/переменные из `.env`)
  - `docker-compose.kafka.override.yml` (Kafka образ для dev)
  - `docker-compose.services.yml` (.NET сервисы + API gateway)
  - `docker-compose.apps.yml` (опционально: фронтенды Next.js)

Переменные окружения (`.env`)
- [ ] Открыть `./ois-cfa/.env` и проверить:
  - [ ] Порты сервисов: `GATEWAY_HOST_PORT=55000`, `IDENTITY_HOST_PORT=55001`, `ISSUANCE_HOST_PORT=55005`, `REGISTRY_HOST_PORT=55006`, `SETTLEMENT_HOST_PORT=55007`, `COMPLIANCE_HOST_PORT=55008`
  - [ ] Инфра: `POSTGRES_HOST_PORT=55432`, `KAFKA_HOST_PORT=59092`, `ZOOKEEPER_HOST_PORT=52181`, `KEYCLOAK_HOST_PORT=58080`, `MINIO_HOST_PORT=59000`, `MINIO_CONSOLE_PORT=59001`
  - [ ] Соединения: `SERVICE_DB_CONN=Host=postgres;Port=5432;Database=ois;Username=ois;Password=ois_dev_password`
  - [ ] Kafka bootstrap: `KAFKA_BOOTSTRAP=kafka:9092`
  - [ ] (Опционально для фронтов) `API_PUBLIC_URL`, `KEYCLOAK_PUBLIC_URL`, `KEYCLOAK_REALM`, `ISSUER_HOST_PORT`, `INVESTOR_HOST_PORT`, `BACKOFFICE_HOST_PORT`

Git/синхронизация кода на VPS
- [ ] Если нужно обновить код из локали: 
  ```bash
  rsync -az --delete --exclude '.git' --exclude 'node_modules' ././ois-cfa/ cfa1:/opt/ois-cfa/
  ```


```
---
# docs/deploy/docker-compose-at-vps/03-infra.md
```md
---
created: 2025-11-11 15:21
updated: 2025-11-11 15:21
type: runbook
sphere: [devops]
topic: [infra, postgres, kafka, keycloak, minio]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [compose, infra]
---

# 03 — Инфраструктура (Postgres, Kafka/ZK, Keycloak, Minio)

Запуск инфраструктуры
- [ ] ```bash
  cd /opt/ois-cfa
  docker compose -f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml up -d
  ```
- [ ] Проверить контейнеры: 
  - `docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"`

Health/порты (локально на сервере)
- [ ] Postgres: `docker exec -it ois-postgres pg_isready -U ois`
- [ ] Keycloak: порт `58080` (админ admin/admin123), URL: `http://localhost:58080`
- [ ] Minio: `http://localhost:59001` (minioadmin/minioadmin)

Примечание по Kafka
- [ ] В dev используем образ `confluentinc/cp-kafka:7.5.0` (через override)


```
---
# docs/deploy/docker-compose-at-vps/04-services.md
```md
---
created: 2025-11-11 15:22
updated: 2025-11-11 15:22
type: runbook
sphere: [devops]
topic: [services, dotnet]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [dotnet, compose]
---

# 04 — .NET‑сервисы (поэтапный запуск)

Общие правила
- [ ] На малых VPS собирать по одному сервису (RAM 2 ГБ)
- [ ] Миграции БД — через флаг `MIGRATE_ON_STARTUP=true` (по умолчанию не применяются)
- [ ] Проверка готовности: `/health` на соответствующем порту

Identity Service
- [ ] ```bash
  cd /opt/ois-cfa
  C="-f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml -f docker-compose.services.yml"
  docker compose $C build identity-service && docker compose $C up -d identity-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55001/health
  ```

Registry Service
- [ ] ```bash
  docker compose $C build --no-cache registry-service
  MIGRATE_ON_STARTUP=false docker compose $C up -d registry-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55006/health
  ```

Issuance Service (dev‑правки учтены)
- [ ] Примечание: в dev отключены Prometheus‑экспортер и scraping endpoint, авто‑валидация временно выключена
- [ ] ```bash
  docker compose $C build --no-cache issuance-service
  MIGRATE_ON_STARTUP=false docker compose $C up -d issuance-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55005/health
  ```

Settlement Service
- [ ] ```bash
  docker compose $C build settlement-service
  MIGRATE_ON_STARTUP=false docker compose $C up -d settlement-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55007/health
  ```

Compliance Service
- [ ] ```bash
  docker compose $C build compliance-service
  MIGRATE_ON_STARTUP=false docker compose $C up -d compliance-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55008/health
  ```

Логи и статус
- [ ] `docker compose $C ps`
- [ ] `docker logs -f <service>`


```
---
# docs/deploy/docker-compose-at-vps/05-gateway.md
```md
---
created: 2025-11-11 15:22
updated: 2025-11-11 15:22
type: runbook
sphere: [devops]
topic: [gateway, yarp]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [yarp, reverse-proxy]
---

# 05 — API Gateway (YARP)

Сборка и запуск
- [ ] ```bash
  cd /opt/ois-cfa
  C="-f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml -f docker-compose.services.yml"
  docker compose $C build api-gateway && docker compose $C up -d api-gateway
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55000/health
  ```

Примечания по маршрутам
- [ ] Маршруты читаются из `apps/api-gateway/appsettings.json` (секция `ReverseProxy`)
- [ ] Исправлено правило redeem: `"/v1/issuances/{id}/redeem"` (catch‑all в середине запрещён)

Проверки
- [ ] `/health` → 200
- [ ] Запросы на `/v1/orders/{id}`, `/v1/wallets/{investorId}` возвращают 404 (NotFound), если нет данных — это нормальная реакция


```
---
# docs/deploy/docker-compose-at-vps/06-keycloak.md
```md
---
created: 2025-11-11 15:23
updated: 2025-11-21 12:30
type: runbook
sphere: [devops]
topic: [keycloak, oidc]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.1
tags: [keycloak, oidc]
---

# 06 — Keycloak (realm/clients)

Параметры
- [ ] URL (внутри compose сети): `http://keycloak:8080`
- [ ] URL (на хосте): `http://localhost:58080`
- [ ] Админ: `admin/admin123`
- [ ] Realm: `ois`

Бутстрап realm и клиентов (issuer, investor, backoffice)
- [ ] ```bash
  cd /opt/ois-cfa
  chmod +x ops/keycloak/bootstrap-realm.sh
  docker exec ois-keycloak bash -lc "bash -s" < ops/keycloak/bootstrap-realm.sh
  ```
- [ ] Скрипт создаёт клиентов с redirect URIs по публичным URL (редактируем переменные в начале при необходимости)
- [ ] Демо‑пользователи: `investor/Passw0rd!`, `issuer/Passw0rd!`, `backoffice/Passw0rd!`

Внешний доступ
- [ ] Если 58080 недоступен снаружи — это, вероятно, фаервол провайдера
- [ ] Временное решение: SSH‑туннель (см. 07 и 09)

## CFA1 login recovery (2025-11-21)
- Убедиться, что контейнер запущен: `docker ps | grep ois-keycloak`
- Сбросить пароль тестового пользователя (realm `ois-dev`):  
  `docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh config credentials --server http://localhost:8080 --realm master --user admin --password admin123`  
  `docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh set-password -r ois-dev --username alexabook1 --new-password 'zdwouE$ybQ!4!hCHRtG!ML76HHuA2p' --temporary=false`
- Принудительно включить/подтвердить почту при проблемах с логином:  
  `docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh update users/$(docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh get users -r ois-dev -q username=alexabook1 --fields id --format csv | tr -d '\r\n') -r ois-dev -s enabled=true -s emailVerified=true`
- Админ логин: `https://auth.cfa1.llmneighbors.com/admin` (admin/admin123 по умолчанию).

```
---
# docs/deploy/docker-compose-at-vps/07-frontends-dev-on-vps.md
```md
# Frontends on VPS (Dev mode)

## ✅ TL;DR
- Запускаем фронтенды в dev-режиме на VPS (без Docker)
- Порты: 3001 (issuer), 3002 (investor), 3003 (backoffice)
- Для доступа с Mac используйте SSH-туннели (см. ниже)

## 1) Предусловия (host)
- [x] Docker/Compose для бэкендов уже подняты (gateway 5000, keycloak 8080)
- [x] Node.js 20 LTS установлен
  ```bash
  curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
  apt-get update -y && apt-get install -y nodejs build-essential
  node -v && npm -v
  npm i -g pm2@latest
  ```

## 2) Keycloak (realm и клиенты)
- [x] Убедитесь, что Keycloak запущен и доступен
  ```bash
  docker compose -f docker-compose.yml -f docker-compose.override.yml up -d keycloak
  curl -I http://localhost:8080/admin   # 302
  ```
- [x] Бутстрап реалма и клиентов (PUBLIC)
  ```bash
  docker cp ops/keycloak/bootstrap-realm.sh ois-keycloak:/tmp/bootstrap.sh
  docker exec ois-keycloak bash -lc \
    'KC_USER=admin KC_PASS=admin123 REALM=ois-dev \
     ISSUER_URL=http://localhost:3001 INVESTOR_URL=http://localhost:3002 BACKOFFICE_URL=http://localhost:3003 \
     ISSUER_TUNNEL_URL=http://localhost:15301 INVESTOR_TUNNEL_URL=http://localhost:15302 BACKOFFICE_TUNNEL_URL=http://localhost:15303 \
     bash /tmp/bootstrap.sh'
  ```

## 3) Env для фронтов
- [x] Создайте `.env.local` в каждой из папок:
  - `apps/portal-issuer/.env.local`
  - `apps/portal-investor/.env.local`
  - `apps/backoffice/.env.local`

  Содержимое:
  ```dotenv
  NEXT_PUBLIC_API_BASE_URL=http://localhost:5000
  NEXT_PUBLIC_KEYCLOAK_URL=http://localhost:8080
  NEXT_PUBLIC_KEYCLOAK_REALM=ois-dev
  NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=<portal-issuer|portal-investor|backoffice>
  NEXTAUTH_URL=http://localhost:<3001|3002|3003>
  ```

## 4) Установка зависимостей
- [x] Сначала SDK и shared-ui:
  ```bash
  cd /opt/ois-cfa/packages/sdks/ts && npm install --no-audit --no-fund --include=dev && npm run build
  cd /opt/ois-cfa/apps/shared-ui && npm install --no-audit --no-fund --include=dev
  ```
- [x] Затем каждый фронт:
  ```bash
  cd /opt/ois-cfa/apps/portal-issuer && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/portal-investor && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/backoffice && npm install --no-audit --no-fund --include=dev
  ```

## 5) Старт в dev-режиме (pm2)
- [x] Запуск и автосохранение:
  ```bash
  pm2 start npm --name portal-issuer --cwd /opt/ois-cfa/apps/portal-issuer -- run dev
  pm2 start npm --name portal-investor --cwd /opt/ois-cfa/apps/portal-investor -- run dev
  pm2 start npm --name backoffice    --cwd /opt/ois-cfa/apps/backoffice    -- run dev
  pm2 save
  pm2 ls
  ```

## 6) Проверки (обязательные)
- [x] Слушатели:
  ```bash
  ss -ltnp | egrep ":5000|:8080|:3001|:3002|:3003"
  ```
- [x] Коды ответов:
  ```bash
  curl -s -o /dev/null -w "GATEWAY:%{http_code}\n" http://localhost:5000/health
  curl -s -o /dev/null -w "KC:/admin %{http_code}\n" http://localhost:8080/admin
  for p in 3001 3002 3003; do curl -s -o /dev/null -w ":$p => %{http_code}\n" http://localhost:$p/; done
  ```

## 7) SSH‑туннели (Mac)
```bash
ssh -N \
  -L 15500:localhost:5000 \
  -L 15808:localhost:8080 \
  -L 15301:localhost:3001 \
  -L 15302:localhost:3002 \
  -L 15303:localhost:3003 \
  cfa1-mux
```
- Gateway: http://localhost:15500/health
- Keycloak: http://localhost:15808/admin (admin/admin123)
- Issuer: http://localhost:15301
- Investor: http://localhost:15302
- Backoffice: http://localhost:15303

## 8) Примечания
- Для временной разработки модульные зависимости `shared-ui` резолвятся через `next.config.js` (modules: `../shared-ui/node_modules`).
- В перспективе лучше перейти на workspaces (hoist deps на корень).

## CFA1 hotfix (2025-11-21) — missing deps & pm2 restart
- Установить зависимости в Sharedui/порталах (от пользователя `user`):  
  ```
  cd /opt/ois-cfa/apps/shared-ui && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/portal-issuer && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/portal-investor && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/backoffice && npm install --no-audit --no-fund --include=dev
  ```
- Построить, чтобы поймать типовые ошибки: `npm run build` в portal-issuer/portal-investor.
- Перезапустить dev-серверы: `PM2_HOME=/home/user/.pm2 pm2 restart portal-issuer portal-investor backoffice`.

```
---
# docs/deploy/docker-compose-at-vps/07-frontends.md
```md
---
created: 2025-11-11 15:23
updated: 2025-11-11 15:23
type: runbook
sphere: [devops]
topic: [nextjs, web]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [nextjs, docker]
---

# 07 — Веб‑клиенты (Next.js)

Сервисы
- [ ] Portal Issuer (порт по умолчанию 53001)
- [ ] Portal Investor (порт по умолчанию 53002)
- [ ] Backoffice (порт по умолчанию 53003)

Зависимости monorepo
- [ ] Некоторые приложения импортируют `shared-ui` и `@ois/api-client`
- [ ] Для корректной сборки нужен «корневой» install и сборка пакетов (или простая альтернатива ниже)

Альтернатива (минимальный путь на dev)
- [ ] Сборка Portal Issuer/Investor из своих папок (Dockerfiles добавлены)
- [ ] Backoffice можно отложить (ошибки резолва модулей при отсутствии сборки shared‑ui/sdk)

Запуск (issuer + investor)
- [ ] ```bash
  cd /opt/ois-cfa
  C="-f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml -f docker-compose.services.yml -f docker-compose.apps.yml"
  docker compose $C build portal-issuer portal-investor
  docker compose $C up -d portal-issuer portal-investor
  for p in 53001 53002; do curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:${p}/; done
  ```

Переменные окружения для фронтов
- [ ] `API_PUBLIC_URL=http://<host-ip>:55000`
- [ ] `KEYCLOAK_PUBLIC_URL=http://<host-ip>:58080` (или локальный туннель)
- [ ] `KEYCLOAK_REALM=ois`
- [ ] `NEXTAUTH_URL` для каждого фронта на свой URL (см. docker-compose.apps.yml)

Логин через Keycloak
- [ ] Убедиться, что клиенты в Keycloak созданы (см. 06)
- [ ] Проверить redirect URIs и web origins под ваши адреса

- SSH‑туннели (если внешний фаервол закрыт)
- [ ] Порты должны быть ≤ 65535. Пример корректного туннеля:
  ```bash
  ssh -N \
    -L 15500:localhost:55000 \
    -L 15501:localhost:55001 \
    -L 15506:localhost:55006 \
    -L 15808:localhost:58080 \
    -L 15301:localhost:53001 \
    -L 15302:localhost:53002 \
    cfa1-mux
  ```
- [ ] Открыть в браузере: 
  - Gateway: `http://localhost:15500/health`
  - Issuer app: `http://localhost:15301/`
  - Investor app: `http://localhost:15302/`
  - Keycloak: `http://localhost:15808/`

```
---
# docs/deploy/docker-compose-at-vps/08-smoke-tests.md
```md
---
created: 2025-11-11 15:24
updated: 2025-11-11 15:24
type: runbook
sphere: [devops]
topic: [smoke, curl]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [testing]
---

# 08 — Smoke‑тесты (через Gateway)

Health
- [ ] `curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55000/health` → 200
- [ ] `curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55001/health` → 200
- [ ] `curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55006/health` → 200

Прокси маршруты (без данных ожидаемо 404)
- [ ] `curl -i http://localhost:55000/v1/orders/$(uuidgen)` → 404
- [ ] `curl -i http://localhost:55000/v1/wallets/$(uuidgen)` → 404

Создание выпуска (как пример, после сидирования)
- [ ] ```bash
  cat > /tmp/issuance.json <<JSON
  {
    "assetId": "$(uuidgen)",
    "issuerId": "$(uuidgen)",
    "totalAmount": 1000000,
    "nominal": 1000,
    "issueDate": "2025-01-01",
    "maturityDate": "2026-01-01",
    "scheduleJson": {"coupons": []}
  }
  JSON
  curl -sS -H "Content-Type: application/json" -d @/tmp/issuance.json -i http://localhost:55000/v1/issuances
  ```

Примечание
- [ ] Для полного сквозного сценария потребуется сид‑данные и/или dev‑упрощения для compliance/bank‑nominal


```
---
# docs/deploy/docker-compose-at-vps/09-troubleshooting.md
```md
---
created: 2025-11-11 15:24
updated: 2025-11-11 15:24
type: runbook
sphere: [devops]
topic: [troubleshooting]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [troubleshooting, logs]
---

# 09 — Траблшутинг

Типовые проверки
- [ ] `docker compose -f ... ps` — статусы
- [ ] `docker logs -f <name>` — логи
- [ ] `ss -ltnp` — порты слушаются на хосте
- [ ] `curl -i http://localhost:<port>/health` — готовность

Нехватка памяти при сборке
- [ ] Добавить swap (см. 01)
- [ ] Собирайте по одному сервису: `docker compose ... build <service>`

Проблемы миграций БД при старте
- [ ] Запускать без миграций: `MIGRATE_ON_STARTUP=false docker compose ... up -d <service>`
- [ ] Для разового применения — на время старта: `MIGRATE_ON_STARTUP=true ...`

Gateway не стартует, ошибка YARP
- [ ] Проверить `appsettings.json` — маршрут `redeem` должен быть `"/v1/issuances/{id}/redeem"`

Keycloak недоступен снаружи
- [ ] Проверить провайдерский фаервол (58080 TCP). На самом сервере UFW может быть выключен, но у провайдера порт может быть закрыт.
- [ ] Временно использовать SSH‑туннель (см. 07); пример: `ssh -N -L 15808:localhost:58080 cfa1-mux`

Next.js фронты не собираются
- [ ] Требуют сборки `shared-ui` и SDK: сделать корневой install и сборку пакетов (workspaces)
- [ ] Минимальный путь — собирать issuer/investor; backoffice перенести на следующий этап

Очистка образов/кэша
- [ ] `docker system df`, `docker image prune -f`, `docker builder prune -f`

```
---
# docs/deploy/docker-compose-at-vps/10-eywa1-control-plane-runbook.md
```md
---
created: 2025-11-19 18:30
updated: 2025-11-19 21:10
type: runbook
sphere: [devops]
topic: [deploy, control-plane, vps]
author: alex-a
agentID: co-76ca
partAgentID: [co-76ca, co-7b1b]
version: 0.3.0
tags: [eywa1, tmux, ssh, cloudflare, docker-compose]
---

# OIS‑CFA · Eywa1 Control Plane — Multi‑VPS Runbook

Цель: превратить `eywa1` в управляющий узел (Control Plane) для однотипного деплоя OIS‑CFA на VPS (`cfa1`, `fin2`, `germ1`, …), не ломая рабочий UK1.

## Scope
- Workspace: `eywa1`, директория проекта `~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets`.
- Код: рабочий `worktree` `repositories/customer-gitlab/wt__ois-cfa__NX01` (ветка `tasks/NX-01-spec-validate-and-matrix` / `infra.defis.deploy`).
- Целевые узлы: `cfa1`, `fin2`, `germ1`, … (UK1 — только как референс, без изменений).
- DNS: Cloudflare для `*.cfa.llmneighbors.com`, `*.cfa{1,2,3}.llmneighbors.com`.

## TL;DR
- Eywa1 становится единым Control Plane: все операции — через SSH + `tmux` на целевых узлах, логи сохраняются в сессии `p-cfa`.
- На каждом VPS создаётся пользователь `user` с sudo, базовый стек (Docker, Node 20, tmux, nginx, postfix) и директория `/srv/cfa`.
- Новый деплой стандартизирован через два скрипта в `wt__ois-cfa__NX01`: `ops/scripts/deploy/provision-node.sh` (bootstrap) и `ops/scripts/deploy/deploy-node.sh` (деплой стека).
- UK1 остаётся каноническим демо‑стендом (см. `docs/deploy/20251113-cloudflare-ingress.md` и `docker-compose-at-vps/*`); на нём ничего не меняем без отдельного плана.
- Для NX‑05/06 рабочим окружением для кода считаем `wt__ois-cfa__NX01`, а для проверок UI/flows — новые VPS, развернутые по этому runbook’у.

## Architecture (High‑Level)

```mermaid
flowchart LR
  subgraph Eywa1["eywa1 · Control Plane"]
    Agent[CLI agent / user]
    Repo[prj_Cifra-rwa-exachange-assets\nwt__ois-cfa__NX01]
    CF[Cloudflare CLI/API]
    SSHKeys[SSH keys]
  end

  subgraph Nodes["Target VPS nodes"]
    subgraph Node1["cfa1"]
      User1[user sudo]
      Tmux1[tmux session\np-cfa]
      Stack1[OIS-CFA stack\nDocker + PM2]
    end
    subgraph Node2["fin2"]
      User2[user sudo]
      Tmux2[tmux session\np-cfa]
      Stack2[OIS-CFA stack\nDocker + PM2]
    end
  end

  Agent --> Repo
  Agent --> CF
  Agent --> SSHKeys

  SSHKeys --> User1
  SSHKeys --> User2

  Agent -->|provision-node.sh| Node1
  Agent -->|deploy-node.sh| Node1
  Agent -->|provision-node.sh| Node2
  Agent -->|deploy-node.sh| Node2
```

## Phases Overview

1. **Phase 0 — Rules & Safety**: фиксируем запреты и инварианты UK1 не трогаем, только `user`, только `/srv/cfa`).
2. **Phase 1 — Prepare Eywa1**: убеждаемся, что есть SSH‑ключи, Cloudflare CLI, актуальный `wt__ois-cfa__NX01`.
3. **Phase 2 — Provision Node**: подготавливаем VPS (user, SSH, базовые пакеты, tmux, `/srv/cfa`, сессия `p-cfa`).
4. **Phase 3 — Deploy OIS‑CFA Stack**: клонируем `ois-cfa`, включаем docker‑compose, подключаем фронты через PM2 и nginx.
5. **Phase 4 — Verify & Handover**: health‑чеки, smoke‑тесты, фиксация итогового состояния в memory‑bank.

---

## Phase 0 — Rules & Safety

Why  
- Минимизировать риск сломать единственный рабочий стенд и превратить деплой в «необратимый эксперимент».

What  
- Описать инварианты, которые агент/инженер не имеет права нарушать.

How  
- Перед запуском любых скриптов проговорить/прописать ограничения.

Result  
- Любые действия по bootstrap/deploy выполняются только в рамках согласованных узлов и веток.

### Invariants
- **UK1 не трогаем** — используем только как эталон (см. `docs/deploy/20251113-cloudflare-ingress.md` и `docker-compose-at-vps/*`).
- **Только пользователь `user`** для приложений и деплоя (никаких сервисов от `root`).
- **Единый путь проекта**: `/srv/cfa` на всех узлах.
- **Все длительные команды** — только внутри `tmux`‑сессии `p-cfa` на целевом VPS.
- **Только зафиксированные ветки**: для деплоя используем `infra.defis.deploy` (или явно согласованную ветку), код для NX‑05/06 — из `wt__ois-cfa__NX01`.

---

## Phase 1 — Prepare Eywa1 (Control Plane)

Why  
- Без корректного состояния на `eywa1` невозможен безопасный bootstrap узлов.

What  
- Проверяем наличие SSH‑ключей, Cloudflare‑кредов, актуальной копии репо и утилит.

How  
- Ручной чеклист + точечные команды.

Result  
- `eywa1` готов отдавать команды на `cfa1`/`fin2` и управлять DNS.

### Checklist
- [ ] SSH‑ключ `~/.ssh/id_rsa` (или другой) привязан к `root`/`user` на целевых VPS (`ssh cfa1`, `ssh fin2` работает без пароля).
- [ ] В `~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets` актуален `git pull` для монорепо.
- [ ] В `repositories/customer-gitlab/wt__ois-cfa__NX01` подтянуты последние изменения ветки `infra.defis.deploy` / `tasks/NX-01-spec-...`.
- [ ] На `eywa1` установлен Cloudflare CLI или подготовлен `curl` + `.env` с `CLOUDFLARE_API_TOKEN` (см. `docs/deploy/20251113-cloudflare-ingress.md`).
- [ ] Установлены базовые утилиты: `jq`, `tmux`, `git`, `docker` (на `eywa1` только если нужно).

---

## Phase 2 — Provision Node (Bootstrap VPS)

Why  
- Нужно стандартизировать базовый образ сервера, чтобы все последующие шаги не превращались в «каждый VPS по‑своему».

What  
- Скрипт `ops/scripts/deploy/provision-node.sh` выполняет bootstrap: пользователь `user`, пакеты, Docker, Node, tmux, `p-cfa`.

How  
- Запускаем скрипт с `eywa1`, который через SSH конфигурирует целевой VPS.

Result  
- На `cfa1`/`fin2` есть готовый «пустой, но правильный» хост для деплоя OIS‑CFA.

### Minimal usage

```bash
cd ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets/repositories/customer-gitlab/wt__ois-cfa__NX01
ops/scripts/deploy/provision-node.sh cfa1
ops/scripts/deploy/provision-node.sh fin2
```

### What it standardizes
- Создаёт (если нет) пользователя `user` с группой `sudo`.
- Настраивает базовые пакеты: `curl`, `git`, `tmux`, `jq`, `ufw`, `docker`, `docker-compose-plugin`, `nginx`, `postfix`.
- Устанавливает Node.js 20 для `user` (через `nvm` или системный пакет, зависит от окружения).
- Создаёт `/srv/cfa`, назначает владельца `user:user`.
- Добавляет в `~user/.tmux.conf` параметр `set-option -g history-limit 1000000`.
- Создаёт (если нет) `tmux`‑сессию `p-cfa`, рабочий каталог `/srv/cfa`.

---

## Phase 3 — Deploy OIS‑CFA Stack

Why  
- Поддерживать один сценарий деплоя для всех узлов, чтобы не плодить «уникальные» стенды.

What  
- Скрипт `ops/scripts/deploy/deploy-node.sh` клонирует `ois-cfa`, подтягивает ветку и запускает docker‑compose + фронты.

How  
- Из `eywa1` вызываем скрипт для выбранного узла; скрипт отправляет команды в `tmux`‑сессию `p-cfa` на VPS.

Result  
- На целевом VPS развёрнут стек OIS‑CFA, готовый к smoke‑тестам NX‑05/06.

### Minimal usage

```bash
cd ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets/repositories/customer-gitlab/wt__ois-cfa__NX01
OIS_CFA_BRANCH=infra.defis.deploy ops/scripts/deploy/deploy-node.sh cfa1
OIS_CFA_BRANCH=infra.defis.deploy ops/scripts/deploy/deploy-node.sh fin2
```

### Notes
- По умолчанию используется репозиторий `git@git.telex.global:npk/ois-cfa.git` и ветка `infra.defis.deploy` (можно переопределить переменными окружения).
- Скрипт **не заполняет секреты** — `.env`‑файлы должны быть подготовлены отдельно (см. `docs/deploy/docker-compose-at-vps/02-env-and-compose.md`).
- Для фронтендов (Next.js) скрипт создаёт базовый scaffold команд в `tmux`, но конкретные `pm2`‑процессы и `env.local` лучше выровнять по UK1 (см. сессии `co-3dd7` и `20251113-cloudflare-ingress.md`).

---

## Phase 4 — Verify & Handover

Why  
- Без чётких health‑чеков легко получить «оно где‑то крутится, но не факт, что работает».

What  
- Проверяем `/health` и ключевые UI‑флоу, фиксируем результаты и риски.

How  
- Команды curl, базовый UI walkthrough, при возможности — Playwright e2e.

Result  
- Описанный, воспроизводимый стенд с понятным статусом готовности.

### Basic health
- [ ] `curl http://<host>:55000/health` (gateway) → `200 OK`.
- [ ] `curl http://<host>:55005/health` (issuance), `55006` (registry), `55007` (settlement), `55008` (compliance).
- [ ] Keycloak доступен по HTTP (до настройки ingress/TLS).

### Smoke‑flows (минимум)
- [ ] Issuer портал открывается (локальный порт или домен через nginx/Cloudflare).
- [ ] Базовый issuance‑flow (создание простого выпуска без сложного payout schedule).
- [ ] Просмотр отчётности `/reports` (после NX‑05 implementation).

### Memory‑bank / Logging
- [ ] Создан файл в `memory-bank/Scrum/<date>/<timestamp>-<host>-bootstrap.session.md` с кратким логом команд и ссылками на tmux‑сессии.

---

## Troubleshooting / Lessons Learned

- **Права на код (`chown -R user:user`).**  
  При переносе `/opt/ois-cfa` или клонировании репозитория от `root` фронты (Next.js) и `npm install` под `user` ломаются с `EACCES` на `package-lock.json`/`node_modules`.  
  Решение: после bootstrap/деплоя привести права в порядок:
  - Для Control Plane‑пути: `chown -R user:user /srv/cfa/ois-cfa` (если репо там).  
  - Для старых UK1‑образов (как на cfa1): `chown -R user:user /opt/ois-cfa`.

- **NEXTAUTH_URL и Redirect URIs в Keycloak.**  
  Если `NEXTAUTH_URL`/публичные URL фронтов (`issuer|investor|backoffice.cfa{N}.llmneighbors.com`) не совпадают с `redirectUris`/`webOrigins` в Keycloak, логин/регистрация падают (loop, `invalid redirect`, пустой экран).  
  Решение:
  - Для клиентов `portal-issuer`, `portal-investor`, `backoffice` в realm `ois-dev` держать:
    - `rootUrl = https://<app>.cfa{N}.llmneighbors.com`
    - `redirectUris = ["https://<app>.cfa{N}.llmneighbors.com/*"]`
    - `webOrigins = ["https://<app>.cfa{N}.llmneighbors.com"]`
  - В `.env.local` фронтов `NEXTAUTH_URL` должен быть ровно тем же публичным https‑URL.

- **Playwright как канонический smoke для ingress.**  
  E2E‑тесты (`tests/e2e-playwright`) с доменами `issuer|investor|backoffice.cfa1.llmneighbors.com` и логином через Keycloak — лучший индикатор, что весь стек (DNS/TLS/nginx + backend + фронты + почта) работает end‑to‑end. Скриншоты живут под `artifacts/tests/e2e/playwright/*.e2e.png` с timestamp и run id.

---

## Definition of Done (DoD)

### 1. Control Plane & Scripts
- [x] Runbook `10-eywa1-control-plane-runbook.md` и скрипты `ops/scripts/deploy/*` зафиксированы в текущей ветке (`deploy`/`tasks/NX-01-*`) и описаны в `README`/manifests.
- [x] Для узлов `cfa1` и `fin2` успешно выполнены Phases 1–3 (Control Plane baseline):
  - [x] Создан пользователь `user` (sudo + docker), настроен SSH по ключам.
  - [x] Создана директория `/srv/cfa`, настроена `tmux`‑сессия `p-cfa`.
  - [x] Репозиторий `npk/ois-cfa` клонирован в `/srv/cfa/ois-cfa` с нужной веткой (work3) или перенесён из UK1‑образа.
- [ ] Состояние UK1 **не изменено** в процессе работ (используется только как референс).

### 2. Parity с UK1 по docker-compose runbook’ам (00–09)
Для каждого активного окружения (`uk1`, `cfa1`, `cfa2`/`fin2`) должны быть закрыты шаги из `docker-compose-at-vps`:

- [ ] 00–02: `00-overview.md`, `01-prereqs-and-host-prep.md`, `02-env-and-compose.md` — выполнены, `.env` и compose‑файлы задокументированы.
- [ ] 03–04: `03-infra.md`, `04-services.md` — базовая инфраструктура (Postgres, Kafka, Minio) и .NET‑сервисы подняты через `docker compose`.
- [ ] 05–06: `05-gateway.md`, `06-keycloak.md` — API gateway и Keycloak работают, health‑эндпоинты и логин проверены.
- [ ] 07–08: `07-frontends*.md`, `08-smoke-tests.md` — порталы (Issuer/Investor/Backoffice) подняты (PM2 или dev), basic UX‑флоу и e2e smoke‑тесты проходят.

Фактический прогресс по узлам фиксируется в отдельных DoD/отчётах в `memory-bank` (например, `*-cfa1-fin2-deploy-DoD.md`), а не через изменение этого чеклиста.

### 3. DNS, TLS и Ingress (Cloudflare + nginx)
- [ ] Для UK1: актуальны записи `auth|issuer|investor|backoffice|api.cfa.llmneighbors.com` и wildcard‑сертификат `*.cfa.llmneighbors.com` (см. `20251113-cloudflare-ingress.md`).
- [x] Для `cfa1`: созданы A‑записи в Cloudflare `auth|issuer|investor|backoffice|api.cfa1.llmneighbors.com` с IP `cfa1`; выпущен и установлен LE‑сертификат `*.cfa1.llmneighbors.com`, nginx‑конфиг задокументирован.
- [ ] Для `cfa2` (fin2): аналогично `cfa1`, но с доменами `*.cfa2.llmneighbors.com` и IP `fin2`, при этом UK1 не затронут.
- [ ] Для каждого окружения описана таблица `Service → URL → Health endpoint → Notes` (в docs/или memory‑bank).

### 3a. Multi‑account Cloudflare / domains
- [ ] Для разных узлов (например, `cfa1` и `cfa2/fin2`) поддерживается конфигурация **разных** Cloudflare‑аккаунтов и доменов (см. `docs/deploy/MULTI_ACCOUNT_SETUP.md`), без жёсткой привязки ко всем `*.cfa{N}.llmneighbors.com` в одном аккаунте.

### 4. NX‑05 / NX‑06 Readiness
- [x] Зафиксировано, на каких стендах (`uk1`, `cfa1`, `cfa2/fin2`) будет выполняться разработка и проверка NX‑05/NX‑06 (issuer dashboard, reports, payout schedule).
- [x] Минимум один стенд (предпочтительно `cfa1`) имеет:
  - [x] Рабочий issuer‑портал с доступом через домен (`issuer.cfa1.llmneighbors.com`).
  - [x] Базовый issuance‑флоу и отчётность `/reports`, проверенные по runbook’у `08-smoke-tests.md` и e2e‑тестам Playwright.
  - [x] Задокументированное состояние (ссылки на realm/URL‑ы/тест‑учётки) для быстрого включения backend/FE инженеров и агентов (см. e2e `.env` и memory‑bank DoD для cfa1).

### CFA1 — текущий статус (2025‑11‑19)
- [x] Control Plane: `user` + `/srv/cfa` + `tmux p-cfa` + клон `ois-cfa` (work3).
- [x] Backend: Postgres, Kafka/ZK, Minio, Keycloak, все .NET‑сервисы и API Gateway запущены; все `/health` → `200`.
- [x] Ingress: DNS/TLS/nginx настроены для `auth|issuer|investor|backoffice|api.cfa1.llmneighbors.com`; `https://api.cfa1.../health` → `200`.
- [x] Frontends: Issuer/Investor/Backoffice подняты в dev‑режиме PM2; `curl -I https://issuer|investor|backoffice.cfa1...` → 30x → приложения.
- [x] E2E: Playwright‑тесты (`public-auth`, `backoffice-auth`, `self-registration`) проходят против cfa1‑домена; скриншоты флоу лежат в `artifacts/tests/e2e/playwright`.

---

## Agent Kickoff Prompt (Codex/Claude/Gemini)

Ниже — заготовка промпта для CLI‑агента, заточенная под этот runbook и `wt__ois-cfa__NX01`. Её можно адаптировать под конкретную задачу (например, «подними cfa1» или «подготовь fin2 для NX‑05/06»).

```text
You are a DevOps/Backend engineer working on the OIS-CFA project.

Workspace:
- You are running on host "eywa1".
- Local repo: ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets
- Main backend worktree: repositories/customer-gitlab/wt__ois-cfa__NX01 (branch tasks/NX-01-spec-validate-and-matrix / infra.defis.deploy)

Goal:
- Provision and deploy the OIS-CFA stack to a target VPS (e.g. cfa1 or fin2)
  using the "Eywa1 Control Plane" approach described in:
  - docs/deploy/docker-compose-at-vps/00-overview.md
  - docs/deploy/docker-compose-at-vps/10-eywa1-control-plane-runbook.md

Hard rules:
- DO NOT touch or modify the existing UK1 environment (prod demo).
- Use only the "user" account with sudo on target nodes (no root-only services).
- Use /srv/cfa as the project root on all nodes.
- Run all long-running commands inside tmux session "p-cfa" on the target node.
- For code changes and NX-05/06 work, treat wt__ois-cfa__NX01 as the primary tree.

Phases:
1) Phase 1 – validate Eywa1: SSH keys, Cloudflare token, local repo state.
2) Phase 2 – run ops/scripts/deploy/provision-node.sh <host> to bootstrap the node.
3) Phase 3 – run ops/scripts/deploy/deploy-node.sh <host> with the correct branch.
4) Phase 4 – run health checks (/health, Keycloak, portals) and record results in memory-bank.

Output expectations:
- Follow Why → What → How → Result structure.
- Use numbered steps and small tables where helpful.
- Explicitly call out any deviations from the runbook (SPEC DIFF-like).
```

```
---
# docs/deploy/localhost/FRONTEND-STARTUP.md
```md
# Frontend Applications - Startup Guide

## URLs

### Development Servers
- **Portal Issuer**: http://localhost:3001
- **Portal Investor**: http://localhost:3002
- **Backoffice**: http://localhost:3003

### Backend Services
- **API Gateway**: http://localhost:5000
- **Keycloak**: http://localhost:8080

---

## Quick Start

### 1. Install Dependencies

```bash
# Install all frontend dependencies
cd apps/portal-issuer && npm install
cd ../portal-investor && npm install
cd ../backoffice && npm install

# Install E2E test dependencies
cd ../../tests/e2e && npm install

# Generate SDKs (optional, if needed)
cd ../../packages/sdks/ts && npm install && npm run generate
```

### 2. Start Backend Services

```bash
docker-compose up -d
```

### 3. Setup Keycloak

См. `KEYCLOAK-SETUP.md` для настройки realm, clients и users.

**Quick setup:**
1. Go to http://localhost:8080 (admin/admin)
2. Create realm `ois-dev`
3. Create clients: `portal-issuer`, `portal-investor`, `backoffice`
4. Create roles: `issuer`, `investor`, `admin`
5. Create test users с соответствующими ролями

### 4. Start Frontend Apps

**Terminal 1:**
```bash
cd apps/portal-issuer
npm run dev
```

**Terminal 2:**
```bash
cd apps/portal-investor
npm run dev
```

**Terminal 3:**
```bash
cd apps/backoffice
npm run dev
```

---

## Test Credentials (Keycloak)

После создания в Keycloak:

- **Issuer**: `issuer@test.com` / `password123` (role: issuer)
- **Investor**: `investor@test.com` / `password123` (role: investor)
- **Admin**: `admin@test.com` / `password123` (roles: admin, backoffice)

---

## E2E Testing

```bash
# Run tests
make e2e

# Run with UI
make e2e-ui

# View report
cd tests/e2e && npx playwright show-report
```

---

## Troubleshooting

1. **Keycloak connection errors**: Проверьте, что Keycloak запущен и realm настроен
2. **CORS errors**: Убедитесь, что API Gateway запущен и CORS настроен
3. **SDK errors**: Запустите `npm run generate` в `packages/sdks/ts`


```
---
# docs/deploy/localhost/KEYCLOAK-SETUP.md
```md
# Keycloak Setup for Local Development

## ✅ Quick Start

### 1. Создание базы данных (ВАЖНО!)

Keycloak требует отдельную базу данных. Создайте её перед запуском:

```bash
docker exec ois-postgres psql -U ois -d postgres -c "CREATE DATABASE keycloak;"
```

### 2. Запуск Keycloak

```bash
docker-compose up -d keycloak
```

**Важно:** Первый запуск может занять 1-2 минуты для инициализации схемы БД (создание 94+ таблиц).

### 3. Доступ к админке

- **URL:** http://localhost:8080/admin
- **Username:** `admin`
- **Password:** `admin`

Проверка готовности:
```bash
# Health check
curl http://localhost:8080/health/ready

# Или просто откройте в браузере
http://localhost:8080/admin
```

## Create Realm: `ois-dev`

1. После входа в админку, нажмите на выпадающий список вверху слева (показывает "Master")
2. Выберите **"Create Realm"**
3. Name: `ois-dev`
4. **Save**

## Create Clients

### portal-issuer
1. В realm `ois-dev`, перейдите: **Clients** → **Create Client**
2. Client ID: `portal-issuer`
3. Client Protocol: `openid-connect`
4. **Next**
5. Access Type: `public`
6. Valid Redirect URIs: `http://localhost:3001/*`
7. Web Origins: `http://localhost:3001`
8. **Save**

### portal-investor
1. Clients → Create Client
2. Client ID: `portal-investor`
3. Client Protocol: `openid-connect`
4. **Next**
5. Access Type: `public`
6. Valid Redirect URIs: `http://localhost:3002/*`
7. Web Origins: `http://localhost:3002`
8. **Save**

### backoffice
1. Clients → Create Client
2. Client ID: `backoffice`
3. Client Protocol: `openid-connect`
4. **Next**
5. Access Type: `public`
6. Valid Redirect URIs: `http://localhost:3003/*`
7. Web Origins: `http://localhost:3003`
8. **Save**

## Create Roles

1. В realm `ois-dev`, перейдите: **Realm Roles** → **Create Role**
2. Создайте следующие роли (по одной):
   - `issuer`
   - `investor`
   - `admin`
   - `backoffice`

## Create Test Users

### Issuer User
1. **Users** → **Create User**
2. Username: `issuer@test.com`
3. Email: `issuer@test.com`
4. Email Verified: `ON`
5. **Create**
6. Вкладка **Credentials**:
   - Password: `password123`
   - Password Confirmation: `password123`
   - Temporary: `OFF`
   - **Save**
7. Вкладка **Role Mappings**:
   - Assign role: `issuer`
   - **Assign**

### Investor User
1. Users → Create User
2. Username: `investor@test.com`
3. Email: `investor@test.com`
4. Email Verified: `ON`
5. Create
6. Credentials: Password `password123`, Temporary: OFF
7. Role Mappings: Assign role `investor`

### Admin User
1. Users → Create User
2. Username: `admin@test.com`
3. Email: `admin@test.com`
4. Email Verified: `ON`
5. Create
6. Credentials: Password `password123`, Temporary: OFF
7. Role Mappings: Assign roles `admin` и `backoffice`

## Troubleshooting

### База данных не существует
```bash
docker exec ois-postgres psql -U ois -d postgres -c "CREATE DATABASE keycloak;"
docker-compose restart keycloak
```

### Keycloak не запускается
```bash
# Проверьте логи
docker logs ois-keycloak --tail 50

# Проверьте статус
docker ps --filter "name=keycloak"
```

### Не могу зайти в админку
- Убедитесь, что используете правильный URL: http://localhost:8080/admin (не просто /)
- Проверьте, что контейнер запущен: `docker ps`
- Проверьте health: `curl http://localhost:8080/health/ready`

---

**Note:** Для production используйте правильные секреты и HTTPS.

```
---
# ops/scripts/README.md
```md
# Operations Scripts

Скрипты для операций и диагностики Kubernetes кластера.

## k8s-healthcheck.sh

Комплексная проверка здоровья Kubernetes кластера с генерацией HTML-отчёта.

### Использование

```bash
# Локально
./ops/scripts/k8s-healthcheck.sh

# Через Makefile
make k8s-healthcheck

# Из debug toolbox pod
make k8s-healthcheck-debug
```

### Проверки

1. **Nodes** — количество и статус узлов, версии, ресурсы
2. **Ingress Controller** — статус pods и LoadBalancer
3. **Cert-Manager** — статус pods, сертификатов и issuers
4. **DNS** — CoreDNS pods и разрешение DNS
5. **Critical Namespaces** — наличие системных namespace'ов
6. **System Pods** — статус системных pods
7. **API Server** — проверка доступности API сервера

### Отчёты

Скрипт генерирует:
- **HTML-отчёт** (`healthcheck-report-*.html`) — визуальный отчёт с результатами проверок
- **JSON-отчёт** (`healthcheck-*.json`) — структурированные данные для автоматизации

### Action Items

При обнаружении проблем скрипт формирует список действий с командами для исправления.

### GitLab CI

Интегрирован в GitLab CI как manual job `k8s:healthcheck`. Отчёты сохраняются в artifacts и доступны в UI.

## setup-twc-cluster.sh

Автоматическая настройка доступа к Kubernetes кластеру в Timeweb Cloud.

### Использование

```bash
# Настроить доступ к кластеру ois-cfa-k8s
./ops/scripts/setup-twc-cluster.sh

# Или указать имя кластера
./ops/scripts/setup-twc-cluster.sh my-cluster-name
```

### Что делает скрипт

1. Проверяет установку `twc` CLI
2. Находит токен (из переменной окружения или terraform.tfvars)
3. Проверяет аутентификацию с Timeweb Cloud
4. Находит кластер по имени
5. Показывает детали кластера и node groups
6. Экспортирует kubeconfig
7. Проверяет подключение к кластеру

### Требования

- Установленный `twc` CLI (см. `tools/timeweb/install.sh`)
- Токен Timeweb Cloud API (см. `docs/ops/timeweb/twc-setup.md`)
- `kubectl` (опционально, для проверки подключения)
- `jq` (опционально, для парсинга JSON)

### Пример вывода

```
=== Timeweb Cloud Cluster Setup ===
Cluster name: ois-cfa-k8s

=== Verifying twc configuration ===
✓ Authentication successful

=== Available Kubernetes Clusters ===
ID          Name           Status    Version
12345       ois-cfa-k8s   active    1.28

=== Finding cluster: ois-cfa-k8s ===
✓ Found cluster ID: 12345

=== Cluster Details ===
...

=== Exporting Kubeconfig ===
✓ Kubeconfig exported to: ops/infra/timeweb/kubeconfig.yaml

=== Verifying Kubeconfig ===
✓ Successfully connected to cluster
```

### Troubleshooting

**Ошибка: "TWC_TOKEN is not set"**
- Установите токен: `export TWC_TOKEN='your-token'`
- Или создайте `terraform.tfvars` с токеном

**Ошибка: "Cluster not found"**
- Проверьте список кластеров: `twc k8s list`
- Создайте кластер через Terraform: `cd ops/infra/timeweb && terraform apply`

**Ошибка: "Failed to authenticate"**
- Проверьте правильность токена
- Убедитесь, что токен имеет права `k8s:read` и `k8s:write`

## Другие скрипты

- `backup.sh` — резервное копирование
- `create-helm-chart.sh` — создание Helm charts
- `test-restore.sh` — тестирование восстановления

```
---
# ops/scripts/auth/fix-redirects.sh
```sh
#!/bin/bash
set -euo pipefail

# OIS-CFA · Keycloak redirects/webOrigins fixer for cfa1
# Runs inside the ois-keycloak container via kcadm.sh
#
# Usage:
#   BASE_DOMAIN=cfa1.llmneighbors.com ./ops/scripts/auth/fix-redirects.sh
#
# Env (optional):
#   KC_CONTAINER   - keycloak container name (default: ois-keycloak)
#   KC_URL         - Keycloak admin URL (default: http://localhost:8080)
#   KC_USER        - admin user (default: admin)
#   KC_PASS        - admin password (default: admin123)
#   REALM          - target realm (default: ois-dev)
#   BASE_DOMAIN    - base domain (default: cfa1.llmneighbors.com)

KC_CONTAINER="${KC_CONTAINER:-ois-keycloak}"
KC_URL="${KC_URL:-http://localhost:8080}"
KC_USER="${KC_USER:-admin}"
KC_PASS="${KC_PASS:-admin123}"
REALM="${REALM:-ois-dev}"
BASE_DOMAIN="${BASE_DOMAIN:-cfa1.llmneighbors.com}"

echo ">>> Fix Keycloak redirects for realm='${REALM}' domain='${BASE_DOMAIN}' in container='${KC_CONTAINER}'"

docker exec \
  -e KC_URL="$KC_URL" \
  -e KC_USER="$KC_USER" \
  -e KC_PASS="$KC_PASS" \
  -e REALM="$REALM" \
  -e BASE_DOMAIN="$BASE_DOMAIN" \
  "${KC_CONTAINER}" bash -lc '
set -euo pipefail

KC_URL="${KC_URL:-http://localhost:8080}"
KC_USER="${KC_USER:-admin}"
KC_PASS="${KC_PASS:-admin123}"
REALM="${REALM:-ois-dev}"
BASE_DOMAIN="${BASE_DOMAIN:-cfa1.llmneighbors.com}"
KCADM=/opt/keycloak/bin/kcadm.sh

clients=(
  "portal-issuer:issuer"
  "portal-investor:investor"
  "backoffice:backoffice"
)

echo ">> Authenticating to ${KC_URL} (realm master) ..."
"${KCADM}" config credentials --server "${KC_URL}" --realm master --user "${KC_USER}" --password "${KC_PASS}"

update_client() {
  local client_id="$1"
  local host_prefix="$2"
  local host="${host_prefix}.${BASE_DOMAIN}"
  local root_url="https://${host}"
  local redirects="[\"${root_url}/*\"]"
  local origins="[\"${root_url}\"]"

  local rid
  rid=$("${KCADM}" get clients -r "${REALM}" -q clientId="${client_id}" | sed -n '\''s/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p'\'' | head -1 || true)
  if [ -z "${rid:-}" ]; then
    echo "WARN: client_id=${client_id} not found in realm ${REALM}, skipping"
    return
  fi

  echo ">> Updating ${client_id} for host ${host}"
  "${KCADM}" update "clients/${rid}" -r "${REALM}" \
    -s "rootUrl=${root_url}" \
    -s "redirectUris=${redirects}" \
    -s "webOrigins=${origins}"
}

for entry in "${clients[@]}"; do
  IFS=":" read -r cid prefix <<< "${entry}"
  update_client "${cid}" "${prefix}"
done

echo ">> Done."
'

echo ">>> Keycloak client redirect/webOrigins update completed."

```
---
# ops/scripts/backup.sh
```sh
#!/bin/bash
set -euo pipefail

# PostgreSQL Backup Script for OIS
# Usage: ./backup.sh [output_dir]

BACKUP_DIR="${1:-./backups}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/ois_backup_${TIMESTAMP}.sql.gz"
RETENTION_DAYS=7

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Database connection
DB_HOST="${POSTGRES_HOST:-postgres}"
DB_PORT="${POSTGRES_PORT:-5432}"
DB_NAME="${POSTGRES_DB:-ois}"
DB_USER="${POSTGRES_USER:-ois}"
DB_PASSWORD="${POSTGRES_PASSWORD:-ois_dev_password}"

export PGPASSWORD="$DB_PASSWORD"

echo "Starting backup at $(date)"
echo "Database: $DB_NAME@$DB_HOST:$DB_PORT"

# Perform backup
pg_dump -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" \
    --no-owner --no-acl \
    | gzip > "$BACKUP_FILE"

if [ $? -eq 0 ]; then
    BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
    echo "✅ Backup completed: $BACKUP_FILE ($BACKUP_SIZE)"
    echo "$BACKUP_FILE" > "${BACKUP_DIR}/latest.txt"
else
    echo "❌ Backup failed!"
    exit 1
fi

# Cleanup old backups
find "$BACKUP_DIR" -name "ois_backup_*.sql.gz" -type f -mtime +$RETENTION_DAYS -delete
echo "Cleaned up backups older than $RETENTION_DAYS days"

unset PGPASSWORD
echo "Backup finished at $(date)"


```
---
# ops/scripts/check-gitlab-jobs-status.sh
```sh
#!/usr/bin/env bash
# Check GitLab CI jobs status via API and Kubernetes
# Usage: ./ops/scripts/check-gitlab-jobs-status.sh

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

GITLAB_URL="${GITLAB_URL:-https://git.telex.global}"
PROJECT_ID="${PROJECT_ID:-npk/ois-cfa}"
KUBECONFIG_FILE="${KUBECONFIG:-}"

if [ -z "${KUBECONFIG_FILE}" ] && [ -f "ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="$(pwd)/ops/infra/timeweb/kubeconfig.yaml"
fi

echo -e "${BLUE}=== GitLab CI Jobs Status Check ===${NC}"
echo ""

# Check Kubernetes pods
if [ -n "${KUBECONFIG_FILE}" ] && [ -f "${KUBECONFIG_FILE}" ]; then
    export KUBECONFIG="${KUBECONFIG_FILE}"
    
    echo -e "${BLUE}=== Kubernetes Job Pods ===${NC}"
    kubectl get pods -n gitlab-runner --no-headers 2>/dev/null | grep "runner-" | while read -r line; do
        NAME=$(echo "$line" | awk '{print $1}')
        STATUS=$(echo "$line" | awk '{print $3}')
        RESTARTS=$(echo "$line" | awk '{print $4}')
        AGE=$(echo "$line" | awk '{print $5}')
        
        if [ "$STATUS" = "Running" ]; then
            echo -e "${GREEN}✓${NC} $NAME: $STATUS (restarts: $RESTARTS, age: $AGE)"
        elif [ "$STATUS" = "Pending" ]; then
            echo -e "${YELLOW}⚠${NC} $NAME: $STATUS (restarts: $RESTARTS, age: $AGE)"
            # Get reason
            REASON=$(kubectl get pod -n gitlab-runner "$NAME" -o jsonpath='{.status.conditions[?(@.type=="PodScheduled")].message}' 2>/dev/null || echo "")
            if [ -n "$REASON" ]; then
                echo "    Reason: $REASON"
            fi
        elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Error" ]; then
            echo -e "${RED}✗${NC} $NAME: $STATUS (restarts: $RESTARTS, age: $AGE)"
        else
            echo "  $NAME: $STATUS (restarts: $RESTARTS, age: $AGE)"
        fi
    done
    
    echo ""
    echo -e "${BLUE}=== Runner Pods ===${NC}"
    kubectl get pods -n gitlab-runner -l app=gitlab-runner --no-headers 2>/dev/null | while read -r line; do
        NAME=$(echo "$line" | awk '{print $1}')
        STATUS=$(echo "$line" | awk '{print $3}')
        READY=$(echo "$line" | awk '{print $2}')
        
        if [ "$STATUS" = "Running" ] && [[ "$READY" == "1/1" ]]; then
            echo -e "${GREEN}✓${NC} $NAME: $STATUS ($READY)"
        else
            echo -e "${YELLOW}⚠${NC} $NAME: $STATUS ($READY)"
        fi
    done
    
    echo ""
fi

# Check GitLab API if token available
if [ -n "${GITLAB_TOKEN:-}" ]; then
    echo -e "${BLUE}=== GitLab API: Running Jobs ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/jobs?scope=running" 2>/dev/null | \
        jq -r '.[] | "\(.id) | \(.name) | \(.status) | \(.stage) | Runner: \(.runner.description // "none")"' 2>/dev/null || \
        echo "Нет запущенных jobs или ошибка API"
    
    echo ""
    echo -e "${BLUE}=== GitLab API: Pending Jobs ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/jobs?scope=pending" 2>/dev/null | \
        jq -r '.[] | "\(.id) | \(.name) | \(.status) | \(.stage)"' 2>/dev/null || \
        echo "Нет ожидающих jobs или ошибка API"
    
    echo ""
    echo -e "${BLUE}=== GitLab API: Latest Pipelines ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/pipelines?per_page=3" 2>/dev/null | \
        jq -r '.[] | "\(.id) | \(.status) | \(.ref) | \(.created_at)"' 2>/dev/null || \
        echo "Ошибка получения pipelines"
else
    echo -e "${YELLOW}⚠ GITLAB_TOKEN не установлен, пропуск API проверки${NC}"
    echo "Для проверки через API установите:"
    echo "  export GITLAB_TOKEN='ваш-токен'"
fi

echo ""
echo -e "${BLUE}=== Check Complete ===${NC}"


```
---
# ops/scripts/check-gitlab-jobs.sh
```sh
#!/usr/bin/env bash
# Check GitLab CI jobs status
# Usage: ./ops/scripts/check-gitlab-jobs.sh

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}=== GitLab CI Jobs Status Check ===${NC}"
echo ""

# Check if we have GitLab token
GITLAB_TOKEN="${GITLAB_TOKEN:-}"
GITLAB_URL="${GITLAB_URL:-https://git.telex.global}"
PROJECT_ID="${PROJECT_ID:-npk/ois-cfa}"

if [ -z "${GITLAB_TOKEN}" ]; then
    echo -e "${YELLOW}⚠ GITLAB_TOKEN not set${NC}"
    echo "Set it with: export GITLAB_TOKEN='your-token'"
    echo ""
    echo "Checking runner status instead..."
    echo ""
else
    echo -e "${GREEN}✓ GITLAB_TOKEN set${NC}"
    echo "GitLab URL: ${GITLAB_URL}"
    echo "Project: ${PROJECT_ID}"
    echo ""
    
    # Get latest pipelines
    echo -e "${BLUE}=== Latest Pipelines ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/pipelines?per_page=5" | \
        jq -r '.[] | "\(.id) | \(.status) | \(.ref) | \(.created_at)"' || echo "Failed to get pipelines"
    echo ""
    
    # Get running jobs
    echo -e "${BLUE}=== Running Jobs ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/jobs?scope=running" | \
        jq -r '.[] | "\(.id) | \(.name) | \(.status) | \(.stage) | Runner: \(.runner.description // "none")"' || echo "No running jobs or failed to get jobs"
    echo ""
    
    # Get pending jobs
    echo -e "${BLUE}=== Pending Jobs ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/jobs?scope=pending" | \
        jq -r '.[] | "\(.id) | \(.name) | \(.status) | \(.stage) | Runner: \(.runner.description // "none")"' || echo "No pending jobs or failed to get jobs"
    echo ""
fi

# Check runner status
echo -e "${BLUE}=== Runner Status (Kubernetes) ===${NC}"
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="$(pwd)/ops/infra/timeweb/kubeconfig.yaml"
fi

if [ -n "${KUBECONFIG_FILE}" ] && [ -f "${KUBECONFIG_FILE}" ]; then
    export KUBECONFIG="${KUBECONFIG_FILE}"
    kubectl get pods -n gitlab-runner -l app=gitlab-runner 2>/dev/null || echo "Cannot connect to cluster"
    echo ""
    echo "Runner logs (last 20 lines):"
    kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=20 2>/dev/null | tail -20 || echo "Cannot get logs"
else
    echo "KUBECONFIG not configured"
fi

echo ""
echo -e "${BLUE}=== Check Complete ===${NC}"


```
---
# ops/scripts/check-gitlab-runners.sh
```sh
#!/bin/bash
# Check GitLab runners via API
# Usage: ./ops/scripts/check-gitlab-runners.sh [GITLAB_TOKEN] [PROJECT_ID]

set -euo pipefail

GITLAB_URL="${GITLAB_URL:-https://git.telex.global}"
GITLAB_TOKEN="${1:-${GITLAB_TOKEN:-}}"
PROJECT_ID="${2:-${CI_PROJECT_ID:-npk/ois-cfa}}"

if [ -z "${GITLAB_TOKEN}" ]; then
    echo "Error: GITLAB_TOKEN not set"
    echo "Usage: $0 <gitlab-token> [project-id]"
    echo "Or set: export GITLAB_TOKEN='your-token'"
    exit 1
fi

echo "=== GitLab Runners Status ==="
echo "GitLab URL: ${GITLAB_URL}"
echo "Project: ${PROJECT_ID}"
echo ""

# Try to get project ID if path provided
if [[ "${PROJECT_ID}" == *"/"* ]]; then
    echo "Resolving project ID from path: ${PROJECT_ID}"
    PROJECT_ID=$(curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}" | \
        jq -r '.id // empty' 2>/dev/null || echo "")
    
    if [ -z "${PROJECT_ID}" ] || [ "${PROJECT_ID}" == "null" ]; then
        echo "Error: Cannot resolve project ID. Using path directly."
        PROJECT_PATH="${PROJECT_ID}"
    else
        echo "Project ID: ${PROJECT_ID}"
        PROJECT_PATH="${PROJECT_ID}"
    fi
else
    PROJECT_PATH="${PROJECT_ID}"
fi

echo ""
echo "=== Project Runners ==="
curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
    "${GITLAB_URL}/api/v4/projects/${PROJECT_PATH}/runners" | \
    jq -r '.[] | "\(.id) | \(.name) | \(.description // "N/A") | \(.online) | \(.active) | \(.tag_list | join(",") // "none")"' 2>/dev/null || \
    echo "Error: Cannot fetch runners. Check token permissions."

echo ""
echo "=== Instance/Group Runners ==="
curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
    "${GITLAB_URL}/api/v4/runners/all" | \
    jq -r '.[] | select(.project_ids == [] or (.project_ids | length > 0)) | "\(.id) | \(.name) | \(.description // "N/A") | \(.online) | \(.active) | \(.tag_list | join(",") // "none")"' 2>/dev/null || \
    echo "Error: Cannot fetch instance runners. Check token permissions."

echo ""
echo "=== Runner Registration Token ==="
echo "To get registration token:"
echo "1. Open: ${GITLAB_URL}/${PROJECT_PATH}/-/settings/ci_cd"
echo "2. Expand 'Runners' section"
echo "3. Copy 'Registration token'"
echo ""
echo "Or via API (if token has admin rights):"
echo "curl --header \"PRIVATE-TOKEN: \${GITLAB_TOKEN}\" \\"
echo "  \"${GITLAB_URL}/api/v4/projects/${PROJECT_PATH}/runners_token\""


```
---
# ops/scripts/check-kubeconfig.sh
```sh
#!/bin/bash
# Check if kubeconfig is configured and accessible
# Usage: ./ops/scripts/check-kubeconfig.sh

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "=== Checking kubeconfig ==="

# Check kubectl
if ! command -v kubectl &> /dev/null; then
    echo -e "${RED}✗ kubectl is not installed${NC}"
    echo "Install kubectl: https://kubernetes.io/docs/tasks/tools/"
    exit 1
fi

echo -e "${GREEN}✓ kubectl is installed${NC}"

# Check kubeconfig
if ! kubectl cluster-info &>/dev/null; then
    echo -e "${RED}✗ kubectl cannot connect to cluster${NC}"
    echo ""
    echo "Kubeconfig is not configured or cluster is not accessible."
    echo ""
    echo "To configure kubeconfig:"
    echo ""
    echo "1. If using Timeweb Cloud:"
    echo "   export TWC_TOKEN='your-token'"
    echo "   ./tools/timeweb/kubeconfig-export.sh ois-cfa-k8s"
    echo "   export KUBECONFIG=\"\$(pwd)/ops/infra/timeweb/kubeconfig.yaml\""
    echo ""
    echo "2. If you have existing kubeconfig:"
    echo "   export KUBECONFIG=\"/path/to/kubeconfig.yaml\""
    echo ""
    echo "3. Or copy to default location:"
    echo "   mkdir -p ~/.kube"
    echo "   cp kubeconfig.yaml ~/.kube/config"
    echo ""
    echo "See: docs/ops/timeweb/kubeconfig.md"
    exit 1
fi

echo -e "${GREEN}✓ kubectl can connect to cluster${NC}"

# Show cluster info
echo ""
echo "=== Cluster Information ==="
kubectl cluster-info | head -3
echo ""
kubectl get nodes 2>/dev/null | head -5 || echo "Cannot get nodes (may need permissions)"

echo ""
echo -e "${GREEN}✓ Kubeconfig is properly configured${NC}"


```
---
# ops/scripts/check-runner-status.sh
```sh
#!/bin/bash
# Check GitLab Runner status and configuration
# Usage: ./ops/scripts/check-runner-status.sh

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

echo "=== GitLab Runner Status Check ==="
echo ""

# Check kubeconfig
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
elif [ -n "${KUBECONFIG_FILE}" ] && [ ! -f "${KUBECONFIG_FILE}" ]; then
    # If relative path, try to resolve it
    if [ ! "${KUBECONFIG_FILE}" = /* ]; then
        ABS_PATH="${PROJECT_ROOT}/${KUBECONFIG_FILE}"
        if [ -f "${ABS_PATH}" ]; then
            KUBECONFIG_FILE="${ABS_PATH}"
        fi
    fi
fi

if [ -z "${KUBECONFIG_FILE}" ] || [ ! -f "${KUBECONFIG_FILE}" ]; then
    echo "⚠ Warning: KUBECONFIG not set or file not found"
    echo "Set it with: export KUBECONFIG=\$(pwd)/ops/infra/timeweb/kubeconfig.yaml"
    echo "Or run: make setup-kubeconfig"
    echo ""
    if [ -z "${KUBECONFIG_FILE}" ]; then
        exit 1
    fi
else
    export KUBECONFIG="${KUBECONFIG_FILE}"
    echo "✓ Using KUBECONFIG: ${KUBECONFIG_FILE}"
fi

# Check kubectl
if ! command -v kubectl &> /dev/null; then
    echo "Error: kubectl not found"
    exit 1
fi

# Check cluster connection
if ! kubectl cluster-info &>/dev/null; then
    echo "⚠ Warning: Cannot connect to cluster"
    echo "Check kubeconfig: kubectl cluster-info"
    exit 1
fi

echo "✓ Cluster connection OK"
echo ""

# Check namespace
if ! kubectl get namespace gitlab-runner &>/dev/null; then
    echo "⚠ Warning: gitlab-runner namespace not found"
    echo "Install runner: make gitlab-runner-install"
    exit 1
fi

echo "=== Runner Pods ==="
kubectl get pods -n gitlab-runner
echo ""

# Check pod status
RUNNING_PODS=$(kubectl get pods -n gitlab-runner -l app=gitlab-runner --no-headers 2>/dev/null | grep -c " Running " || echo "0")
TOTAL_PODS=$(kubectl get pods -n gitlab-runner -l app=gitlab-runner --no-headers 2>/dev/null | wc -l || echo "0")

if [ "${RUNNING_PODS}" -eq 0 ]; then
    echo "❌ Error: No running runner pods"
    echo "Check logs: make gitlab-runner-logs"
    exit 1
elif [ "${RUNNING_PODS}" -lt "${TOTAL_PODS}" ]; then
    echo "⚠ Warning: Not all pods are running (${RUNNING_PODS}/${TOTAL_PODS})"
else
    echo "✓ All runner pods running (${RUNNING_PODS}/${TOTAL_PODS})"
fi

echo ""
echo "=== Runner Configuration ==="
kubectl get configmap gitlab-runner-config -n gitlab-runner -o yaml | grep -A 5 "name = " || echo "ConfigMap not found"

echo ""
echo "=== Runner Logs (last 10 lines) ==="
kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=10 || echo "Cannot get logs"

echo ""
echo "=== Next Steps ==="
echo "1. Check runner in GitLab UI: Settings → CI/CD → Runners"
echo "2. Verify runner is 'Online' (green indicator)"
echo "3. Check runner tags (should be empty or match job tags)"
echo "4. Try running debug:deploy job manually"
echo ""
echo "To view full logs: make gitlab-runner-logs"
echo "To restart runner: make gitlab-runner-restart"


```
---
# ops/scripts/cloudflare-dns-upsert.sh
```sh
#!/bin/bash
set -euo pipefail

# OIS-CFA · Cloudflare DNS Upsert Helper
#
# Purpose:
#   Upsert A-records for a given host label set in a Cloudflare zone.
#   Used from eywa1 to configure DNS for cfa1/cfa2/etc with different accounts/domains.
#
# Usage:
#   ./ops/scripts/cloudflare-dns-upsert.sh <config-env-file> <ip-address>
#
# Where <config-env-file> exports:
#   CF_ZONE_NAME     - Cloudflare zone name (e.g. llmneighbors.com)
#   CF_ZONE_ID       - Cloudflare zone id
#   CF_API_TOKEN     - API token with DNS edit permission for this zone
#   CF_HOST_PREFIXES - Comma-separated host prefixes (e.g. "auth,issuer,investor,backoffice,api")
#   CF_BASE_LABEL    - Base label for this environment (e.g. "cfa1" => auth.cfa1.<zone>)
#
# Example:
#   ./ops/scripts/cloudflare-dns-upsert.sh \
#     /home/user/__Repositories/cloudflare__developerisnow/.env.cfa1 \
#     87.249.49.56

usage() {
  echo "Usage: $0 <config-env-file> <ip-address>" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

CONFIG_FILE="${1:-}"
TARGET_IP="${2:-}"

if [ -z "$CONFIG_FILE" ] || [ -z "$TARGET_IP" ]; then
  usage
fi

if [ ! -f "$CONFIG_FILE" ]; then
  echo "ERROR: config-env-file '$CONFIG_FILE' not found" >&2
  exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
  echo "ERROR: jq is required for parsing Cloudflare responses (apt-get install jq)" >&2
  exit 1
fi

# shellcheck disable=SC1090
set -a && source "$CONFIG_FILE" && set +a

: "${CF_ZONE_NAME:?CF_ZONE_NAME is required in config-env-file}"
: "${CF_ZONE_ID:?CF_ZONE_ID is required in config-env-file}"
: "${CF_API_TOKEN:?CF_API_TOKEN is required in config-env-file}"
: "${CF_HOST_PREFIXES:?CF_HOST_PREFIXES is required in config-env-file}"
: "${CF_BASE_LABEL:?CF_BASE_LABEL is required in config-env-file}"

echo ">>> Cloudflare DNS upsert"
echo "    Zone:   ${CF_ZONE_NAME} (${CF_ZONE_ID})"
echo "    IP:     ${TARGET_IP}"
echo "    Prefix: ${CF_HOST_PREFIXES}"
echo "    Label:  ${CF_BASE_LABEL}"

CF_API_BASE="https://api.cloudflare.com/client/v4"

create_or_update() {
  local HOST_PREFIX="$1"
  local NAME="${HOST_PREFIX}.${CF_BASE_LABEL}"
  local FQDN="${NAME}.${CF_ZONE_NAME}"

  echo "-- upsert ${FQDN} -> ${TARGET_IP}"

  local EXIST_ID
  EXIST_ID=$(
    curl -s -X GET "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records?type=A&name=${FQDN}" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" |
      jq -r '.result[0].id // empty'
  )

  local PAYLOAD
  PAYLOAD=$(jq -n \
    --arg type "A" \
    --arg name "${FQDN}" \
    --arg content "${TARGET_IP}" \
    --argjson ttl 1 \
    --argjson proxied false \
    '{type: $type, name: $name, content: $content, ttl: $ttl, proxied: $proxied}')

  if [ -n "$EXIST_ID" ] && [ "$EXIST_ID" != "null" ]; then
    curl -s -X PATCH "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records/${EXIST_ID}" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" \
      --data "$PAYLOAD" >/dev/null
  else
    curl -s -X POST "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" \
      --data "$PAYLOAD" >/dev/null
  fi
}

IFS=',' read -r -a PREFIXES <<<"$CF_HOST_PREFIXES"
for prefix in "${PREFIXES[@]}"; do
  prefix_trimmed="${prefix//[[:space:]]/}"
  [ -z "$prefix_trimmed" ] && continue
  create_or_update "$prefix_trimmed"
done

echo ">>> DNS upsert completed."


```
---
# ops/scripts/create-helm-chart.sh
```sh
#!/bin/bash
# Script to create Helm chart from api-gateway template
# Usage: ./ops/scripts/create-helm-chart.sh <chart-name>

set -euo pipefail

CHART_NAME="${1:-}"
if [ -z "$CHART_NAME" ]; then
  echo "Usage: $0 <chart-name>"
  echo "Example: $0 identity"
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
TEMPLATE_CHART="api-gateway"
CHART_DIR="${PROJECT_ROOT}/ops/infra/helm/${CHART_NAME}"

if [ -d "$CHART_DIR" ]; then
  echo "Error: Chart $CHART_NAME already exists at $CHART_DIR"
  exit 1
fi

echo "Creating Helm chart: $CHART_NAME"
echo "Template: $TEMPLATE_CHART"
echo "Target: $CHART_DIR"

# Create directory structure
mkdir -p "${CHART_DIR}/templates"

# Copy files from template
cp "${PROJECT_ROOT}/ops/infra/helm/${TEMPLATE_CHART}/Chart.yaml" "${CHART_DIR}/"
cp "${PROJECT_ROOT}/ops/infra/helm/${TEMPLATE_CHART}/values.yaml" "${CHART_DIR}/"
cp "${PROJECT_ROOT}/ops/infra/helm/${TEMPLATE_CHART}/values-"*.yaml "${CHART_DIR}/" 2>/dev/null || true
cp "${PROJECT_ROOT}/ops/infra/helm/${TEMPLATE_CHART}/templates/"* "${CHART_DIR}/templates/"

# Replace chart name in all files
find "${CHART_DIR}" -type f \( -name "*.yaml" -o -name "*.tpl" \) -exec sed -i "s/${TEMPLATE_CHART}/${CHART_NAME}/g" {} \;

# Update Chart.yaml name
sed -i "s/name: ${TEMPLATE_CHART}/name: ${CHART_NAME}/" "${CHART_DIR}/Chart.yaml"

echo "✓ Created Helm chart: $CHART_DIR"
echo ""
echo "Next steps:"
echo "1. Review and update values.yaml with service-specific settings"
echo "2. Update values-*.yaml for environment-specific configurations"
echo "3. Test with: helm template $CHART_NAME $CHART_DIR"


```
---
# ops/scripts/deploy/deploy-node.sh
```sh
#!/bin/bash
set -euo pipefail

# OIS-CFA · Deploy Node Script
# Usage:
#   ./ops/scripts/deploy/deploy-node.sh <host>
#
# Responsibilities:
#   - Ensure tmux session "p-cfa" exists on target host
#   - Clone or update ois-cfa repo under /srv/cfa (or REMOTE_PROJECT_ROOT)
#   - Checkout desired branch (infra.defis.deploy by default)
#   - Run docker compose to start backend stack
#   - Prepare basic commands for frontends (Next.js + PM2) inside tmux
#   - Hint: after clone, ensure the project tree is writable by SSH_USER (e.g. chown -R user:user /srv/cfa/ois-cfa)
#   - Optional: set DEPLOY_FIX_PERMS=1 to force chown even if already cloned (avoids npm/pm2 EACCES)

usage() {
  echo "Usage: $0 <host>" >&2
  echo "Environment (optional):" >&2
  echo "  SSH_USER             - SSH user for connection (default: user)" >&2
  echo "  REMOTE_PROJECT_ROOT  - Project root on target (default: /srv/cfa)" >&2
  echo "  OIS_CFA_GIT_URL      - Git URL for ois-cfa (default: git@git.telex.global:npk/ois-cfa.git)" >&2
  echo "  OIS_CFA_BRANCH       - Branch to checkout (default: infra.defis.deploy)" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

TARGET_HOST="${1:-}"
if [ -z "$TARGET_HOST" ]; then
  usage
fi

SSH_USER="${SSH_USER:-user}"
REMOTE_PROJECT_ROOT="${REMOTE_PROJECT_ROOT:-/srv/cfa}"
OIS_CFA_GIT_URL="${OIS_CFA_GIT_URL:-git@git.telex.global:npk/ois-cfa.git}"
OIS_CFA_BRANCH="${OIS_CFA_BRANCH:-infra.defis.deploy}"
SSH_OPTS="-o StrictHostKeyChecking=accept-new"
FIX_PERMS="${DEPLOY_FIX_PERMS:-0}"

echo ">>> Deploying OIS-CFA to host '${TARGET_HOST}' as ${SSH_USER}"
echo "    REMOTE_PROJECT_ROOT=${REMOTE_PROJECT_ROOT}"
echo "    OIS_CFA_GIT_URL=${OIS_CFA_GIT_URL}"
echo "    OIS_CFA_BRANCH=${OIS_CFA_BRANCH}"

SSH_CMD="ssh -A ${SSH_OPTS} ${SSH_USER}@${TARGET_HOST}"

$SSH_CMD bash -s << EOF
set -euo pipefail

echo ">>> [\$(hostname)] Phase 3 · Deploy OIS-CFA Stack"

if ! command -v tmux >/dev/null 2>&1; then
  echo "ERROR: tmux is not installed. Run provision-node.sh first." >&2
  exit 1
fi

mkdir -p "${REMOTE_PROJECT_ROOT}"
cd "${REMOTE_PROJECT_ROOT}"

if ! tmux has-session -t p-cfa 2>/dev/null; then
  echo ">>> Creating tmux session 'p-cfa'"
  tmux new-session -d -s p-cfa -c "${REMOTE_PROJECT_ROOT}"
else
  echo ">>> Reusing existing tmux session 'p-cfa'"
fi

tmux send-keys -t p-cfa "set -euo pipefail" C-m
tmux send-keys -t p-cfa "cd '${REMOTE_PROJECT_ROOT}'" C-m

if [ ! -d "${REMOTE_PROJECT_ROOT}/ois-cfa/.git" ]; then
  echo ">>> Cloning ois-cfa repo"
  tmux send-keys -t p-cfa "git clone '${OIS_CFA_GIT_URL}' ois-cfa" C-m
  tmux send-keys -t p-cfa "cd ois-cfa" C-m
else
  echo ">>> Updating existing ois-cfa repo"
  tmux send-keys -t p-cfa "cd ois-cfa" C-m
fi

tmux send-keys -t p-cfa "git fetch origin" C-m
tmux send-keys -t p-cfa "git checkout '${OIS_CFA_BRANCH}'" C-m
tmux send-keys -t p-cfa "git pull --ff-only origin '${OIS_CFA_BRANCH}'" C-m

if [ "$FIX_PERMS" = "1" ]; then
  tmux send-keys -t p-cfa "echo '>>> Fixing permissions for ${SSH_USER} on ${REMOTE_PROJECT_ROOT}/ois-cfa (DEPLOY_FIX_PERMS=1)'" C-m
  tmux send-keys -t p-cfa "sudo chown -R ${SSH_USER}:${SSH_USER} '${REMOTE_PROJECT_ROOT}/ois-cfa' || echo 'WARNING: chown failed, check permissions or sudo rights'" C-m
else
  tmux send-keys -t p-cfa "echo '>>> NOTE: permissions not changed (set DEPLOY_FIX_PERMS=1 to force chown if npm/pm2 EACCES)'" C-m
fi

tmux send-keys -t p-cfa "echo '>>> NOTE: ensure .env files are prepared as per docs/deploy/docker-compose-at-vps/02-env-and-compose.md'" C-m

tmux send-keys -t p-cfa "docker compose -f docker-compose.yml -f docker-compose.override.yml up -d" C-m

tmux send-keys -t p-cfa "echo '>>> Backend stack started. Next steps: configure Keycloak, nginx, and PM2 frontends as per docs/deploy/docker-compose-at-vps/* and 20251113-cloudflare-ingress.md'" C-m

echo ">>> Commands sent to tmux session 'p-cfa'. Attach with: tmux attach -t p-cfa"
EOF

echo ">>> Deploy commands dispatched to host '${TARGET_HOST}'"

```
---
# ops/scripts/deploy/provision-node.sh
```sh
#!/bin/bash
set -euo pipefail

# OIS-CFA · Provision Node Script
# Usage:
#   ./ops/scripts/deploy/provision-node.sh <host>
#
# Responsibilities (idempotent as much as possible):
#   - Ensure sudo user "user" exists on target host
#   - Install base packages (curl, git, tmux, jq, docker, docker-compose plugin, nginx, postfix)
#   - Install Node.js 20 for "user" (via nvm or system package)
#   - Create /srv/cfa and set ownership to user:user
#   - Configure tmux history-limit (1_000_000) for user
#   - Create tmux session "p-cfa" with working dir /srv/cfa

usage() {
  echo "Usage: $0 <host>" >&2
  echo "Environment (optional):" >&2
  echo "  SSH_USER         - SSH user for initial connection (default: root)" >&2
  echo "  REMOTE_USER      - App user to create/use (default: user)" >&2
  echo "  REMOTE_PROJECT_ROOT - Project root on target (default: /srv/cfa)" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

TARGET_HOST="${1:-}"
if [ -z "$TARGET_HOST" ]; then
  usage
fi

SSH_USER="${SSH_USER:-root}"
REMOTE_USER="${REMOTE_USER:-user}"
REMOTE_PROJECT_ROOT="${REMOTE_PROJECT_ROOT:-/srv/cfa}"

SSH_OPTS="-o StrictHostKeyChecking=accept-new"

echo ">>> Provisioning host '${TARGET_HOST}' via ${SSH_USER}"

ssh $SSH_OPTS "${SSH_USER}@${TARGET_HOST}" \
  REMOTE_USER="$REMOTE_USER" REMOTE_PROJECT_ROOT="$REMOTE_PROJECT_ROOT" bash -s << 'EOF'
set -euo pipefail

echo ">>> [$(hostname)] Phase 2 · Provision Node"
echo "    REMOTE_USER=${REMOTE_USER}"
echo "    REMOTE_PROJECT_ROOT=${REMOTE_PROJECT_ROOT}"

if ! id "${REMOTE_USER}" >/dev/null 2>&1; then
  echo ">>> Creating user '${REMOTE_USER}' with sudo"
  useradd -m -s /bin/bash "${REMOTE_USER}"
  usermod -aG sudo "${REMOTE_USER}"
else
  echo ">>> User '${REMOTE_USER}' already exists, skipping creation"
fi

echo ">>> Propagating SSH authorized_keys to '${REMOTE_USER}' (if available)"
SRC_AUTH_KEYS=""
if [ -f /root/.ssh/authorized_keys ]; then
  SRC_AUTH_KEYS="/root/.ssh/authorized_keys"
fi

if [ -n "$SRC_AUTH_KEYS" ]; then
  install -d -m 700 "/home/${REMOTE_USER}/.ssh"
  cp "$SRC_AUTH_KEYS" "/home/${REMOTE_USER}/.ssh/authorized_keys"
  chown -R "${REMOTE_USER}:${REMOTE_USER}" "/home/${REMOTE_USER}/.ssh"
  chmod 700 "/home/${REMOTE_USER}/.ssh"
  chmod 600 "/home/${REMOTE_USER}/.ssh/authorized_keys"
else
  echo ">>> WARNING: no source authorized_keys found, SSH key-based login for '${REMOTE_USER}' must be configured manually" >&2
fi

echo ">>> Installing base packages (curl, git, tmux, jq, ufw, docker, nginx, postfix)"
export DEBIAN_FRONTEND=noninteractive
apt-get update -y
apt-get install -y \
  ca-certificates curl git tmux jq ufw \
  nginx postfix

if ! command -v docker >/dev/null 2>&1; then
  echo ">>> Installing Docker Engine + compose plugin"
  install -m 0755 -d /etc/apt/keyrings
  if [ ! -f /etc/apt/keyrings/docker.gpg ]; then
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg
  fi
  . /etc/os-release
  echo "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  "$VERSION_CODENAME" stable" >/etc/apt/sources.list.d/docker.list
  apt-get update -y
  apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
  systemctl enable --now docker
else
  echo ">>> Docker already installed, skipping"
fi

echo ">>> Ensuring '${REMOTE_USER}' is in 'docker' group"
if getent group docker >/dev/null 2>&1; then
  usermod -aG docker "${REMOTE_USER}" || echo ">>> WARNING: failed to add ${REMOTE_USER} to docker group" >&2
else
  echo ">>> WARNING: docker group not found; Docker permissions for ${REMOTE_USER} may need manual adjustment" >&2
fi

echo ">>> Ensuring ${REMOTE_PROJECT_ROOT} exists"
mkdir -p "${REMOTE_PROJECT_ROOT}"
chown -R "${REMOTE_USER}:${REMOTE_USER}" "${REMOTE_PROJECT_ROOT}"

echo ">>> Installing Node.js 20 for ${REMOTE_USER} (via nvm if not present)"
su - "${REMOTE_USER}" -c 'bash -s' << 'EONVM'
set -euo pipefail
if [ ! -d "$HOME/.nvm" ]; then
  echo ">>> Installing nvm for ${USER}"
  curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
fi

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"

if ! nvm ls 20 >/dev/null 2>&1; then
  echo ">>> Installing Node.js 20 via nvm"
  nvm install 20
fi
nvm alias default 20
EONVM

TMUX_CONF="/home/${REMOTE_USER}/.tmux.conf"
if [ -f "\$TMUX_CONF" ]; then
  if ! grep -q 'history-limit' "\$TMUX_CONF"; then
    echo "set-option -g history-limit 1000000" >> "\$TMUX_CONF"
  fi
else
  echo "set-option -g history-limit 1000000" > "\$TMUX_CONF"
fi
chown "${REMOTE_USER}:${REMOTE_USER}" "\$TMUX_CONF"

echo ">>> Creating tmux session 'p-cfa' (if not exists)"
su - "${REMOTE_USER}" -c "tmux has-session -t p-cfa 2>/dev/null || tmux new-session -d -s p-cfa -c '${REMOTE_PROJECT_ROOT}'"

echo ">>> Provisioning done on \$(hostname)"
EOF

echo ">>> Host '${TARGET_HOST}' provisioned successfully"

```
---
# ops/scripts/fix-runner-and-deploy.sh
```sh
#!/bin/bash
# Master script: Fix Runner and Deploy Test Pod
# Usage: ./ops/scripts/fix-runner-and-deploy.sh [RUNNER_TOKEN]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${GREEN}=== Мастер-скрипт: Исправление Runner и выкатка тестового pod ===${NC}"
echo ""

# Setup kubeconfig
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
    export KUBECONFIG="${KUBECONFIG_FILE}"
fi

if [ -z "${KUBECONFIG_FILE}" ] || [ ! -f "${KUBECONFIG_FILE}" ]; then
    echo -e "${RED}Error: KUBECONFIG not found${NC}"
    echo "Run: make setup-kubeconfig"
    exit 1
fi

export KUBECONFIG="${KUBECONFIG_FILE}"
echo -e "${GREEN}✓ Using KUBECONFIG: ${KUBECONFIG_FILE}${NC}"
echo ""

# Step 1: Fix Runner
RUNNER_TOKEN="${1:-${RUNNER_TOKEN:-}}"
if [ -n "${RUNNER_TOKEN}" ]; then
    echo -e "${YELLOW}=== ШАГ 1: Исправление GitLab Runner ===${NC}"
    echo "Updating runner token..."
    
    # Update ConfigMap
    sed -e "s/__REPLACE_WITH_RUNNER_TOKEN__/${RUNNER_TOKEN}/g" \
        -e "s/token = \".*\"/token = \"${RUNNER_TOKEN}\"/g" \
        "${PROJECT_ROOT}/ops/infra/k8s/gitlab-runner/configmap.yaml" | \
        kubectl apply -f -
    
    # Restart pods
    echo "Restarting runner pods..."
    kubectl rollout restart deployment/gitlab-runner -n gitlab-runner
    kubectl wait --for=condition=Ready pod -l app=gitlab-runner -n gitlab-runner --timeout=120s || true
    
    echo -e "${GREEN}✓ Runner token updated${NC}"
    echo ""
else
    echo -e "${YELLOW}⚠ RUNNER_TOKEN not provided, skipping runner update${NC}"
    echo "To update runner: export RUNNER_TOKEN='token' && $0"
    echo ""
fi

# Step 2: Deploy test pod
echo -e "${YELLOW}=== ШАГ 2: Выкатка тестового pod ===${NC}"
kubectl apply -f "${PROJECT_ROOT}/ops/infra/k8s/test-pod.yaml"

echo "Waiting for pod to be ready..."
kubectl wait --for=condition=Ready pod -l app=test-nginx -n ois-cfa --timeout=60s || {
    echo -e "${YELLOW}⚠ Pod may still be starting${NC}"
}

echo ""
echo -e "${GREEN}=== Статус развёртывания ===${NC}"
kubectl get pods -n ois-cfa
echo ""
kubectl get svc -n ois-cfa
echo ""
kubectl get ingress -n ois-cfa
echo ""

# Step 3: Get access info
NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null || \
          kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')

echo -e "${GREEN}=== Информация для доступа ===${NC}"
echo "Node IP: ${NODE_IP}"
echo ""
echo "Доступ к тестовому pod:"
echo "1. Через Ingress (если DNS настроен): http://cfa.capital"
echo "2. По IP узла (если настроен NodePort): http://${NODE_IP}"
echo ""
echo "Проверка:"
echo "  curl http://cfa.capital"
echo "  или"
echo "  curl http://${NODE_IP} -H 'Host: cfa.capital'"
echo ""

echo -e "${GREEN}✓ Тестовый pod выкачен${NC}"


```
---
# ops/scripts/force-runner-reregister.sh
```sh
#!/bin/bash
# Force GitLab Runner to re-register by clearing saved state
# Usage: ./ops/scripts/force-runner-reregister.sh

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${GREEN}=== Принудительная перерегистрация GitLab Runner ===${NC}"
echo ""

# Setup kubeconfig
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
    export KUBECONFIG="${KUBECONFIG_FILE}"
fi

if [ -z "${KUBECONFIG_FILE}" ] || [ ! -f "${KUBECONFIG_FILE}" ]; then
    echo -e "${RED}Error: KUBECONFIG not found${NC}"
    exit 1
fi

export KUBECONFIG="${KUBECONFIG_FILE}"
echo -e "${GREEN}✓ Using KUBECONFIG: ${KUBECONFIG_FILE}${NC}"
echo ""

# Step 1: Get pods
echo -e "${YELLOW}=== ШАГ 1: Поиск pods GitLab Runner ===${NC}"
PODS=$(kubectl get pods -n gitlab-runner -l app=gitlab-runner -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

if [ -z "${PODS}" ]; then
    echo -e "${RED}Error: No GitLab Runner pods found${NC}"
    exit 1
fi

echo "Найдено pods: ${PODS}"
echo ""

# Step 2: Clear runner state in pods (if possible)
echo -e "${YELLOW}=== ШАГ 2: Очистка сохраненной конфигурации ===${NC}"
for POD in ${PODS}; do
    echo "Обработка pod: ${POD}"
    
    # Try to clear runner state files (may fail if ConfigMap is read-only)
    kubectl exec -n gitlab-runner "${POD}" -- sh -c "
        rm -f /etc/gitlab-runner/.runner_system_id 2>/dev/null || true
        rm -f /etc/gitlab-runner/.runner_* 2>/dev/null || true
        echo 'State files cleared (if writable)'
    " 2>&1 || echo "Не удалось очистить state files (ConfigMap read-only - это нормально)"
done
echo ""

# Step 3: Delete pods to force re-registration
echo -e "${YELLOW}=== ШАГ 3: Удаление pods для перерегистрации ===${NC}"
echo "Удаление pods..."
kubectl delete pods -n gitlab-runner -l app=gitlab-runner

echo "Ожидание пересоздания pods..."
sleep 10

# Step 4: Wait for pods to be ready
echo -e "${YELLOW}=== ШАГ 4: Ожидание готовности pods ===${NC}"
kubectl wait --for=condition=Ready pod -l app=gitlab-runner -n gitlab-runner --timeout=120s || {
    echo -e "${YELLOW}⚠ Pods могут еще запускаться${NC}"
}

echo ""
echo -e "${GREEN}=== Статус pods ===${NC}"
kubectl get pods -n gitlab-runner
echo ""

# Step 5: Check logs
echo -e "${YELLOW}=== ШАГ 5: Проверка логов ===${NC}"
sleep 5
kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=30 2>&1 | tail -30
echo ""

echo -e "${GREEN}=== ИНСТРУКЦИИ ===${NC}"
echo ""
echo "⚠️  ВАЖНО: Если runner все еще получает 403 Forbidden:"
echo ""
echo "1. Удалите старый runner из GitLab UI:"
echo "   https://git.telex.global/npk/ois-cfa/-/settings/ci_cd"
echo "   → Runners → Удалить runner с ID HYErDk_6w"
echo ""
echo "2. Перезапустите pods еще раз:"
echo "   kubectl delete pods -n gitlab-runner -l app=gitlab-runner"
echo ""
echo "3. Проверьте логи:"
echo "   kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=50"
echo ""

echo -e "${GREEN}✓ Скрипт выполнен${NC}"


```
---
# ops/scripts/get-runner-token.sh
```sh
#!/bin/bash
# Get GitLab Runner Registration Token via API
# Usage: ./ops/scripts/get-runner-token.sh [GITLAB_TOKEN] [PROJECT_PATH]

set -euo pipefail

GITLAB_URL="${GITLAB_URL:-https://git.telex.global}"
GITLAB_TOKEN="${1:-${GITLAB_TOKEN:-}}"
PROJECT_PATH="${2:-${CI_PROJECT_PATH:-npk/ois-cfa}}"

if [ -z "${GITLAB_TOKEN}" ]; then
    echo "Error: GITLAB_TOKEN not set"
    echo "Usage: $0 <gitlab-token> [project-path]"
    echo "Or set: export GITLAB_TOKEN='your-token'"
    exit 1
fi

echo "Getting Runner Registration Token for project: ${PROJECT_PATH}"
echo ""

# Encode project path for URL
PROJECT_PATH_ENCODED=$(echo "${PROJECT_PATH}" | sed 's/\//%2F/g')

# Try to get runner token via API
RESPONSE=$(curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
    "${GITLAB_URL}/api/v4/projects/${PROJECT_PATH_ENCODED}/runners_token" 2>/dev/null)

if [ $? -eq 0 ] && [ -n "${RESPONSE}" ]; then
    TOKEN=$(echo "${RESPONSE}" | jq -r '.token // .' 2>/dev/null || echo "${RESPONSE}")
    
    if [ "${TOKEN}" != "null" ] && [ "${TOKEN}" != "" ] && [ "${TOKEN}" != "${RESPONSE}" ]; then
        echo "✓ Runner Registration Token получен:"
        echo "${TOKEN}"
        echo ""
        echo "Для обновления раннера:"
        echo "  export RUNNER_TOKEN=\"${TOKEN}\""
        echo "  make gitlab-runner-update-token"
        exit 0
    fi
fi

echo "⚠ Не удалось получить токен через API"
echo ""
echo "Получите токен вручную из GitLab UI:"
echo "1. Откройте: ${GITLAB_URL}/${PROJECT_PATH}/-/settings/ci_cd"
echo "2. Раздел: Runners"
echo "3. Скопируйте Registration token"
echo ""
echo "Или используйте групповой/instance runner token:"
echo "  Settings → CI/CD → Runners → Expand 'Runners' → Registration token"


```
---
# ops/scripts/gitlab-runner-install.sh
```sh
#!/bin/bash
# Install GitLab Runner in Kubernetes
# Usage: ./ops/scripts/gitlab-runner-install.sh [RUNNER_TOKEN]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check kubectl
if ! command -v kubectl &> /dev/null; then
    echo -e "${RED}Error: kubectl is not installed${NC}"
    exit 1
fi

# Get runner token
RUNNER_TOKEN="${1:-${RUNNER_TOKEN:-}}"

if [ -z "$RUNNER_TOKEN" ]; then
    echo -e "${YELLOW}Runner token not provided.${NC}"
    echo "Getting token from GitLab API..."
    
    if [ -z "${GITLAB_TOKEN:-}" ]; then
        echo -e "${RED}Error: GITLAB_TOKEN not set${NC}"
        echo "Set it with: export GITLAB_TOKEN='your-token'"
        echo ""
        echo "Or provide runner token directly:"
        echo "  $0 <runner-token>"
        echo ""
        echo "To get token from GitLab UI:"
        echo "  Settings → CI/CD → Runners → Registration token"
        exit 1
    fi
    
    echo -e "${RED}Cannot get runner token from API (endpoint not available)${NC}"
    echo "Please get token from GitLab UI:"
    echo "  1. Open: https://git.telex.global/npk/ois-cfa/-/settings/ci_cd"
    echo "  2. Expand 'Runners' section"
    echo "  3. Copy 'Registration token'"
    echo ""
    echo "Then run:"
    echo "  $0 <runner-token>"
    exit 1
fi

# Runner directory
RUNNER_DIR="${PROJECT_ROOT}/ops/infra/k8s/gitlab-runner"

echo -e "${GREEN}=== Installing GitLab Runner ===${NC}"
echo "Runner token: ${RUNNER_TOKEN:0:10}...${RUNNER_TOKEN: -10}"
echo ""

# Check if namespace exists
if kubectl get namespace gitlab-runner &>/dev/null; then
    echo -e "${YELLOW}Namespace gitlab-runner already exists${NC}"
else
    echo "Creating namespace..."
    kubectl apply -f "${RUNNER_DIR}/namespace.yaml"
fi

# Apply RBAC
echo "Applying RBAC..."
kubectl apply -f "${RUNNER_DIR}/rbac.yaml"

# Update configmap with token
echo "Updating configmap with runner token..."
TEMP_CONFIGMAP=$(mktemp)
sed "s/__REPLACE_WITH_RUNNER_TOKEN__/$RUNNER_TOKEN/g" \
    "${RUNNER_DIR}/configmap.yaml" > "$TEMP_CONFIGMAP"
kubectl apply -f "$TEMP_CONFIGMAP"
rm "$TEMP_CONFIGMAP"

# Apply deployment and service
echo "Applying deployment..."
kubectl apply -f "${RUNNER_DIR}/deployment.yaml"
kubectl apply -f "${RUNNER_DIR}/service.yaml"

# Wait for pods
echo ""
echo "Waiting for pods to be ready..."
if kubectl wait --for=condition=Ready pod -l app=gitlab-runner -n gitlab-runner --timeout=120s 2>/dev/null; then
    echo -e "${GREEN}✓ GitLab Runner pods are ready${NC}"
else
    echo -e "${YELLOW}⚠ Pods may still be starting. Check status:${NC}"
    echo "  kubectl get pods -n gitlab-runner"
fi

# Show status
echo ""
echo -e "${GREEN}=== GitLab Runner Status ===${NC}"
kubectl get pods -n gitlab-runner
echo ""
echo "Runner logs (last 10 lines):"
kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=10 || true

echo ""
echo -e "${GREEN}=== Installation Complete ===${NC}"
echo "Check runners in GitLab UI:"
echo "  https://git.telex.global/npk/ois-cfa/-/settings/ci_cd"
echo ""
echo "Useful commands:"
echo "  kubectl logs -n gitlab-runner -l app=gitlab-runner -f  # Watch logs"
echo "  kubectl get pods -n gitlab-runner                      # Check pods"
echo "  make gitlab-runner-status                              # Show status"


```
---
# ops/scripts/gitops-sync.sh
```sh
#!/bin/bash
# GitOps Sync Script for GitLab Agent
# Usage: ./ops/scripts/gitops-sync.sh [env]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

ENV="${1:-dev}"

echo -e "${GREEN}=== GitOps Sync: GitLab Agent ===${NC}"
echo "Environment: ${ENV}"
echo ""

# Setup kubeconfig
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
    export KUBECONFIG="${KUBECONFIG_FILE}"
fi

if [ -z "${KUBECONFIG_FILE}" ] || [ ! -f "${KUBECONFIG_FILE}" ]; then
    echo -e "${RED}Error: KUBECONFIG not found${NC}"
    exit 1
fi

export KUBECONFIG="${KUBECONFIG_FILE}"
echo -e "${GREEN}✓ Using KUBECONFIG: ${KUBECONFIG_FILE}${NC}"
echo ""

# Step 1: Check GitLab Agent status
echo -e "${YELLOW}=== ШАГ 1: Проверка GitLab Agent ===${NC}"
AGENT_PODS=$(kubectl get pods -n gitlab-agent -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

if [ -z "${AGENT_PODS}" ]; then
    echo -e "${YELLOW}⚠ GitLab Agent pods not found, but continuing...${NC}"
    echo "Install agent: make gitlab-agent-install"
else
    echo "GitLab Agent pods: ${AGENT_PODS}"
fi

echo "GitLab Agent pods: ${AGENT_PODS}"
for POD in ${AGENT_PODS}; do
    STATUS=$(kubectl get pod -n gitlab-agent "${POD}" -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
    echo "  - ${POD}: ${STATUS}"
done
echo ""

# Step 2: Check agent configuration
echo -e "${YELLOW}=== ШАГ 2: Проверка конфигурации агента ===${NC}"
if [ ! -f "${PROJECT_ROOT}/.gitlab/agents/ois-cfa-agent/config.yaml" ]; then
    echo -e "${YELLOW}⚠ Конфигурация агента не найдена, создаю...${NC}"
    mkdir -p "${PROJECT_ROOT}/.gitlab/agents/ois-cfa-agent"
    cp "${PROJECT_ROOT}/ops/gitops/gitlab-agent/agent-config.yaml" \
       "${PROJECT_ROOT}/.gitlab/agents/ois-cfa-agent/config.yaml"
    echo -e "${GREEN}✓ Конфигурация создана${NC}"
else
    echo -e "${GREEN}✓ Конфигурация найдена${NC}"
fi
echo ""

# Step 3: Check manifests
echo -e "${YELLOW}=== ШАГ 3: Проверка манифестов ===${NC}"
MANIFEST_DIRS=(
    "ops/gitops/gitlab-agent/manifests/system"
    "ops/gitops/gitlab-agent/manifests/platform"
    "ops/gitops/gitlab-agent/manifests/business"
)

for DIR in "${MANIFEST_DIRS[@]}"; do
    if [ -d "${PROJECT_ROOT}/${DIR}" ]; then
        MANIFEST_COUNT=$(find "${PROJECT_ROOT}/${DIR}" -name "*.yaml" -o -name "*.yml" | wc -l)
        echo "  ${DIR}: ${MANIFEST_COUNT} манифестов"
    else
        echo -e "${YELLOW}  ⚠ ${DIR}: не найдено${NC}"
    fi
done
echo ""

# Step 4: Apply manifests manually (for testing)
echo -e "${YELLOW}=== ШАГ 4: Применение манифестов ===${NC}"
echo "Применяю манифесты в порядке: system → platform → business"
echo ""

# System manifests
if [ -d "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/system" ]; then
    echo -e "${BLUE}→ System manifests${NC}"
    kubectl apply -f "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/system/" --recursive || true
    sleep 2
fi

# Platform manifests
if [ -d "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/platform" ]; then
    echo -e "${BLUE}→ Platform manifests${NC}"
    kubectl apply -f "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/platform/" --recursive || true
    sleep 2
fi

# Business manifests
if [ -d "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/business" ]; then
    echo -e "${BLUE}→ Business manifests${NC}"
    kubectl apply -f "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/business/" --recursive || true
    sleep 2
fi

echo ""

# Step 5: Check applied resources
echo -e "${YELLOW}=== ШАГ 5: Проверка примененных ресурсов ===${NC}"
echo "Namespaces:"
kubectl get namespaces | grep -E "(ois-cfa|default)" || echo "  (нет соответствующих namespace)"
echo ""

echo "Deployments в ois-cfa:"
kubectl get deployments -n ois-cfa 2>/dev/null || echo "  Namespace ois-cfa не существует или пуст"
echo ""

echo "Services в ois-cfa:"
kubectl get services -n ois-cfa 2>/dev/null || echo "  Namespace ois-cfa не существует или пуст"
echo ""

echo "Ingress в ois-cfa:"
kubectl get ingress -n ois-cfa 2>/dev/null || echo "  Namespace ois-cfa не существует или пуст"
echo ""

# Step 6: Summary
echo -e "${GREEN}=== ИТОГОВЫЙ СТАТУС ===${NC}"
echo ""
echo "✅ GitLab Agent: Running"
echo "✅ Конфигурация: ${PROJECT_ROOT}/.gitlab/agents/ois-cfa-agent/config.yaml"
echo "✅ Манифесты применены"
echo ""
echo -e "${YELLOW}Следующие шаги:${NC}"
echo "1. Проверить статус в GitLab UI:"
echo "   Infrastructure → Kubernetes clusters → ваш кластер → Connected agents"
echo ""
echo "2. Создать MR с изменениями манифестов (если нужно)"
echo ""
echo "3. GitLab Agent автоматически синхронизирует изменения из Git"
echo ""
echo -e "${GREEN}✓ GitOps sync выполнен${NC}"


```
---
# ops/scripts/install-helm.sh
```sh
#!/bin/bash
# Install Helm package manager for Kubernetes
# Usage: ./ops/scripts/install-helm.sh

set -euo pipefail

HELM_VERSION="${HELM_VERSION:-3.14.0}"

echo "=== Installing Helm ${HELM_VERSION} ==="

# Check if helm is already installed
if command -v helm &> /dev/null; then
    CURRENT_VERSION=$(helm version --template '{{.Version}}' 2>/dev/null | sed 's/v//' || echo "")
    if [ -n "${CURRENT_VERSION}" ]; then
        echo "✓ Helm already installed: v${CURRENT_VERSION}"
        echo "To reinstall, remove existing helm first: sudo rm -f $(which helm)"
        exit 0
    fi
fi

# Detect OS and architecture
OS=$(uname -s | tr '[:upper:]' '[:lower:]')
ARCH=$(uname -m)

case "${ARCH}" in
    x86_64)
        ARCH="amd64"
        ;;
    aarch64|arm64)
        ARCH="arm64"
        ;;
    *)
        echo "Error: Unsupported architecture: ${ARCH}"
        exit 1
        ;;
esac

echo "Detected OS: ${OS}, Architecture: ${ARCH}"

# Download Helm
HELM_URL="https://get.helm.sh/helm-v${HELM_VERSION}-${OS}-${ARCH}.tar.gz"
TMP_DIR=$(mktemp -d)
TAR_FILE="${TMP_DIR}/helm.tar.gz"

echo "Downloading Helm from ${HELM_URL}..."
curl -L -o "${TAR_FILE}" "${HELM_URL}" || {
    echo "Error: Failed to download Helm"
    rm -rf "${TMP_DIR}"
    exit 1
}

# Extract and install
echo "Extracting Helm..."
tar -xzf "${TAR_FILE}" -C "${TMP_DIR}"

# Install to /usr/local/bin (requires sudo) or ~/.local/bin
INSTALL_DIR="${HOME}/.local/bin"
mkdir -p "${INSTALL_DIR}"

if [ -w "/usr/local/bin" ]; then
    INSTALL_DIR="/usr/local/bin"
    echo "Installing to ${INSTALL_DIR}..."
    sudo cp "${TMP_DIR}/${OS}-${ARCH}/helm" "${INSTALL_DIR}/helm" || {
        echo "Error: Failed to install helm to ${INSTALL_DIR}"
        rm -rf "${TMP_DIR}"
        exit 1
    }
else
    echo "Installing to ${INSTALL_DIR}..."
    cp "${TMP_DIR}/${OS}-${ARCH}/helm" "${INSTALL_DIR}/helm" || {
        echo "Error: Failed to install helm to ${INSTALL_DIR}"
        rm -rf "${TMP_DIR}"
        exit 1
    }
    
    # Add to PATH if not already there
    if [[ ":$PATH:" != *":${INSTALL_DIR}:"* ]]; then
        echo ""
        echo "⚠ Add ${INSTALL_DIR} to PATH:"
        echo "  export PATH=\"\${PATH}:${INSTALL_DIR}\""
        echo ""
        echo "Or add to ~/.bashrc:"
        echo "  echo 'export PATH=\"\${PATH}:${INSTALL_DIR}\"' >> ~/.bashrc"
    fi
fi

# Cleanup
rm -rf "${TMP_DIR}"

# Verify installation
if command -v helm &> /dev/null || [ -f "${INSTALL_DIR}/helm" ]; then
    if [ -f "${INSTALL_DIR}/helm" ]; then
        "${INSTALL_DIR}/helm" version --client
    else
        helm version --client
    fi
    echo ""
    echo "✓ Helm installed successfully"
    echo "Version: $("${INSTALL_DIR}/helm" version --template '{{.Version}}' 2>/dev/null || helm version --template '{{.Version}}')"
else
    echo "Error: Helm installation verification failed"
    exit 1
fi


```
---
# ops/scripts/k8s-healthcheck.sh
```sh
#!/bin/bash
# Kubernetes Cluster Health Check
# Generates HTML report with cluster status, checks, and action items

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OUTPUT_DIR="${OUTPUT_DIR:-/tmp/k8s-healthcheck}"
ARTIFACTS_DIR="${ARTIFACTS_DIR:-/tmp/artifacts}"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
REPORT_FILE="${OUTPUT_DIR}/healthcheck-report-${TIMESTAMP}.html"
JSON_FILE="${OUTPUT_DIR}/healthcheck-${TIMESTAMP}.json"

mkdir -p "${OUTPUT_DIR}"
mkdir -p "${ARTIFACTS_DIR}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Initialize results
declare -A CHECKS
declare -a ACTION_ITEMS
declare -a WARNINGS
declare -a ERRORS

# Helper functions
check_pass() {
    local name="$1"
    local message="$2"
    CHECKS["${name}"]="PASS"
    echo -e "${GREEN}✓${NC} ${name}: ${message}"
}

check_fail() {
    local name="$1"
    local message="$2"
    local fix_cmd="${3:-}"
    CHECKS["${name}"]="FAIL"
    ERRORS+=("${name}: ${message}")
    if [ -n "${fix_cmd}" ]; then
        ACTION_ITEMS+=("${name}|${message}|${fix_cmd}")
    else
        ACTION_ITEMS+=("${name}|${message}|N/A")
    fi
    echo -e "${RED}✗${NC} ${name}: ${message}"
}

check_warn() {
    local name="$1"
    local message="$2"
    CHECKS["${name}"]="WARN"
    WARNINGS+=("${name}: ${message}")
    echo -e "${YELLOW}⚠${NC} ${name}: ${message}"
}

# Check if kubectl is available
if ! command -v kubectl &> /dev/null; then
    echo "Error: kubectl not found. Please install kubectl."
    exit 1
fi

# Check if cluster is accessible
if ! kubectl cluster-info &> /dev/null; then
    check_fail "cluster-access" "Cannot access Kubernetes cluster" "kubectl cluster-info"
    exit 1
fi

echo "=== Kubernetes Cluster Health Check ==="
echo "Timestamp: ${TIMESTAMP}"
echo ""

# 1. Check Nodes
echo "=== Checking Nodes ==="
NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l || echo "0")
if [ "${NODES}" -eq 0 ]; then
    check_fail "nodes-count" "No nodes found in cluster" "kubectl get nodes"
else
    check_pass "nodes-count" "${NODES} node(s) found"
fi

# Check node status
READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c " Ready " || echo "0")
NOT_READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -v " Ready " | wc -l || echo "0")

if [ "${NOT_READY_NODES}" -gt 0 ]; then
    check_fail "nodes-ready" "${NOT_READY_NODES} node(s) not ready" "kubectl get nodes; kubectl describe node <node-name>"
else
    check_pass "nodes-ready" "All ${READY_NODES} node(s) ready"
fi

# Get node versions
NODE_VERSIONS=$(kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}: {.status.nodeInfo.kubeletVersion}{"\n"}{end}' 2>/dev/null || echo "")
if [ -n "${NODE_VERSIONS}" ]; then
    echo "Node versions:"
    echo "${NODE_VERSIONS}" | while IFS= read -r line; do
        echo "  - ${line}"
    done
fi

# Check node resources
echo ""
echo "Node resources:"
kubectl top nodes 2>/dev/null || check_warn "node-metrics" "Metrics server not available (kubectl top nodes)"

# 2. Check Ingress Controller
echo ""
echo "=== Checking Ingress Controller ==="
INGRESS_NS="ingress-nginx"
if kubectl get namespace "${INGRESS_NS}" &>/dev/null; then
    INGRESS_PODS=$(kubectl get pods -n "${INGRESS_NS}" --no-headers 2>/dev/null | grep -c " Running " || echo "0")
    if [ "${INGRESS_PODS}" -gt 0 ]; then
        check_pass "ingress-controller" "Ingress controller running (${INGRESS_PODS} pod(s))"
    else
        check_fail "ingress-controller" "Ingress controller pods not running" "kubectl get pods -n ${INGRESS_NS}; kubectl describe pod -n ${INGRESS_NS}"
    fi
else
    check_warn "ingress-controller" "Ingress namespace not found (${INGRESS_NS})"
fi

# Check ingress service
INGRESS_SVC=$(kubectl get svc -n "${INGRESS_NS}" -l app.kubernetes.io/component=controller 2>/dev/null | grep -v "^NAME" | head -1 | awk '{print $1}' || echo "")
if [ -n "${INGRESS_SVC}" ]; then
    INGRESS_IP=$(kubectl get svc -n "${INGRESS_NS}" "${INGRESS_SVC}" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
    if [ -n "${INGRESS_IP}" ]; then
        check_pass "ingress-lb" "Ingress LoadBalancer IP: ${INGRESS_IP}"
    else
        check_warn "ingress-lb" "Ingress LoadBalancer IP not assigned"
    fi
fi

# 3. Check Cert-Manager
echo ""
echo "=== Checking Cert-Manager ==="
CERT_MANAGER_NS="cert-manager"
if kubectl get namespace "${CERT_MANAGER_NS}" &>/dev/null; then
    CERT_MANAGER_PODS=$(kubectl get pods -n "${CERT_MANAGER_NS}" --no-headers 2>/dev/null | grep -c " Running " || echo "0")
    if [ "${CERT_MANAGER_PODS}" -gt 0 ]; then
        check_pass "cert-manager-pods" "Cert-Manager running (${CERT_MANAGER_PODS} pod(s))"
    else
        check_fail "cert-manager-pods" "Cert-Manager pods not running" "kubectl get pods -n ${CERT_MANAGER_NS}; kubectl describe pod -n ${CERT_MANAGER_NS}"
    fi
    
    # Check certificates
    CERT_COUNT=$(kubectl get certificates -A --no-headers 2>/dev/null | wc -l || echo "0")
    if [ "${CERT_COUNT}" -gt 0 ]; then
        READY_CERTS=$(kubectl get certificates -A --no-headers 2>/dev/null | grep -c " True " || echo "0")
        NOT_READY_CERTS=$(kubectl get certificates -A --no-headers 2>/dev/null | grep -v " True " | wc -l || echo "0")
        
        if [ "${NOT_READY_CERTS}" -gt 0 ]; then
            check_fail "certificates-ready" "${NOT_READY_CERTS} certificate(s) not ready" "kubectl get certificates -A; kubectl describe certificate -n <namespace> <cert-name>"
        else
            check_pass "certificates-ready" "All ${READY_CERTS} certificate(s) ready"
        fi
    else
        check_warn "certificates" "No certificates found"
    fi
    
    # Check certificate issuers
    ISSUER_COUNT=$(kubectl get clusterissuers,issuers -A --no-headers 2>/dev/null | wc -l || echo "0")
    if [ "${ISSUER_COUNT}" -gt 0 ]; then
        READY_ISSUERS=$(kubectl get clusterissuers,issuers -A --no-headers 2>/dev/null | grep -c " True " || echo "0")
        check_pass "issuers" "${READY_ISSUERS} issuer(s) ready"
    else
        check_warn "issuers" "No certificate issuers found"
    fi
else
    check_warn "cert-manager" "Cert-Manager namespace not found (${CERT_MANAGER_NS})"
fi

# 4. Check DNS
echo ""
echo "=== Checking DNS ==="
# Check CoreDNS
COREDNS_NS="kube-system"
COREDNS_PODS=$(kubectl get pods -n "${COREDNS_NS}" -l k8s-app=kube-dns --no-headers 2>/dev/null | grep -c " Running " || echo "0")
if [ "${COREDNS_PODS}" -gt 0 ]; then
    check_pass "coredns" "CoreDNS running (${COREDNS_PODS} pod(s))"
else
    check_fail "coredns" "CoreDNS pods not running" "kubectl get pods -n ${COREDNS_NS} -l k8s-app=kube-dns"
fi

# Test DNS resolution (if test pod can be created)
# Use timeout to prevent hanging
DNS_TEST_OUTPUT=$(timeout 15 kubectl run dns-test-${TIMESTAMP} --image=busybox:1.36 --rm -i --restart=Never -- nslookup kubernetes.default 2>&1 || echo "FAIL")
if echo "${DNS_TEST_OUTPUT}" | grep -q "kubernetes.default"; then
    check_pass "dns-resolution" "DNS resolution working"
else
    # Cleanup pod if it wasn't cleaned up automatically
    kubectl delete pod dns-test-${TIMESTAMP} --ignore-not-found=true &>/dev/null || true
    check_warn "dns-resolution" "DNS resolution test inconclusive (may require manual verification)"
fi

# 5. Check critical namespaces
echo ""
echo "=== Checking Critical Namespaces ==="
CRITICAL_NS=("kube-system" "kube-public" "kube-node-lease")
for ns in "${CRITICAL_NS[@]}"; do
    if kubectl get namespace "${ns}" &>/dev/null; then
        check_pass "namespace-${ns}" "Namespace ${ns} exists"
    else
        check_fail "namespace-${ns}" "Namespace ${ns} not found" "kubectl create namespace ${ns}"
    fi
done

# 6. Check system pods
echo ""
echo "=== Checking System Pods ==="
SYSTEM_PODS_NOT_READY=$(kubectl get pods -n kube-system --no-headers 2>/dev/null | grep -v " Running " | grep -v " Completed " | wc -l || echo "0")
if [ "${SYSTEM_PODS_NOT_READY}" -gt 0 ]; then
    check_fail "system-pods" "${SYSTEM_PODS_NOT_READY} system pod(s) not ready" "kubectl get pods -n kube-system; kubectl describe pod -n kube-system <pod-name>"
else
    check_pass "system-pods" "All system pods ready"
fi

# 7. Check API server
echo ""
echo "=== Checking API Server ==="
API_SERVER=$(kubectl cluster-info | grep "Kubernetes control plane" | awk '{print $NF}' || echo "")
if [ -n "${API_SERVER}" ]; then
    if curl -k -s -o /dev/null -w "%{http_code}" "${API_SERVER}/healthz" | grep -q "200"; then
        check_pass "api-server" "API server healthy"
    else
        check_fail "api-server" "API server health check failed" "kubectl cluster-info"
    fi
else
    check_warn "api-server" "Cannot determine API server URL"
fi

# Generate JSON report
cat > "${JSON_FILE}" <<EOF
{
  "timestamp": "${TIMESTAMP}",
  "cluster": "$(kubectl config current-context 2>/dev/null || echo 'unknown')",
  "checks": {
$(for key in "${!CHECKS[@]}"; do
    echo "    \"${key}\": \"${CHECKS[$key]}\","
done | sed '$ s/,$//')
  },
  "summary": {
    "total": ${#CHECKS[@]},
    "passed": $(echo "${CHECKS[@]}" | grep -o "PASS" | wc -l),
    "failed": $(echo "${CHECKS[@]}" | grep -o "FAIL" | wc -l),
    "warnings": $(echo "${CHECKS[@]}" | grep -o "WARN" | wc -l)
  },
  "errors": [
$(for error in "${ERRORS[@]}"; do
    echo "    \"${error}\","
done | sed '$ s/,$//')
  ],
  "warnings": [
$(for warning in "${WARNINGS[@]}"; do
    echo "    \"${warning}\","
done | sed '$ s/,$//')
  ],
  "action_items": [
$(for item in "${ACTION_ITEMS[@]}"; do
    IFS='|' read -r name message cmd <<< "${item}"
    echo "    {\"check\": \"${name}\", \"message\": \"${message}\", \"command\": \"${cmd}\"},"
done | sed '$ s/,$//')
  ]
}
EOF

# Generate HTML report
cat > "${REPORT_FILE}" <<EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kubernetes Cluster Health Check Report</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
        }
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .summary-card {
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .summary-card.total { background-color: #e3f2fd; }
        .summary-card.passed { background-color: #e8f5e9; }
        .summary-card.failed { background-color: #ffebee; }
        .summary-card.warnings { background-color: #fff3e0; }
        .summary-card h3 {
            margin: 0;
            font-size: 2em;
            color: #333;
        }
        .summary-card p {
            margin: 5px 0 0 0;
            color: #666;
        }
        .check-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
        }
        .check-item.pass {
            background-color: #e8f5e9;
            border-left: 4px solid #4CAF50;
        }
        .check-item.fail {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
        }
        .check-item.warn {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
        }
        .status-icon {
            font-size: 1.5em;
            margin-right: 10px;
        }
        .action-items {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }
        .action-items h3 {
            margin-top: 0;
            color: #856404;
        }
        .action-item {
            background: white;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 3px solid #ff9800;
        }
        .action-item strong {
            color: #f44336;
        }
        .command {
            background-color: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-top: 5px;
            word-break: break-all;
        }
        .timestamp {
            color: #666;
            font-size: 0.9em;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kubernetes Cluster Health Check Report</h1>
        <p class="timestamp">Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")</p>
        <p class="timestamp">Cluster: $(kubectl config current-context 2>/dev/null || echo 'unknown')</p>
        
        <div class="summary">
            <div class="summary-card total">
                <h3>${#CHECKS[@]}</h3>
                <p>Total Checks</p>
            </div>
            <div class="summary-card passed">
                <h3>$(echo "${CHECKS[@]}" | grep -o "PASS" | wc -l)</h3>
                <p>Passed</p>
            </div>
            <div class="summary-card failed">
                <h3>$(echo "${CHECKS[@]}" | grep -o "FAIL" | wc -l)</h3>
                <p>Failed</p>
            </div>
            <div class="summary-card warnings">
                <h3>$(echo "${CHECKS[@]}" | grep -o "WARN" | wc -l)</h3>
                <p>Warnings</p>
            </div>
        </div>
        
        <h2>Check Results</h2>
        <table>
            <thead>
                <tr>
                    <th>Check</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
$(for key in $(printf '%s\n' "${!CHECKS[@]}" | sort); do
    status="${CHECKS[$key]}"
    case "${status}" in
        PASS)
            echo "                <tr><td>${key}</td><td><span class=\"status-icon\">✓</span> Pass</td></tr>"
            ;;
        FAIL)
            echo "                <tr><td>${key}</td><td><span class=\"status-icon\">✗</span> Fail</td></tr>"
            ;;
        WARN)
            echo "                <tr><td>${key}</td><td><span class=\"status-icon\">⚠</span> Warning</td></tr>"
            ;;
    esac
done)
            </tbody>
        </table>
        
$(if [ ${#ACTION_ITEMS[@]} -gt 0 ]; then
cat <<ACTION_EOF
        <div class="action-items">
            <h3>Action Items</h3>
            <p>The following issues were detected and require attention:</p>
$(for item in "${ACTION_ITEMS[@]}"; do
    IFS='|' read -r name message cmd <<< "${item}"
    echo "            <div class=\"action-item\">"
    echo "                <strong>${name}</strong>: ${message}"
    if [ "${cmd}" != "N/A" ]; then
        echo "                <div class=\"command\">${cmd}</div>"
    fi
    echo "            </div>"
done)
        </div>
ACTION_EOF
fi)

$(if [ ${#WARNINGS[@]} -gt 0 ]; then
cat <<WARN_EOF
        <h2>Warnings</h2>
        <ul>
$(for warning in "${WARNINGS[@]}"; do
    echo "            <li>${warning}</li>"
done)
        </ul>
WARN_EOF
fi)

        <h2>Cluster Information</h2>
        <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto;">
$(kubectl cluster-info 2>/dev/null || echo "Cluster info not available")
        </pre>
        
        <h2>Node Information</h2>
        <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto;">
$(kubectl get nodes -o wide 2>/dev/null || echo "Node info not available")
        </pre>
    </div>
</body>
</html>
EOF

# Copy reports to artifacts
cp "${REPORT_FILE}" "${ARTIFACTS_DIR}/" || true
cp "${JSON_FILE}" "${ARTIFACTS_DIR}/" || true

echo ""
echo "=== Health Check Complete ==="
echo "HTML Report: ${REPORT_FILE}"
echo "JSON Report: ${JSON_FILE}"
echo "Artifacts: ${ARTIFACTS_DIR}/"

# Exit with error code if there are failures
if [ ${#ERRORS[@]} -gt 0 ]; then
    echo ""
    echo "Health check completed with ${#ERRORS[@]} error(s). See report for details."
    exit 1
else
    echo ""
    echo "All health checks passed!"
    exit 0
fi


```
---
# ops/scripts/restore.md
```md
# PostgreSQL Restore Guide

## Prerequisites

- PostgreSQL client tools installed (`pg_dump`, `psql`)
- Access to backup file (`.sql.gz`)
- Database credentials

## Restore Steps

### 1. Prepare Environment

```bash
export POSTGRES_HOST=postgres
export POSTGRES_PORT=5432
export POSTGRES_DB=ois
export POSTGRES_USER=ois
export POSTGRES_PASSWORD=ois_dev_password
```

### 2. Stop Application Services (Optional)

```bash
docker-compose stop api-gateway issuance-service registry-service settlement-service compliance-service
```

### 3. Restore Backup

```bash
# Restore from compressed backup
gunzip < backups/ois_backup_YYYYMMDD_HHMMSS.sql.gz | \
    PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d $POSTGRES_DB

# Or restore from uncompressed
PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d $POSTGRES_DB < backup.sql
```

### 4. Verify Restore

```bash
# Check table count
PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d $POSTGRES_DB \
    -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';"

# Check sample data
PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d $POSTGRES_DB \
    -c "SELECT COUNT(*) FROM issuances;"
```

### 5. Restart Services

```bash
docker-compose start api-gateway issuance-service registry-service settlement-service compliance-service
```

## Restore to Fresh Database Container

### 1. Create Fresh Container

```bash
docker-compose stop postgres
docker volume rm capital_postgres_data  # WARNING: Deletes existing data
docker-compose up -d postgres
```

### 2. Wait for PostgreSQL to be Ready

```bash
docker-compose exec postgres pg_isready -U ois
```

### 3. Restore Backup

```bash
./ops/scripts/restore.sh backups/ois_backup_YYYYMMDD_HHMMSS.sql.gz
```

## Automated Test Restore Script

See `ops/scripts/test-restore.sh` for automated restore testing.


```
---
# ops/scripts/setup-kubeconfig.sh
```sh
#!/bin/bash
# Setup kubeconfig for Kubernetes cluster
# Usage: ./ops/scripts/setup-kubeconfig.sh

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"

echo -e "${BLUE}=== Kubernetes Kubeconfig Setup ===${NC}"
echo ""

# Check kubectl
if ! command -v kubectl &> /dev/null; then
    echo -e "${RED}✗ kubectl is not installed${NC}"
    echo "Install kubectl: https://kubernetes.io/docs/tasks/tools/"
    exit 1
fi
echo -e "${GREEN}✓ kubectl is installed${NC}"

# Check if kubeconfig already works
if kubectl cluster-info &>/dev/null 2>&1; then
    echo -e "${GREEN}✓ kubeconfig is already configured and working${NC}"
    echo ""
    echo "Current cluster:"
    kubectl cluster-info | head -1
    echo ""
    echo "Nodes:"
    kubectl get nodes 2>/dev/null | head -3 || echo "  (Cannot list nodes - may need permissions)"
    exit 0
fi

echo -e "${YELLOW}⚠ kubeconfig is not configured${NC}"
echo ""

# Check if kubeconfig file exists
if [ -f "$KUBECONFIG_FILE" ]; then
    echo -e "${GREEN}✓ Found kubeconfig file: $KUBECONFIG_FILE${NC}"
    echo ""
    echo "Setting KUBECONFIG environment variable..."
    export KUBECONFIG="$KUBECONFIG_FILE"
    
    if kubectl cluster-info &>/dev/null 2>&1; then
        echo -e "${GREEN}✓ kubeconfig file is valid and working!${NC}"
        echo ""
        echo "To use this kubeconfig in current session:"
        echo -e "${BLUE}  export KUBECONFIG=\"$KUBECONFIG_FILE\"${NC}"
        echo ""
        echo "To make it permanent, add to ~/.bashrc or ~/.zshrc:"
        echo -e "${BLUE}  echo 'export KUBECONFIG=\"$KUBECONFIG_FILE\"' >> ~/.bashrc${NC}"
        exit 0
    else
        echo -e "${YELLOW}⚠ kubeconfig file exists but cannot connect to cluster${NC}"
        echo "  File may be outdated or cluster may be unavailable"
    fi
fi

# Try to export from Timeweb Cloud
echo "Attempting to export kubeconfig from Timeweb Cloud..."
echo ""

# Check twc CLI
if ! command -v twc &> /dev/null; then
    if [ -f "${HOME}/.local/bin/twc" ]; then
        export PATH="${HOME}/.local/bin:${PATH}"
    else
        echo -e "${RED}✗ twc CLI is not installed${NC}"
        echo ""
        echo "To install twc CLI:"
        echo "  ./tools/timeweb/install.sh"
        echo ""
        echo "Or manually:"
        echo "  pip install --user twc-cli"
        echo "  export PATH=\"\${HOME}/.local/bin:\${PATH}\""
        exit 1
    fi
fi
echo -e "${GREEN}✓ twc CLI is installed${NC}"

# Check TWC_TOKEN or twc config
if [ -z "${TWC_TOKEN:-}" ]; then
    # Check if twc can work without explicit token (may be configured via twc config)
    if ! twc k8s list &>/dev/null; then
        echo -e "${YELLOW}⚠ TWC_TOKEN is not set and twc config is not configured${NC}"
        echo ""
        echo "To get TWC_TOKEN:"
        echo "  1. Go to https://timeweb.cloud"
        echo "  2. API → Токены доступа"
        echo "  3. Create new token with permissions: k8s:read, k8s:write"
        echo ""
        echo "Then set it:"
        echo -e "${BLUE}  export TWC_TOKEN='your-token-here'${NC}"
        echo ""
        echo "Or configure twc:"
        echo -e "${BLUE}  twc config set token 'your-token-here'${NC}"
        exit 1
    else
        echo -e "${GREEN}✓ twc CLI is configured (token via twc config)${NC}"
    fi
else
    echo -e "${GREEN}✓ TWC_TOKEN is set${NC}"
fi

# Try to export kubeconfig
echo ""
echo "Exporting kubeconfig..."
if [ -f "${PROJECT_ROOT}/tools/timeweb/kubeconfig-export.sh" ]; then
    "${PROJECT_ROOT}/tools/timeweb/kubeconfig-export.sh" ois-cfa-k8s
else
    echo -e "${RED}✗ kubeconfig-export.sh not found${NC}"
    exit 1
fi

# Set KUBECONFIG
if [ -f "$KUBECONFIG_FILE" ]; then
    export KUBECONFIG="$KUBECONFIG_FILE"
    echo ""
    echo -e "${GREEN}✓ Kubeconfig exported successfully${NC}"
    echo ""
    echo "Testing connection..."
    if kubectl cluster-info &>/dev/null 2>&1; then
        echo -e "${GREEN}✓ Successfully connected to cluster!${NC}"
        echo ""
        echo "Cluster info:"
        kubectl cluster-info | head -3
        echo ""
        echo "To use this kubeconfig in current session:"
        echo -e "${BLUE}  export KUBECONFIG=\"$KUBECONFIG_FILE\"${NC}"
        echo ""
        echo "To make it permanent, add to ~/.bashrc or ~/.zshrc:"
        echo -e "${BLUE}  echo 'export KUBECONFIG=\"$KUBECONFIG_FILE\"' >> ~/.bashrc${NC}"
    else
        echo -e "${YELLOW}⚠ Kubeconfig exported but cannot connect to cluster${NC}"
        echo "  Cluster may be still provisioning or unavailable"
        echo ""
        echo "You can still use the kubeconfig file:"
        echo -e "${BLUE}  export KUBECONFIG=\"$KUBECONFIG_FILE\"${NC}"
    fi
else
    echo -e "${RED}✗ Failed to export kubeconfig${NC}"
    exit 1
fi


```
---
# ops/scripts/setup-twc-cluster.sh
```sh
#!/bin/bash
# Setup Timeweb Cloud cluster access and get configuration
# Usage: ./ops/scripts/setup-twc-cluster.sh [cluster-name]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
CLUSTER_NAME="${1:-ois-cfa-k8s}"

# Ensure twc is in PATH
export PATH="${HOME}/.local/bin:${PATH}"

echo "=== Timeweb Cloud Cluster Setup ==="
echo "Cluster name: ${CLUSTER_NAME}"
echo ""

# Check if twc is installed
if ! command -v twc &> /dev/null; then
    echo "Error: twc CLI is not installed."
    echo "Installing twc..."
    "${PROJECT_ROOT}/tools/timeweb/install.sh"
    export PATH="${HOME}/.local/bin:${PATH}"
fi

# Check for token
TWC_TOKEN="${TWC_TOKEN:-}"
if [ -z "${TWC_TOKEN}" ]; then
    # Try to get from terraform.tfvars
    if [ -f "${PROJECT_ROOT}/ops/infra/timeweb/terraform.tfvars" ]; then
        echo "Reading token from terraform.tfvars..."
        TWC_TOKEN=$(grep -E "^twc_token" "${PROJECT_ROOT}/ops/infra/timeweb/terraform.tfvars" | sed 's/twc_token = "\(.*\)"/\1/' | tr -d ' ')
    fi
fi

if [ -z "${TWC_TOKEN}" ]; then
    echo "Error: TWC_TOKEN is not set."
    echo ""
    echo "Please set it using one of the following methods:"
    echo "1. Environment variable:"
    echo "   export TWC_TOKEN='your-token-here'"
    echo ""
    echo "2. Configure twc:"
    echo "   twc config set token 'your-token-here'"
    echo ""
    echo "3. Or create terraform.tfvars with token:"
    echo "   cp ops/infra/timeweb/terraform.tfvars.example ops/infra/timeweb/terraform.tfvars"
    echo "   # Edit terraform.tfvars and set twc_token"
    exit 1
fi

# Set token for twc
export TWC_TOKEN="${TWC_TOKEN}"

echo "=== Verifying twc configuration ==="
if ! twc k8s list &>/dev/null; then
    echo "Error: Failed to authenticate with Timeweb Cloud."
    echo "Please check your TWC_TOKEN."
    exit 1
fi

echo "✓ Authentication successful"
echo ""

# List clusters
echo "=== Available Kubernetes Clusters ==="
twc k8s list
echo ""

# Get cluster ID
echo "=== Finding cluster: ${CLUSTER_NAME} ==="
CLUSTER_ID=$(twc k8s list --format json 2>/dev/null | jq -r ".[] | select(.name == \"${CLUSTER_NAME}\") | .id" 2>/dev/null || echo "")

if [ -z "${CLUSTER_ID}" ] || [ "${CLUSTER_ID}" == "null" ]; then
    echo "Warning: Cluster '${CLUSTER_NAME}' not found."
    echo ""
    echo "Available clusters:"
    twc k8s list
    echo ""
    echo "To create a new cluster, use Terraform:"
    echo "  cd ops/infra/timeweb"
    echo "  terraform init"
    echo "  terraform plan"
    echo "  terraform apply"
    exit 1
fi

echo "✓ Found cluster ID: ${CLUSTER_ID}"
echo ""

# Get cluster details
echo "=== Cluster Details ==="
twc k8s show "${CLUSTER_ID}" 2>/dev/null || twc k8s list --format json | jq ".[] | select(.id == \"${CLUSTER_ID}\")"
echo ""

# Get node groups
echo "=== Node Groups ==="
twc k8s group list --cluster-id "${CLUSTER_ID}" 2>/dev/null || echo "No node groups found or command not available"
echo ""

# Export kubeconfig
echo "=== Exporting Kubeconfig ==="
KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
twc k8s kubeconfig "${CLUSTER_ID}" > "${KUBECONFIG_FILE}" 2>/dev/null || \
twc k8s cluster kubeconfig "${CLUSTER_ID}" > "${KUBECONFIG_FILE}" 2>/dev/null || \
(twc k8s cluster get-kubeconfig "${CLUSTER_ID}" > "${KUBECONFIG_FILE}" 2>/dev/null && echo "Using get-kubeconfig command")

if [ $? -eq 0 ] && [ -f "${KUBECONFIG_FILE}" ]; then
    chmod 600 "${KUBECONFIG_FILE}"
    echo "✓ Kubeconfig exported to: ${KUBECONFIG_FILE}"
    echo ""
    
    # Verify kubeconfig
    if command -v kubectl &> /dev/null; then
        echo "=== Verifying Kubeconfig ==="
        export KUBECONFIG="${KUBECONFIG_FILE}"
        if kubectl cluster-info --request-timeout=10s &>/dev/null; then
            echo "✓ Successfully connected to cluster"
            echo ""
            echo "Cluster information:"
            kubectl cluster-info | head -3
            echo ""
            echo "Nodes:"
            kubectl get nodes
            echo ""
            echo "To use this kubeconfig:"
            echo "  export KUBECONFIG=\"${KUBECONFIG_FILE}\""
            echo "  kubectl get nodes"
        else
            echo "⚠ Warning: Could not connect to cluster (may be still provisioning)"
        fi
    else
        echo "kubectl not found. Install kubectl to verify connection."
    fi
else
    echo "Error: Failed to export kubeconfig"
    echo "Trying alternative method..."
    "${PROJECT_ROOT}/tools/timeweb/kubeconfig-export.sh" "${CLUSTER_NAME}" "${KUBECONFIG_FILE}"
fi

echo ""
echo "=== Setup Complete ==="
echo "Kubeconfig: ${KUBECONFIG_FILE}"
echo "Cluster ID: ${CLUSTER_ID}"
echo "Cluster Name: ${CLUSTER_NAME}"


```
---
# ops/scripts/test-restore.sh
```sh
#!/bin/bash
set -euo pipefail

# Test restore into fresh DB container
# Usage: ./test-restore.sh <backup_file>

BACKUP_FILE="${1:-}"
if [ -z "$BACKUP_FILE" ]; then
    echo "Usage: $0 <backup_file>"
    exit 1
fi

if [ ! -f "$BACKUP_FILE" ]; then
    echo "Error: Backup file not found: $BACKUP_FILE"
    exit 1
fi

echo "Testing restore of $BACKUP_FILE"

# Export connection params
export POSTGRES_HOST=localhost
export POSTGRES_PORT=5432
export POSTGRES_DB=ois_test
export POSTGRES_USER=ois
export POSTGRES_PASSWORD=ois_dev_password

export PGPASSWORD="$POSTGRES_PASSWORD"

# Create test database (if using existing container)
psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d postgres \
    -c "DROP DATABASE IF EXISTS $POSTGRES_DB;" || true

psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d postgres \
    -c "CREATE DATABASE $POSTGRES_DB;"

# Restore
echo "Restoring backup..."
gunzip < "$BACKUP_FILE" | \
    psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB"

# Verify
echo "Verifying restore..."
TABLE_COUNT=$(psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB" \
    -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")

if [ "$TABLE_COUNT" -gt 0 ]; then
    echo "✅ Restore successful! Found $TABLE_COUNT tables."
    exit 0
else
    echo "❌ Restore failed: No tables found"
    exit 1
fi


```
---
# ops/scripts/validate-specs.sh
```sh
#!/usr/bin/env bash
set -euo pipefail

# Validate OpenAPI, AsyncAPI, and JSON Schemas without requiring global installs.
# It bootstraps a local Node.js (v20) toolchain in .tools if needed.

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
TOOLS_DIR="$ROOT_DIR/.tools"
NODE_VERSION="v20.17.0"
NODE_DIR="$TOOLS_DIR/node-${NODE_VERSION}-linux-x64"
NODE_BIN="$NODE_DIR/bin"

mkdir -p "$TOOLS_DIR"

need_node_install() {
  if [ -x "$NODE_BIN/node" ]; then
    # Check version >= 18
    local v
    v=$($NODE_BIN/node -v | sed 's/v//; s/\..*//')
    if [ "$v" -ge 18 ]; then
      return 1 # no install needed
    fi
  fi
  return 0
}

if need_node_install; then
  echo "Bootstrapping Node.js v20 locally under $NODE_DIR ..."
  OS="linux"
  ARCH="x64"
  URL="https://nodejs.org/dist/${NODE_VERSION}/node-${NODE_VERSION}-${OS}-${ARCH}.tar.xz"
  TMP_TAR="$TOOLS_DIR/node-${NODE_VERSION}-${OS}-${ARCH}.tar.xz"

  rm -rf "$NODE_DIR"
  curl -fsSL "$URL" -o "$TMP_TAR"
  tar -xJf "$TMP_TAR" -C "$TOOLS_DIR"
  rm -f "$TMP_TAR"
fi

export PATH="$NODE_BIN:$PATH"

echo "Using Node: $(node -v)" >&2
echo "Using npm:  $(npm -v)" >&2

cd "$ROOT_DIR"

echo "\n[1/3] Spectral: lint OpenAPI specs (custom minimal ruleset)" >&2
npx -y @stoplight/spectral-cli@6 lint -r .spectral.yaml packages/contracts/openapi-*.yaml

echo "\n[2/3] AsyncAPI: validate asyncapi.yaml" >&2
npx -y @asyncapi/cli@2 validate packages/contracts/asyncapi.yaml

echo "\n[3/3] AJV: compile JSON Schemas" >&2
AJV_OK=true
for schema in packages/contracts/schemas/*.json; do
  echo "Compiling $schema" >&2
  if ! npx -y ajv-cli@5 compile --validate-formats=false --strict=false -s "$schema"; then
    AJV_OK=false
    break
  fi
done

if [ "$AJV_OK" != true ]; then
  echo "AJV schema compilation failed" >&2
  exit 1
fi

echo "\nAll spec validations passed." >&2

```
---
# packages/contracts/README.md
```md
# Contracts Package

API контракты (OpenAPI/AsyncAPI/JSON Schemas) для ОИС ЦФА.

## Структура

```
packages/contracts/
├── openapi-gateway.yaml          # Gateway API
├── openapi-identity.yaml          # Identity Service
├── openapi-integrations-esia.yaml # ESIA Adapter
├── openapi-integrations-bank.yaml # Bank Nominal
├── openapi-integrations-edo.yaml  # EDO Connector
├── asyncapi.yaml                  # Kafka Events
└── schemas/
    ├── CFA.json
    ├── Issuance.json
    ├── Order.json
    ├── Payout.json
    └── AuditEvent.json
```

## Валидация

```bash
# OpenAPI
spectral lint openapi-*.yaml

# AsyncAPI
asyncapi validate asyncapi.yaml

# JSON Schemas
ajv validate -s schemas/CFA.json -d <data>
```

## Генерация SDK

См. `/Makefile` target `generate-sdks`.


```
---
# packages/contracts/asyncapi.yaml
```yaml
asyncapi: 2.6.0
info:
  title: OIS Events API
  version: 1.0.0
  description: События системы ОИС (Kafka)
servers:
  kafka:
    url: localhost:9092
    protocol: kafka
    description: Development Kafka broker

defaultContentType: application/json

channels:
  ois.issuance.published:
    description: Событие публикации выпуска ЦФА
    publish:
      operationId: onIssuancePublished
      summary: Issuance published event
      message:
        $ref: '#/components/messages/IssuancePublished'
  
  ois.issuance.closed:
    description: Событие закрытия выпуска
    publish:
      operationId: onIssuanceClosed
      summary: Issuance closed event
      message:
        $ref: '#/components/messages/IssuanceClosed'
  
  ois.order.placed:
    description: Событие размещения заказа на покупку
    publish:
      operationId: onOrderPlaced
      summary: Order placed event
      message:
        $ref: '#/components/messages/OrderPlaced'
  
  ois.order.confirmed:
    description: Событие подтверждения заказа
    publish:
      operationId: onOrderConfirmed
      summary: Order confirmed event
      message:
        $ref: '#/components/messages/OrderConfirmed'

  ois.order.created:
    description: Событие создания заказа
    publish:
      operationId: onOrderCreated
      summary: Order created event
      message:
        $ref: '#/components/messages/OrderCreated'

  ois.order.reserved:
    description: Событие резерва средств по заказу
    publish:
      operationId: onOrderReserved
      summary: Order reserved event
      message:
        $ref: '#/components/messages/OrderReserved'

  ois.order.paid:
    description: Событие оплаты заказа
    publish:
      operationId: onOrderPaid
      summary: Order paid event
      message:
        $ref: '#/components/messages/OrderPaid'
  
  ois.payout.executed:
    description: Событие выполнения выплаты
    publish:
      operationId: onPayoutExecuted
      summary: Payout executed event
      message:
        $ref: '#/components/messages/PayoutExecuted'
  
  ois.payout.scheduled:
    description: Событие запланированной выплаты
    publish:
      operationId: onPayoutScheduled
      summary: Payout scheduled event
      message:
        $ref: '#/components/messages/PayoutScheduled'
  
  ois.audit.logged:
    description: Событие аудита (журналирование действий)
    publish:
      operationId: onAuditLogged
      summary: Audit log event
      message:
        $ref: '#/components/messages/AuditLogged'
  
  ois.transfer.completed:
    description: Событие завершения перевода на DLT
    publish:
      operationId: onTransferCompleted
      summary: Transfer completed event
      message:
        $ref: '#/components/messages/TransferCompleted'
  
  ois.registry.transferred:
    description: Событие перевода ЦФА через реестр
    publish:
      operationId: onRegistryTransferred
      summary: Registry transfer event
      message:
        $ref: '#/components/messages/RegistryTransferred'
  
  ois.compliance.flagged:
    description: Событие флага compliance для инвестора
    publish:
      operationId: onComplianceFlagged
      summary: Compliance flagged event
      message:
        $ref: '#/components/messages/ComplianceFlagged'

  ois.kyc.updated:
    description: Обновление статуса KYC инвестора
    publish:
      operationId: onKycUpdated
      summary: KYC updated event
      message:
        $ref: '#/components/messages/KycUpdated'

components:
  messages:
    OrderCreated:
      name: OrderCreated
      title: Order Created Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderCreatedPayload'

    OrderReserved:
      name: OrderReserved
      title: Order Reserved Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderReservedPayload'

    OrderPaid:
      name: OrderPaid
      title: Order Paid Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderPaidPayload'
    IssuancePublished:
      name: IssuancePublished
      title: Issuance Published Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/IssuancePublishedPayload'
    
    IssuanceClosed:
      name: IssuanceClosed
      title: Issuance Closed Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/IssuanceClosedPayload'
    
    OrderPlaced:
      name: OrderPlaced
      title: Order Placed Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderPlacedPayload'
    
    OrderConfirmed:
      name: OrderConfirmed
      title: Order Confirmed Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderConfirmedPayload'
    
    PayoutExecuted:
      name: PayoutExecuted
      title: Payout Executed Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/PayoutExecutedPayload'
    
    PayoutScheduled:
      name: PayoutScheduled
      title: Payout Scheduled Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/PayoutScheduledPayload'
    
    AuditLogged:
      name: AuditLogged
      title: Audit Log Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/AuditLoggedPayload'
    
    TransferCompleted:
      name: TransferCompleted
      title: Transfer Completed Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/TransferCompletedPayload'
    
    RegistryTransferred:
      name: RegistryTransferred
      title: Registry Transferred Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/RegistryTransferredPayload'
    
    ComplianceFlagged:
      name: ComplianceFlagged
      title: Compliance Flagged Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/ComplianceFlaggedPayload'

    KycUpdated:
      name: KycUpdated
      title: KYC Updated Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/KycUpdatedPayload'
  
  schemas:
    OrderCreatedPayload:
      type: object
      required: [orderId, investorId, issuanceId, amount, createdAt]
      properties:
        orderId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        createdAt:
          type: string
          format: date-time

    OrderReservedPayload:
      type: object
      required: [orderId, investorId, issuanceId, amount, reservedAt]
      properties:
        orderId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        reservedAt:
          type: string
          format: date-time
        bankTransferId:
          type: string

    OrderPaidPayload:
      type: object
      required: [orderId, investorId, issuanceId, amount, paidAt, txHash]
      properties:
        orderId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        paidAt:
          type: string
          format: date-time
        txHash:
          type: string
    IssuancePublishedPayload:
      type: object
      required:
        - issuanceId
        - assetId
        - issuerId
        - publishedAt
      properties:
        issuanceId:
          type: string
          format: uuid
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
        schedule:
          type: object
          description: Payout schedule JSON
        publishedAt:
          type: string
          format: date-time
        metadata:
          type: object
    
    IssuanceClosedPayload:
      type: object
      required:
        - issuanceId
        - closedAt
      properties:
        issuanceId:
          type: string
          format: uuid
        closedAt:
          type: string
          format: date-time
        reason:
          type: string
    
    OrderPlacedPayload:
      type: object
      required:
        - orderId
        - investorId
        - issuanceId
        - amount
        - placedAt
      properties:
        orderId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        placedAt:
          type: string
          format: date-time
    
    OrderConfirmedPayload:
      type: object
      required:
        - orderId
        - confirmedAt
        - dltTxHash
      properties:
        orderId:
          type: string
          format: uuid
        confirmedAt:
          type: string
          format: date-time
        dltTxHash:
          type: string
        walletId:
          type: string
          format: uuid
    
    PayoutExecutedPayload:
      type: object
      required:
        - batchId
        - executedAt
        - items
      properties:
        batchId:
          type: string
          format: uuid
        executedAt:
          type: string
          format: date-time
        items:
          type: array
          items:
            type: object
            properties:
              payoutId:
                type: string
                format: uuid
              investorId:
                type: string
                format: uuid
              issuanceId:
                type: string
                format: uuid
              amount:
                type: number
                format: decimal
              status:
                type: string
                enum: [executed, failed]
        totalAmount:
          type: number
          format: decimal
    
    PayoutScheduledPayload:
      type: object
      required:
        - batchId
        - scheduledFor
        - issuanceId
      properties:
        batchId:
          type: string
          format: uuid
        scheduledFor:
          type: string
          format: date-time
        issuanceId:
          type: string
          format: uuid
        expectedAmount:
          type: number
          format: decimal
    
    AuditLoggedPayload:
      type: object
      required:
        - id
        - actor
        - action
        - entity
        - timestamp
      properties:
        id:
          type: string
          format: uuid
          description: Audit event ID
        actor:
          type: string
          format: uuid
          description: User/system that performed the action
        actorName:
          type: string
          description: Actor name or identifier
        action:
          type: string
          description: Action type (e.g., 'create', 'update', 'delete', 'approve', 'reject')
        entity:
          type: string
          description: Entity type (e.g., 'issuance', 'order', 'kyc', 'investor', 'audit')
        entityId:
          type: string
          format: uuid
          nullable: true
          description: Entity ID
        payload:
          type: object
          description: Additional event data
          additionalProperties: true
        ip:
          type: string
          format: ipv4
          nullable: true
          description: IP address
        userAgent:
          type: string
          nullable: true
          description: User agent string
        timestamp:
          type: string
          format: date-time
        result:
          type: string
          enum: [success, failure, pending]
          nullable: true
          description: Action result
        correlationId:
          type: string
          format: uuid
          nullable: true
          description: Request correlation ID
    
    TransferCompletedPayload:
      type: object
      required:
        - transferId
        - dltTxHash
        - completedAt
      properties:
        transferId:
          type: string
          format: uuid
        dltTxHash:
          type: string
        blockNumber:
          type: integer
        fromWalletId:
          type: string
          format: uuid
        toWalletId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        completedAt:
          type: string
      format: date-time
    
    RegistryTransferredPayload:
      type: object
      required:
        - orderId
        - issuanceId
        - investorId
        - amount
        - txHash
        - transferredAt
      properties:
        orderId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        walletId:
          type: string
          format: uuid
          nullable: true
        amount:
          type: number
          format: decimal
        txHash:
          type: string
        transferredAt:
          type: string
          format: date-time
    
    ComplianceFlaggedPayload:
      type: object
      required:
        - id
        - investorId
        - reason
        - severity
        - flaggedAt
      properties:
        id:
          type: string
          format: uuid
          description: Compliance flag ID
        investorId:
          type: string
          format: uuid
        investorName:
          type: string
          nullable: true
          description: Investor name or identifier
        reason:
          type: string
          enum: [kyc_fail, qualification_exceeded, watchlist_match, manual_review, document_issue]
          description: Reason for flagging
        severity:
          type: string
          enum: [low, medium, high, critical]
        flaggedAt:
          type: string
          format: date-time
        flaggedBy:
          type: string
          format: uuid
          nullable: true
          description: User/system that flagged the investor
        details:
          type: object
          description: Additional compliance flag details
          additionalProperties: true
        resolvedAt:
          type: string
          format: date-time
          nullable: true
          description: Resolution timestamp
        resolvedBy:
          type: string
          format: uuid
          nullable: true
          description: User who resolved the flag

    KycUpdatedPayload:
      type: object
      required:
        - investorId
        - status
        - updatedAt
      properties:
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [pass, fail, pending, review]
        reason:
          type: string
          nullable: true
        updatedAt:
          type: string
          format: date-time


```
---
# packages/contracts/openapi-compliance.yaml
```yaml
openapi: 3.1.0
info:
  title: Compliance Service API
  version: 1.0.0
  description: Compliance service для KYC, qualification и complaints
servers:
  - url: http://localhost:5008
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
  
  /v1/compliance/kyc/check:
    post:
      summary: Check KYC status for investor
      operationId: checkKyc
      tags:
        - Compliance
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycCheckRequest'
      responses:
        '200':
          description: KYC check result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/qualification/evaluate:
    post:
      summary: Evaluate investor qualification tier
      operationId: evaluateQualification
      tags:
        - Compliance
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QualificationEvaluateRequest'
      responses:
        '200':
          description: Qualification evaluation result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/investors/{id}/status:
    get:
      summary: Get compliance status for investor
      operationId: getInvestorStatus
      tags:
        - Compliance
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Investor compliance status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InvestorStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/compliance/kyc/investors/{id}/approve:
    post:
      summary: Approve KYC for investor
      operationId: approveKyc
      tags:
        - KYC
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: KYC updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'

  /v1/compliance/kyc/investors/{id}/reject:
    post:
      summary: Reject KYC for investor
      operationId: rejectKyc
      tags:
        - KYC
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: KYC updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'

  /v1/kyc/tasks:
    post:
      summary: Create KYC manual review task
      operationId: createKycTask
      tags:
        - KYC Tasks
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [investorId]
              properties:
                investorId:
                  type: string
                  format: uuid
                reason:
                  type: string
                  nullable: true
      responses:
        '201':
          description: Task created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
    get:
      summary: List KYC tasks
      operationId: listKycTasks
      tags:
        - KYC Tasks
      parameters:
        - name: status
          in: query
          schema:
            type: string
            enum: [open, approved, rejected]
      responses:
        '200':
          description: List of tasks
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycTask'

  /v1/kyc/tasks/{id}/approve:
    post:
      summary: Approve KYC task and investor
      operationId: approveKycTask
      tags:
        - KYC Tasks
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Task approved
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/kyc/tasks/{id}/reject:
    post:
      summary: Reject KYC task and investor
      operationId: rejectKycTask
      tags:
        - KYC Tasks
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Task rejected
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/complaints:
    post:
      summary: Create complaint
      operationId: createComplaint
      tags:
        - Complaints
      parameters:
        - name: Idempotency-Key
          in: header
          required: false
          schema:
            type: string
            format: uuid
          description: Idempotency key for duplicate prevention
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateComplaintRequest'
      responses:
        '201':
          description: Complaint created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/complaints/{id}:
    get:
      summary: Get complaint by ID
      operationId: getComplaint
      tags:
        - Complaints
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Complaint details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    KycCheckRequest:
      type: object
      required:
        - investorId
      properties:
        investorId:
          type: string
          format: uuid
    
    KycResult:
      type: object
      required:
        - investorId
        - status
      properties:
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [pass, fail, pending, review]
        checkedAt:
          type: string
          format: date-time
        reason:
          type: string
          nullable: true
    
    QualificationEvaluateRequest:
      type: object
      required:
        - investorId
        - amount
      properties:
        investorId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    QualificationResult:
      type: object
      required:
        - investorId
        - tier
        - allowed
      properties:
        investorId:
          type: string
          format: uuid
        tier:
          type: string
          enum: [unqualified, qualified, professional]
        limit:
          type: number
          format: decimal
          nullable: true
        used:
          type: number
          format: decimal
          nullable: true
        allowed:
          type: boolean
        reason:
          type: string
          nullable: true
        evaluatedAt:
          type: string
          format: date-time
    
    InvestorStatusResponse:
      type: object
      required:
        - investorId
        - kyc
        - qualificationTier
      properties:
        investorId:
          type: string
          format: uuid
        kyc:
          type: string
          enum: [pass, fail, pending, review]
        qualificationTier:
          type: string
          enum: [unqualified, qualified, professional]
        qualificationLimit:
          type: number
          format: decimal
          nullable: true
        qualificationUsed:
          type: number
          format: decimal
          nullable: true
        updatedAt:
          type: string
          format: date-time

    KycTask:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [open, approved, rejected]
        reason:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        resolvedAt:
          type: string
          format: date-time
          nullable: true
    
    CreateComplaintRequest:
      type: object
      required:
        - category
        - text
      properties:
        investorId:
          type: string
          format: uuid
          nullable: true
        category:
          type: string
          enum: [fraud, service, technical, other]
        text:
          type: string
          minLength: 10
          maxLength: 5000
    
    ComplaintResponse:
      type: object
      required:
        - id
        - status
        - createdAt
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
          nullable: true
        category:
          type: string
          enum: [fraud, service, technical, other]
        text:
          type: string
        status:
          type: string
          enum: [open, in_progress, resolved, closed]
        slaDue:
          type: string
          format: date-time
          nullable: true
        createdAt:
          type: string
          format: date-time
        resolvedAt:
          type: string
          format: date-time
          nullable: true
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'


```
---
# packages/contracts/openapi-gateway.yaml
```yaml
openapi: 3.1.0
info:
  title: OIS Gateway API
  version: 1.0.0
  description: API Gateway для оператора информационной системы ЦФА
  contact:
    name: OIS Support
servers:
  - url: http://localhost:5000
    description: Development
  - url: https://api.ois.example.com
    description: Production

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthStatus'
  
  /issuances:
    post:
      summary: Create draft issuance
      operationId: createIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateIssuanceRequest'
      responses:
        '201':
          description: Issuance created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
  
  /issuances/{id}:
    get:
      summary: Get issuance by ID
      operationId: getIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '404':
          $ref: '#/components/responses/NotFound'
    
  /issuances/{id}/publish:
    post:
      summary: Publish issuance
      operationId: publishIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance published
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /issuances/{id}/close:
    post:
      summary: Close issuance
      operationId: closeIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance closed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/orders:
    post:
      summary: Place buy order
      operationId: placeOrder
      tags:
        - Orders
      security:
        - BearerAuth: []
      parameters:
        - name: Idempotency-Key
          in: header
          required: true
          schema:
            type: string
            format: uuid
          description: Idempotency key to prevent duplicate orders
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        '202':
          description: Order accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '409':
          description: Order with this idempotency key already exists
  
  /orders/{id}:
    get:
      summary: Get order by ID
      operationId: getOrder
      tags:
        - Orders
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/wallets/{investorId}:
    get:
      summary: Get wallet portfolio
      operationId: getWallet
      tags:
        - Wallets
      security:
        - BearerAuth: []
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Wallet portfolio
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WalletResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/redeem:
    post:
      summary: Redeem issuance
      operationId: redeemIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RedeemRequest'
      responses:
        '200':
          description: Issuance redeemed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RedeemResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/settlement/run:
    post:
      summary: Run settlement for a specific date
      operationId: runSettlement
      tags:
        - Settlement
      security:
        - BearerAuth: []
      parameters:
        - name: date
          in: query
          schema:
            type: string
            format: date
          description: Date to run settlement for (YYYY-MM-DD). Defaults to today.
      responses:
        '202':
          description: Settlement accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SettlementResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/kyc/check:
    post:
      summary: Check KYC status
      operationId: checkKyc
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycCheckRequest'
      responses:
        '200':
          description: KYC check result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/qualification/evaluate:
    post:
      summary: Evaluate qualification
      operationId: evaluateQualification
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QualificationEvaluateRequest'
      responses:
        '200':
          description: Qualification result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/investors/{id}/status:
    get:
      summary: Get investor compliance status
      operationId: getInvestorStatus
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Investor status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InvestorStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/compliance/kyc:
    get:
      summary: List KYC requests (tasks)
      operationId: listKycRequests
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: status
          in: query
          required: false
          schema:
            type: string
            enum: [pending, approved, rejected]
          description: Filter by status
      responses:
        '200':
          description: List of KYC requests
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
    post:
      summary: Submit KYC application (investor/issuer)
      operationId: submitKycApplication
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycApplicationRequest'
      responses:
        '201':
          description: KYC application created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycRequest'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/compliance/kyc/{id}/decision:
    post:
      summary: Resolve KYC request (approve/reject)
      operationId: resolveKycRequest
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: KYC task identifier
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycDecisionRequest'
      responses:
        '200':
          description: Updated KYC request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycRequest'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/complaints:
    post:
      summary: Create complaint
      operationId: createComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: Idempotency-Key
          in: header
          required: false
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateComplaintRequest'
      responses:
        '201':
          description: Complaint created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/complaints/{id}:
    get:
      summary: Get complaint
      operationId: getComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Complaint details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/reports/payouts:
    get:
      summary: Get payouts report
      operationId: getPayoutsReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Payouts report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PayoutsReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'

  /v1/market/issuances:
    get:
      summary: List market issuances
      operationId: listMarketIssuances
      tags:
        - Market
      security:
        - BearerAuth: []
      parameters:
        - name: status
          in: query
          schema:
            type: string
            enum: [open, closed, all]
            default: open
          description: Filter by status
        - name: sort
          in: query
          schema:
            type: string
            enum: [-yield, yield, -maturityDate, maturityDate, -totalAmount, totalAmount]
            default: -yield
          description: Sort order (prefix - for descending)
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
          description: Page size
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
          description: Page offset
      responses:
        '200':
          description: Market issuances list
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MarketIssuancesResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/market/issuances/{id}:
    get:
      summary: Get market issuance details
      operationId: getMarketIssuance
      tags:
        - Market
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Issuance ID
      responses:
        '200':
          description: Market issuance details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MarketIssuanceCard'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/investors/{id}/transactions:
    get:
      summary: Get investor transaction history
      operationId: getInvestorTransactions
      tags:
        - Investors
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
        - name: type
          in: query
          schema:
            type: string
            enum: [transfer, redeem, issue, all]
            default: all
          description: Filter by transaction type
      responses:
        '200':
          description: Transaction history
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TransactionHistoryResponse'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/investors/{id}/payouts:
    get:
      summary: Get investor payout history
      operationId: getInvestorPayouts
      tags:
        - Investors
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Payout history
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PayoutHistoryResponse'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/reports/issuances:
    get:
      summary: Get issuer report for issuances
      operationId: getIssuerIssuancesReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: issuerId
          in: query
          required: true
          schema:
            type: string
            format: uuid
          description: Issuer ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Issuer issuances report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuerIssuancesReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/reports/issuer/payouts:
    get:
      summary: Get issuer payouts report
      operationId: getIssuerPayoutsReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: issuerId
          in: query
          required: true
          schema:
            type: string
            format: uuid
          description: Issuer ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
        - name: granularity
          in: query
          schema:
            type: string
            enum: [day, week, month, year]
            default: month
          description: Report granularity
      responses:
        '200':
          description: Issuer payouts report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuerPayoutsReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/audit:
    get:
      summary: Get audit events
      operationId: getAuditEvents
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: actor
          in: query
          schema:
            type: string
            format: uuid
          description: Filter by actor ID
        - name: action
          in: query
          schema:
            type: string
          description: Filter by action type
        - name: entity
          in: query
          schema:
            type: string
          description: Filter by entity type
        - name: from
          in: query
          schema:
            type: string
            format: date-time
          description: Start datetime
        - name: to
          in: query
          schema:
            type: string
            format: date-time
          description: End datetime
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
          description: Page size
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
          description: Page offset
      responses:
        '200':
          description: Audit events list
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuditEventsResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/audit/export.csv:
    get:
      summary: Export audit events as CSV
      operationId: exportAuditCsv
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: actor
          in: query
          schema:
            type: string
            format: uuid
        - name: action
          in: query
          schema:
            type: string
        - name: entity
          in: query
          schema:
            type: string
        - name: from
          in: query
          schema:
            type: string
            format: date-time
        - name: to
          in: query
          schema:
            type: string
            format: date-time
      responses:
        '200':
          description: CSV export
          content:
            text/csv:
              schema:
                type: string
                format: binary
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/audit/{id}:
    get:
      summary: Get audit event by ID
      operationId: getAuditEvent
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Audit event ID
      responses:
        '200':
          description: Audit event details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuditEvent'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/identity/users:
    get:
      summary: List users (Identity registry stub)
      operationId: listIdentityUsers
      tags:
        - Identity
      parameters:
        - name: query
          in: query
          required: false
          schema:
            type: string
          description: Filter by email/role
      responses:
        '200':
          description: List of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/IdentityUser'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/kyc/{investorId}/decision:
    post:
      summary: Make KYC decision
      operationId: makeKycDecision
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycDecisionRequest'
      responses:
        '200':
          description: KYC decision made
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycDecisionResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/kyc/{investorId}/documents:
    post:
      summary: Upload KYC documents
      operationId: uploadKycDocuments
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              required:
                - files
              properties:
                files:
                  type: array
                  items:
                    type: string
                    format: binary
                documentType:
                  type: string
                  enum: [passport, inn, snils, address_proof, income_proof, other]
                comment:
                  type: string
                  description: Optional comment
      responses:
        '201':
          description: Documents uploaded
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycDocumentsResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  parameters:
    IssuanceId:
      name: id
      in: path
      required: true
      schema:
        type: string
        format: uuid
      description: Issuance ID
  
  schemas:
    HealthStatus:
      type: object
      properties:
        status:
          type: string
          enum: [healthy, unhealthy]
        timestamp:
          type: string
          format: date-time
    
    CreateIssuanceRequest:
      type: object
      required:
        - assetId
        - issuerId
        - totalAmount
        - nominal
        - issueDate
        - maturityDate
      properties:
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        nominal:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        scheduleJson:
          type: object
          description: Payout schedule (optional)
    
    IssuanceResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
        nominal:
          type: number
          format: decimal
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        status:
          type: string
          enum: [draft, published, closed, redeemed]
        scheduleJson:
          type: object
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    RedeemRequest:
      type: object
      required:
        - amount
      properties:
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    RedeemResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        status:
          type: string
          enum: [redeemed, partial]
        redeemedAmount:
          type: number
          format: decimal
        remainingAmount:
          type: number
          format: decimal

    # Cross-file references to service schemas
    SettlementResponse:
      $ref: 'openapi-settlement.yaml#/components/schemas/SettlementResponse'
    KycCheckRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/KycCheckRequest'
    KycResult:
      $ref: 'openapi-compliance.yaml#/components/schemas/KycResult'
    QualificationEvaluateRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/QualificationEvaluateRequest'
    QualificationResult:
      $ref: 'openapi-compliance.yaml#/components/schemas/QualificationResult'
    InvestorStatusResponse:
      $ref: 'openapi-compliance.yaml#/components/schemas/InvestorStatusResponse'
    CreateComplaintRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/CreateComplaintRequest'
    ComplaintResponse:
      $ref: 'openapi-compliance.yaml#/components/schemas/ComplaintResponse'
    
    CreateOrderRequest:
      type: object
      required:
        - investorId
        - issuanceId
        - amount
      properties:
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    OrderResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [created, reserved, paid, failed, cancelled]
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    WalletResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        ownerType:
          type: string
          enum: [individual, legal_entity]
        ownerId:
          type: string
          format: uuid
        balance:
          type: number
          format: decimal
        blocked:
          type: number
          format: decimal
        holdings:
          type: array
          items:
            $ref: '#/components/schemas/Holding'
    
    Holding:
      type: object
      properties:
        assetId:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        amount:
          type: number
          format: decimal
    
    PayoutsReportResponse:
      type: object
      properties:
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        items:
          type: array
          items:
            $ref: '#/components/schemas/PayoutItem'
        totalAmount:
          type: number
          format: decimal
    
    PayoutItem:
      type: object
      properties:
        id:
          type: string
          format: uuid
        batchId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, executed, failed]
        executedAt:
          type: string
          format: date-time

    MarketIssuanceCard:
      type: object
      properties:
        id:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        issuerName:
          type: string
        totalAmount:
          type: number
          format: decimal
        nominal:
          type: number
          format: decimal
        availableAmount:
          type: number
          format: decimal
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        yield:
          type: number
          format: decimal
          description: Annual yield percentage
        status:
          type: string
          enum: [open, closed]
        publishedAt:
          type: string
          format: date-time
        scheduleJson:
          type: object
          description: Payout schedule

    MarketIssuancesResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/MarketIssuanceCard'
        total:
          type: integer
          description: Total count
        limit:
          type: integer
        offset:
          type: integer

    TxHistoryItem:
      type: object
      properties:
        id:
          type: string
          format: uuid
        type:
          type: string
          enum: [transfer, redeem, issue]
        issuanceId:
          type: string
          format: uuid
        issuanceCode:
          type: string
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, confirmed, failed]
        dltTxHash:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        confirmedAt:
          type: string
          format: date-time
          nullable: true

    TransactionHistoryResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/TxHistoryItem'
        total:
          type: integer

    PayoutHistoryResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/PayoutItem'
        total:
          type: integer
        totalAmount:
          type: number
          format: decimal

    IssuerReportRow:
      type: object
      properties:
        issuanceId:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        totalAmount:
          type: number
          format: decimal
        soldAmount:
          type: number
          format: decimal
        investorsCount:
          type: integer
        status:
          type: string
          enum: [draft, published, closed, redeemed]
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        publishedAt:
          type: string
          format: date-time
          nullable: true

    IssuerIssuancesReportResponse:
      type: object
      properties:
        issuerId:
          type: string
          format: uuid
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        items:
          type: array
          items:
            $ref: '#/components/schemas/IssuerReportRow'
        summary:
          type: object
          properties:
            totalIssuances:
              type: integer
            totalAmount:
              type: number
              format: decimal
            totalSold:
              type: number
              format: decimal
            totalInvestors:
              type: integer

    IssuerPayoutsReportResponse:
      type: object
      properties:
        issuerId:
          type: string
          format: uuid
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        granularity:
          type: string
          enum: [day, week, month, year]
        items:
          type: array
          items:
            type: object
            properties:
              period:
                type: string
                description: Period label (depends on granularity)
              totalAmount:
                type: number
                format: decimal
              payoutCount:
                type: integer
              investorsCount:
                type: integer
        summary:
          type: object
          properties:
            totalAmount:
              type: number
              format: decimal
            totalPayouts:
              type: integer
            totalInvestors:
              type: integer

    BrokerClient:
      type: object
      required: [id, name, email, kycStatus, qualificationStatus]
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
          description: Client name
        email:
          type: string
          format: email
        inn:
          type: string
          description: Tax ID (for legal entities)
        type:
          type: string
          enum: [individual, legal_entity]
        kycStatus:
          type: string
          enum: [pending, approved, rejected]
        qualificationStatus:
          type: string
          enum: [none, qualified, unqualified]
        createdAt:
          type: string
          format: date-time
        lastActivityAt:
          type: string
          format: date-time
          nullable: true

    BrokerClientsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/BrokerClient'
        total:
          type: integer
        limit:
          type: integer
        offset:
          type: integer

    CreateBrokerOrderRequest:
      type: object
      required: [clientId, issuanceId, amount]
      properties:
        clientId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true

    BrokerOrderResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        clientId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, confirmed, failed, cancelled]
        commission:
          type: number
          format: decimal
          description: Commission amount
        createdAt:
          type: string
          format: date-time

    CommissionRow:
      type: object
      properties:
        period:
          type: string
          description: Period label (YYYY-MM or YYYY-MM-DD)
        totalAmount:
          type: number
          format: decimal
          description: Total order amount
        commissionAmount:
          type: number
          format: decimal
          description: Commission earned
        ordersCount:
          type: integer
          description: Number of orders
        clientsCount:
          type: integer
          description: Number of unique clients

    CommissionsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/CommissionRow'
        total:
          type: integer
        totalAmount:
          type: number
          format: decimal
        totalCommission:
          type: number
          format: decimal

    FeedItem:
      type: object
      required: [id, type, timestamp]
      properties:
        id:
          type: string
          format: uuid
        type:
          type: string
          enum: [order, transfer, payout, kyc, qualification]
        title:
          type: string
          description: Event title
        description:
          type: string
          description: Event description
        clientId:
          type: string
          format: uuid
          nullable: true
        clientName:
          type: string
          nullable: true
        issuanceId:
          type: string
          format: uuid
          nullable: true
        amount:
          type: number
          format: decimal
          nullable: true
        status:
          type: string
          enum: [pending, completed, failed]
          nullable: true
        timestamp:
          type: string
          format: date-time
        metadata:
          type: object
          description: Additional event data
          additionalProperties: true

    FeedResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/FeedItem'
        total:
          type: integer
        hasMore:
          type: boolean

    AuditEvent:
      type: object
      required: [id, actor, action, entity, timestamp]
      properties:
        id:
          type: string
          format: uuid
        actor:
          type: string
          format: uuid
          description: User/system that performed the action
        actorName:
          type: string
          description: Actor name or identifier
        action:
          type: string
          description: Action type (e.g., 'create', 'update', 'delete', 'approve', 'reject')
        entity:
          type: string
          description: Entity type (e.g., 'issuance', 'order', 'kyc', 'investor')
        entityId:
          type: string
          format: uuid
          nullable: true
          description: Entity ID
        payload:
          type: object
          description: Additional event data
          additionalProperties: true
        ip:
          type: string
          format: ipv4
          nullable: true
          description: IP address
        userAgent:
          type: string
          nullable: true
          description: User agent string
        timestamp:
          type: string
          format: date-time
        result:
          type: string
          enum: [success, failure, pending]
          nullable: true
          description: Action result

    AuditEventsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/AuditEvent'
        total:
          type: integer
        limit:
          type: integer
        offset:
          type: integer

    KycDecisionRequest:
      type: object
      required: [decision]
      properties:
        decision:
          type: string
          enum: [approved, rejected]
          description: KYC decision status
        comment:
          type: string
          description: Optional decision comment/reason

    KycDecisionResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [approved, rejected]
        comment:
          type: string
        decisionBy:
          type: string
          format: uuid
          description: User who made the decision
        decisionAt:
          type: string
          format: date-time

    KycApplicationRequest:
      type: object
      properties:
        investorId:
          type: string
          format: uuid
          description: Optional investorId; will default to authenticated user
        fullName:
          type: string
          description: Full name of applicant
        documentType:
          type: string
          description: Document type (passport/inn/other)
        documentNumber:
          type: string
          description: Document number
        comment:
          type: string
          description: Additional comment for backoffice

    KycRequest:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [pending, approved, rejected]
        reason:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        resolvedAt:
          type: string
          format: date-time
          nullable: true
    KycDocument:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        documentType:
          type: string
          enum: [passport, inn, snils, address_proof, income_proof, other]
        fileName:
          type: string
        fileSize:
          type: integer
          description: File size in bytes
        mimeType:
          type: string
        storageUrl:
          type: string
          format: uri
          description: S3/MinIO storage URL
        uploadedAt:
          type: string
          format: date-time
        uploadedBy:
          type: string
          format: uuid
        comment:
          type: string
          nullable: true

    KycDocumentsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/KycDocument'
        total:
          type: integer

    IdentityUser:
      type: object
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        roles:
          type: array
          items:
            type: string
        status:
          type: string
          description: User status (active/blocked/invited)
        createdAt:
          type: string
          format: date-time
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
          example:
            type: "https://tools.ietf.org/html/rfc7807"
            title: "Bad Request"
            status: 400
            detail: "Invalid request parameters"
    
    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    Forbidden:
      description: Forbidden
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'

```
---
# packages/contracts/openapi-identity.yaml
```yaml
openapi: 3.1.0
info:
  title: Identity Service API
  version: 1.0.0
  description: Identity and authentication service (OIDC proxy)
servers:
  - url: http://localhost:5001
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, unhealthy]
  
  /.well-known/openid-configuration:
    get:
      summary: OpenID Connect configuration
      operationId: getOidcConfig
      tags:
        - OIDC
      responses:
        '200':
          description: OIDC configuration
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OidcConfiguration'
  
  /authorize:
    get:
      summary: OAuth2/OIDC authorization endpoint
      operationId: authorize
      tags:
        - OIDC
      parameters:
        - name: response_type
          in: query
          required: true
          schema:
            type: string
            enum: [code]
        - name: client_id
          in: query
          required: true
          schema:
            type: string
        - name: redirect_uri
          in: query
          required: true
          schema:
            type: string
            format: uri
        - name: scope
          in: query
          schema:
            type: string
            default: openid profile email
        - name: state
          in: query
          schema:
            type: string
      responses:
        '302':
          description: Redirect to ESIA or callback
        '400':
          description: Invalid request
  
  /token:
    post:
      summary: OAuth2 token endpoint
      operationId: token
      tags:
        - OIDC
      requestBody:
        required: true
        content:
          application/x-www-form-urlencoded:
            schema:
              type: object
              required:
                - grant_type
                - code
                - redirect_uri
                - client_id
              properties:
                grant_type:
                  type: string
                  enum: [authorization_code]
                code:
                  type: string
                redirect_uri:
                  type: string
                client_id:
                  type: string
      responses:
        '200':
          description: Token response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TokenResponse'
        '400':
          description: Invalid request
        '401':
          description: Unauthorized
  
  /userinfo:
    get:
      summary: Get user info
      operationId: getUserInfo
      tags:
        - OIDC
      security:
        - BearerAuth: []
      responses:
        '200':
          description: User information
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserInfo'
        '401':
          description: Unauthorized
  
  /users:
    get:
      summary: List users
      operationId: listUsers
      tags:
        - Users
      security:
        - BearerAuth: []
      parameters:
        - name: email
          in: query
          schema:
            type: string
        - name: role
          in: query
          schema:
            type: string
            enum: [issuer, investor, admin]
        - name: status
          in: query
          schema:
            type: string
            enum: [active, inactive, suspended, blocked]
      responses:
        '200':
          description: List of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
        '401':
          description: Unauthorized
  
  /users/{id}:
    get:
      summary: Get user by ID
      operationId: getUser
      tags:
        - Users
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: User details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          description: User not found

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    OidcConfiguration:
      type: object
      properties:
        issuer:
          type: string
          format: uri
        authorization_endpoint:
          type: string
          format: uri
        token_endpoint:
          type: string
          format: uri
        userinfo_endpoint:
          type: string
          format: uri
        jwks_uri:
          type: string
          format: uri
        response_types_supported:
          type: array
          items:
            type: string
        scopes_supported:
          type: array
          items:
            type: string
    
    TokenResponse:
      type: object
      properties:
        access_token:
          type: string
        token_type:
          type: string
          default: Bearer
        expires_in:
          type: integer
        refresh_token:
          type: string
        id_token:
          type: string
        scope:
          type: string
    
    UserInfo:
      type: object
      properties:
        sub:
          type: string
          description: Subject (user ID)
        email:
          type: string
          format: email
        email_verified:
          type: boolean
        name:
          type: string
        given_name:
          type: string
        family_name:
          type: string
        middle_name:
          type: string
        picture:
          type: string
          format: uri
    
    User:
      type: object
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        role:
          type: string
          enum: [issuer, investor, admin]
        status:
          type: string
          enum: [active, inactive, suspended, blocked]
        createdAt:
          type: string
          format: date-time
        lastLogin:
          type: string
          format: date-time


```
---
# packages/contracts/openapi-integrations-bank.yaml
```yaml
openapi: 3.1.0
info:
  title: Bank Nominal Account API
  version: 1.0.0
  description: Адаптер номинального счёта и аналитического учёта (mock)
servers:
  - url: http://localhost:5003
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, unhealthy]
  
  /nominal/accounts:
    post:
      summary: Открыть номинальный счёт
      operationId: createNominalAccount
      tags:
        - Nominal Accounts
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateNominalAccountRequest'
      responses:
        '201':
          description: Счёт создан
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NominalAccountResponse'
        '400':
          description: Bad request
        '409':
          description: Account already exists
  
  /nominal/accounts/{accountId}:
    get:
      summary: Get nominal account
      operationId: getNominalAccount
      tags:
        - Nominal Accounts
      security:
        - BearerAuth: []
      parameters:
        - name: accountId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Account details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NominalAccountResponse'
        '404':
          description: Account not found
  
  /nominal/transfer:
    post:
      summary: Перевод средств (с идемпотентностью)
      operationId: transfer
      tags:
        - Transfers
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TransferRequest'
      responses:
        '200':
          description: Перевод проведён
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TransferResponse'
        '400':
          description: Bad request
        '409':
          description: Idempotency key conflict (already processed)
        '422':
          description: Insufficient funds or invalid account

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    CreateNominalAccountRequest:
      type: object
      required:
        - issuerId
        - accountType
      properties:
        issuerId:
          type: string
          format: uuid
        accountType:
          type: string
          enum: [nominal, analytical]
        currency:
          type: string
          default: RUB
        metadata:
          type: object
          description: Additional account metadata
    
    NominalAccountResponse:
      type: object
      properties:
        accountId:
          type: string
        issuerId:
          type: string
          format: uuid
        accountType:
          type: string
          enum: [nominal, analytical]
        currency:
          type: string
        balance:
          type: number
          format: decimal
        status:
          type: string
          enum: [active, frozen, closed]
        createdAt:
          type: string
          format: date-time
    
    TransferRequest:
      type: object
      required:
        - fromAccountId
        - toAccountId
        - amount
        - idempotencyKey
      properties:
        fromAccountId:
          type: string
        toAccountId:
          type: string
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        currency:
          type: string
          default: RUB
        idempotencyKey:
          type: string
          format: uuid
          description: Unique key for idempotency
        description:
          type: string
        metadata:
          type: object
    
    TransferResponse:
      type: object
      properties:
        transferId:
          type: string
          format: uuid
        fromAccountId:
          type: string
        toAccountId:
          type: string
        amount:
          type: number
          format: decimal
        currency:
          type: string
        status:
          type: string
          enum: [completed, pending, failed]
        executedAt:
          type: string
          format: date-time
        idempotencyKey:
          type: string
          format: uuid


```
---
# packages/contracts/openapi-integrations-edo.yaml
```yaml
openapi: 3.1.0
info:
  title: EDO Connector API
  version: 1.0.0
  description: Интеграция с ЭДО (Диадок/СБИС/1С) - mock UKEP
servers:
  - url: http://localhost:5004
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, unhealthy]
  
  /documents:
    post:
      summary: Отправить документ на подпись (UKEP)
      operationId: uploadDocument
      tags:
        - Documents
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              required:
                - file
                - documentType
              properties:
                file:
                  type: string
                  format: binary
                documentType:
                  type: string
                  enum: [rules, issuance_decision, payout_schedule]
                metadata:
                  type: object
                  description: Additional document metadata
      responses:
        '202':
          description: Документ принят на обработку
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentResponse'
        '400':
          description: Bad request
  
  /documents/{id}:
    get:
      summary: Get document by ID
      operationId: getDocument
      tags:
        - Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Document details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentResponse'
        '404':
          description: Document not found
  
  /documents/{id}/status:
    get:
      summary: Статус документа
      operationId: getDocumentStatus
      tags:
        - Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Document status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentStatusResponse'
        '404':
          description: Document not found
  
  /documents/{id}/sign:
    post:
      summary: Подписать документ (mock UKEP)
      operationId: signDocument
      tags:
        - Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                signerId:
                  type: string
                  format: uuid
                signatureType:
                  type: string
                  enum: [ukep, simple]
      responses:
        '200':
          description: Document signed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SignedDocumentResponse'
        '400':
          description: Bad request
        '404':
          description: Document not found

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    DocumentResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        documentType:
          type: string
          enum: [rules, issuance_decision, payout_schedule]
        fileName:
          type: string
        fileSize:
          type: integer
        status:
          type: string
          enum: [uploaded, processing, signed, failed]
        uploadedAt:
          type: string
          format: date-time
        signedAt:
          type: string
          format: date-time
          nullable: true
        metadata:
          type: object
    
    DocumentStatusResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        status:
          type: string
          enum: [uploaded, processing, signed, failed]
        signature:
          type: object
          nullable: true
          properties:
            signerId:
              type: string
              format: uuid
            signedAt:
              type: string
              format: date-time
            signatureType:
              type: string
              enum: [ukep, simple]
            signatureValue:
              type: string
        error:
          type: string
          nullable: true
    
    SignedDocumentResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        status:
          type: string
          enum: [signed]
        signature:
          type: object
          properties:
            signerId:
              type: string
              format: uuid
            signedAt:
              type: string
              format: date-time
            signatureType:
              type: string
              enum: [ukep, simple]
            signatureValue:
              type: string
            certificateInfo:
              type: object
              properties:
                serialNumber:
                  type: string
                issuer:
                  type: string
                validFrom:
                  type: string
                  format: date-time
                validTo:
                  type: string
                  format: date-time


```
---
# packages/contracts/openapi-integrations-esia.yaml
```yaml
openapi: 3.1.0
info:
  title: ESIA Adapter API
  version: 1.0.0
  description: ЕСИА адаптер - OIDC и профиль пользователя (mock для dev)
servers:
  - url: http://localhost:5002
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, unhealthy]
  
  /oidc/authorize:
    get:
      summary: OIDC authorization (redirect to ESIA or mock)
      operationId: authorize
      tags:
        - OIDC
      parameters:
        - name: response_type
          in: query
          required: true
          schema:
            type: string
        - name: client_id
          in: query
          required: true
          schema:
            type: string
        - name: redirect_uri
          in: query
          required: true
          schema:
            type: string
            format: uri
        - name: scope
          in: query
          schema:
            type: string
        - name: state
          in: query
          schema:
            type: string
      responses:
        '302':
          description: Redirect to ESIA or mock callback
        '400':
          description: Invalid request
  
  /oidc/callback:
    post:
      summary: OIDC callback handler
      operationId: callback
      tags:
        - OIDC
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                code:
                  type: string
                state:
                  type: string
      responses:
        '200':
          description: Callback processed
          content:
            application/json:
              schema:
                type: object
                properties:
                  code:
                    type: string
                  state:
                    type: string
        '400':
          description: Invalid callback
  
  /profile:
    get:
      summary: Get ESIA profile (mock)
      operationId: getProfile
      tags:
        - Profile
      security:
        - BearerAuth: []
      parameters:
        - name: snils
          in: query
          schema:
            type: string
            description: СНИЛС для поиска
      responses:
        '200':
          description: ESIA profile
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EsiaProfile'
        '401':
          description: Unauthorized
        '404':
          description: Profile not found

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    EsiaProfile:
      type: object
      properties:
        snils:
          type: string
          description: СНИЛС
        firstName:
          type: string
        lastName:
          type: string
        middleName:
          type: string
        birthDate:
          type: string
          format: date
        passport:
          type: object
          properties:
            series:
              type: string
            number:
              type: string
            issuedBy:
              type: string
            issuedDate:
              type: string
              format: date
        address:
          type: object
          properties:
            registration:
              type: string
            residence:
              type: string
        contacts:
          type: object
          properties:
            email:
              type: string
              format: email
            phone:
              type: string


```
---
# packages/contracts/openapi-issuance.yaml
```yaml
openapi: 3.1.0
info:
  title: Issuance Service API
  version: 1.0.0
  description: Issuance service для управления выпусками ЦФА
servers:
  - url: http://localhost:5005
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
  
  /v1/issuances:
    post:
      summary: Create draft issuance
      operationId: createIssuance
      tags:
        - Issuances
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateIssuanceRequest'
      responses:
        '201':
          description: Issuance created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/issuances/{id}:
    get:
      summary: Get issuance by ID
      operationId: getIssuance
      tags:
        - Issuances
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Issuance details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/publish:
    post:
      summary: Publish issuance
      operationId: publishIssuance
      tags:
        - Issuances
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Issuance published
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/close:
    post:
      summary: Close issuance
      operationId: closeIssuance
      tags:
        - Issuances
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Issuance closed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    CreateIssuanceRequest:
      type: object
      required:
        - assetId
        - issuerId
        - totalAmount
        - nominal
        - issueDate
        - maturityDate
      properties:
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        nominal:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        scheduleJson:
          type: object
          additionalProperties: true
    
    IssuanceResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
        nominal:
          type: number
          format: decimal
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        status:
          type: string
          enum: [draft, published, closed, redeemed]
        scheduleJson:
          type: object
          additionalProperties: true
          nullable: true
        dltTxHash:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
        publishedAt:
          type: string
          format: date-time
          nullable: true
        closedAt:
          type: string
          format: date-time
          nullable: true
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'


```
---
# packages/contracts/openapi-registry.yaml
```yaml
openapi: 3.1.0
info:
  title: Registry Service API
  version: 1.0.0
  description: Registry service для управления заказами, кошельками и операциями с ЦФА
servers:
  - url: http://localhost:5006
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
  
  /v1/orders:
    post:
      summary: Place buy order
      operationId: placeOrder
      tags:
        - Orders
      parameters:
        - name: Idempotency-Key
          in: header
          required: true
          schema:
            type: string
            format: uuid
          description: Idempotency key to prevent duplicate orders
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        '202':
          description: Order accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '409':
          description: Order with this idempotency key already exists
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProblemDetails'
  
  /v1/orders/{id}:
    get:
      summary: Get order by ID
      operationId: getOrder
      tags:
        - Orders
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/orders/{id}/cancel:
    post:
      summary: Cancel order
      operationId: cancelOrder
      tags:
        - Orders
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order cancelled
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/orders/{id}/mark-paid:
    post:
      summary: Mark order as paid
      operationId: markOrderPaid
      tags:
        - Orders
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order paid
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/wallets/{investorId}:
    get:
      summary: Get wallet portfolio
      operationId: getWallet
      tags:
        - Wallets
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Wallet portfolio
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WalletResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/redeem:
    post:
      summary: Redeem issuance
      operationId: redeemIssuance
      tags:
        - Issuances
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RedeemRequest'
      responses:
        '200':
          description: Issuance redeemed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RedeemResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    CreateOrderRequest:
      type: object
      required:
        - investorId
        - issuanceId
        - amount
      properties:
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    OrderResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [created, reserved, paid, failed, cancelled]
        walletId:
          type: string
          format: uuid
          nullable: true
        dltTxHash:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
        confirmedAt:
          type: string
          format: date-time
          nullable: true
        failureReason:
          type: string
          nullable: true
    
    WalletResponse:
      type: object
      properties:
        investorId:
          type: string
          format: uuid
        balance:
          type: number
          format: decimal
        blocked:
          type: number
          format: decimal
        holdings:
          type: array
          items:
            $ref: '#/components/schemas/Holding'
    
    Holding:
      type: object
      properties:
        issuanceId:
          type: string
          format: uuid
        quantity:
          type: number
          format: decimal
        updatedAt:
          type: string
          format: date-time
    
    RedeemRequest:
      type: object
      required:
        - amount
      properties:
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    RedeemResponse:
      type: object
      properties:
        issuanceId:
          type: string
          format: uuid
        redeemedAmount:
          type: number
          format: decimal
        dltTxHash:
          type: string
        redeemedAt:
          type: string
          format: date-time
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'


```
---
# packages/contracts/openapi-settlement.yaml
```yaml
openapi: 3.1.0
info:
  title: Settlement Service API
  version: 1.0.0
  description: Settlement service для batch payouts и reconciliation
servers:
  - url: http://localhost:5007
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
  
  /v1/settlement/run:
    post:
      summary: Run settlement for a specific date
      operationId: runSettlement
      tags:
        - Settlement
      parameters:
        - name: date
          in: query
          schema:
            type: string
            format: date
          description: Date to run settlement for (YYYY-MM-DD). Defaults to today.
      responses:
        '202':
          description: Settlement accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SettlementResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/reports/payouts:
    get:
      summary: Get payouts report
      operationId: getPayoutsReport
      tags:
        - Reports
      parameters:
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Payouts report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PayoutsReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'

components:
  schemas:
    SettlementResponse:
      type: object
      properties:
        batchId:
          type: string
          format: uuid
        runDate:
          type: string
          format: date
        issuanceId:
          type: string
          format: uuid
          nullable: true
        totalAmount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, processing, completed, failed]
        itemCount:
          type: integer
        createdAt:
          type: string
          format: date-time
    
    PayoutsReportResponse:
      type: object
      properties:
        from:
          type: string
          format: date
        to:
          type: string
          format: date
        totalBatches:
          type: integer
        totalAmount:
          type: number
          format: decimal
        totalItems:
          type: integer
        completedItems:
          type: integer
        failedItems:
          type: integer
        batches:
          type: array
          items:
            $ref: '#/components/schemas/PayoutBatch'
    
    PayoutBatch:
      type: object
      properties:
        id:
          type: string
          format: uuid
        runDate:
          type: string
          format: date
        issuanceId:
          type: string
          format: uuid
          nullable: true
        totalAmount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, processing, completed, failed]
        itemCount:
          type: integer
        completedCount:
          type: integer
        failedCount:
          type: integer
        createdAt:
          type: string
          format: date-time
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'


```
---
# packages/contracts/schemas/AuditEvent.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "AuditEvent",
  "description": "Схема события аудита",
  "type": "object",
  "required": ["id", "actorId", "action", "entity", "timestamp"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор события аудита"
    },
    "actorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор пользователя, выполнившего действие"
    },
    "action": {
      "type": "string",
      "enum": ["create", "update", "delete", "read", "execute"],
      "description": "Тип действия"
    },
    "entity": {
      "type": "string",
      "enum": ["issuance", "order", "wallet", "payout", "user", "asset", "transfer"],
      "description": "Тип сущности"
    },
    "entityId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор сущности"
    },
    "payload": {
      "type": ["object", "null"],
      "description": "Дополнительные данные события (изменённые поля, значения и т.д.)"
    },
    "ip": {
      "type": ["string", "null"],
      "format": "ipv4",
      "description": "IP-адрес источника запроса"
    },
    "userAgent": {
      "type": ["string", "null"],
      "description": "User-Agent браузера/клиента"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "Временная метка события"
    },
    "correlationId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор корреляции запроса"
    },
    "result": {
      "type": ["string", "null"],
      "enum": ["success", "failure", "denied"],
      "description": "Результат действия"
    },
    "errorMessage": {
      "type": ["string", "null"],
      "description": "Сообщение об ошибке (если результат failure)"
    }
  }
}


```
---
# packages/contracts/schemas/BrokerClient.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "BrokerClient",
  "description": "Клиент брокера",
  "type": "object",
  "required": ["id", "name", "email", "kycStatus", "qualificationStatus"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "name": {
      "type": "string",
      "description": "Имя клиента"
    },
    "email": {
      "type": "string",
      "format": "email"
    },
    "inn": {
      "type": "string",
      "description": "ИНН (для юридических лиц)"
    },
    "type": {
      "type": "string",
      "enum": ["individual", "legal_entity"],
      "description": "Тип клиента"
    },
    "kycStatus": {
      "type": "string",
      "enum": ["pending", "approved", "rejected"],
      "description": "Статус KYC"
    },
    "qualificationStatus": {
      "type": "string",
      "enum": ["none", "qualified", "unqualified"],
      "description": "Статус квалификации инвестора"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time"
    },
    "lastActivityAt": {
      "type": ["string", "null"],
      "format": "date-time"
    }
  }
}


```
---
# packages/contracts/schemas/BrokerOrder.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "BrokerOrder",
  "description": "Заявка брокера от имени клиента",
  "type": "object",
  "required": ["id", "clientId", "issuanceId", "amount", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "clientId": {
      "type": "string",
      "format": "uuid"
    },
    "issuanceId": {
      "type": "string",
      "format": "uuid"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0
    },
    "status": {
      "type": "string",
      "enum": ["pending", "confirmed", "failed", "cancelled"]
    },
    "commission": {
      "type": "number",
      "format": "decimal",
      "description": "Сумма комиссии"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time"
    },
    "brokerId": {
      "type": "string",
      "format": "uuid",
      "description": "ID брокера, создавшего заявку"
    }
  }
}


```
---
# packages/contracts/schemas/CFA.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CFA (Digital Financial Asset)",
  "description": "Схема цифрового финансового актива",
  "type": "object",
  "required": ["id", "code", "name", "type", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор ЦФА"
    },
    "code": {
      "type": "string",
      "pattern": "^[A-Z0-9]{3,20}$",
      "description": "Код ЦФА (символ)"
    },
    "name": {
      "type": "string",
      "minLength": 1,
      "maxLength": 200,
      "description": "Наименование ЦФА"
    },
    "type": {
      "type": "string",
      "enum": ["TOKEN", "BOND", "SHARE", "MONETARY_CLAIM", "OTHER"],
      "description": "Тип ЦФА"
    },
    "description": {
      "type": "string",
      "maxLength": 5000,
      "description": "Описание ЦФА"
    },
    "issuerId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор эмитента"
    },
    "totalSupply": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Общий объём выпуска"
    },
    "issuedAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Выпущенный объём"
    },
    "status": {
      "type": "string",
      "enum": ["DRAFT", "ACTIVE", "SUSPENDED", "CANCELLED"],
      "description": "Статус ЦФА"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата обновления"
    },
    "activatedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата активации"
    }
  }
}


```
---
# packages/contracts/schemas/CommissionRow.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CommissionRow",
  "description": "Строка отчета по комиссиям брокера",
  "type": "object",
  "required": ["period", "totalAmount", "commissionAmount", "ordersCount"],
  "properties": {
    "period": {
      "type": "string",
      "description": "Период (YYYY-MM или YYYY-MM-DD)"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Общая сумма заявок"
    },
    "commissionAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Заработанная комиссия"
    },
    "ordersCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество заявок"
    },
    "clientsCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество уникальных клиентов"
    }
  }
}


```
---
# packages/contracts/schemas/Complaint.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Complaint",
  "description": "Схема жалобы",
  "type": "object",
  "required": ["id", "category", "text", "status", "createdAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор жалобы"
    },
    "investorId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор инвестора (null для анонимных)"
    },
    "category": {
      "type": "string",
      "enum": ["fraud", "service", "technical", "other"],
      "description": "Категория жалобы"
    },
    "text": {
      "type": "string",
      "minLength": 10,
      "maxLength": 5000,
      "description": "Текст жалобы"
    },
    "status": {
      "type": "string",
      "enum": ["open", "in_progress", "resolved", "closed"],
      "description": "Статус обработки"
    },
    "slaDue": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Срок SLA"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания"
    },
    "resolvedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата разрешения"
    }
  }
}


```
---
# packages/contracts/schemas/FeedItem.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "FeedItem",
  "description": "Элемент ленты активности брокера",
  "type": "object",
  "required": ["id", "type", "timestamp"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "type": {
      "type": "string",
      "enum": ["order", "transfer", "payout", "kyc", "qualification"],
      "description": "Тип события"
    },
    "title": {
      "type": "string",
      "description": "Заголовок события"
    },
    "description": {
      "type": "string",
      "description": "Описание события"
    },
    "clientId": {
      "type": ["string", "null"],
      "format": "uuid"
    },
    "clientName": {
      "type": ["string", "null"]
    },
    "issuanceId": {
      "type": ["string", "null"],
      "format": "uuid"
    },
    "amount": {
      "type": ["number", "null"],
      "format": "decimal"
    },
    "status": {
      "type": ["string", "null"],
      "enum": ["pending", "completed", "failed"]
    },
    "timestamp": {
      "type": "string",
      "format": "date-time"
    },
    "metadata": {
      "type": "object",
      "description": "Дополнительные данные события",
      "additionalProperties": true
    }
  }
}


```
---
# packages/contracts/schemas/Holding.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Holding",
  "description": "Схема владения ЦФА",
  "type": "object",
  "required": ["issuanceId", "quantity"],
  "properties": {
    "issuanceId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор выпуска"
    },
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "quantity": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Количество ЦФА"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата последнего обновления"
    }
  }
}


```
---
# packages/contracts/schemas/Issuance.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Issuance",
  "description": "Схема выпуска ЦФА",
  "type": "object",
  "required": ["id", "assetId", "issuerId", "totalAmount", "nominal", "issueDate", "maturityDate", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор выпуска"
    },
    "assetId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор ЦФА"
    },
    "issuerId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор эмитента"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Общая сумма выпуска"
    },
    "nominal": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Номинальная стоимость единицы"
    },
    "issueDate": {
      "type": "string",
      "format": "date",
      "description": "Дата выпуска"
    },
    "maturityDate": {
      "type": "string",
      "format": "date",
      "description": "Дата погашения"
    },
    "status": {
      "type": "string",
      "enum": ["draft", "published", "closed", "redeemed"],
      "description": "Статус выпуска"
    },
    "scheduleJson": {
      "type": ["object", "null"],
      "description": "График выплат (JSON объект)"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата обновления"
    },
    "publishedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата публикации"
    },
    "closedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата закрытия"
    }
  }
}


```
---
# packages/contracts/schemas/IssuerReportRow.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "IssuerReportRow",
  "description": "Строка отчета эмитента по выпускам",
  "type": "object",
  "required": ["issuanceId", "assetCode", "assetName", "totalAmount", "soldAmount", "investorsCount", "status", "issueDate", "maturityDate"],
  "properties": {
    "issuanceId": {
      "type": "string",
      "format": "uuid"
    },
    "assetCode": {
      "type": "string"
    },
    "assetName": {
      "type": "string"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0
    },
    "soldAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Проданная сумма"
    },
    "investorsCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество инвесторов"
    },
    "status": {
      "type": "string",
      "enum": ["draft", "published", "closed", "redeemed"]
    },
    "issueDate": {
      "type": "string",
      "format": "date"
    },
    "maturityDate": {
      "type": "string",
      "format": "date"
    },
    "publishedAt": {
      "type": ["string", "null"],
      "format": "date-time"
    }
  }
}


```
---
# packages/contracts/schemas/KycDecision.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "KycDecision",
  "description": "Решение по KYC",
  "type": "object",
  "required": ["id", "investorId", "status", "comment", "decisionBy", "decisionAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "investorId": {
      "type": "string",
      "format": "uuid"
    },
    "status": {
      "type": "string",
      "enum": ["approved", "rejected"],
      "description": "Статус решения"
    },
    "comment": {
      "type": "string",
      "description": "Комментарий к решению"
    },
    "decisionBy": {
      "type": "string",
      "format": "uuid",
      "description": "ID пользователя, принявшего решение"
    },
    "decisionAt": {
      "type": "string",
      "format": "date-time"
    }
  }
}


```
---
# packages/contracts/schemas/KycDocument.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "KycDocument",
  "description": "Документ KYC",
  "type": "object",
  "required": ["id", "investorId", "documentType", "fileName", "storageUrl", "uploadedAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "investorId": {
      "type": "string",
      "format": "uuid"
    },
    "documentType": {
      "type": "string",
      "enum": ["passport", "inn", "snils", "address_proof", "income_proof", "other"],
      "description": "Тип документа"
    },
    "fileName": {
      "type": "string",
      "description": "Имя файла"
    },
    "fileSize": {
      "type": "integer",
      "minimum": 0,
      "description": "Размер файла в байтах"
    },
    "mimeType": {
      "type": "string",
      "description": "MIME тип файла"
    },
    "storageUrl": {
      "type": "string",
      "format": "uri",
      "description": "URL в хранилище (S3/MinIO)"
    },
    "uploadedAt": {
      "type": "string",
      "format": "date-time"
    },
    "uploadedBy": {
      "type": "string",
      "format": "uuid",
      "description": "ID пользователя, загрузившего документ"
    },
    "comment": {
      "type": ["string", "null"],
      "description": "Комментарий к документу"
    }
  }
}


```
---
# packages/contracts/schemas/KycResult.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "KycResult",
  "description": "Результат проверки KYC",
  "type": "object",
  "required": ["investorId", "status"],
  "properties": {
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "status": {
      "type": "string",
      "enum": ["pass", "fail", "pending", "review"],
      "description": "Статус KYC"
    },
    "checkedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Время проверки"
    },
    "reason": {
      "type": ["string", "null"],
      "description": "Причина (если status=fail или review)"
    }
  }
}


```
---
# packages/contracts/schemas/MarketIssuanceCard.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "MarketIssuanceCard",
  "description": "Карточка выпуска для каталога",
  "type": "object",
  "required": ["id", "assetCode", "assetName", "issuerName", "totalAmount", "nominal", "issueDate", "maturityDate", "yield", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "assetCode": {
      "type": "string",
      "description": "Код актива"
    },
    "assetName": {
      "type": "string",
      "description": "Название актива"
    },
    "issuerName": {
      "type": "string",
      "description": "Название эмитента"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0
    },
    "nominal": {
      "type": "number",
      "format": "decimal",
      "minimum": 0
    },
    "availableAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Доступная для покупки сумма"
    },
    "issueDate": {
      "type": "string",
      "format": "date"
    },
    "maturityDate": {
      "type": "string",
      "format": "date"
    },
    "yield": {
      "type": "number",
      "format": "decimal",
      "description": "Годовая доходность в процентах"
    },
    "status": {
      "type": "string",
      "enum": ["open", "closed"],
      "description": "Статус выпуска на рынке"
    },
    "publishedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата публикации"
    },
    "scheduleJson": {
      "type": ["object", "null"],
      "description": "График выплат"
    }
  }
}


```
---
# packages/contracts/schemas/Order.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Order",
  "description": "Схема заказа на покупку ЦФА",
  "type": "object",
  "required": ["id", "investorId", "issuanceId", "amount", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор заказа"
    },
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "issuanceId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор выпуска"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Сумма заказа"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "confirmed", "failed", "cancelled"],
      "description": "Статус заказа"
    },
    "walletId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор кошелька после подтверждения"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания заказа"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата обновления"
    },
    "confirmedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата подтверждения"
    },
    "failureReason": {
      "type": ["string", "null"],
      "description": "Причина отказа (если статус failed)"
    },
    "idemKey": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Ключ идемпотентности"
    }
  }
}


```
---
# packages/contracts/schemas/Payout.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Payout",
  "description": "Схема выплаты по ЦФА",
  "type": "object",
  "required": ["id", "batchId", "issuanceId", "investorId", "amount", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор выплаты"
    },
    "batchId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор пакета выплат"
    },
    "issuanceId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор выпуска"
    },
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Сумма выплаты"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "executed", "failed"],
      "description": "Статус выплаты"
    },
    "scheduledFor": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Запланированная дата выплаты"
    },
    "executedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата выполнения выплаты"
    },
    "bankTransferId": {
      "type": ["string", "null"],
      "description": "Идентификатор банковского перевода"
    },
    "failureReason": {
      "type": ["string", "null"],
      "description": "Причина ошибки (если статус failed)"
    },
    "metadata": {
      "type": ["object", "null"],
      "description": "Дополнительные данные выплаты"
    }
  }
}


```
---
# packages/contracts/schemas/PayoutBatch.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "PayoutBatch",
  "description": "Схема batch payout",
  "type": "object",
  "required": ["id", "runDate", "totalAmount", "status", "createdAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор batch"
    },
    "runDate": {
      "type": "string",
      "format": "date",
      "description": "Дата выполнения settlement"
    },
    "issuanceId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор выпуска (null если batch для нескольких)"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Общая сумма выплат"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "processing", "completed", "failed"],
      "description": "Статус batch"
    },
    "itemCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество items в batch"
    },
    "completedCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество успешно выполненных items"
    },
    "failedCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество failed items"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания batch"
    }
  }
}


```
---
# packages/contracts/schemas/PayoutItem.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "PayoutItem",
  "description": "Схема item в batch payout",
  "type": "object",
  "required": ["id", "investorId", "amount", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор item"
    },
    "batchId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор batch"
    },
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Сумма выплаты"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "completed", "failed"],
      "description": "Статус выплаты"
    },
    "bankRef": {
      "type": ["string", "null"],
      "description": "Ссылка на банковскую операцию"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "failureReason": {
      "type": ["string", "null"],
      "description": "Причина ошибки (если status=failed)"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания item"
    }
  }
}


```
---
# packages/contracts/schemas/QualificationResult.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "QualificationResult",
  "description": "Результат оценки квалификации инвестора",
  "type": "object",
  "required": ["investorId", "tier", "allowed"],
  "properties": {
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "tier": {
      "type": "string",
      "enum": ["unqualified", "qualified", "professional"],
      "description": "Уровень квалификации"
    },
    "limit": {
      "type": ["number", "null"],
      "format": "decimal",
      "minimum": 0,
      "description": "Лимит инвестирования (null для unqualified)"
    },
    "used": {
      "type": ["number", "null"],
      "format": "decimal",
      "minimum": 0,
      "description": "Использованный лимит"
    },
    "allowed": {
      "type": "boolean",
      "description": "Разрешена ли операция"
    },
    "reason": {
      "type": ["string", "null"],
      "description": "Причина отказа (если allowed=false)"
    },
    "evaluatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Время оценки"
    }
  }
}


```
---
# packages/contracts/schemas/ReconciliationReport.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ReconciliationReport",
  "description": "Схема отчёта по reconciliation",
  "type": "object",
  "required": ["batchId", "runDate", "reconciledAt"],
  "properties": {
    "batchId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор batch"
    },
    "runDate": {
      "type": "string",
      "format": "date",
      "description": "Дата settlement"
    },
    "reconciledAt": {
      "type": "string",
      "format": "date-time",
      "description": "Время reconciliation"
    },
    "payload": {
      "type": "object",
      "description": "JSON payload с деталями reconciliation",
      "additionalProperties": true
    },
    "status": {
      "type": "string",
      "enum": ["matched", "mismatch", "partial"],
      "description": "Статус reconciliation"
    }
  }
}


```
---
# packages/contracts/schemas/RegistryTx.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "RegistryTx",
  "description": "Схема транзакции в реестре",
  "type": "object",
  "required": ["id", "type", "amount", "status", "createdAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор транзакции"
    },
    "type": {
      "type": "string",
      "enum": ["transfer", "redeem", "issue"],
      "description": "Тип транзакции"
    },
    "fromWalletId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор кошелька отправителя (null для issue)"
    },
    "toWalletId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор кошелька получателя (null для redeem)"
    },
    "issuanceId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор выпуска"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Сумма транзакции"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "confirmed", "failed"],
      "description": "Статус транзакции"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания транзакции"
    },
    "confirmedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата подтверждения транзакции"
    }
  }
}


```
---
# packages/contracts/schemas/TxHistoryItem.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "TxHistoryItem",
  "description": "Элемент истории транзакций инвестора",
  "type": "object",
  "required": ["id", "type", "issuanceId", "issuanceCode", "amount", "status", "createdAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "type": {
      "type": "string",
      "enum": ["transfer", "redeem", "issue"],
      "description": "Тип транзакции"
    },
    "issuanceId": {
      "type": "string",
      "format": "uuid"
    },
    "issuanceCode": {
      "type": "string",
      "description": "Код выпуска для отображения"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0
    },
    "status": {
      "type": "string",
      "enum": ["pending", "confirmed", "failed"],
      "description": "Статус транзакции"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time"
    },
    "confirmedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата подтверждения"
    }
  }
}


```
---
# packages/contracts/schemas/Wallet.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Wallet",
  "description": "Схема кошелька инвестора",
  "type": "object",
  "required": ["investorId", "balance", "blocked", "holdings"],
  "properties": {
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "balance": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Баланс кошелька"
    },
    "blocked": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Заблокированные средства"
    },
    "holdings": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Holding"
      },
      "description": "Владения ЦФА"
    }
  },
  "definitions": {
    "Holding": {
      "type": "object",
      "required": ["issuanceId", "quantity"],
      "properties": {
        "issuanceId": {
          "type": "string",
          "format": "uuid",
          "description": "Идентификатор выпуска"
        },
        "quantity": {
          "type": "number",
          "format": "decimal",
          "exclusiveMinimum": 0,
          "description": "Количество ЦФА"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Дата последнего обновления"
        }
      }
    }
  }
}


```
---
# scripts/git/zip_branches.sh
```sh
#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <branches-file> [base-branch]" >&2
  exit 1
fi

branches_file="$1"
base_branch="${2:-infra.defis.deploy}"

if [[ ! -f "$branches_file" ]]; then
  echo "Branch list file not found: $branches_file" >&2
  exit 1
fi

repo_root="$(git rev-parse --show-toplevel)"
cd "$repo_root"

git fetch origin --prune >/dev/null 2>&1 || true

cleanup_worktree() {
  local branch="$1"
  local path
  path=$(git worktree list --porcelain | awk -v b="$branch" '
    $1 == "worktree" { wt=$2 }
    $1 == "branch" {
      gsub("refs/heads/", "", $2)
      if ($2 == b) {
        print wt
      }
    }
  ' | head -n1)

  if [[ -n "$path" ]]; then
    if [[ -n "$(git -C "$path" status --porcelain)" ]]; then
      echo "[SKIP] Worktree $path for $branch has uncommitted changes" >&2
      return 1
    fi
    git worktree remove "$path"
  fi
  return 0
}

while IFS= read -r raw_branch || [[ -n "$raw_branch" ]]; do
  branch="$(echo "$raw_branch" | xargs)"
  [[ -z "$branch" || "$branch" =~ ^# ]] && continue

  echo "--- Archiving $branch ---"

  if ! git show-ref --verify --quiet "refs/heads/$branch"; then
    if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
      git fetch origin "$branch:$branch"
    else
      echo "[SKIP] Branch $branch not found locally or on origin" >&2
      continue
    fi
  fi

  if ! git show-ref --verify --quiet "refs/heads/$base_branch"; then
    git fetch origin "$base_branch:$base_branch"
  fi

  if ! git merge-base --is-ancestor "$branch" "$base_branch"; then
    echo "[SKIP] $branch is not merged into $base_branch" >&2
    continue
  fi

  if ! cleanup_worktree "$branch"; then
    continue
  fi

  tag_name="zip/$branch"
  if git rev-parse --verify --quiet "refs/tags/$tag_name"; then
    echo "[INFO] Tag $tag_name already exists, skipping tag creation"
  else
    git tag "$tag_name" "$branch"
    git push origin "$tag_name"
  fi

  if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
    git push origin --delete "$branch" || true
  fi

  git branch -D "$branch"
  echo "[DONE] $branch archived as $tag_name"
done < "$branches_file"

```
---
# services/compliance/Background/OutboxPublisher.cs
```cs
using MassTransit;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using OIS.Contracts.Events;
using Polly;

namespace OIS.Compliance.Background;

public class OutboxPublisher : BackgroundService
{
    private readonly IServiceProvider _services;
    private readonly ILogger<OutboxPublisher> _logger;

    public OutboxPublisher(IServiceProvider services, ILogger<OutboxPublisher> logger)
    {
        _services = services;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _services.CreateScope();
                var db = scope.ServiceProvider.GetRequiredService<ComplianceDbContext>();
                var publisher = scope.ServiceProvider.GetRequiredService<IPublishEndpoint>();

                var messages = await db.OutboxMessages
                    .Where(x => x.ProcessedAt == null)
                    .OrderBy(x => x.CreatedAt)
                    .Take(50)
                    .ToListAsync(stoppingToken);

                foreach (var msg in messages)
                {
                    var retry = Polly.Policy
                        .Handle<Exception>()
                        .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)));

                    await retry.ExecuteAsync(async () =>
                    {
                        await PublishTypedAsync(publisher, msg, stoppingToken);
                    });

                    msg.ProcessedAt = DateTime.UtcNow;
                }

                await db.SaveChangesAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken);
            }
            catch (OperationCanceledException) { break; }
            catch (Exception ex)
            {
                _logger.LogError(ex, "OutboxPublisher (Compliance) failed");
                await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
            }
        }
    }

    private static async Task PublishTypedAsync(IPublishEndpoint publisher, OutboxMessage msg, CancellationToken ct)
    {
        switch (msg.Topic)
        {
            case "ois.compliance.flagged":
                if (System.Text.Json.JsonSerializer.Deserialize<ComplianceFlagged>(msg.Payload) is { } cf)
                { await publisher.Publish(cf, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.kyc.updated":
                if (System.Text.Json.JsonSerializer.Deserialize<KycUpdated>(msg.Payload) is { } ku)
                { await publisher.Publish(ku, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.audit.logged":
                if (System.Text.Json.JsonSerializer.Deserialize<AuditLogged>(msg.Payload) is { } al)
                { await publisher.Publish(al, x => x.MessageId = msg.Id, ct); return; }
                break;
        }
    }
}


```
---
# services/compliance/ComplianceDbContext.cs
```cs
using Microsoft.EntityFrameworkCore;

namespace OIS.Compliance;

public class ComplianceDbContext : DbContext
{
    public ComplianceDbContext(DbContextOptions<ComplianceDbContext> options) : base(options) { }

    public DbSet<InvestorComplianceEntity> InvestorsCompliance => Set<InvestorComplianceEntity>();
    public DbSet<ComplaintEntity> Complaints => Set<ComplaintEntity>();
    public DbSet<OutboxMessage> OutboxMessages => Set<OutboxMessage>();
    public DbSet<KycTaskEntity> KycTasks => Set<KycTaskEntity>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity<InvestorComplianceEntity>(entity =>
        {
            entity.ToTable("investors_compliance");
            entity.HasKey(e => e.InvestorId);

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .ValueGeneratedNever();

            entity.Property(e => e.Kyc)
                .HasColumnName("kyc")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.QualificationTier)
                .HasColumnName("qualification_tier")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.QualLimit)
                .HasColumnName("qual_limit")
                .HasPrecision(20, 8);

            entity.Property(e => e.QualUsed)
                .HasColumnName("qual_used")
                .HasPrecision(20, 8);

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();
        });

        modelBuilder.Entity<ComplaintEntity>(entity =>
        {
            entity.ToTable("complaints");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id");

            entity.Property(e => e.Category)
                .HasColumnName("category")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.Text)
                .HasColumnName("text")
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.SlaDue)
                .HasColumnName("sla_due");

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ResolvedAt)
                .HasColumnName("resolved_at");

            entity.Property(e => e.IdemKey)
                .HasColumnName("idem_key")
                .HasMaxLength(255);

            entity.HasIndex(e => e.IdemKey).IsUnique()
                .HasFilter("\"idem_key\" IS NOT NULL");
            entity.HasIndex(e => e.InvestorId);
            entity.HasIndex(e => e.Status);
            entity.HasIndex(e => e.Category);
        });

        modelBuilder.Entity<OutboxMessage>(entity =>
        {
            entity.ToTable("outbox_messages");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.Topic)
                .HasColumnName("topic")
                .HasMaxLength(255)
                .IsRequired();

            entity.Property(e => e.Payload)
                .HasColumnName("payload")
                .HasColumnType("jsonb")
                .IsRequired();

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ProcessedAt)
                .HasColumnName("processed_at");

            entity.HasIndex(e => new { e.ProcessedAt, e.CreatedAt });
        });

        modelBuilder.Entity<KycTaskEntity>(entity =>
        {
            entity.ToTable("kyc_tasks");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.Reason)
                .HasColumnName("reason");

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ResolvedAt)
                .HasColumnName("resolved_at");

            entity.HasIndex(e => e.InvestorId);
            entity.HasIndex(e => e.Status);
        });
    }
}

public class InvestorComplianceEntity
{
    public Guid InvestorId { get; set; }
    public string Kyc { get; set; } = "pending"; // pass, fail, pending, review
    public string QualificationTier { get; set; } = "unqualified"; // unqualified, qualified, professional
    public decimal? QualLimit { get; set; }
    public decimal? QualUsed { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class ComplaintEntity
{
    public Guid Id { get; set; }
    public Guid? InvestorId { get; set; }
    public string Category { get; set; } = string.Empty; // fraud, service, technical, other
    public string Text { get; set; } = string.Empty;
    public string Status { get; set; } = "open"; // open, in_progress, resolved, closed
    public DateTime? SlaDue { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ResolvedAt { get; set; }
    public string? IdemKey { get; set; }
}

public class OutboxMessage
{
    public Guid Id { get; set; }
    public string Topic { get; set; } = string.Empty;
    public string Payload { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
}

public class KycTaskEntity
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public string Status { get; set; } = "open"; // open, approved, rejected
    public string? Reason { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ResolvedAt { get; set; }
}


```
---
# services/compliance/DTOs/ComplaintResponse.cs
```cs
namespace OIS.Compliance.DTOs;

public record ComplaintResponse
{
    public Guid Id { get; init; }
    public Guid? InvestorId { get; init; }
    public string Category { get; init; } = string.Empty;
    public string Text { get; init; } = string.Empty;
    public string Status { get; init; } = string.Empty;
    public DateTime? SlaDue { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime? ResolvedAt { get; init; }
}

public record CreateComplaintRequest
{
    public Guid? InvestorId { get; init; }
    public string Category { get; init; } = string.Empty;
    public string Text { get; init; } = string.Empty;
}


```
---
# services/compliance/DTOs/InvestorStatusResponse.cs
```cs
namespace OIS.Compliance.DTOs;

public record InvestorStatusResponse
{
    public Guid InvestorId { get; init; }
    public string Kyc { get; init; } = string.Empty;
    public string QualificationTier { get; init; } = string.Empty;
    public decimal? QualificationLimit { get; init; }
    public decimal? QualificationUsed { get; init; }
    public DateTime UpdatedAt { get; init; }
}


```
---
# services/compliance/DTOs/KycApplicationRequest.cs
```cs
using System;

namespace OIS.Compliance.DTOs;

public record KycApplicationRequest
{
    public Guid? InvestorId { get; init; }
    public string? FullName { get; init; }
    public string? DocumentType { get; init; }
    public string? DocumentNumber { get; init; }
    public string? Comment { get; init; }
}

```
---
# services/compliance/DTOs/KycRequestDto.cs
```cs
namespace OIS.Compliance.DTOs;

public record KycRequestDto
{
    public Guid Id { get; init; }
    public Guid InvestorId { get; init; }
    public string Status { get; init; } = "pending"; // pending | approved | rejected
    public string? Reason { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime? ResolvedAt { get; init; }
}

public record KycDecisionRequest
{
    public string Decision { get; init; } = string.Empty; // approved | rejected
    public string? Comment { get; init; }
}

```
---
# services/compliance/DTOs/KycResult.cs
```cs
namespace OIS.Compliance.DTOs;

public record KycResult
{
    public Guid InvestorId { get; init; }
    public string Status { get; init; } = string.Empty; // pass, fail, pending, review
    public DateTime CheckedAt { get; init; }
    public string? Reason { get; init; }
}

public record KycCheckRequest
{
    public Guid InvestorId { get; init; }
}


```
---
# services/compliance/DTOs/QualificationResult.cs
```cs
namespace OIS.Compliance.DTOs;

public record QualificationResult
{
    public Guid InvestorId { get; init; }
    public string Tier { get; init; } = string.Empty; // unqualified, qualified, professional
    public decimal? Limit { get; init; }
    public decimal? Used { get; init; }
    public bool Allowed { get; init; }
    public string? Reason { get; init; }
    public DateTime EvaluatedAt { get; init; }
}

public record QualificationEvaluateRequest
{
    public Guid InvestorId { get; init; }
    public decimal Amount { get; init; }
}


```
---
# services/compliance/Dockerfile
```
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 8080

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY ["services/compliance/compliance.csproj", "services/compliance/"]
COPY ["packages/domain/domain.csproj", "packages/domain/"]
RUN dotnet restore "services/compliance/compliance.csproj"
COPY packages/domain/ packages/domain/
COPY services/compliance/ services/compliance/
RUN rm -rf services/compliance/compliance.Tests || true
WORKDIR "/src/services/compliance"
RUN dotnet build "compliance.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "compliance.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "compliance.dll"]

```
---
# services/compliance/Infrastructure/Metrics.cs
```cs
using System.Diagnostics.Metrics;

namespace OIS.Compliance.Infrastructure;

public static class Metrics
{
    public const string MeterName = "compliance-service";
    private static readonly Meter Meter = new(MeterName);

    public static readonly Histogram<double> RequestDurationMs = Meter.CreateHistogram<double>(
        name: "request_duration_ms",
        unit: "ms",
        description: "API request latency in milliseconds");

    public static readonly Counter<long> RequestErrors = Meter.CreateCounter<long>(
        name: "request_errors_total",
        unit: "requests",
        description: "Number of API requests resulting in 5xx");
}


```
---
# services/compliance/Migrations/20250104000000_InitialCreate.cs
```cs
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace OIS.Compliance.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "investors_compliance",
                columns: table => new
                {
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    kyc = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    qualification_tier = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    qual_limit = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: true),
                    qual_used = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: true),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_investors_compliance", x => x.investor_id);
                });

            migrationBuilder.CreateTable(
                name: "complaints",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: true),
                    category = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    text = table.Column<string>(type: "text", nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    sla_due = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    resolved_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    idem_key = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_complaints", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_complaints_idem_key",
                table: "complaints",
                column: "idem_key",
                unique: true,
                filter: "\"idem_key\" IS NOT NULL");

            migrationBuilder.CreateIndex(
                name: "ix_complaints_investor_id",
                table: "complaints",
                column: "investor_id");

            migrationBuilder.CreateIndex(
                name: "ix_complaints_status",
                table: "complaints",
                column: "status");

            migrationBuilder.CreateIndex(
                name: "ix_complaints_category",
                table: "complaints",
                column: "category");

            migrationBuilder.CreateTable(
                name: "outbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    topic = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    payload = table.Column<string>(type: "jsonb", nullable: false),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    processed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_outbox_messages", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_outbox_messages_processed_at_created_at",
                table: "outbox_messages",
                columns: new[] { "processed_at", "created_at" });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "complaints");

            migrationBuilder.DropTable(
                name: "outbox_messages");

            migrationBuilder.DropTable(
                name: "investors_compliance");
        }
    }
}


```
---
# services/compliance/Migrations/20250104110000_AddKycTasks.cs
```cs
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace OIS.Compliance.Migrations
{
    /// <inheritdoc />
    public partial class AddKycTasks : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "kyc_tasks",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    reason = table.Column<string>(type: "text", nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    resolved_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_kyc_tasks", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_kyc_tasks_investor_id",
                table: "kyc_tasks",
                column: "investor_id");

            migrationBuilder.CreateIndex(
                name: "ix_kyc_tasks_status",
                table: "kyc_tasks",
                column: "status");
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "kyc_tasks");
        }
    }
}


```
---
# services/compliance/Program.cs
```cs
using Microsoft.EntityFrameworkCore;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using System.Collections.Generic;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using OIS.Compliance.Services;
using OIS.Compliance.Infrastructure;
using MassTransit;
using OIS.Contracts.Events;
using Serilog;
using System.Text;
using System.Text.Json;
using Microsoft.AspNetCore.RateLimiting;
using System.Threading.RateLimiting;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("compliance-service"))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Database
var complianceMigrationsAssembly = typeof(ComplianceDbContext).Assembly.GetName().Name;
builder.Services.AddDbContext<ComplianceDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions => npgsqlOptions.MigrationsAssembly(complianceMigrationsAssembly)));

// Services
builder.Services.AddScoped<IWatchlistsService, WatchlistsServiceStub>();
builder.Services.AddScoped<IQualificationPolicyService, QualificationPolicyService>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IComplianceService, ComplianceService>();

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<ComplianceDbContext>();

// Rate limiting
builder.Services.AddRateLimiter(options =>
{
    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
    options.AddPolicy("sensitive", httpContext =>
    {
        var key = httpContext.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
        if (!string.IsNullOrEmpty(key)) key = $"user:{key}"; else key = $"ip:{httpContext.Connection.RemoteIpAddress}";
        return RateLimitPartition.GetTokenBucketLimiter(key!, _ => new TokenBucketRateLimiterOptions
        {
            TokenLimit = 10,
            TokensPerPeriod = 10,
            ReplenishmentPeriod = TimeSpan.FromSeconds(1),
            AutoReplenishment = true,
            QueueLimit = 0,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst
        });
    });
});

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        if (!string.IsNullOrEmpty(authority)) options.Authority = authority;
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            RoleClaimType = ClaimTypes.Role
        };
        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx => { MapKeycloakRoles(ctx); return Task.CompletedTask; }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:investor", p => p.RequireRole("investor"));
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:backoffice", p => p.RequireRole("backoffice"));
    options.AddPolicy("role:investor-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
    options.AddPolicy("role:issuer-or-investor-or-backoffice", p =>
        p.RequireAssertion(ctx =>
            ctx.User.IsInRole("issuer") || ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
});

// MassTransit + Kafka for publishing
if (builder.Configuration.GetValue<bool>("Kafka:Enabled", true))
{
    builder.Services.AddMassTransit(x =>
    {
        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092");
            });
        });
    });

    builder.Services.AddHostedService<OIS.Compliance.Background.OutboxPublisher>();
}

var app = builder.Build();

// Apply migrations (optional, via MIGRATE_ON_STARTUP=true)
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<ComplianceDbContext>();
    db.Database.Migrate();
}

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");
app.UseRateLimiter();

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();
    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// (Kafka rider configured above)

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Compliance").RequireAuthorization();

api.MapPost("/compliance/kyc/check", async (
    KycCheckRequest request,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.CheckKycAsync(request, ct);
    return Results.Ok(result);
})
.WithName("CheckKyc")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapPost("/compliance/qualification/evaluate", async (
    QualificationEvaluateRequest request,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.EvaluateQualificationAsync(request, ct);
    return Results.Ok(result);
})
.WithName("EvaluateQualification")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapGet("/compliance/investors/{id:guid}/status", async (
    Guid id,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.GetInvestorStatusAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetInvestorStatus")
.RequireAuthorization("role:issuer-or-investor-or-backoffice")
.WithOpenApi();

var complaintsApi = app.MapGroup("/v1/complaints").WithTags("Complaints").RequireAuthorization();

complaintsApi.MapPost("", async (
    CreateComplaintRequest request,
    HttpContext httpContext,
    IComplianceService service,
    CancellationToken ct) =>
{
    string? idemKey = null;
    if (httpContext.Request.Headers.TryGetValue("Idempotency-Key", out var idemKeyValues))
    {
        idemKey = idemKeyValues.FirstOrDefault();
    }

    var result = await service.CreateComplaintAsync(request, idemKey, ct);
    return Results.Created($"/v1/complaints/{result.Id}", result);
})
.WithName("CreateComplaint")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

complaintsApi.MapGet("/{id:guid}", async (
    Guid id,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.GetComplaintAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetComplaint")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

// KYC endpoints
var kycApi = app.MapGroup("/v1/compliance/kyc").WithTags("KYC");

kycApi.MapPost("", async (
    KycApplicationRequest request,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actorId = TryGetUserId(http);
    var investorId = request.InvestorId ?? actorId;
    if (investorId is null)
    {
        return Results.BadRequest(new { error = "investorId is required" });
    }

    var reasonParts = new List<string>();
    if (!string.IsNullOrWhiteSpace(request.FullName)) reasonParts.Add($"name={request.FullName}");
    if (!string.IsNullOrWhiteSpace(request.DocumentType) || !string.IsNullOrWhiteSpace(request.DocumentNumber))
    {
        var doc = $"{request.DocumentType} {request.DocumentNumber}".Trim();
        if (!string.IsNullOrWhiteSpace(doc)) reasonParts.Add($"doc={doc}");
    }
    if (!string.IsNullOrWhiteSpace(request.Comment)) reasonParts.Add($"comment={request.Comment}");
    var reason = reasonParts.Count > 0 ? string.Join("; ", reasonParts) : "kyc submitted";

    await service.UpdateKycStatusAsync(investorId.Value, "pending", actorId, reason, ct);
    var task = await service.CreateKycTaskAsync(investorId.Value, reason, ct);

    var dto = new KycRequestDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        Status = NormalizeKycStatus(task.Status),
        Reason = task.Reason,
        CreatedAt = task.CreatedAt,
        ResolvedAt = task.ResolvedAt
    };

    return Results.Created($"/v1/compliance/kyc/{dto.Id}", dto);
})
.WithName("SubmitKycApplication")
.RequireAuthorization("role:issuer-or-investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

var kycAdminApi = kycApi.RequireAuthorization("role:backoffice");

kycAdminApi.MapPost("/investors/{id:guid}/approve", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actor = TryGetUserId(http);
    var result = await service.UpdateKycStatusAsync(id, "pass", actor, null, ct);
    return Results.Ok(result);
})
.WithName("ApproveKyc")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycAdminApi.MapPost("/investors/{id:guid}/reject", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actor = TryGetUserId(http);
    var result = await service.UpdateKycStatusAsync(id, "fail", actor, null, ct);
    return Results.Ok(result);
})
.WithName("RejectKyc")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// Backoffice KYC list + decision (UI expects /v1/compliance/kyc and /v1/compliance/kyc/{id}/decision)
kycAdminApi.MapGet("", async (
    string? status,
    IComplianceService service,
    CancellationToken ct) =>
{
    var tasks = await service.ListKycTasksAsync(status switch
    {
        "pending" => "open",
        "approved" => "approved",
        "rejected" => "rejected",
        _ => null
    }, ct);

    var mapped = tasks.Select(t => new KycRequestDto
    {
        Id = t.Id,
        InvestorId = t.InvestorId,
        Status = NormalizeKycStatus(t.Status),
        Reason = t.Reason,
        CreatedAt = t.CreatedAt,
        ResolvedAt = t.ResolvedAt
    }).ToArray();

    return Results.Ok(mapped);
})
.WithName("ListKycRequests")
.WithOpenApi();

kycAdminApi.MapPost("/{id:guid}/decision", async (
    Guid id,
    KycDecisionRequest body,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var action = body.Decision?.ToLowerInvariant() == "approved" ? "approve" : "reject";
    var actor = TryGetUserId(http);

    var task = await service.ResolveKycTaskAsync(id, action, actor, body.Comment, ct);
    if (task == null) return Results.NotFound();

    var dto = new KycRequestDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        Status = NormalizeKycStatus(task.Status),
        Reason = task.Reason,
        CreatedAt = task.CreatedAt,
        ResolvedAt = task.ResolvedAt
    };
    return Results.Ok(dto);
})
.WithName("ResolveKycRequest")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// KYC tasks queue
var kycTasks = app.MapGroup("/v1/kyc/tasks").WithTags("KYC Tasks").RequireAuthorization("role:backoffice");

kycTasks.MapPost("", async (
    CreateKycTaskRequest req,
    IComplianceService service,
    CancellationToken ct) =>
{
    var task = await service.CreateKycTaskAsync(req.InvestorId, req.Reason, ct);
    return Results.Created($"/v1/kyc/tasks/{task.Id}", task);
})
.WithName("CreateKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycTasks.MapGet("", async (
    string? status,
    IComplianceService service,
    CancellationToken ct) =>
{
    var list = await service.ListKycTasksAsync(status, ct);
    return Results.Ok(list);
})
.WithName("ListKycTasks")
.WithOpenApi();

kycTasks.MapPost("/{id:guid}/approve", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    Guid? actor = http.User.Identity?.IsAuthenticated == true ?
        http.User.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.NameIdentifier)?.Value is string s && Guid.TryParse(s, out var g) ? g : null
        : null;

    var task = await service.ResolveKycTaskAsync(id, "approve", actor, null, ct);
    return task != null ? Results.Ok(task) : Results.NotFound();
})
.WithName("ApproveKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycTasks.MapPost("/{id:guid}/reject", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    Guid? actor = http.User.Identity?.IsAuthenticated == true ?
        http.User.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.NameIdentifier)?.Value is string s && Guid.TryParse(s, out var g) ? g : null
        : null;

    var task = await service.ResolveKycTaskAsync(id, "reject", actor, null, ct);
    return task != null ? Results.Ok(task) : Results.NotFound();
})
.WithName("RejectKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// Audit reporting (immutable, from outbox write-ahead log)
var auditApi = app.MapGroup("/v1/audit").WithTags("Audit").RequireAuthorization("role:backoffice");

auditApi.MapGet("", async (
    Guid? actor,
    string? action,
    string? entity,
    DateTime? from,
    DateTime? to,
    int? limit,
    int? offset,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var q = db.OutboxMessages
        .Where(m => m.Topic == "ois.audit.logged")
        .OrderByDescending(m => m.CreatedAt)
        .AsEnumerable();

    IEnumerable<OutboxMessage> filtered = q;

    filtered = filtered.Where(m =>
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            var root = doc.RootElement;
            if (actor.HasValue)
            {
                var actorVal = root.TryGetProperty("actor", out var el) ? el.GetString() : null;
                if (!Guid.TryParse(actorVal, out var a) || a != actor.Value) return false;
            }
            if (!string.IsNullOrEmpty(action))
            {
                var act = root.TryGetProperty("action", out var el) ? el.GetString() : null;
                if (!string.Equals(act, action, StringComparison.OrdinalIgnoreCase)) return false;
            }
            if (!string.IsNullOrEmpty(entity))
            {
                var ent = root.TryGetProperty("entity", out var el) ? el.GetString() : null;
                if (!string.Equals(ent, entity, StringComparison.OrdinalIgnoreCase)) return false;
            }
            var ts = root.TryGetProperty("timestamp", out var tsEl) && tsEl.ValueKind == JsonValueKind.String
                ? DateTime.Parse(tsEl.GetString()!)
                : m.CreatedAt;
            if (from.HasValue && ts < from.Value) return false;
            if (to.HasValue && ts > to.Value) return false;
            return true;
        }
        catch
        {
            return false;
        }
    });

    var take = Math.Clamp(limit ?? 20, 1, 100);
    var skip = Math.Max(offset ?? 0, 0);
    var page = filtered.Skip(skip).Take(take).Select(m => MapAudit(m)).ToList();

    return Results.Ok(new { items = page });
})
.WithName("GetAuditEvents")
.WithOpenApi();

auditApi.MapGet("/{id:guid}", async (
    Guid id,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var msg = await db.OutboxMessages
        .Where(m => m.Topic == "ois.audit.logged")
        .OrderByDescending(m => m.CreatedAt)
        .ToListAsync(ct);

    foreach (var m in msg)
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            if (doc.RootElement.TryGetProperty("id", out var idEl) && idEl.ValueKind == JsonValueKind.String)
            {
                if (Guid.TryParse(idEl.GetString(), out var aid) && aid == id)
                    return Results.Ok(MapAudit(m));
            }
        }
        catch { }
    }
    return Results.NotFound();
})
.WithName("GetAuditEvent")
.WithOpenApi();

auditApi.MapGet("/export.csv", async (
    Guid? actor,
    string? action,
    string? entity,
    DateTime? from,
    DateTime? to,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var sb = new StringBuilder();
    // Stable header
    sb.AppendLine("id,actor,actorName,action,entity,entityId,result,timestamp,ip,userAgent");

    var rows = db.OutboxMessages
        .Where(m => m.Topic == "ois.audit.logged")
        .OrderBy(m => m.CreatedAt) // chronological for exports
        .AsEnumerable();

    foreach (var m in rows)
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            var r = doc.RootElement;
            var idStr = r.TryGetProperty("id", out var idEl) ? idEl.GetString() : null;
            var actorStr = r.TryGetProperty("actor", out var actEl) ? actEl.GetString() : null;
            var actorName = r.TryGetProperty("actorName", out var anEl) ? anEl.GetString() : null;
            var actionStr = r.TryGetProperty("action", out var acEl) ? acEl.GetString() : null;
            var entityStr = r.TryGetProperty("entity", out var enEl) ? enEl.GetString() : null;
            var entityId = r.TryGetProperty("entityId", out var eiEl) ? eiEl.GetString() : null;
            var result = r.TryGetProperty("result", out var resEl) ? resEl.GetString() : null;
            var ts = r.TryGetProperty("timestamp", out var tsEl) ? tsEl.GetString() : m.CreatedAt.ToString("O");
            var ip = r.TryGetProperty("ip", out var ipEl) ? ipEl.GetString() : null;
            var ua = r.TryGetProperty("userAgent", out var uaEl) ? uaEl.GetString() : null;

            // Filter checks
            if (actor.HasValue && (!Guid.TryParse(actorStr, out var a) || a != actor.Value)) continue;
            if (!string.IsNullOrEmpty(action) && !string.Equals(actionStr, action, StringComparison.OrdinalIgnoreCase)) continue;
            if (!string.IsNullOrEmpty(entity) && !string.Equals(entityStr, entity, StringComparison.OrdinalIgnoreCase)) continue;
            if (from.HasValue && DateTime.Parse(ts) < from.Value) continue;
            if (to.HasValue && DateTime.Parse(ts) > to.Value) continue;

            sb.AppendLine(string.Join(',', new[]
            {
                Csv(idStr), Csv(actorStr), Csv(actorName), Csv(actionStr), Csv(entityStr), Csv(entityId), Csv(result), Csv(ts), Csv(ip), Csv(ua)
            }));
        }
        catch { }
    }

    return Results.Text(sb.ToString(), "text/csv", Encoding.UTF8);
})
.WithName("ExportAuditCsv")
.WithOpenApi();

static string Csv(string? s)
{
    if (s is null) return "";
    var needsQuotes = s.Contains(',') || s.Contains('"') || s.Contains('\n') || s.Contains('\r');
    var escaped = s.Replace("\"", "\"\"");
    return needsQuotes ? $"\"{escaped}\"" : escaped;
}

static object MapAudit(OutboxMessage m)
{
    try
    {
        using var doc = JsonDocument.Parse(m.Payload);
        var r = doc.RootElement;
        return new
        {
            id = Guid.TryParse(r.TryGetProperty("id", out var idEl) ? idEl.GetString() : null, out var aid) ? aid : m.Id,
            actor = r.TryGetProperty("actor", out var actEl) ? actEl.GetString() : null,
            actorName = r.TryGetProperty("actorName", out var anEl) ? anEl.GetString() : null,
            action = r.TryGetProperty("action", out var acEl) ? acEl.GetString() : null,
            entity = r.TryGetProperty("entity", out var enEl) ? enEl.GetString() : null,
            entityId = r.TryGetProperty("entityId", out var eiEl) ? eiEl.GetString() : null,
            payload = r.TryGetProperty("payload", out var pEl) ? pEl : default(JsonElement?),
            ip = r.TryGetProperty("ip", out var ipEl) ? ipEl.GetString() : null,
            userAgent = r.TryGetProperty("userAgent", out var uaEl) ? uaEl.GetString() : null,
            timestamp = r.TryGetProperty("timestamp", out var tsEl) ? tsEl.GetString() : m.CreatedAt.ToString("O"),
            result = r.TryGetProperty("result", out var resEl) ? resEl.GetString() : null
        };
    }
    catch
    {
        return new { id = m.Id, timestamp = m.CreatedAt.ToString("O") };
    }
}

app.Run();

static string NormalizeKycStatus(string status) => status switch
{
    "open" => "pending",
    "approved" => "approved",
    "rejected" => "rejected",
    _ => "pending"
};

static Guid? TryGetUserId(HttpContext http)
{
    var raw =
        http.User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value ??
        http.User.Claims.FirstOrDefault(c => c.Type == "sub")?.Value;
    return Guid.TryParse(raw, out var id) ? id : null;
}

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { }
}

public partial class Program { }

```
---
# services/compliance/Properties/launchSettings.json
```json
{
  "profiles": {
    "compliance": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:53979;http://localhost:53986"
    }
  }
}
```
---
# services/compliance/Services/ComplianceService.cs
```cs
using Microsoft.EntityFrameworkCore;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using System.Text.Json;

namespace OIS.Compliance.Services;

public interface IComplianceService
{
    Task<KycResult> CheckKycAsync(KycCheckRequest request, CancellationToken ct);
    Task<QualificationResult> EvaluateQualificationAsync(QualificationEvaluateRequest request, CancellationToken ct);
    Task<InvestorStatusResponse?> GetInvestorStatusAsync(Guid investorId, CancellationToken ct);
    Task<ComplaintResponse> CreateComplaintAsync(CreateComplaintRequest request, string? idempotencyKey, CancellationToken ct);
    Task<ComplaintResponse?> GetComplaintAsync(Guid id, CancellationToken ct);
    Task<KycResult> UpdateKycStatusAsync(Guid investorId, string status, Guid? actorId, string? reason, CancellationToken ct);
    Task<KycTaskDto> CreateKycTaskAsync(Guid investorId, string? reason, CancellationToken ct);
    Task<IReadOnlyList<KycTaskDto>> ListKycTasksAsync(string? status, CancellationToken ct);
    Task<KycTaskDto?> ResolveKycTaskAsync(Guid taskId, string action, Guid? actorId, string? reason, CancellationToken ct);
}

public class ComplianceService : IComplianceService
{
    private readonly ComplianceDbContext _db;
    private readonly ILogger<ComplianceService> _logger;
    private readonly IWatchlistsService _watchlists;
    private readonly IQualificationPolicyService _qualificationPolicy;
    private readonly IOutboxService _outbox;

    public ComplianceService(
        ComplianceDbContext db,
        ILogger<ComplianceService> logger,
        IWatchlistsService watchlists,
        IQualificationPolicyService qualificationPolicy,
        IOutboxService outbox)
    {
        _db = db;
        _logger = logger;
        _watchlists = watchlists;
        _qualificationPolicy = qualificationPolicy;
        _outbox = outbox;
    }

    public async Task<KycResult> UpdateKycStatusAsync(Guid investorId, string status, Guid? actorId, string? reason, CancellationToken ct)
    {
        var compliance = await GetOrCreateComplianceAsync(investorId, ct);

        if (status is not ("pass" or "fail" or "pending" or "review"))
            throw new InvalidOperationException($"Unsupported KYC status '{status}'");

        compliance.Kyc = status;
        compliance.UpdatedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        // Events: kyc.updated
        await _outbox.AddAsync("ois.kyc.updated", new
        {
            investorId,
            status,
            reason,
            updatedAt = compliance.UpdatedAt
        }, ct);

        // Audit
        await _outbox.AddAsync("ois.audit.logged", new
        {
            id = Guid.NewGuid(),
            actor = actorId,
            action = "kyc.update",
            entity = "investor",
            entityId = investorId,
            payload = new { status, reason },
            timestamp = DateTime.UtcNow,
            result = "success"
        }, ct);

        await _db.SaveChangesAsync(ct);

        return new KycResult
        {
            InvestorId = investorId,
            Status = compliance.Kyc,
            CheckedAt = compliance.UpdatedAt,
            Reason = reason
        };
    }

    public async Task<KycTaskDto> CreateKycTaskAsync(Guid investorId, string? reason, CancellationToken ct)
    {
        var task = new KycTaskEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = investorId,
            Status = "open",
            Reason = reason,
            CreatedAt = DateTime.UtcNow
        };
        _db.KycTasks.Add(task);
        await _db.SaveChangesAsync(ct);
        return MapToDto(task);
    }

    public async Task<IReadOnlyList<KycTaskDto>> ListKycTasksAsync(string? status, CancellationToken ct)
    {
        var query = _db.KycTasks.AsQueryable();
        if (!string.IsNullOrEmpty(status))
            query = query.Where(t => t.Status == status);
        var items = await query.OrderBy(t => t.CreatedAt).ToListAsync(ct);
        return items.Select(MapToDto).ToList();
    }

    public async Task<KycTaskDto?> ResolveKycTaskAsync(Guid taskId, string action, Guid? actorId, string? reason, CancellationToken ct)
    {
        var task = await _db.KycTasks.FindAsync(new object[] { taskId }, ct);
        if (task == null) return null;
        if (task.Status != "open") return MapToDto(task);

        string status = action == "approve" ? "pass" : action == "reject" ? "fail" : throw new InvalidOperationException("Unknown action");
        task.Status = action == "approve" ? "approved" : "rejected";
        task.ResolvedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        // Update KYC
        await UpdateKycStatusAsync(task.InvestorId, status, actorId, reason, ct);
        return MapToDto(task);
    }

    private static KycTaskDto MapToDto(KycTaskEntity e) => new()
    {
        Id = e.Id,
        InvestorId = e.InvestorId,
        Status = e.Status,
        Reason = e.Reason,
        CreatedAt = e.CreatedAt,
        ResolvedAt = e.ResolvedAt
    };

    public async Task<KycResult> CheckKycAsync(KycCheckRequest request, CancellationToken ct)
    {
        var compliance = await GetOrCreateComplianceAsync(request.InvestorId, ct);

        // Check watchlists
        var watchlistResult = await _watchlists.CheckAsync(request.InvestorId, ct);
        if (watchlistResult.Matched)
        {
            compliance.Kyc = "fail";
            compliance.UpdatedAt = DateTime.UtcNow;
            await _db.SaveChangesAsync(ct);

            // Emit flagged event
            await _outbox.AddAsync("ois.compliance.flagged", new
            {
                investorId = request.InvestorId,
                reason = "watchlist_match",
                severity = watchlistResult.Severity,
                flaggedAt = DateTime.UtcNow,
                details = new { watchlistReason = watchlistResult.Reason }
            }, ct);

            await _db.SaveChangesAsync(ct);

            return new KycResult
            {
                InvestorId = request.InvestorId,
                Status = "fail",
                CheckedAt = DateTime.UtcNow,
                Reason = watchlistResult.Reason ?? "Watchlist match"
            };
        }

        // If KYC is already pass, return it
        if (compliance.Kyc == "pass")
        {
            return new KycResult
            {
                InvestorId = request.InvestorId,
                Status = "pass",
                CheckedAt = compliance.UpdatedAt,
                Reason = null
            };
        }

        // For demo: set KYC to pass if not already set
        if (compliance.Kyc == "pending")
        {
            compliance.Kyc = "pass";
            compliance.UpdatedAt = DateTime.UtcNow;
            await _db.SaveChangesAsync(ct);
        }

        return new KycResult
        {
            InvestorId = request.InvestorId,
            Status = compliance.Kyc,
            CheckedAt = compliance.UpdatedAt,
            Reason = null
        };
    }

    public async Task<QualificationResult> EvaluateQualificationAsync(QualificationEvaluateRequest request, CancellationToken ct)
    {
        var compliance = await GetOrCreateComplianceAsync(request.InvestorId, ct);

        // Evaluate tier if not set
        if (compliance.QualificationTier == "unqualified")
        {
            var tier = await _qualificationPolicy.EvaluateTierAsync(request.InvestorId, ct);
            compliance.QualificationTier = tier.ToString().ToLowerInvariant();
            compliance.QualLimit = _qualificationPolicy.GetLimitForTier(compliance.QualificationTier);
            compliance.QualUsed = 0;
            compliance.UpdatedAt = DateTime.UtcNow;
            await _db.SaveChangesAsync(ct);
        }

        // Check if amount is allowed
        var limit = compliance.QualLimit;
        var used = compliance.QualUsed ?? 0;
        var allowed = true;
        string? reason = null;

        if (limit.HasValue && used + request.Amount > limit.Value)
        {
            allowed = false;
            reason = $"Qualification limit exceeded: used {used}, limit {limit}, requested {request.Amount}";

            // Emit flagged event
            await _outbox.AddAsync("ois.compliance.flagged", new
            {
                investorId = request.InvestorId,
                reason = "qualification_exceeded",
                severity = "high",
                flaggedAt = DateTime.UtcNow,
                details = new { used = used, limit = limit, requested = request.Amount }
            }, ct);

            await _db.SaveChangesAsync(ct);
        }

        return new QualificationResult
        {
            InvestorId = request.InvestorId,
            Tier = compliance.QualificationTier,
            Limit = compliance.QualLimit,
            Used = compliance.QualUsed,
            Allowed = allowed,
            Reason = reason,
            EvaluatedAt = DateTime.UtcNow
        };
    }

    public async Task<InvestorStatusResponse?> GetInvestorStatusAsync(Guid investorId, CancellationToken ct)
    {
        var compliance = await _db.InvestorsCompliance
            .FirstOrDefaultAsync(c => c.InvestorId == investorId, ct);

        if (compliance == null)
            return null;

        return new InvestorStatusResponse
        {
            InvestorId = compliance.InvestorId,
            Kyc = compliance.Kyc,
            QualificationTier = compliance.QualificationTier,
            QualificationLimit = compliance.QualLimit,
            QualificationUsed = compliance.QualUsed,
            UpdatedAt = compliance.UpdatedAt
        };
    }

    public async Task<ComplaintResponse> CreateComplaintAsync(CreateComplaintRequest request, string? idempotencyKey, CancellationToken ct)
    {
        // Check idempotency if key provided
        if (!string.IsNullOrEmpty(idempotencyKey))
        {
            var existing = await _db.Complaints
                .FirstOrDefaultAsync(c => c.IdemKey == idempotencyKey, ct);

            if (existing != null)
            {
                _logger.LogInformation("Complaint with idempotency key {IdemKey} already exists: {ComplaintId}",
                    idempotencyKey, existing.Id);
                return MapToComplaintResponse(existing);
            }
        }

        var complaint = new ComplaintEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = request.InvestorId,
            Category = request.Category,
            Text = request.Text,
            Status = "open",
            SlaDue = DateTime.UtcNow.AddDays(7), // 7-day SLA
            CreatedAt = DateTime.UtcNow,
            IdemKey = idempotencyKey
        };

        _db.Complaints.Add(complaint);
        await _db.SaveChangesAsync(ct);

        var investorMasked = request.InvestorId.HasValue ? OIS.Domain.Security.MaskGuid(request.InvestorId.Value) : "(null)";
        _logger.LogInformation("Created complaint {ComplaintId} for investor {Investor}, category {Category}",
            complaint.Id, investorMasked, request.Category);

        return MapToComplaintResponse(complaint);
    }

    public async Task<ComplaintResponse?> GetComplaintAsync(Guid id, CancellationToken ct)
    {
        var complaint = await _db.Complaints.FindAsync(new object[] { id }, ct);
        return complaint != null ? MapToComplaintResponse(complaint) : null;
    }

    private async Task<InvestorComplianceEntity> GetOrCreateComplianceAsync(Guid investorId, CancellationToken ct)
    {
        var compliance = await _db.InvestorsCompliance
            .FirstOrDefaultAsync(c => c.InvestorId == investorId, ct);

        if (compliance == null)
        {
            compliance = new InvestorComplianceEntity
            {
                InvestorId = investorId,
                Kyc = "pending",
                QualificationTier = "unqualified",
                UpdatedAt = DateTime.UtcNow
            };
            _db.InvestorsCompliance.Add(compliance);
            await _db.SaveChangesAsync(ct);
        }

        return compliance;
    }

    private static ComplaintResponse MapToComplaintResponse(ComplaintEntity entity)
    {
        return new ComplaintResponse
        {
            Id = entity.Id,
            InvestorId = entity.InvestorId,
            Category = entity.Category,
            Text = entity.Text,
            Status = entity.Status,
            SlaDue = entity.SlaDue,
            CreatedAt = entity.CreatedAt,
            ResolvedAt = entity.ResolvedAt
        };
    }
}

public record KycTaskDto
{
    public Guid Id { get; init; }
    public Guid InvestorId { get; init; }
    public string Status { get; init; } = string.Empty;
    public string? Reason { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime? ResolvedAt { get; init; }
}

public record CreateKycTaskRequest
{
    public Guid InvestorId { get; init; }
    public string? Reason { get; init; }
}

public interface IOutboxService
{
    Task AddAsync(string topic, object payload, CancellationToken ct);
}

public class OutboxService : IOutboxService
{
    private readonly ComplianceDbContext _db;

    public OutboxService(ComplianceDbContext db)
    {
        _db = db;
    }

    public async Task AddAsync(string topic, object payload, CancellationToken ct)
    {
        var message = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            Topic = topic,
            Payload = JsonSerializer.Serialize(payload),
            CreatedAt = DateTime.UtcNow
        };

        _db.OutboxMessages.Add(message);
    }
}


```
---
# services/compliance/Services/IWatchlistsService.cs
```cs
namespace OIS.Compliance.Services;

public interface IWatchlistsService
{
    Task<WatchlistCheckResult> CheckAsync(Guid investorId, CancellationToken ct);
}

public record WatchlistCheckResult
{
    public bool Matched { get; init; }
    public string? Reason { get; init; }
    public string Severity { get; init; } = "low"; // low, medium, high, critical
}

public class WatchlistsServiceStub : IWatchlistsService
{
    private readonly ILogger<WatchlistsServiceStub> _logger;

    public WatchlistsServiceStub(ILogger<WatchlistsServiceStub> logger)
    {
        _logger = logger;
    }

    public Task<WatchlistCheckResult> CheckAsync(Guid investorId, CancellationToken ct)
    {
        // Deterministic demo: check last byte of GUID
        var lastByte = investorId.ToByteArray().Last();
        var matched = lastByte % 10 == 0; // ~10% match rate

        _logger.LogInformation("Watchlists check for investor {Investor}: matched={Matched}", OIS.Domain.Security.MaskGuid(investorId), matched);

        return Task.FromResult(new WatchlistCheckResult
        {
            Matched = matched,
            Reason = matched ? "Demo watchlist match" : null,
            Severity = matched ? "medium" : "low"
        });
    }
}


```
---
# services/compliance/Services/QualificationPolicyService.cs
```cs
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace OIS.Compliance.Services;

public interface IQualificationPolicyService
{
    Task<QualificationTier> EvaluateTierAsync(Guid investorId, CancellationToken ct);
    decimal? GetLimitForTier(string tier);
}

public enum QualificationTier
{
    Unqualified,
    Qualified,
    Professional
}

public class QualificationPolicyService : IQualificationPolicyService
{
    private readonly ILogger<QualificationPolicyService> _logger;
    private readonly IConfiguration _configuration;

    public QualificationPolicyService(ILogger<QualificationPolicyService> logger, IConfiguration configuration)
    {
        _logger = logger;
        _configuration = configuration;
    }

    public Task<QualificationTier> EvaluateTierAsync(Guid investorId, CancellationToken ct)
    {
        // Config-driven policy evaluation
        // For demo: deterministic based on investor ID
        var lastByte = investorId.ToByteArray().Last();
        var tier = lastByte switch
        {
            >= 200 => QualificationTier.Professional,
            >= 100 => QualificationTier.Qualified,
            _ => QualificationTier.Unqualified
        };

        _logger.LogInformation("Evaluated tier for investor {Investor}: {Tier}", OIS.Domain.Security.MaskGuid(investorId), tier);
        return Task.FromResult(tier);
    }

    public decimal? GetLimitForTier(string tier)
    {
        var limits = _configuration.GetSection("Qualification:Limits").Get<Dictionary<string, decimal?>>()
            ?? new Dictionary<string, decimal?>
            {
                { "unqualified", null },
                { "qualified", 60000m },
                { "professional", null } // unlimited
            };

        return limits.GetValueOrDefault(tier.ToLowerInvariant(), null);
    }
}


```
---
# services/compliance/appsettings.json
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=ois;Username=ois;Password=ois_dev_password"
  },
  "Qualification": {
    "Limits": {
      "unqualified": null,
      "qualified": 60000,
      "professional": null
    }
  },
  "Serilog": {
    "Using": ["Serilog.Sinks.Console"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  }
}


```
---
# services/compliance/compliance.Tests/AuditApiTests.cs
```cs
using System.Net;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Security.Claims;
using System.Text.Json;
using FluentAssertions;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.AspNetCore.TestHost;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using OIS.Compliance;
using Xunit;

namespace OIS.Compliance.Tests;

public class AuditApiTests : IClassFixture<ComplianceFactory>
{
    private readonly ComplianceFactory _factory;
    public AuditApiTests(ComplianceFactory factory) { _factory = factory; }

    [Fact]
    public async Task GetAudit_Returns_Items_In_Order()
    {
        var client = _factory.CreateClient();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "test");

        // seed one audit outbox message
        using (var scope = _factory.Services.CreateScope())
        {
            var db = scope.ServiceProvider.GetRequiredService<ComplianceDbContext>();
            db.OutboxMessages.Add(new OutboxMessage
            {
                Id = Guid.NewGuid(),
                Topic = "ois.audit.logged",
                Payload = JsonSerializer.Serialize(new
                {
                    id = Guid.NewGuid(),
                    actor = Guid.NewGuid(),
                    action = "kyc.update",
                    entity = "investor",
                    timestamp = DateTime.UtcNow,
                }),
                CreatedAt = DateTime.UtcNow
            });
            await db.SaveChangesAsync();
        }

        var res = await client.GetAsync("/v1/audit");
        res.StatusCode.Should().Be(HttpStatusCode.OK);
        var body = await res.Content.ReadFromJsonAsync<JsonElement>();
        body.TryGetProperty("items", out var items).Should().BeTrue();
        items.GetArrayLength().Should().BeGreaterThan(0);
    }

    [Fact]
    public async Task ExportCsv_Returns_Csv_Content()
    {
        var client = _factory.CreateClient();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "test");
        var res = await client.GetAsync("/v1/audit/export.csv");
        res.StatusCode.Should().Be(HttpStatusCode.OK);
        res.Content.Headers.ContentType!.MediaType.Should().Be("text/csv");
        var text = await res.Content.ReadAsStringAsync();
        text.Should().Contain("id,actor,actorName,action,entity,entityId,result,timestamp,ip,userAgent");
    }
}

public class ComplianceFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureTestServices(services =>
        {
            // Replace DB with InMemory
            var descriptor = services.SingleOrDefault(d => d.ServiceType == typeof(DbContextOptions<ComplianceDbContext>));
            if (descriptor != null) services.Remove(descriptor);
            services.AddDbContext<ComplianceDbContext>(o => o.UseInMemoryDatabase("compliance-audit-tests"));

            // Bypass auth; always authenticate with backoffice role
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddScheme<AuthenticationSchemeOptions, TestAuthHandler>(JwtBearerDefaults.AuthenticationScheme, options => { });
        });
    }
}

public class TestAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    public TestAuthHandler(IOptionsMonitor<AuthenticationSchemeOptions> options, ILoggerFactory logger, System.Text.Encodings.Web.UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock) { }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, Guid.NewGuid().ToString()),
            new Claim(ClaimTypes.Role, "backoffice")
        };
        var identity = new ClaimsIdentity(claims, Scheme.Name);
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, Scheme.Name);
        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}


```
---
# services/compliance/compliance.Tests/KycWorkflowTests.cs
```cs
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using OIS.Compliance.Services;
using Xunit;

namespace OIS.Compliance.Tests;

public class KycWorkflowTests
{
    private readonly ComplianceDbContext _db;
    private readonly ComplianceService _service;

    public KycWorkflowTests()
    {
        var options = new DbContextOptionsBuilder<ComplianceDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        _db = new ComplianceDbContext(options);
        var logger = new Mock<ILogger<ComplianceService>>();
        var watchlists = new Mock<IWatchlistsService>();
        var policy = new Mock<IQualificationPolicyService>();
        var outbox = new OutboxService(_db);
        _service = new ComplianceService(_db, logger.Object, watchlists.Object, policy.Object, outbox);
    }

    [Fact]
    public async Task UpdateKycStatus_Changes_Status_And_Writes_Outbox()
    {
        var investorId = Guid.NewGuid();
        var res = await _service.UpdateKycStatusAsync(investorId, "pass", Guid.NewGuid(), "manual approve", CancellationToken.None);
        res.Status.Should().Be("pass");
        var outbox = await _db.OutboxMessages.ToListAsync();
        outbox.Should().NotBeEmpty();
        outbox.Any(m => m.Topic == "ois.kyc.updated").Should().BeTrue();
        outbox.Any(m => m.Topic == "ois.audit.logged").Should().BeTrue();
    }

    [Fact]
    public async Task KycTasks_Create_Approve_Updates_Investor()
    {
        var investorId = Guid.NewGuid();
        var task = await _service.CreateKycTaskAsync(investorId, "doc review", CancellationToken.None);
        task.Status.Should().Be("open");

        var resolved = await _service.ResolveKycTaskAsync(task.Id, "approve", Guid.NewGuid(), null, CancellationToken.None);
        resolved!.Status.Should().Be("approved");
        var status = await _service.GetInvestorStatusAsync(investorId, CancellationToken.None);
        status!.Kyc.Should().Be("pass");
    }
}


```
---
# services/compliance/compliance.Tests/QualificationPolicyTests.cs
```cs
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Compliance.Services;
using Xunit;
using FluentAssertions;

namespace OIS.Compliance.Tests;

public class QualificationPolicyTests
{
    private readonly Mock<ILogger<QualificationPolicyService>> _logger;
    private readonly IConfiguration _config;
    private readonly QualificationPolicyService _service;

    public QualificationPolicyTests()
    {
        _logger = new Mock<ILogger<QualificationPolicyService>>();
        _config = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["QualificationPolicy:Tier1:MaxAmount"] = "100000",
                ["QualificationPolicy:Tier2:MaxAmount"] = "500000",
            })
            .Build();
        _service = new QualificationPolicyService(_logger.Object, _config);
    }

    [Fact]
    public async Task EvaluateQualification_WithAmountWithinLimit_ReturnsAllowed()
    {
        // Arrange
        var investorId = Guid.NewGuid();
        var amount = 50000m;

        // Act
        var result = await _service.EvaluateQualificationAsync(investorId, amount, CancellationToken.None);

        // Assert
        result.Allowed.Should().BeTrue();
    }

    [Fact]
    public async Task EvaluateQualification_WithAmountExceedingLimit_ReturnsNotAllowed()
    {
        // Arrange
        var investorId = Guid.NewGuid();
        var amount = 200000m;

        // Act
        var result = await _service.EvaluateQualificationAsync(investorId, amount, CancellationToken.None);

        // Assert
        result.Allowed.Should().BeFalse();
    }
}


```
---
# services/compliance/compliance.Tests/compliance.Tests.csproj
```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Moq" Version="4.20.70" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="FluentAssertions" Version="6.12.0" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="9.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\compliance.csproj" />
  </ItemGroup>

</Project>


```
---
# services/compliance/compliance.csproj
```csproj
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <DefaultItemExcludes>$(DefaultItemExcludes);compliance.Tests/**</DefaultItemExcludes>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="compliance.Tests/**/*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="1.9.0-beta.1" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.9.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Polly" Version="8.4.1" />
    <PackageReference Include="System.Text.Json" Version="9.0.0" />
    <PackageReference Include="MassTransit" Version="8.2.0" />
    <PackageReference Include="MassTransit.Kafka" Version="8.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Compile Remove="compliance.Tests/**/*.cs" />
  </ItemGroup>

</Project>

```
---
# services/identity/Dockerfile
```
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 8080

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY ["services/identity/identity.csproj", "services/identity/"]
RUN dotnet restore "services/identity/identity.csproj"
COPY . .
WORKDIR "/src/services/identity"
RUN dotnet build "identity.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "identity.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "identity.dll"]


```
---
# services/identity/Program.cs
```cs
using Microsoft.EntityFrameworkCore;
using Serilog;
using System.Collections.Generic;
using System.Linq;

var builder = WebApplication.CreateBuilder(args);

builder.Host.UseSerilog((ctx, lc) => lc
    .WriteTo.Console()
    .ReadFrom.Configuration(ctx.Configuration));

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks();
builder.Services.AddDbContext<IdentityDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.MapHealthChecks("/health");

app.MapGet("/.well-known/openid-configuration", () => Results.Ok(new
{
    issuer = builder.Configuration["Keycloak:Authority"],
    authorization_endpoint = $"{builder.Configuration["Keycloak:Authority"]}/protocol/openid-connect/auth",
    token_endpoint = $"{builder.Configuration["Keycloak:Authority"]}/protocol/openid-connect/token",
    userinfo_endpoint = "/userinfo",
    response_types_supported = new[] { "code" },
    scopes_supported = new[] { "openid", "profile", "email" }
}));

app.MapGet("/userinfo", () => Results.Ok(new
{
    sub = Guid.NewGuid().ToString(),
    email = "test@example.com",
    email_verified = true,
    name = "Test User"
}));

// Simple in-memory registry for backoffice UI until real Keycloak/registry integration is ready
var seededUsers = new List<User>
{
    new() { Id = Guid.Parse("11111111-1111-1111-1111-111111111111"), Email = "issuer@example.com", Role = "issuer", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-5) },
    new() { Id = Guid.Parse("22222222-2222-2222-2222-222222222222"), Email = "backoffice@example.com", Role = "backoffice", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-10) },
    new() { Id = Guid.Parse("33333333-3333-3333-3333-333333333333"), Email = "investor@example.com", Role = "investor", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-15) }
};

app.MapGet("/users", () => Results.Ok(seededUsers.Select(MapUser)));
app.MapGet("/users/{id:guid}", (Guid id) =>
{
    var user = seededUsers.FirstOrDefault(u => u.Id == id);
    return user is null ? Results.NotFound() : Results.Ok(MapUser(user));
});

app.MapGet("/v1/identity/users", (string? query) =>
{
    var filtered = string.IsNullOrWhiteSpace(query)
        ? seededUsers
        : seededUsers.Where(u => u.Email.Contains(query, StringComparison.OrdinalIgnoreCase) || u.Role.Contains(query, StringComparison.OrdinalIgnoreCase)).ToList();
    return Results.Ok(filtered.Select(MapUser));
});

app.Run();

static object MapUser(User u) => new
{
    id = u.Id,
    email = u.Email,
    roles = new[] { u.Role },
    status = u.Status,
    createdAt = u.CreatedAt
};

// Minimal DbContext for now
public class IdentityDbContext : DbContext
{
    public IdentityDbContext(DbContextOptions<IdentityDbContext> options) : base(options) { }
    public DbSet<User> Users => Set<User>();
}

public class User
{
    public Guid Id { get; set; }
    public string Email { get; set; } = string.Empty;
    public string Role { get; set; } = string.Empty;
    public string Status { get; set; } = "active";
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

```
---
# services/identity/Properties/launchSettings.json
```json
{
  "profiles": {
    "identity": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:53981;http://localhost:53987"
    }
  }
}
```
---
# services/identity/appsettings.json
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=ois;Username=ois;Password=ois_dev_password"
  },
  "Keycloak": {
    "Authority": "http://localhost:8080/realms/ois"
  }
}


```
---
# services/identity/identity.csproj
```csproj
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <Compile Remove="identity.Tests/**/*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
  </ItemGroup>

</Project>

```
---
# services/issuance/Background/OutboxPublisher.cs
```cs
using MassTransit;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using OIS.Contracts.Events;
using Polly;

namespace OIS.Issuance.Background;

public class OutboxPublisher : BackgroundService
{
    private readonly IServiceProvider _services;
    private readonly ILogger<OutboxPublisher> _logger;

    public OutboxPublisher(IServiceProvider services, ILogger<OutboxPublisher> logger)
    {
        _services = services;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _services.CreateScope();
                var db = scope.ServiceProvider.GetRequiredService<IssuanceDbContext>();
                var publisher = scope.ServiceProvider.GetRequiredService<IPublishEndpoint>();

                var messages = await db.OutboxMessages
                    .Where(x => x.ProcessedAt == null)
                    .OrderBy(x => x.CreatedAt)
                    .Take(50)
                    .ToListAsync(stoppingToken);

                foreach (var msg in messages)
                {
                    var retry = Polly.Policy
                        .Handle<Exception>()
                        .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)));

                    await retry.ExecuteAsync(async () =>
                    {
                        await PublishTypedAsync(publisher, msg, stoppingToken);
                    });

                    msg.ProcessedAt = DateTime.UtcNow;
                }

                await db.SaveChangesAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken);
            }
            catch (OperationCanceledException) { break; }
            catch (Exception ex)
            {
                _logger.LogError(ex, "OutboxPublisher (Issuance) failed");
                await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
            }
        }
    }

    private static async Task PublishTypedAsync(IPublishEndpoint publisher, OutboxMessage msg, CancellationToken ct)
    {
        switch (msg.Topic)
        {
            case "ois.issuance.published":
                if (System.Text.Json.JsonSerializer.Deserialize<IssuancePublished>(msg.Payload) is { } ip)
                { await publisher.Publish(ip, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.issuance.closed":
                if (System.Text.Json.JsonSerializer.Deserialize<IssuanceClosed>(msg.Payload) is { } ic)
                { await publisher.Publish(ic, x => x.MessageId = msg.Id, ct); return; }
                break;
        }

        if (System.Text.Json.JsonSerializer.Deserialize<AuditLogged>(msg.Payload) is { } audit)
            await publisher.Publish(audit, x => x.MessageId = msg.Id, ct);
    }
}

```
---
# services/issuance/DTOs/CreateIssuanceRequest.cs
```cs
using System.ComponentModel.DataAnnotations;

namespace OIS.Issuance.DTOs;

public record CreateIssuanceRequest
{
    [Required]
    public Guid AssetId { get; init; }

    [Required]
    public Guid IssuerId { get; init; }

    [Required]
    [Range(0.00000001, double.MaxValue)]
    public decimal TotalAmount { get; init; }

    [Required]
    [Range(0.00000001, double.MaxValue)]
    public decimal Nominal { get; init; }

    [Required]
    public DateOnly IssueDate { get; init; }

    [Required]
    public DateOnly MaturityDate { get; init; }

    public Dictionary<string, object>? ScheduleJson { get; init; }
}


```
---
# services/issuance/DTOs/IssuanceResponse.cs
```cs
namespace OIS.Issuance.DTOs;

public record IssuanceResponse
{
    public Guid Id { get; init; }
    public Guid AssetId { get; init; }
    public Guid IssuerId { get; init; }
    public decimal TotalAmount { get; init; }
    public decimal Nominal { get; init; }
    public DateOnly IssueDate { get; init; }
    public DateOnly MaturityDate { get; init; }
    public string Status { get; init; } = string.Empty;
    public Dictionary<string, object>? ScheduleJson { get; init; }
    public string? DltTxHash { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime UpdatedAt { get; init; }
    public DateTime? PublishedAt { get; init; }
    public DateTime? ClosedAt { get; init; }
}


```
---
# services/issuance/DTOs/IssuerIssuancesReportResponse.cs
```cs
using System.ComponentModel.DataAnnotations;

namespace OIS.Issuance.DTOs;

public record IssuerIssuancesReportResponse
{
    [Required]
    public Guid IssuerId { get; init; }

    public IssuerIssuancesReportPeriod? Period { get; init; }

    [Required]
    public IReadOnlyList<IssuerReportRow> Items { get; init; } = Array.Empty<IssuerReportRow>();

    public IssuerIssuancesReportSummary? Summary { get; init; }
}

public record IssuerIssuancesReportPeriod
{
    public DateOnly? From { get; init; }
    public DateOnly? To { get; init; }
}

public record IssuerIssuancesReportSummary
{
    public int TotalIssuances { get; init; }
    public decimal TotalAmount { get; init; }
    public decimal TotalSold { get; init; }
    public int TotalInvestors { get; init; }
}

public record IssuerReportRow
{
    public Guid IssuanceId { get; init; }
    public string AssetCode { get; init; } = string.Empty;
    public string AssetName { get; init; } = string.Empty;
    public decimal TotalAmount { get; init; }
    public decimal SoldAmount { get; init; }
    public int InvestorsCount { get; init; }
    public string Status { get; init; } = string.Empty;
    public DateOnly IssueDate { get; init; }
    public DateOnly MaturityDate { get; init; }
    public DateTime? PublishedAt { get; init; }
}


```
---
# services/issuance/Dockerfile
```
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 8080

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY ["services/issuance/issuance.csproj", "services/issuance/"]
COPY ["packages/domain/domain.csproj", "packages/domain/"]
RUN dotnet restore "services/issuance/issuance.csproj"
COPY packages/domain/ packages/domain/
COPY services/issuance/ services/issuance/
RUN rm -rf services/issuance/issuance.Tests || true
WORKDIR "/src/services/issuance"
RUN dotnet build "issuance.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "issuance.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "issuance.dll"]

```
---
# services/issuance/Infrastructure/Metrics.cs
```cs
using System.Diagnostics.Metrics;

namespace OIS.Issuance.Infrastructure;

public static class Metrics
{
    public const string MeterName = "issuance-service";
    private static readonly Meter Meter = new(MeterName);

    public static readonly Histogram<double> RequestDurationMs = Meter.CreateHistogram<double>(
        name: "request_duration_ms",
        unit: "ms",
        description: "API request latency in milliseconds");

    public static readonly Counter<long> RequestErrors = Meter.CreateCounter<long>(
        name: "request_errors_total",
        unit: "requests",
        description: "Number of API requests resulting in 5xx");
}


```
---
# services/issuance/IssuanceDbContext.cs
```cs
using Microsoft.EntityFrameworkCore;
using OIS.Domain;
using System.Text.Json;

namespace OIS.Issuance;

public class IssuanceDbContext : DbContext
{
    public IssuanceDbContext(DbContextOptions<IssuanceDbContext> options) : base(options) { }

    public DbSet<IssuanceEntity> Issuances => Set<IssuanceEntity>();
    public DbSet<OutboxMessage> OutboxMessages => Set<OutboxMessage>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity<IssuanceEntity>(entity =>
        {
            entity.ToTable("issuances");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.AssetId)
                .HasColumnName("asset_id")
                .IsRequired();

            entity.Property(e => e.IssuerId)
                .HasColumnName("issuer_id")
                .IsRequired();

            entity.Property(e => e.TotalAmount)
                .HasColumnName("total_amount")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.Nominal)
                .HasColumnName("nominal")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.IssueDate)
                .HasColumnName("issue_date")
                .HasColumnType("date")
                .IsRequired();

            entity.Property(e => e.MaturityDate)
                .HasColumnName("maturity_date")
                .HasColumnType("date")
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .HasConversion(
                    v => v.ToStringValue(),
                    v => IssuanceStatusExtensions.FromString(v))
                .IsRequired();

            entity.Property(e => e.ScheduleJson)
                .HasColumnName("schedule_json")
                .HasColumnType("jsonb");

            entity.Property(e => e.DltTxHash)
                .HasColumnName("dlt_tx_hash")
                .HasMaxLength(64);

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();

            entity.Property(e => e.PublishedAt)
                .HasColumnName("published_at");

            entity.Property(e => e.ClosedAt)
                .HasColumnName("closed_at");

            entity.HasIndex(e => e.AssetId);
            entity.HasIndex(e => e.IssuerId);
            entity.HasIndex(e => e.Status);
        });

        modelBuilder.Entity<OutboxMessage>(entity =>
        {
            entity.ToTable("outbox_messages");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.Topic)
                .HasColumnName("topic")
                .HasMaxLength(255)
                .IsRequired();

            entity.Property(e => e.Payload)
                .HasColumnName("payload")
                .HasColumnType("jsonb")
                .IsRequired();

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ProcessedAt)
                .HasColumnName("processed_at");

            entity.HasIndex(e => new { e.ProcessedAt, e.CreatedAt });
        });
    }
}

public class IssuanceEntity
{
    public Guid Id { get; set; }
    public Guid AssetId { get; set; }
    public Guid IssuerId { get; set; }
    public decimal TotalAmount { get; set; }
    public decimal Nominal { get; set; }
    public DateOnly IssueDate { get; set; }
    public DateOnly MaturityDate { get; set; }
    public IssuanceStatus Status { get; set; }
    public string? ScheduleJson { get; set; }
    public string? DltTxHash { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public DateTime? PublishedAt { get; set; }
    public DateTime? ClosedAt { get; set; }
}

public class OutboxMessage
{
    public Guid Id { get; set; }
    public string Topic { get; set; } = string.Empty;
    public string Payload { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
}


```
---
# services/issuance/Migrations/20250101000000_InitialCreate.cs
```cs
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace OIS.Issuance.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "issuances",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false),
                    asset_id = table.Column<Guid>(type: "uuid", nullable: false),
                    issuer_id = table.Column<Guid>(type: "uuid", nullable: false),
                    total_amount = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    nominal = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    issue_date = table.Column<DateOnly>(type: "date", nullable: false),
                    maturity_date = table.Column<DateOnly>(type: "date", nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    schedule_json = table.Column<string>(type: "jsonb", nullable: true),
                    dlt_tx_hash = table.Column<string>(type: "character varying(64)", maxLength: 64, nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    published_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    closed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_issuances", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_issuances_asset_id",
                table: "issuances",
                column: "asset_id");

            migrationBuilder.CreateIndex(
                name: "ix_issuances_issuer_id",
                table: "issuances",
                column: "issuer_id");

            migrationBuilder.CreateIndex(
                name: "ix_issuances_status",
                table: "issuances",
                column: "status");

            migrationBuilder.CreateTable(
                name: "outbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    topic = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    payload = table.Column<string>(type: "jsonb", nullable: false),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    processed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_outbox_messages", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_outbox_messages_processed_at_created_at",
                table: "outbox_messages",
                columns: new[] { "processed_at", "created_at" });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "issuances");

            migrationBuilder.DropTable(
                name: "outbox_messages");
        }
    }
}


```
---
# services/issuance/Program.cs
```cs
using FluentValidation;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Issuance;
using OIS.Issuance.DTOs;
using OIS.Issuance.Services;
using OIS.Issuance.Validators;
using Serilog;
using MassTransit;
using OIS.Contracts.Events;
using OIS.Issuance.Infrastructure;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using System.Diagnostics;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
var otlpEndpoint = builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"] ?? "http://otel-collector:4317";
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("issuance-service")
        .AddAttributes(new Dictionary<string, object> { ["environment"] = builder.Environment.EnvironmentName }))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddOtlpExporter(options => options.Endpoint = new Uri(otlpEndpoint)))
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Prometheus metrics endpoint is added via OpenTelemetry above

// Database
var useInMemoryDb = builder.Configuration.GetValue<bool>("UseInMemoryDatabase", false);
var issuanceMigrationsAssembly = typeof(IssuanceDbContext).Assembly.GetName().Name;

builder.Services.AddDbContext<IssuanceDbContext>(options =>
{
    if (useInMemoryDb)
    {
        var dbName = builder.Configuration.GetValue<string>("InMemoryDatabaseName") ?? "IssuanceTestsDb";
        options.UseInMemoryDatabase(dbName);
    }
    else
    {
        options.UseNpgsql(
            builder.Configuration.GetConnectionString("DefaultConnection"),
            npgsqlOptions => npgsqlOptions.MigrationsAssembly(issuanceMigrationsAssembly));
    }
});

// HTTP Client for Ledger Adapter
builder.Services.AddHttpClient<LedgerIssuanceAdapter>()
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

// Services
builder.Services.AddScoped<ILedgerIssuance, LedgerIssuanceAdapter>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IIssuanceService, IssuanceService>();

// MassTransit + Kafka publish
if (builder.Configuration.GetValue<bool>("Kafka:Enabled", true))
{
    builder.Services.AddMassTransit(x =>
    {
        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092");
            });
        });
    });

    builder.Services.AddHostedService<OIS.Issuance.Background.OutboxPublisher>();
}

// Validation
builder.Services.AddValidatorsFromAssemblyContaining<CreateIssuanceRequestValidator>();
builder.Services.AddFluentValidationAutoValidation();

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        if (!string.IsNullOrEmpty(authority)) options.Authority = authority;
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            RoleClaimType = ClaimTypes.Role
        };
        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx => { MapKeycloakRoles(ctx); return Task.CompletedTask; }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:any-auth", p => p.RequireAuthenticatedUser());
    options.AddPolicy("role:issuer-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("issuer") || ctx.User.IsInRole("backoffice")));
});

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<IssuanceDbContext>();

var app = builder.Build();

// Apply migrations (env MIGRATE_ON_STARTUP overrides RunMigrations flag)
var runMigrations = builder.Configuration.GetValue<bool>("RunMigrations", true);
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    runMigrations = true;
}
else if (string.Equals(migrateOnStartup, "false", StringComparison.OrdinalIgnoreCase))
{
    runMigrations = false;
}

if (runMigrations)
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<IssuanceDbContext>();
    db.Database.Migrate();
}

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

var disableHttpsRedirect = builder.Configuration.GetValue<bool>("DisableHttpsRedirection", false);
if (!disableHttpsRedirect)
{
    app.UseHttpsRedirection();
}
app.UseAuthentication();
app.UseAuthorization();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    // Correlate X-Request-ID
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();

    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Issuances").RequireAuthorization();

api.MapPost("/issuances", async (
    CreateIssuanceRequest request,
    IIssuanceService service,
    ILoggerFactory loggerFactory,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CreateAsync(request, ct);
        return Results.Created($"/v1/issuances/{result.Id}", result);
    }
    catch (FluentValidation.ValidationException vex)
    {
        var logger = loggerFactory.CreateLogger("CreateIssuance");
        logger.LogWarning(vex, "Validation failed for CreateIssuance");
        var errors = vex.Errors
            .GroupBy(e => e.PropertyName)
            .ToDictionary(g => g.Key, g => g.Select(e => e.ErrorMessage).ToArray());
        return Results.ValidationProblem(errors, statusCode: 400, title: "Validation Failed");
    }
    catch (Exception ex)
    {
        var logger = loggerFactory.CreateLogger("CreateIssuance");
        logger.LogError(ex, "CreateIssuance failed");
        return Results.Problem(detail: ex.Message, statusCode: 500, title: "Internal Server Error");
    }
})
.WithName("CreateIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapGet("/issuances/{id:guid}", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    var result = await service.GetByIdAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetIssuance")
.RequireAuthorization("role:any-auth")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/publish", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.PublishAsync(id, ct);
        return result is not null ? Results.Ok(result) : Results.NotFound();
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("PublishIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/close", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CloseAsync(id, ct);
        return result is not null ? Results.Ok(result) : Results.NotFound();
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("CloseIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapGet("/reports/issuances", async (
    Guid issuerId,
    DateOnly? from,
    DateOnly? to,
    IIssuanceService service,
    CancellationToken ct) =>
{
    var report = await service.GetIssuerIssuancesReportAsync(issuerId, from, to, ct);
    return Results.Ok(report);
})
.WithName("GetIssuerIssuancesReport")
.RequireAuthorization("role:issuer-or-backoffice")
.WithOpenApi();

app.Run();

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { }
}

public partial class Program { }

```
---
# services/issuance/Properties/launchSettings.json
```json
{
  "profiles": {
    "issuance": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:53978;http://localhost:53983"
    }
  }
}
```
---
# services/issuance/Services/ILedgerIssuance.cs
```cs
namespace OIS.Issuance.Services;

/// <summary>
/// Interface for ledger operations (Hyperledger Fabric chaincode)
/// </summary>
public interface ILedgerIssuance
{
    /// <summary>
    /// Issue an issuance on the ledger
    /// </summary>
    Task<string> IssueAsync(
        Guid id,
        Guid assetId,
        Guid issuerId,
        decimal totalAmount,
        decimal nominal,
        DateOnly issueDate,
        DateOnly maturityDate,
        string? scheduleJson,
        CancellationToken ct);

    /// <summary>
    /// Close an issuance on the ledger
    /// </summary>
    Task<string> CloseAsync(Guid id, CancellationToken ct);

    /// <summary>
    /// Get issuance from ledger
    /// </summary>
    Task<LedgerIssuanceInfo?> GetAsync(Guid id, CancellationToken ct);
}

public record LedgerIssuanceInfo
{
    public string Status { get; init; } = string.Empty;
    public int Version { get; init; }
    public string? TransactionHash { get; init; }
}


```
---
# services/issuance/Services/IssuanceService.cs
```cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using OIS.Domain;
using OIS.Issuance.DTOs;
using System.Text.Json;

namespace OIS.Issuance.Services;

public interface IIssuanceService
{
    Task<IssuanceResponse> CreateAsync(CreateIssuanceRequest request, CancellationToken ct);
    Task<IssuanceResponse?> GetByIdAsync(Guid id, CancellationToken ct);
    Task<IssuanceResponse?> PublishAsync(Guid id, CancellationToken ct);
    Task<IssuanceResponse?> CloseAsync(Guid id, CancellationToken ct);
    Task<IssuerIssuancesReportResponse> GetIssuerIssuancesReportAsync(Guid issuerId, DateOnly? from, DateOnly? to, CancellationToken ct);
}

public class IssuanceService : IIssuanceService
{
    private readonly IssuanceDbContext _db;
    private readonly ILogger<IssuanceService> _logger;
    private readonly IOutboxService _outbox;
    private readonly ILedgerIssuance _ledger;

    public IssuanceService(
        IssuanceDbContext db,
        ILogger<IssuanceService> logger,
        IOutboxService outbox,
        ILedgerIssuance ledger)
    {
        _db = db;
        _logger = logger;
        _outbox = outbox;
        _ledger = ledger;
    }

    public async Task<IssuanceResponse> CreateAsync(CreateIssuanceRequest request, CancellationToken ct)
    {
        var issuance = new IssuanceEntity
        {
            Id = Guid.NewGuid(),
            AssetId = request.AssetId,
            IssuerId = request.IssuerId,
            TotalAmount = request.TotalAmount,
            Nominal = request.Nominal,
            IssueDate = request.IssueDate,
            MaturityDate = request.MaturityDate,
            Status = IssuanceStatus.Draft,
            ScheduleJson = request.ScheduleJson != null 
                ? JsonSerializer.Serialize(request.ScheduleJson) 
                : null,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _db.Issuances.Add(issuance);
        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Created issuance {IssuanceId} for asset {AssetId}", issuance.Id, issuance.AssetId);

        return MapToResponse(issuance);
    }

    public async Task<IssuerIssuancesReportResponse> GetIssuerIssuancesReportAsync(
        Guid issuerId,
        DateOnly? from,
        DateOnly? to,
        CancellationToken ct)
    {
        var query = _db.Issuances
            .AsNoTracking()
            .Where(i => i.IssuerId == issuerId);

        if (from.HasValue)
        {
            query = query.Where(i => i.IssueDate >= from.Value);
        }

        if (to.HasValue)
        {
            query = query.Where(i => i.IssueDate <= to.Value);
        }

        var issuances = await query.ToListAsync(ct);

        var items = issuances.Select(i => new IssuerReportRow
        {
            IssuanceId = i.Id,
            AssetCode = i.AssetId.ToString(), // TODO: replace with real asset code when available
            AssetName = i.AssetId.ToString(), // TODO: replace with real asset name from domain/catalog
            TotalAmount = i.TotalAmount,
            SoldAmount = 0m, // TODO: pull real sold amount from registry once available
            InvestorsCount = 0, // TODO: pull investors count from registry once available
            Status = i.Status.ToStringValue(),
            IssueDate = i.IssueDate,
            MaturityDate = i.MaturityDate,
            PublishedAt = i.PublishedAt
        }).ToList();

        var summary = new IssuerIssuancesReportSummary
        {
            TotalIssuances = items.Count,
            TotalAmount = items.Sum(x => x.TotalAmount),
            TotalSold = items.Sum(x => x.SoldAmount),
            TotalInvestors = items.Sum(x => x.InvestorsCount)
        };

        return new IssuerIssuancesReportResponse
        {
            IssuerId = issuerId,
            Period = new IssuerIssuancesReportPeriod
            {
                From = from,
                To = to
            },
            Items = items,
            Summary = summary
        };
    }

    public async Task<IssuanceResponse?> GetByIdAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        return issuance != null ? MapToResponse(issuance) : null;
    }

    public async Task<IssuanceResponse?> PublishAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        if (issuance == null)
        {
            _logger.LogWarning("Publish requested for missing issuance {IssuanceId}", id);
            return null;
        }

        if (issuance.Status != IssuanceStatus.Draft)
            throw new InvalidOperationException($"Cannot publish issuance in status {issuance.Status}");

        // Issue on ledger
        var scheduleJson = issuance.ScheduleJson;
        string txHash;
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        try
        {
            txHash = await _ledger.IssueAsync(
                issuance.Id,
                issuance.AssetId,
                issuance.IssuerId,
                issuance.TotalAmount,
                issuance.Nominal,
                issuance.IssueDate,
                issuance.MaturityDate,
                scheduleJson,
                ct);

            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Issue successful for {IssuanceId}: txHash={TxHash}, duration={Duration}ms",
                issuance.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Issue failed for {IssuanceId} after {Duration}ms",
                issuance.Id, stopwatch.ElapsedMilliseconds);
            throw new InvalidOperationException($"Failed to issue on ledger: {ex.Message}", ex);
        }

        // Update database
        issuance.Status = IssuanceStatus.Published;
        issuance.PublishedAt = DateTime.UtcNow;
        issuance.UpdatedAt = DateTime.UtcNow;
        issuance.DltTxHash = txHash;

        await _db.SaveChangesAsync(ct);

        // Publish event via outbox
        var schedule = scheduleJson != null
            ? JsonSerializer.Deserialize<Dictionary<string, object>>(scheduleJson)
            : null;

        await _outbox.AddAsync("ois.issuance.published", new
        {
            issuanceId = issuance.Id,
            assetId = issuance.AssetId,
            issuerId = issuance.IssuerId,
            totalAmount = issuance.TotalAmount,
            schedule = schedule,
            publishedAt = issuance.PublishedAt,
            dltTxHash = txHash
        }, ct);

        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Published issuance {IssuanceId} with txHash {TxHash}", issuance.Id, txHash);

        return MapToResponse(issuance);
    }

    public async Task<IssuanceResponse?> CloseAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        if (issuance == null)
        {
            _logger.LogWarning("Close requested for missing issuance {IssuanceId}", id);
            return null;
        }

        if (issuance.Status != IssuanceStatus.Published)
            throw new InvalidOperationException($"Cannot close issuance in status {issuance.Status}");

        // Close on ledger
        string txHash;
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        try
        {
            txHash = await _ledger.CloseAsync(issuance.Id, ct);

            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Close successful for {IssuanceId}: txHash={TxHash}, duration={Duration}ms",
                issuance.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Close failed for {IssuanceId} after {Duration}ms",
                issuance.Id, stopwatch.ElapsedMilliseconds);
            throw new InvalidOperationException($"Failed to close on ledger: {ex.Message}", ex);
        }

        // Update database
        issuance.Status = IssuanceStatus.Closed;
        issuance.ClosedAt = DateTime.UtcNow;
        issuance.UpdatedAt = DateTime.UtcNow;
        issuance.DltTxHash = txHash; // Update with latest transaction hash

        await _db.SaveChangesAsync(ct);

        await _outbox.AddAsync("ois.issuance.closed", new
        {
            issuanceId = issuance.Id,
            closedAt = issuance.ClosedAt,
            dltTxHash = txHash
        }, ct);

        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Closed issuance {IssuanceId} with txHash {TxHash}", issuance.Id, txHash);

        return MapToResponse(issuance);
    }

    private static IssuanceResponse MapToResponse(IssuanceEntity entity)
    {
        Dictionary<string, object>? scheduleJson = null;
        if (!string.IsNullOrEmpty(entity.ScheduleJson))
        {
            scheduleJson = JsonSerializer.Deserialize<Dictionary<string, object>>(entity.ScheduleJson);
        }

        return new IssuanceResponse
        {
            Id = entity.Id,
            AssetId = entity.AssetId,
            IssuerId = entity.IssuerId,
            TotalAmount = entity.TotalAmount,
            Nominal = entity.Nominal,
            IssueDate = entity.IssueDate,
            MaturityDate = entity.MaturityDate,
            Status = entity.Status.ToStringValue(),
            ScheduleJson = scheduleJson,
            DltTxHash = entity.DltTxHash,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            PublishedAt = entity.PublishedAt,
            ClosedAt = entity.ClosedAt
        };
    }
}

```
---
# services/issuance/Services/LedgerIssuanceAdapter.cs
```cs
using System.Diagnostics;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Polly;
using Polly.Retry;

namespace OIS.Issuance.Services;

/// <summary>
/// Adapter for Hyperledger Fabric chaincode (with mock mode)
/// </summary>
public class LedgerIssuanceAdapter : ILedgerIssuance
{
    private readonly ILogger<LedgerIssuanceAdapter> _logger;
    private readonly IConfiguration _configuration;
    private readonly HttpClient _httpClient;
    private readonly bool _useMock;
    private readonly string? _chaincodeEndpoint;
    private readonly AsyncRetryPolicy _retryPolicy;

    public LedgerIssuanceAdapter(
        ILogger<LedgerIssuanceAdapter> logger,
        IConfiguration configuration,
        HttpClient httpClient)
    {
        _logger = logger;
        _configuration = configuration;
        _httpClient = httpClient;
        _chaincodeEndpoint = _configuration["Ledger:ChaincodeEndpoint"];
        _useMock = string.IsNullOrEmpty(_chaincodeEndpoint) || 
                   _configuration.GetValue<bool>("Ledger:UseMock", true);

        if (!_useMock && !string.IsNullOrEmpty(_chaincodeEndpoint))
        {
            _httpClient.BaseAddress = new Uri(_chaincodeEndpoint);
            _httpClient.Timeout = TimeSpan.FromSeconds(30);
        }

        // Retry policy with exponential backoff
        _retryPolicy = Policy
            .Handle<HttpRequestException>()
            .Or<TaskCanceledException>()
            .WaitAndRetryAsync(
                retryCount: 3,
                sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                onRetry: (exception, timeSpan, retryCount, context) =>
                {
                    _logger.LogWarning(
                        "Retry {RetryCount} after {Delay}ms for {Operation}",
                        retryCount, timeSpan.TotalMilliseconds, context.OperationKey);
                });

        if (_useMock)
        {
            _logger.LogWarning("Ledger adapter running in MOCK mode");
        }
        else
        {
            _logger.LogInformation("Ledger adapter connected to {Endpoint}", _chaincodeEndpoint);
        }
    }

    public async Task<string> IssueAsync(
        Guid id,
        Guid assetId,
        Guid issuerId,
        decimal totalAmount,
        decimal nominal,
        DateOnly issueDate,
        DateOnly maturityDate,
        string? scheduleJson,
        CancellationToken ct)
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            if (_useMock)
            {
                return await MockIssueAsync(id, ct);
            }

            return await RealIssueAsync(id, assetId, issuerId, totalAmount, nominal, issueDate, maturityDate, scheduleJson, ct);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Issue completed for {IssuanceId} in {Duration}ms",
                id, stopwatch.ElapsedMilliseconds);
        }
    }

    public async Task<string> CloseAsync(Guid id, CancellationToken ct)
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            if (_useMock)
            {
                return await MockCloseAsync(id, ct);
            }

            return await RealCloseAsync(id, ct);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Close completed for {IssuanceId} in {Duration}ms",
                id, stopwatch.ElapsedMilliseconds);
        }
    }

    public async Task<LedgerIssuanceInfo?> GetAsync(Guid id, CancellationToken ct)
    {
        if (_useMock)
        {
            return await MockGetAsync(id, ct);
        }

        return await RealGetAsync(id, ct);
    }

    private async Task<string> MockIssueAsync(Guid id, CancellationToken ct)
    {
        // Simulate network delay
        await Task.Delay(50, ct);

        // Generate mock transaction hash
        var txHash = GenerateMockTxHash();
        
        _logger.LogInformation("MOCK: Issued issuance {IssuanceId} with txHash {TxHash}", id, txHash);
        
        return txHash;
    }

    private async Task<string> MockCloseAsync(Guid id, CancellationToken ct)
    {
        // Simulate network delay
        await Task.Delay(50, ct);

        // Generate mock transaction hash
        var txHash = GenerateMockTxHash();
        
        _logger.LogInformation("MOCK: Closed issuance {IssuanceId} with txHash {TxHash}", id, txHash);
        
        return txHash;
    }

    private async Task<LedgerIssuanceInfo?> MockGetAsync(Guid id, CancellationToken ct)
    {
        await Task.Delay(30, ct);
        
        // Mock: assume issuance exists and is published
        return new LedgerIssuanceInfo
        {
            Status = "published",
            Version = 1,
            TransactionHash = GenerateMockTxHash()
        };
    }

    private async Task<string> RealIssueAsync(
        Guid id,
        Guid assetId,
        Guid issuerId,
        decimal totalAmount,
        decimal nominal,
        DateOnly issueDate,
        DateOnly maturityDate,
        string? scheduleJson,
        CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "issuance",
                function = "Issue",
                args = new[]
                {
                    id.ToString(),
                    assetId.ToString(),
                    issuerId.ToString(),
                    totalAmount.ToString(),
                    nominal.ToString(),
                    issueDate.ToString("yyyy-MM-dd"),
                    maturityDate.ToString("yyyy-MM-dd"),
                    scheduleJson ?? "{}"
                }
            };

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/invoke", content, ct);
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var result = JsonSerializer.Deserialize<ChaincodeResponse>(responseContent);

            if (result?.TransactionHash == null)
            {
                throw new InvalidOperationException($"Failed to get transaction hash from ledger: {result?.Error ?? "Unknown error"}");
            }

            _logger.LogInformation("Issued issuance {IssuanceId} on ledger with txHash {TxHash}", id, result.TransactionHash);

            return result.TransactionHash;
        }, new Context("Issue"));
    }

    private async Task<string> RealCloseAsync(Guid id, CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "issuance",
                function = "Close",
                args = new[] { id.ToString() }
            };

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/invoke", content, ct);
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var result = JsonSerializer.Deserialize<ChaincodeResponse>(responseContent);

            if (result?.TransactionHash == null)
            {
                throw new InvalidOperationException($"Failed to get transaction hash from ledger: {result?.Error ?? "Unknown error"}");
            }

            _logger.LogInformation("Closed issuance {IssuanceId} on ledger with txHash {TxHash}", id, result.TransactionHash);

            return result.TransactionHash;
        }, new Context("Close"));
    }

    private async Task<LedgerIssuanceInfo?> RealGetAsync(Guid id, CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "issuance",
                function = "Get",
                args = new[] { id.ToString() }
            };

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/query", content, ct);
            
            if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                return null;
            }

            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var issuance = JsonSerializer.Deserialize<ChaincodeIssuance>(responseContent);

            if (issuance == null)
            {
                return null;
            }

            return new LedgerIssuanceInfo
            {
                Status = issuance.Status ?? "unknown",
                Version = issuance.Version,
                TransactionHash = issuance.TransactionHash
            };
        }, new Context("Get"));
    }

    private static string GenerateMockTxHash()
    {
        // Generate a mock transaction hash (64 hex characters)
        var random = new Random();
        var bytes = new byte[32];
        random.NextBytes(bytes);
        return Convert.ToHexString(bytes).ToLowerInvariant();
    }

    private class ChaincodeResponse
    {
        public string? TransactionHash { get; set; }
        public bool Success { get; set; }
        public string? Error { get; set; }
    }

    private class ChaincodeIssuance
    {
        public string? Status { get; set; }
        public int Version { get; set; }
        public string? TransactionHash { get; set; }
    }
}


```
---
# services/issuance/Services/OutboxService.cs
```cs
using System.Text.Json;

namespace OIS.Issuance.Services;

public interface IOutboxService
{
    Task AddAsync(string topic, object payload, CancellationToken ct);
}

public class OutboxService : IOutboxService
{
    private readonly IssuanceDbContext _db;

    public OutboxService(IssuanceDbContext db)
    {
        _db = db;
    }

    public async Task AddAsync(string topic, object payload, CancellationToken ct)
    {
        var message = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            Topic = topic,
            Payload = JsonSerializer.Serialize(payload),
            CreatedAt = DateTime.UtcNow
        };

        _db.OutboxMessages.Add(message);
    }
}


```
---
# services/issuance/Validators/CreateIssuanceRequestValidator.cs
```cs
using FluentValidation;
using OIS.Issuance.DTOs;

namespace OIS.Issuance.Validators;

public class CreateIssuanceRequestValidator : AbstractValidator<CreateIssuanceRequest>
{
    public CreateIssuanceRequestValidator()
    {
        RuleFor(x => x.AssetId)
            .NotEmpty()
            .WithMessage("AssetId is required");

        RuleFor(x => x.IssuerId)
            .NotEmpty()
            .WithMessage("IssuerId is required");

        RuleFor(x => x.TotalAmount)
            .GreaterThan(0)
            .WithMessage("TotalAmount must be greater than 0");

        RuleFor(x => x.Nominal)
            .GreaterThan(0)
            .WithMessage("Nominal must be greater than 0");

        RuleFor(x => x.IssueDate)
            .NotEmpty()
            .WithMessage("IssueDate is required");

        RuleFor(x => x.MaturityDate)
            .NotEmpty()
            .WithMessage("MaturityDate is required")
            .GreaterThan(x => x.IssueDate)
            .WithMessage("MaturityDate must be after IssueDate");
    }
}


```
---
# services/issuance/appsettings.json
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=ois;Username=ois;Password=ois_dev_password"
  },
  "Kafka": {
    "BootstrapServers": "localhost:9092"
  },
  "Ledger": {
    "UseMock": false,
    "ChaincodeEndpoint": "http://localhost:8080"
  },
  "Fabric": {
    "PeerEndpoint": "http://localhost:7051",
    "ChannelName": "cfa-main",
    "MspId": "OisDevMSP",
    "TlsCertPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/server.crt",
    "TlsKeyPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/server.key",
    "TlsRootCertPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/ca.crt"
  },
  "Serilog": {
    "Using": ["Serilog.Sinks.Console"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  }
}


```
---
# services/issuance/issuance.Tests.csproj
```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <IsPackable>false</IsPackable>
    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.0" />
    <PackageReference Include="Microsoft.TestPlatform.TestHost" Version="17.11.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="FluentAssertions" Version="6.12.1" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="Moq" Version="4.20.70" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="9.0.0" />
  </ItemGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="issuance.csproj" />
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>

  <!-- Limit compile scope to test files only -->
  <ItemGroup>
    <Compile Include="issuance.Tests/**/*.cs" />
  </ItemGroup>

</Project>

```
---
# services/issuance/issuance.Tests/README.md
```md
# Issuance.Tests Notes

## EF Core provider in WebApplicationFactory

Use **only one** provider in test host. The in-memory host must not register Npgsql alongside InMemory, otherwise tests throw:

```
InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL' and 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider.
```

In `Program` (test bootstrapping) ensure:

- `UseInMemoryDatabase("IssuanceTestsDb")` in tests;
- No `UseNpgsql` registration for tests.

## How to run

```bash
cd services/issuance
dotnet test issuance.Tests/issuance.Tests.csproj -v minimal
```

Place latest test output in `artifacts/issuance-test-report.txt` when available.

```
---
# services/issuance/issuance.Tests/TestResults/issuance.trx
```trx
<?xml version="1.0" encoding="utf-8"?>
<TestRun id="a621d767-2977-4c8f-8efd-de7cb1965760" name="@god 2025-11-12 22:57:35" xmlns="http://microsoft.com/schemas/VisualStudio/TeamTest/2010">
  <Times creation="2025-11-12T22:57:35.8259960+03:00" queuing="2025-11-12T22:57:35.8259960+03:00" start="2025-11-12T22:57:33.5915440+03:00" finish="2025-11-12T22:57:37.3468669+03:00" />
  <TestSettings name="default" id="e56a73df-519e-4e0d-a755-3afe4308f849">
    <Deployment runDeploymentRoot="_god_2025-11-12_22_57_35" />
  </TestSettings>
  <Results>
    <UnitTestResult executionId="bf8ffb69-e951-4d06-bd54-f18aac134af0" testId="b578e133-b828-4a7e-0a9f-fc28e429ed5c" testName="OIS.Issuance.Tests.IssuanceApiTests.Create_Invalid_Should_Return_400" computerName="god" duration="00:00:00.0076138" startTime="2025-11-12T22:57:37.1995144+03:00" endTime="2025-11-12T22:57:37.1995144+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Failed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="bf8ffb69-e951-4d06-bd54-f18aac134af0">
      <Output>
        <ErrorInfo>
          <Message>Expected response.StatusCode to be HttpStatusCode.BadRequest {value: 400}, but found HttpStatusCode.InternalServerError {value: 500}.</Message>
          <StackTrace>   at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)
   at FluentAssertions.Execution.TestFrameworkProvider.Throw(String message)
   at FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(String message)
   at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
   at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
   at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)
   at FluentAssertions.Primitives.EnumAssertions`2.Be(TEnum expected, String because, Object[] becauseArgs)
   at OIS.Issuance.Tests.IssuanceApiTests.Create_Invalid_Should_Return_400() in /mnt/w/development/ois-cfa/services/issuance/issuance.Tests/IssuanceApiTests.cs:line 93
--- End of stack trace from previous location ---</StackTrace>
        </ErrorInfo>
      </Output>
    </UnitTestResult>
    <UnitTestResult executionId="81757ce4-446a-4860-ba70-ec767d45ad15" testId="acbbf9bc-637e-f581-d6c7-953059561031" testName="OIS.Issuance.Tests.IssuanceServiceTests.CloseAsync_FromPublished_ShouldSucceed" computerName="god" duration="00:00:00.0054905" startTime="2025-11-12T22:57:35.4351130+03:00" endTime="2025-11-12T22:57:35.4351131+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Passed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="81757ce4-446a-4860-ba70-ec767d45ad15" />
    <UnitTestResult executionId="b3dac4c4-4ac7-4dfa-85f9-3629e189ebaa" testId="bf851f9a-f7ba-90b7-6ecb-9870f2fd56ec" testName="OIS.Issuance.Tests.IssuanceServiceTests.CreateAsync_ShouldCreateDraftIssuance" computerName="god" duration="00:00:00.7231448" startTime="2025-11-12T22:57:35.3295831+03:00" endTime="2025-11-12T22:57:35.3296657+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Passed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="b3dac4c4-4ac7-4dfa-85f9-3629e189ebaa" />
    <UnitTestResult executionId="d35a9190-c334-4ed1-914d-f945cbcc8d42" testId="32b0aa8e-1e82-1a6a-15af-30efc0e73a02" testName="OIS.Issuance.Tests.IssuanceApiTests.Publish_Then_Close_Should_Succeed" computerName="god" duration="00:00:00.0358204" startTime="2025-11-12T22:57:37.1912076+03:00" endTime="2025-11-12T22:57:37.1912078+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Failed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="d35a9190-c334-4ed1-914d-f945cbcc8d42">
      <Output>
        <ErrorInfo>
          <Message>System.Text.Json.JsonException : 'S' is an invalid start of a value. Path: $ | LineNumber: 0 | BytePositionInLine: 0.
---- System.Text.Json.JsonReaderException : 'S' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0.</Message>
          <StackTrace>   at System.Text.Json.ThrowHelper.ReThrowWithPath(ReadStack&amp; state, JsonReaderException ex)
   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader&amp; reader, T&amp; value, JsonSerializerOptions options, ReadStack&amp; state)
   at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.ContinueDeserialize(ReadBufferState&amp; bufferState, JsonReaderState&amp; jsonReaderState, ReadStack&amp; readStack, T&amp; value)
   at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.DeserializeAsync(Stream utf8Json, CancellationToken cancellationToken)
   at System.Net.Http.Json.HttpContentJsonExtensions.ReadFromJsonAsyncCore[T](HttpContent content, JsonSerializerOptions options, CancellationToken cancellationToken)
   at OIS.Issuance.Tests.IssuanceApiTests.Publish_Then_Close_Should_Succeed() in /mnt/w/development/ois-cfa/services/issuance/issuance.Tests/IssuanceApiTests.cs:line 111
--- End of stack trace from previous location ---
----- Inner Stack Trace -----
   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader&amp; json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes)
   at System.Text.Json.Utf8JsonReader.ConsumeValue(Byte marker)
   at System.Text.Json.Utf8JsonReader.ReadFirstToken(Byte first)
   at System.Text.Json.Utf8JsonReader.ReadSingleSegment()
   at System.Text.Json.Utf8JsonReader.Read()
   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader&amp; reader, T&amp; value, JsonSerializerOptions options, ReadStack&amp; state)</StackTrace>
        </ErrorInfo>
      </Output>
    </UnitTestResult>
    <UnitTestResult executionId="7010f237-c0d9-4eb4-96d0-1103619ae190" testId="cf556f3d-20d5-97bf-3831-c0e7d2f487ac" testName="OIS.Issuance.Tests.IssuanceServiceTests.PublishAsync_FromNonDraft_ShouldThrow" computerName="god" duration="00:00:00.0025104" startTime="2025-11-12T22:57:35.4294247+03:00" endTime="2025-11-12T22:57:35.4294247+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Passed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="7010f237-c0d9-4eb4-96d0-1103619ae190" />
    <UnitTestResult executionId="5aadd27a-fb1f-4fa8-93c7-1f56a4f83e5e" testId="6a93f21e-872c-d16b-a12b-55f7ab85847f" testName="OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404" computerName="god" duration="00:00:00.0160388" startTime="2025-11-12T22:57:37.1688341+03:00" endTime="2025-11-12T22:57:37.1688341+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Failed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="5aadd27a-fb1f-4fa8-93c7-1f56a4f83e5e">
      <Output>
        <ErrorInfo>
          <Message>Expected res.StatusCode to be HttpStatusCode.NotFound {value: 404}, but found HttpStatusCode.InternalServerError {value: 500}.</Message>
          <StackTrace>   at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)
   at FluentAssertions.Execution.TestFrameworkProvider.Throw(String message)
   at FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(String message)
   at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
   at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
   at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)
   at FluentAssertions.Primitives.EnumAssertions`2.Be(TEnum expected, String because, Object[] becauseArgs)
   at OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404() in /mnt/w/development/ois-cfa/services/issuance/issuance.Tests/IssuanceApiTests.cs:line 75
--- End of stack trace from previous location ---</StackTrace>
        </ErrorInfo>
      </Output>
    </UnitTestResult>
    <UnitTestResult executionId="aceea3c5-7b34-4ca5-9526-80e40f6650a2" testId="4904500a-1114-aa1a-fcd9-45e46f3a4c3e" testName="OIS.Issuance.Tests.IssuanceServiceTests.CloseAsync_FromNonPublished_ShouldThrow" computerName="god" duration="00:00:00.0276405" startTime="2025-11-12T22:57:35.4267623+03:00" endTime="2025-11-12T22:57:35.4267624+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Passed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="aceea3c5-7b34-4ca5-9526-80e40f6650a2" />
    <UnitTestResult executionId="1b0a3706-f917-43a0-8170-cc63cd36aba2" testId="ca7063cf-4e58-a6e2-5d37-4029607b328e" testName="OIS.Issuance.Tests.IssuanceServiceTests.PublishAsync_FromDraft_ShouldSucceed" computerName="god" duration="00:00:00.0700479" startTime="2025-11-12T22:57:35.3990660+03:00" endTime="2025-11-12T22:57:35.3990661+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Passed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="1b0a3706-f917-43a0-8170-cc63cd36aba2" />
    <UnitTestResult executionId="ca98ecca-cf7d-4494-b842-3c3095e736b2" testId="b89bc89f-c173-ad53-d0a1-6296deb84cda" testName="OIS.Issuance.Tests.IssuanceApiTests.Create_Then_Get_Should_Return_Issuance" computerName="god" duration="00:00:02.5231499" startTime="2025-11-12T22:57:37.1395254+03:00" endTime="2025-11-12T22:57:37.1395255+03:00" testType="13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b" outcome="Failed" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" relativeResultsDirectory="ca98ecca-cf7d-4494-b842-3c3095e736b2">
      <Output>
        <ErrorInfo>
          <Message>Expected created.StatusCode to be HttpStatusCode.Created {value: 201}, but found HttpStatusCode.InternalServerError {value: 500}.</Message>
          <StackTrace>   at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)
   at FluentAssertions.Execution.TestFrameworkProvider.Throw(String message)
   at FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(String message)
   at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
   at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
   at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)
   at FluentAssertions.Primitives.EnumAssertions`2.Be(TEnum expected, String because, Object[] becauseArgs)
   at OIS.Issuance.Tests.IssuanceApiTests.Create_Then_Get_Should_Return_Issuance() in /mnt/w/development/ois-cfa/services/issuance/issuance.Tests/IssuanceApiTests.cs:line 58
--- End of stack trace from previous location ---</StackTrace>
        </ErrorInfo>
      </Output>
    </UnitTestResult>
  </Results>
  <TestDefinitions>
    <UnitTest name="OIS.Issuance.Tests.IssuanceServiceTests.PublishAsync_FromNonDraft_ShouldThrow" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="cf556f3d-20d5-97bf-3831-c0e7d2f487ac">
      <Execution id="7010f237-c0d9-4eb4-96d0-1103619ae190" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceServiceTests" name="PublishAsync_FromNonDraft_ShouldThrow" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceServiceTests.PublishAsync_FromDraft_ShouldSucceed" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="ca7063cf-4e58-a6e2-5d37-4029607b328e">
      <Execution id="1b0a3706-f917-43a0-8170-cc63cd36aba2" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceServiceTests" name="PublishAsync_FromDraft_ShouldSucceed" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceApiTests.Publish_Then_Close_Should_Succeed" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="32b0aa8e-1e82-1a6a-15af-30efc0e73a02">
      <Execution id="d35a9190-c334-4ed1-914d-f945cbcc8d42" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceApiTests" name="Publish_Then_Close_Should_Succeed" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceApiTests.Create_Invalid_Should_Return_400" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="b578e133-b828-4a7e-0a9f-fc28e429ed5c">
      <Execution id="bf8ffb69-e951-4d06-bd54-f18aac134af0" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceApiTests" name="Create_Invalid_Should_Return_400" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceServiceTests.CloseAsync_FromPublished_ShouldSucceed" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="acbbf9bc-637e-f581-d6c7-953059561031">
      <Execution id="81757ce4-446a-4860-ba70-ec767d45ad15" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceServiceTests" name="CloseAsync_FromPublished_ShouldSucceed" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="6a93f21e-872c-d16b-a12b-55f7ab85847f">
      <Execution id="5aadd27a-fb1f-4fa8-93c7-1f56a4f83e5e" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceApiTests" name="Publish_NonExistent_Should_Return_404" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceServiceTests.CloseAsync_FromNonPublished_ShouldThrow" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="4904500a-1114-aa1a-fcd9-45e46f3a4c3e">
      <Execution id="aceea3c5-7b34-4ca5-9526-80e40f6650a2" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceServiceTests" name="CloseAsync_FromNonPublished_ShouldThrow" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceServiceTests.CreateAsync_ShouldCreateDraftIssuance" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="bf851f9a-f7ba-90b7-6ecb-9870f2fd56ec">
      <Execution id="b3dac4c4-4ac7-4dfa-85f9-3629e189ebaa" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceServiceTests" name="CreateAsync_ShouldCreateDraftIssuance" />
    </UnitTest>
    <UnitTest name="OIS.Issuance.Tests.IssuanceApiTests.Create_Then_Get_Should_Return_Issuance" storage="/mnt/w/development/ois-cfa/services/issuance/issuance.tests/bin/release/net9.0/issuance.tests.dll" id="b89bc89f-c173-ad53-d0a1-6296deb84cda">
      <Execution id="ca98ecca-cf7d-4494-b842-3c3095e736b2" />
      <TestMethod codeBase="/mnt/w/development/ois-cfa/services/issuance/issuance.Tests/bin/Release/net9.0/issuance.Tests.dll" adapterTypeName="executor://xunit/VsTestRunner2/netcoreapp" className="OIS.Issuance.Tests.IssuanceApiTests" name="Create_Then_Get_Should_Return_Issuance" />
    </UnitTest>
  </TestDefinitions>
  <TestEntries>
    <TestEntry testId="b578e133-b828-4a7e-0a9f-fc28e429ed5c" executionId="bf8ffb69-e951-4d06-bd54-f18aac134af0" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="acbbf9bc-637e-f581-d6c7-953059561031" executionId="81757ce4-446a-4860-ba70-ec767d45ad15" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="bf851f9a-f7ba-90b7-6ecb-9870f2fd56ec" executionId="b3dac4c4-4ac7-4dfa-85f9-3629e189ebaa" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="32b0aa8e-1e82-1a6a-15af-30efc0e73a02" executionId="d35a9190-c334-4ed1-914d-f945cbcc8d42" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="cf556f3d-20d5-97bf-3831-c0e7d2f487ac" executionId="7010f237-c0d9-4eb4-96d0-1103619ae190" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="6a93f21e-872c-d16b-a12b-55f7ab85847f" executionId="5aadd27a-fb1f-4fa8-93c7-1f56a4f83e5e" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="4904500a-1114-aa1a-fcd9-45e46f3a4c3e" executionId="aceea3c5-7b34-4ca5-9526-80e40f6650a2" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="ca7063cf-4e58-a6e2-5d37-4029607b328e" executionId="1b0a3706-f917-43a0-8170-cc63cd36aba2" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestEntry testId="b89bc89f-c173-ad53-d0a1-6296deb84cda" executionId="ca98ecca-cf7d-4494-b842-3c3095e736b2" testListId="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
  </TestEntries>
  <TestLists>
    <TestList name="Results Not in a List" id="8c84fa94-04c1-424b-9868-57a2d4851a1d" />
    <TestList name="All Loaded Results" id="19431567-8539-422a-85d7-44ee4e166bda" />
  </TestLists>
  <ResultSummary outcome="Failed">
    <Counters total="9" executed="9" passed="5" failed="4" error="0" timeout="0" aborted="0" inconclusive="0" passedButRunAborted="0" notRunnable="0" notExecuted="0" disconnected="0" warning="0" completed="0" inProgress="0" pending="0" />
    <Output>
      <StdOut>[xUnit.net 00:00:00.00] xUnit.net VSTest Adapter v2.8.2+699d445a1a (64-bit .NET 9.0.11)
[xUnit.net 00:00:00.17]   Discovering: issuance.Tests
[xUnit.net 00:00:00.23]   Discovered:  issuance.Tests
[xUnit.net 00:00:00.23]   Starting:    issuance.Tests
2025-11-12 22:57:36.932 +03:00 [DBG] AuthenticationScheme: Test was successfully authenticated.
{"Timestamp":"2025-11-12T22:57:36.9324716+03:00","Level":"Debug","MessageTemplate":"AuthenticationScheme: {AuthenticationScheme} was successfully authenticated.","TraceId":"ca306ca9686fd353430fbf1107a5e75b","SpanId":"ce5913b20c111d17","Properties":{"AuthenticationScheme":"Test","EventId":{"Id":8,"Name":"AuthenticationSchemeAuthenticated"},"SourceContext":"OIS.Issuance.Tests.TestAuthHandler","RequestId":"0HNH24MT5F0NC","RequestPath":"/v1/issuances"}}
2025-11-12 22:57:37.016 +03:00 [WRN] Ledger adapter running in MOCK mode
{"Timestamp":"2025-11-12T22:57:37.0165290+03:00","Level":"Warning","MessageTemplate":"Ledger adapter running in MOCK mode","TraceId":"ca306ca9686fd353430fbf1107a5e75b","SpanId":"ce5913b20c111d17","Properties":{"SourceContext":"OIS.Issuance.Services.LedgerIssuanceAdapter","RequestId":"0HNH24MT5F0NC","RequestPath":"/v1/issuances"}}
2025-11-12 22:57:37.028 +03:00 [ERR] An unhandled exception has occurred while executing the request.
System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.
   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)
   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()
   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()
   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11
   at OIS.Issuance.Services.IssuanceService.CreateAsync(CreateIssuanceRequest request, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 54
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_9&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 190
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.&lt;&gt;c__DisplayClass101_2.&lt;&lt;HandleRequestBodyAndCompileRequestDelegateForJson&gt;b__2&gt;d.MoveNext()
--- End of stack trace from previous location ---
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)
{"Timestamp":"2025-11-12T22:57:37.0289648+03:00","Level":"Error","MessageTemplate":"An unhandled exception has occurred while executing the request.","TraceId":"ca306ca9686fd353430fbf1107a5e75b","SpanId":"ce5913b20c111d17","Exception":"System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.\n   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)\n   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()\n   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()\n   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()\n   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()\n   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11\n   at OIS.Issuance.Services.IssuanceService.CreateAsync(CreateIssuanceRequest request, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 54\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_9&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 190\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.&lt;&gt;c__DisplayClass101_2.&lt;&lt;HandleRequestBodyAndCompileRequestDelegateForJson&gt;b__2&gt;d.MoveNext()\n--- End of stack trace from previous location ---\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\n   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\n   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)","Properties":{"EventId":{"Id":1,"Name":"UnhandledException"},"SourceContext":"Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware","RequestId":"0HNH24MT5F0NC","RequestPath":"/v1/issuances"}}
[xUnit.net 00:00:02.81]       Expected created.StatusCode to be HttpStatusCode.Created {value: 201}, but found HttpStatusCode.InternalServerError {value: 500}.
[xUnit.net 00:00:02.81]       Stack Trace:
[xUnit.net 00:00:02.81]            at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)
[xUnit.net 00:00:02.81]            at FluentAssertions.Execution.TestFrameworkProvider.Throw(String message)
[xUnit.net 00:00:02.81]            at FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(String message)
[xUnit.net 00:00:02.81]            at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
[xUnit.net 00:00:02.81]            at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
[xUnit.net 00:00:02.81]            at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)
[xUnit.net 00:00:02.81]            at FluentAssertions.Primitives.EnumAssertions`2.Be(TEnum expected, String because, Object[] becauseArgs)
[xUnit.net 00:00:02.81]         /mnt/w/development/ois-cfa/services/issuance/issuance.Tests/IssuanceApiTests.cs(58,0): at OIS.Issuance.Tests.IssuanceApiTests.Create_Then_Get_Should_Return_Issuance()
[xUnit.net 00:00:02.81]         --- End of stack trace from previous location ---
2025-11-12 22:57:37.141 +03:00 [DBG] AuthenticationScheme: Test was successfully authenticated.
{"Timestamp":"2025-11-12T22:57:37.1419919+03:00","Level":"Debug","MessageTemplate":"AuthenticationScheme: {AuthenticationScheme} was successfully authenticated.","TraceId":"4607244e314dbb229e0f96a8fe856e94","SpanId":"a8ae6694fcda2989","Properties":{"AuthenticationScheme":"Test","EventId":{"Id":8,"Name":"AuthenticationSchemeAuthenticated"},"SourceContext":"OIS.Issuance.Tests.TestAuthHandler","RequestId":"0HNH24MT5F0ND","RequestPath":"/v1/issuances/4dfca955-fb4b-4a95-8914-ad007e28ecf7/publish"}}
2025-11-12 22:57:37.143 +03:00 [WRN] Ledger adapter running in MOCK mode
{"Timestamp":"2025-11-12T22:57:37.1438786+03:00","Level":"Warning","MessageTemplate":"Ledger adapter running in MOCK mode","TraceId":"4607244e314dbb229e0f96a8fe856e94","SpanId":"a8ae6694fcda2989","Properties":{"SourceContext":"OIS.Issuance.Services.LedgerIssuanceAdapter","RequestId":"0HNH24MT5F0ND","RequestPath":"/v1/issuances/4dfca955-fb4b-4a95-8914-ad007e28ecf7/publish"}}
2025-11-12 22:57:37.145 +03:00 [ERR] An unhandled exception has occurred while executing the request.
System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.
   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)
   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()
   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()
   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11
   at OIS.Issuance.Services.IssuanceService.GetByIdAsync(Guid id, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 64
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_11&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 214
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)
{"Timestamp":"2025-11-12T22:57:37.1456021+03:00","Level":"Error","MessageTemplate":"An unhandled exception has occurred while executing the request.","TraceId":"4607244e314dbb229e0f96a8fe856e94","SpanId":"a8ae6694fcda2989","Exception":"System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.\n   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)\n   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()\n   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()\n   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()\n   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()\n   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11\n   at OIS.Issuance.Services.IssuanceService.GetByIdAsync(Guid id, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 64\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_11&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 214\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\n   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\n   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)","Properties":{"EventId":{"Id":1,"Name":"UnhandledException"},"SourceContext":"Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware","RequestId":"0HNH24MT5F0ND","RequestPath":"/v1/issuances/4dfca955-fb4b-4a95-8914-ad007e28ecf7/publish"}}
[xUnit.net 00:00:02.82]       Expected res.StatusCode to be HttpStatusCode.NotFound {value: 404}, but found HttpStatusCode.InternalServerError {value: 500}.
[xUnit.net 00:00:02.82]       Stack Trace:
[xUnit.net 00:00:02.82]            at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)
[xUnit.net 00:00:02.82]            at FluentAssertions.Execution.TestFrameworkProvider.Throw(String message)
[xUnit.net 00:00:02.82]            at FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(String message)
[xUnit.net 00:00:02.84]            at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
[xUnit.net 00:00:02.84]            at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
[xUnit.net 00:00:02.84]            at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)
[xUnit.net 00:00:02.84]            at FluentAssertions.Primitives.EnumAssertions`2.Be(TEnum expected, String because, Object[] becauseArgs)
[xUnit.net 00:00:02.84]         /mnt/w/development/ois-cfa/services/issuance/issuance.Tests/IssuanceApiTests.cs(75,0): at OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404()
[xUnit.net 00:00:02.84]         --- End of stack trace from previous location ---
2025-11-12 22:57:37.170 +03:00 [DBG] AuthenticationScheme: Test was successfully authenticated.
{"Timestamp":"2025-11-12T22:57:37.1708676+03:00","Level":"Debug","MessageTemplate":"AuthenticationScheme: {AuthenticationScheme} was successfully authenticated.","TraceId":"ad7bb7d44865b5e21cceed14088770fa","SpanId":"6501f3b628784934","Properties":{"AuthenticationScheme":"Test","EventId":{"Id":8,"Name":"AuthenticationSchemeAuthenticated"},"SourceContext":"OIS.Issuance.Tests.TestAuthHandler","RequestId":"0HNH24MT5F0NE","RequestPath":"/v1/issuances"}}
2025-11-12 22:57:37.175 +03:00 [WRN] Ledger adapter running in MOCK mode
{"Timestamp":"2025-11-12T22:57:37.1751653+03:00","Level":"Warning","MessageTemplate":"Ledger adapter running in MOCK mode","TraceId":"ad7bb7d44865b5e21cceed14088770fa","SpanId":"6501f3b628784934","Properties":{"SourceContext":"OIS.Issuance.Services.LedgerIssuanceAdapter","RequestId":"0HNH24MT5F0NE","RequestPath":"/v1/issuances"}}
2025-11-12 22:57:37.175 +03:00 [ERR] An unhandled exception has occurred while executing the request.
System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.
   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)
   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()
   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()
   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11
   at OIS.Issuance.Services.IssuanceService.CreateAsync(CreateIssuanceRequest request, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 54
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_9&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 190
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.&lt;&gt;c__DisplayClass101_2.&lt;&lt;HandleRequestBodyAndCompileRequestDelegateForJson&gt;b__2&gt;d.MoveNext()
--- End of stack trace from previous location ---
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)
{"Timestamp":"2025-11-12T22:57:37.1759715+03:00","Level":"Error","MessageTemplate":"An unhandled exception has occurred while executing the request.","TraceId":"ad7bb7d44865b5e21cceed14088770fa","SpanId":"6501f3b628784934","Exception":"System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.\n   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)\n   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()\n   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()\n   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()\n   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()\n   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11\n   at OIS.Issuance.Services.IssuanceService.CreateAsync(CreateIssuanceRequest request, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 54\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_9&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 190\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.&lt;&gt;c__DisplayClass101_2.&lt;&lt;HandleRequestBodyAndCompileRequestDelegateForJson&gt;b__2&gt;d.MoveNext()\n--- End of stack trace from previous location ---\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\n   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\n   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)","Properties":{"EventId":{"Id":1,"Name":"UnhandledException"},"SourceContext":"Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware","RequestId":"0HNH24MT5F0NE","RequestPath":"/v1/issuances"}}
[xUnit.net 00:00:02.86]       System.Text.Json.JsonException : 'S' is an invalid start of a value. Path: $ | LineNumber: 0 | BytePositionInLine: 0.
[xUnit.net 00:00:02.86]       ---- System.Text.Json.JsonReaderException : 'S' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0.
[xUnit.net 00:00:02.86]       Stack Trace:
[xUnit.net 00:00:02.86]            at System.Text.Json.ThrowHelper.ReThrowWithPath(ReadStack&amp; state, JsonReaderException ex)
[xUnit.net 00:00:02.86]            at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader&amp; reader, T&amp; value, JsonSerializerOptions options, ReadStack&amp; state)
[xUnit.net 00:00:02.86]            at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.ContinueDeserialize(ReadBufferState&amp; bufferState, JsonReaderState&amp; jsonReaderState, ReadStack&amp; readStack, T&amp; value)
[xUnit.net 00:00:02.86]            at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.DeserializeAsync(Stream utf8Json, CancellationToken cancellationToken)
[xUnit.net 00:00:02.86]            at System.Net.Http.Json.HttpContentJsonExtensions.ReadFromJsonAsyncCore[T](HttpContent content, JsonSerializerOptions options, CancellationToken cancellationToken)
[xUnit.net 00:00:02.86]         /mnt/w/development/ois-cfa/services/issuance/issuance.Tests/IssuanceApiTests.cs(111,0): at OIS.Issuance.Tests.IssuanceApiTests.Publish_Then_Close_Should_Succeed()
[xUnit.net 00:00:02.86]         --- End of stack trace from previous location ---
[xUnit.net 00:00:02.86]         ----- Inner Stack Trace -----
[xUnit.net 00:00:02.86]            at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader&amp; json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes)
[xUnit.net 00:00:02.86]            at System.Text.Json.Utf8JsonReader.ConsumeValue(Byte marker)
[xUnit.net 00:00:02.86]            at System.Text.Json.Utf8JsonReader.ReadFirstToken(Byte first)
2025-11-12 22:57:37.191 +03:00 [DBG] AuthenticationScheme: Test was successfully authenticated.
[xUnit.net 00:00:02.86]            at System.Text.Json.Utf8JsonReader.ReadSingleSegment()
{"Timestamp":"2025-11-12T22:57:37.1915720+03:00","Level":"Debug","MessageTemplate":"AuthenticationScheme: {AuthenticationScheme} was successfully authenticated.","TraceId":"72698552894bc85e0de4e798426ec458","SpanId":"6b098f0a470da2e6","Properties":{"AuthenticationScheme":"Test","EventId":{"Id":8,"Name":"AuthenticationSchemeAuthenticated"},"SourceContext":"OIS.Issuance.Tests.TestAuthHandler","RequestId":"0HNH24MT5F0NF","RequestPath":"/v1/issuances"}}
[xUnit.net 00:00:02.86]            at System.Text.Json.Utf8JsonReader.Read()
[xUnit.net 00:00:02.86]            at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader&amp; reader, T&amp; value, JsonSerializerOptions options, ReadStack&amp; state)
2025-11-12 22:57:37.192 +03:00 [WRN] Ledger adapter running in MOCK mode
{"Timestamp":"2025-11-12T22:57:37.1922546+03:00","Level":"Warning","MessageTemplate":"Ledger adapter running in MOCK mode","TraceId":"72698552894bc85e0de4e798426ec458","SpanId":"6b098f0a470da2e6","Properties":{"SourceContext":"OIS.Issuance.Services.LedgerIssuanceAdapter","RequestId":"0HNH24MT5F0NF","RequestPath":"/v1/issuances"}}
2025-11-12 22:57:37.192 +03:00 [ERR] An unhandled exception has occurred while executing the request.
System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.
   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)
   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()
   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()
   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11
   at OIS.Issuance.Services.IssuanceService.CreateAsync(CreateIssuanceRequest request, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 54
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_9&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 190
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.&lt;&gt;c__DisplayClass101_2.&lt;&lt;HandleRequestBodyAndCompileRequestDelegateForJson&gt;b__2&gt;d.MoveNext()
--- End of stack trace from previous location ---
   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)
{"Timestamp":"2025-11-12T22:57:37.1926553+03:00","Level":"Error","MessageTemplate":"An unhandled exception has occurred while executing the request.","TraceId":"72698552894bc85e0de4e798426ec458","SpanId":"6b098f0a470da2e6","Exception":"System.InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL', 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to 'UseInternalServiceProvider'. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.\n   at Microsoft.EntityFrameworkCore.Internal.DbContextServices.Initialize(IServiceProvider scopedProvider, DbContextOptions contextOptions, DbContext context)\n   at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()\n   at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()\n   at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()\n   at Microsoft.EntityFrameworkCore.DbContext.Set[TEntity]()\n   at OIS.Issuance.IssuanceDbContext.get_Issuances() in /mnt/w/development/ois-cfa/services/issuance/IssuanceDbContext.cs:line 11\n   at OIS.Issuance.Services.IssuanceService.CreateAsync(CreateIssuanceRequest request, CancellationToken ct) in /mnt/w/development/ois-cfa/services/issuance/Services/IssuanceService.cs:line 54\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_9&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 190\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.ExecuteTaskResult[T](Task`1 task, HttpContext httpContext)\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.&lt;&gt;c__DisplayClass101_2.&lt;&lt;HandleRequestBodyAndCompileRequestDelegateForJson&gt;b__2&gt;d.MoveNext()\n--- End of stack trace from previous location ---\n   at Program.&lt;&gt;c.&lt;&lt;&lt;Main&gt;$&gt;b__0_8&gt;d.MoveNext() in /mnt/w/development/ois-cfa/services/issuance/Program.cs:line 156\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\n   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\n   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)","Properties":{"EventId":{"Id":1,"Name":"UnhandledException"},"SourceContext":"Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware","RequestId":"0HNH24MT5F0NF","RequestPath":"/v1/issuances"}}
[xUnit.net 00:00:02.87]       Expected response.StatusCode to be HttpStatusCode.BadRequest {value: 400}, but found HttpStatusCode.InternalServerError {value: 500}.
[xUnit.net 00:00:02.87]       Stack Trace:
[xUnit.net 00:00:02.87]            at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)
[xUnit.net 00:00:02.87]            at FluentAssertions.Execution.TestFrameworkProvider.Throw(String message)
[xUnit.net 00:00:02.87]            at FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(String message)
[xUnit.net 00:00:02.87]            at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
[xUnit.net 00:00:02.87]            at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)
[xUnit.net 00:00:02.87]            at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)
[xUnit.net 00:00:02.87]            at FluentAssertions.Primitives.EnumAssertions`2.Be(TEnum expected, String because, Object[] becauseArgs)
[xUnit.net 00:00:02.87]         /mnt/w/development/ois-cfa/services/issuance/issuance.Tests/IssuanceApiTests.cs(93,0): at OIS.Issuance.Tests.IssuanceApiTests.Create_Invalid_Should_Return_400()
[xUnit.net 00:00:02.87]         --- End of stack trace from previous location ---
[xUnit.net 00:00:02.88]   Finished:    issuance.Tests
</StdOut>
    </Output>
    <RunInfos>
      <RunInfo computerName="god" outcome="Error" timestamp="2025-11-12T22:57:37.1372406+03:00">
        <Text>[xUnit.net 00:00:02.81]     OIS.Issuance.Tests.IssuanceApiTests.Create_Then_Get_Should_Return_Issuance [FAIL]</Text>
      </RunInfo>
      <RunInfo computerName="god" outcome="Error" timestamp="2025-11-12T22:57:37.1535939+03:00">
        <Text>[xUnit.net 00:00:02.82]     OIS.Issuance.Tests.IssuanceApiTests.Publish_NonExistent_Should_Return_404 [FAIL]</Text>
      </RunInfo>
      <RunInfo computerName="god" outcome="Error" timestamp="2025-11-12T22:57:37.1910300+03:00">
        <Text>[xUnit.net 00:00:02.86]     OIS.Issuance.Tests.IssuanceApiTests.Publish_Then_Close_Should_Succeed [FAIL]</Text>
      </RunInfo>
      <RunInfo computerName="god" outcome="Error" timestamp="2025-11-12T22:57:37.1992893+03:00">
        <Text>[xUnit.net 00:00:02.87]     OIS.Issuance.Tests.IssuanceApiTests.Create_Invalid_Should_Return_400 [FAIL]</Text>
      </RunInfo>
    </RunInfos>
  </ResultSummary>
</TestRun>
```
---
# services/issuance/issuance.Tests/artifacts/issuance-test-report.txt
```txt
dotnet test services/issuance/issuance.Tests.csproj -v minimal
SDK: 9.0.308 (local install)
Result: no tests discovered (0 run).
Warnings: OutboxService async lacks await; various type conflicts resolved by limiting compile scope.
Timestamp: 2025-11-21T07:00:57+00:00

```
---
# services/issuance/issuance.csproj
```csproj
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <DefaultItemExcludes>$(DefaultItemExcludes);issuance.Tests/**</DefaultItemExcludes>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="issuance.Tests/**/*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="1.9.0-beta.1" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.9.0" />
    <PackageReference Include="Confluent.Kafka" Version="2.5.3" />
    <PackageReference Include="System.Text.Json" Version="9.0.0" />
    <PackageReference Include="Polly" Version="8.4.1" />
    <PackageReference Include="MassTransit" Version="8.2.0" />
    <PackageReference Include="MassTransit.Kafka" Version="8.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>
</Project>

```
---
# services/registry/Background/OutboxPublisher.cs
```cs
using MassTransit;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using OIS.Contracts.Events;
using Polly;

namespace OIS.Registry.Background;

public class OutboxPublisher : BackgroundService
{
    private readonly IServiceProvider _services;
    private readonly ILogger<OutboxPublisher> _logger;

    public OutboxPublisher(IServiceProvider services, ILogger<OutboxPublisher> logger)
    {
        _services = services;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _services.CreateScope();
                var db = scope.ServiceProvider.GetRequiredService<RegistryDbContext>();
                var publisher = scope.ServiceProvider.GetRequiredService<IPublishEndpoint>();

                var messages = await db.OutboxMessages
                    .Where(x => x.ProcessedAt == null)
                    .OrderBy(x => x.CreatedAt)
                    .Take(50)
                    .ToListAsync(stoppingToken);

                foreach (var msg in messages)
                {
                    var retry = Policy
                        .Handle<Exception>()
                        .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)));

                    await retry.ExecuteAsync(async () =>
                    {
                        await PublishTypedAsync(publisher, msg, stoppingToken);
                    });

                    msg.ProcessedAt = DateTime.UtcNow;
                }

                await db.SaveChangesAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken);
            }
            catch (OperationCanceledException) { break; }
            catch (Exception ex)
            {
                _logger.LogError(ex, "OutboxPublisher (Registry) failed");
                await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
            }
        }
    }

    private static async Task PublishTypedAsync(IPublishEndpoint publisher, OutboxMessage msg, CancellationToken ct)
    {
        switch (msg.Topic)
        {
            case "ois.order.created":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderCreated>(msg.Payload) is { } oc)
                { await publisher.Publish(oc, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.order.placed":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderPlaced>(msg.Payload) is { } placed)
                { await publisher.Publish(placed, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.order.reserved":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderReserved>(msg.Payload) is { } or)
                { await publisher.Publish(or, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.order.paid":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderPaid>(msg.Payload) is { } paid)
                { await publisher.Publish(paid, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.order.confirmed":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderConfirmed>(msg.Payload) is { } ocf)
                { await publisher.Publish(ocf, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.registry.transferred":
                if (System.Text.Json.JsonSerializer.Deserialize<RegistryTransferred>(msg.Payload) is { } rt)
                { await publisher.Publish(rt, x => x.MessageId = msg.Id, ct); return; }
                break;
        }

        // Fallback to audit
        if (System.Text.Json.JsonSerializer.Deserialize<AuditLogged>(msg.Payload) is { } audit)
            await publisher.Publish(audit, x => x.MessageId = msg.Id, ct);
    }
}

```
---
# services/registry/DTOs/CreateOrderRequest.cs
```cs
using System.ComponentModel.DataAnnotations;

namespace OIS.Registry.DTOs;

public record CreateOrderRequest
{
    [Required]
    public Guid InvestorId { get; init; }

    [Required]
    public Guid IssuanceId { get; init; }

    [Required]
    [Range(0.00000001, double.MaxValue)]
    public decimal Amount { get; init; }
}


```
---
# services/registry/DTOs/OrderResponse.cs
```cs
namespace OIS.Registry.DTOs;

public record OrderResponse
{
    public Guid Id { get; init; }
    public Guid InvestorId { get; init; }
    public Guid IssuanceId { get; init; }
    public decimal Amount { get; init; }
    public string Status { get; init; } = string.Empty;
    public Guid? WalletId { get; init; }
    public string? DltTxHash { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime UpdatedAt { get; init; }
    public DateTime? ConfirmedAt { get; init; }
    public string? FailureReason { get; init; }
}


```
---
# services/registry/DTOs/RedeemRequest.cs
```cs
using System.ComponentModel.DataAnnotations;

namespace OIS.Registry.DTOs;

public record RedeemRequest
{
    [Required]
    [Range(0.00000001, double.MaxValue)]
    public decimal Amount { get; init; }
}


```
---
# services/registry/DTOs/RedeemResponse.cs
```cs
namespace OIS.Registry.DTOs;

public record RedeemResponse
{
    public Guid IssuanceId { get; init; }
    public decimal RedeemedAmount { get; init; }
    public string DltTxHash { get; init; } = string.Empty;
    public DateTime RedeemedAt { get; init; }
}


```
---
# services/registry/DTOs/WalletResponse.cs
```cs
namespace OIS.Registry.DTOs;

public record WalletResponse
{
    public Guid InvestorId { get; init; }
    public decimal Balance { get; init; }
    public decimal Blocked { get; init; }
    public IReadOnlyList<HoldingDto> Holdings { get; init; } = Array.Empty<HoldingDto>();
}

public record HoldingDto
{
    public Guid IssuanceId { get; init; }
    public decimal Quantity { get; init; }
    public DateTime UpdatedAt { get; init; }
}


```
---
# services/registry/Dockerfile
```
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 8080

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY ["services/registry/registry.csproj", "services/registry/"]
COPY ["packages/domain/domain.csproj", "packages/domain/"]
RUN dotnet restore "services/registry/registry.csproj"
# Copy only required source to keep context minimal and exclude tests
COPY packages/domain/ packages/domain/
COPY services/registry/ services/registry/
RUN rm -rf services/registry/registry.Tests || true
WORKDIR "/src/services/registry"
RUN dotnet build "registry.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "registry.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "registry.dll"]

```
---
# services/registry/Infrastructure/Metrics.cs
```cs
using System.Diagnostics.Metrics;

namespace OIS.Registry.Infrastructure;

public static class Metrics
{
    public const string MeterName = "registry-service";
    private static readonly Meter Meter = new(MeterName);

    public static readonly Histogram<double> RequestDurationMs = Meter.CreateHistogram<double>(
        name: "request_duration_ms",
        unit: "ms",
        description: "API request latency in milliseconds");

    public static readonly Counter<long> RequestErrors = Meter.CreateCounter<long>(
        name: "request_errors_total",
        unit: "requests",
        description: "Number of API requests resulting in 5xx");
}


```
---
# services/registry/Migrations/20250102000000_InitialCreate.cs
```cs
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace OIS.Registry.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "wallets",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    owner_type = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    owner_id = table.Column<Guid>(type: "uuid", nullable: false),
                    balance = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    blocked = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_wallets", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_wallets_owner_type_owner_id",
                table: "wallets",
                columns: new[] { "owner_type", "owner_id" },
                unique: true);

            migrationBuilder.CreateTable(
                name: "holdings",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false),
                    issuance_id = table.Column<Guid>(type: "uuid", nullable: false),
                    quantity = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_holdings", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_holdings_investor_id_issuance_id",
                table: "holdings",
                columns: new[] { "investor_id", "issuance_id" },
                unique: true);

            migrationBuilder.CreateTable(
                name: "orders",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false),
                    issuance_id = table.Column<Guid>(type: "uuid", nullable: false),
                    amount = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    idem_key = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true),
                    wallet_id = table.Column<Guid>(type: "uuid", nullable: true),
                    dlt_tx_hash = table.Column<string>(type: "character varying(64)", maxLength: 64, nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    confirmed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    failure_reason = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_orders", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_orders_idem_key",
                table: "orders",
                column: "idem_key",
                unique: true,
                filter: "\"idem_key\" IS NOT NULL");

            migrationBuilder.CreateIndex(
                name: "ix_orders_investor_id",
                table: "orders",
                column: "investor_id");

            migrationBuilder.CreateIndex(
                name: "ix_orders_issuance_id",
                table: "orders",
                column: "issuance_id");

            migrationBuilder.CreateIndex(
                name: "ix_orders_status",
                table: "orders",
                column: "status");

            migrationBuilder.CreateTable(
                name: "tx",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    type = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    from_wallet_id = table.Column<Guid>(type: "uuid", nullable: true),
                    to_wallet_id = table.Column<Guid>(type: "uuid", nullable: true),
                    issuance_id = table.Column<Guid>(type: "uuid", nullable: true),
                    amount = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    dlt_tx_hash = table.Column<string>(type: "character varying(64)", maxLength: 64, nullable: true),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    confirmed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_tx", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_tx_issuance_id",
                table: "tx",
                column: "issuance_id");

            migrationBuilder.CreateIndex(
                name: "ix_tx_from_wallet_id",
                table: "tx",
                column: "from_wallet_id");

            migrationBuilder.CreateIndex(
                name: "ix_tx_to_wallet_id",
                table: "tx",
                column: "to_wallet_id");

            migrationBuilder.CreateIndex(
                name: "ix_tx_status",
                table: "tx",
                column: "status");

            migrationBuilder.CreateTable(
                name: "outbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    topic = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    payload = table.Column<string>(type: "jsonb", nullable: false),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    processed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_outbox_messages", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_outbox_messages_processed_at_created_at",
                table: "outbox_messages",
                columns: new[] { "processed_at", "created_at" });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "holdings");

            migrationBuilder.DropTable(
                name: "orders");

            migrationBuilder.DropTable(
                name: "outbox_messages");

            migrationBuilder.DropTable(
                name: "tx");

            migrationBuilder.DropTable(
                name: "wallets");
        }
    }
}


```
---
# services/registry/Program.cs
```cs
using Microsoft.EntityFrameworkCore;
using FluentValidation;
using OIS.Registry.Validators;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Registry;
using OIS.Registry.DTOs;
using OIS.Registry.Services;
using Serilog;
using System.Diagnostics;
using MassTransit;
using OIS.Contracts.Events;
using OIS.Registry.Infrastructure;
using Microsoft.AspNetCore.RateLimiting;
using System.Threading.RateLimiting;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("registry-service"))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Database
var registryMigrationsAssembly = typeof(RegistryDbContext).Assembly.GetName().Name;
builder.Services.AddDbContext<RegistryDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions => npgsqlOptions.MigrationsAssembly(registryMigrationsAssembly)));

// HTTP Clients
builder.Services.AddHttpClient<IBankNominalService, BankNominalServiceClient>();
builder.Services.AddHttpClient<IComplianceService, ComplianceServiceClient>();
builder.Services.AddHttpClient<LedgerRegistryAdapter>()
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

// Services
builder.Services.AddScoped<ILedgerRegistry, LedgerRegistryAdapter>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IRegistryService, RegistryService>();

// Validation
builder.Services.AddValidatorsFromAssemblyContaining<CreateOrderRequestValidator>();
builder.Services.AddFluentValidationAutoValidation();

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        if (!string.IsNullOrEmpty(authority))
        {
            options.Authority = authority;
        }
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            RoleClaimType = ClaimTypes.Role
        };

        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx =>
            {
                MapKeycloakRoles(ctx);
                return Task.CompletedTask;
            }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:investor", p => p.RequireRole("investor"));
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:broker", p => p.RequireRole("broker"));
    options.AddPolicy("role:backoffice", p => p.RequireRole("backoffice"));
    options.AddPolicy("role:investor-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
    options.AddPolicy("scope:orders.write", p => p.RequireAssertion(HasScope("orders.write")));
    options.AddPolicy("scope:orders.read", p => p.RequireAssertion(HasScope("orders.read")));
});

// MassTransit + Kafka for publishing
if (builder.Configuration.GetValue<bool>("Kafka:Enabled", true))
{
    builder.Services.AddMassTransit(x =>
    {
        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092");
            });
        });
    });

    builder.Services.AddHostedService<OIS.Registry.Background.OutboxPublisher>();
}

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<RegistryDbContext>();

// Rate limiting
builder.Services.AddRateLimiter(options =>
{
    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
    options.AddPolicy("sensitive", httpContext =>
    {
        var key = GetPartitionKey(httpContext);
        return RateLimitPartition.GetTokenBucketLimiter(key, _ => new TokenBucketRateLimiterOptions
        {
            TokenLimit = 20,
            TokensPerPeriod = 20,
            ReplenishmentPeriod = TimeSpan.FromSeconds(1),
            AutoReplenishment = true,
            QueueLimit = 0,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst
        });
    });
});

var app = builder.Build();

// Apply migrations (optional, via MIGRATE_ON_STARTUP=true)
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<RegistryDbContext>();
    db.Database.Migrate();
}

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.UseRateLimiter();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();

    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Registry").RequireAuthorization();

api.MapPost("/orders", async (
    CreateOrderRequest request,
    HttpContext httpContext,
    IRegistryService service,
    CancellationToken ct) =>
{
    // Get idempotency key from header
    if (!httpContext.Request.Headers.TryGetValue("Idempotency-Key", out var idemKeyValues) ||
        !Guid.TryParse(idemKeyValues.FirstOrDefault(), out var idemKeyGuid))
    {
        return Results.Problem(
            detail: "Idempotency-Key header is required and must be a valid UUID",
            statusCode: 400,
            title: "Bad Request");
    }

    var idemKey = idemKeyGuid.ToString();
    var result = await service.PlaceOrderAsync(request, idemKey, ct);
    return Results.Accepted($"/v1/orders/{result.Id}", result);
})
.WithName("PlaceOrder")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapGet("/orders/{id:guid}", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    var result = await service.GetOrderAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetOrder")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapGet("/wallets/{investorId:guid}", async (
    Guid investorId,
    IRegistryService service,
    CancellationToken ct) =>
{
    var result = await service.GetWalletAsync(investorId, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetWallet")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/redeem", async (
    Guid id,
    RedeemRequest request,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.RedeemAsync(id, request, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("RedeemIssuance")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapPost("/orders/{id:guid}/cancel", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CancelOrderAsync(id, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? 404 : 400,
            title: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? "Not Found" : "Bad Request");
    }
})
.WithName("CancelOrder")
.RequireAuthorization("role:investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapPost("/orders/{id:guid}/mark-paid", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.MarkPaidAsync(id, null, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? 404 : 400,
            title: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? "Not Found" : "Bad Request");
    }
})
.WithName("MarkOrderPaid")
.RequireAuthorization("role:investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

app.Run();
static Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext, bool> HasScope(string scope) => ctx =>
{
    var scp = ctx.User.FindFirst("scope")?.Value ?? ctx.User.FindFirst("scp")?.Value;
    if (string.IsNullOrWhiteSpace(scp)) return false;
    return scp.Split(' ', StringSplitOptions.RemoveEmptyEntries)
        .Any(s => string.Equals(s, scope, StringComparison.OrdinalIgnoreCase));
};

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { /* ignore parsing errors */ }
}

static string GetPartitionKey(HttpContext ctx)
{
    var sub = ctx.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
    if (!string.IsNullOrEmpty(sub)) return $"user:{sub}";
    return $"ip:{ctx.Connection.RemoteIpAddress}";
}

```
---
# services/registry/Properties/launchSettings.json
```json
{
  "profiles": {
    "registry": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:53980;http://localhost:53988"
    }
  }
}
```
---
# services/registry/RegistryDbContext.cs
```cs
using Microsoft.EntityFrameworkCore;

namespace OIS.Registry;

public class RegistryDbContext : DbContext
{
    public RegistryDbContext(DbContextOptions<RegistryDbContext> options) : base(options) { }

    public DbSet<WalletEntity> Wallets => Set<WalletEntity>();
    public DbSet<HoldingEntity> Holdings => Set<HoldingEntity>();
    public DbSet<OrderEntity> Orders => Set<OrderEntity>();
    public DbSet<TransactionEntity> Transactions => Set<TransactionEntity>();
    public DbSet<OutboxMessage> OutboxMessages => Set<OutboxMessage>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity<WalletEntity>(entity =>
        {
            entity.ToTable("wallets");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.OwnerType)
                .HasColumnName("owner_type")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.OwnerId)
                .HasColumnName("owner_id")
                .IsRequired();

            entity.Property(e => e.Balance)
                .HasColumnName("balance")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.Blocked)
                .HasColumnName("blocked")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();

            entity.HasIndex(e => new { e.OwnerType, e.OwnerId }).IsUnique();
        });

        modelBuilder.Entity<HoldingEntity>(entity =>
        {
            entity.ToTable("holdings");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .IsRequired();

            entity.Property(e => e.IssuanceId)
                .HasColumnName("issuance_id")
                .IsRequired();

            entity.Property(e => e.Quantity)
                .HasColumnName("quantity")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();

            entity.HasIndex(e => new { e.InvestorId, e.IssuanceId }).IsUnique();
        });

        modelBuilder.Entity<OrderEntity>(entity =>
        {
            entity.ToTable("orders");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .IsRequired();

            entity.Property(e => e.IssuanceId)
                .HasColumnName("issuance_id")
                .IsRequired();

            entity.Property(e => e.Amount)
                .HasColumnName("amount")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.IdemKey)
                .HasColumnName("idem_key")
                .HasMaxLength(255);

            entity.Property(e => e.WalletId)
                .HasColumnName("wallet_id");

            entity.Property(e => e.DltTxHash)
                .HasColumnName("dlt_tx_hash")
                .HasMaxLength(64);

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();

            entity.Property(e => e.ConfirmedAt)
                .HasColumnName("confirmed_at");

            entity.Property(e => e.FailureReason)
                .HasColumnName("failure_reason");

            entity.HasIndex(e => e.IdemKey).IsUnique()
                .HasFilter("\"idem_key\" IS NOT NULL");
            entity.HasIndex(e => e.InvestorId);
            entity.HasIndex(e => e.IssuanceId);
            entity.HasIndex(e => e.Status);
        });

        modelBuilder.Entity<TransactionEntity>(entity =>
        {
            entity.ToTable("tx");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.Type)
                .HasColumnName("type")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.FromWalletId)
                .HasColumnName("from_wallet_id");

            entity.Property(e => e.ToWalletId)
                .HasColumnName("to_wallet_id");

            entity.Property(e => e.IssuanceId)
                .HasColumnName("issuance_id");

            entity.Property(e => e.Amount)
                .HasColumnName("amount")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.DltTxHash)
                .HasColumnName("dlt_tx_hash")
                .HasMaxLength(64);

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ConfirmedAt)
                .HasColumnName("confirmed_at");

            entity.HasIndex(e => e.IssuanceId);
            entity.HasIndex(e => e.FromWalletId);
            entity.HasIndex(e => e.ToWalletId);
            entity.HasIndex(e => e.Status);
        });

        modelBuilder.Entity<OutboxMessage>(entity =>
        {
            entity.ToTable("outbox_messages");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.Topic)
                .HasColumnName("topic")
                .HasMaxLength(255)
                .IsRequired();

            entity.Property(e => e.Payload)
                .HasColumnName("payload")
                .HasColumnType("jsonb")
                .IsRequired();

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ProcessedAt)
                .HasColumnName("processed_at");

            entity.HasIndex(e => new { e.ProcessedAt, e.CreatedAt });
        });
    }
}

public class WalletEntity
{
    public Guid Id { get; set; }
    public string OwnerType { get; set; } = string.Empty; // "individual" or "legal_entity"
    public Guid OwnerId { get; set; }
    public decimal Balance { get; set; }
    public decimal Blocked { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class HoldingEntity
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public Guid IssuanceId { get; set; }
    public decimal Quantity { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class OrderEntity
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public Guid IssuanceId { get; set; }
    public decimal Amount { get; set; }
    public string Status { get; set; } = "created"; // created, reserved, paid, failed, cancelled
    public string? IdemKey { get; set; }
    public Guid? WalletId { get; set; }
    public string? DltTxHash { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public DateTime? ConfirmedAt { get; set; }
    public string? FailureReason { get; set; }
}

public class TransactionEntity
{
    public Guid Id { get; set; }
    public string Type { get; set; } = string.Empty; // transfer, redeem, issue
    public Guid? FromWalletId { get; set; }
    public Guid? ToWalletId { get; set; }
    public Guid? IssuanceId { get; set; }
    public decimal Amount { get; set; }
    public string? DltTxHash { get; set; }
    public string Status { get; set; } = "pending"; // pending, confirmed, failed
    public DateTime CreatedAt { get; set; }
    public DateTime? ConfirmedAt { get; set; }
}

public class OutboxMessage
{
    public Guid Id { get; set; }
    public string Topic { get; set; } = string.Empty;
    public string Payload { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
}


```
---
# services/registry/Services/IBankNominalService.cs
```cs
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System.Net.Http.Json;
using System.Text;
using System.Text.Json;

namespace OIS.Registry.Services;

public interface IBankNominalService
{
    Task<string> ReserveFundsAsync(Guid investorId, decimal amount, string idempotencyKey, CancellationToken ct);
}

public class BankNominalServiceClient : IBankNominalService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<BankNominalServiceClient> _logger;
    private readonly string _baseUrl;

    public BankNominalServiceClient(
        HttpClient httpClient,
        ILogger<BankNominalServiceClient> logger,
        IConfiguration configuration)
    {
        _httpClient = httpClient;
        _logger = logger;
        _baseUrl = configuration["BankNominal:BaseUrl"] ?? "http://bank-nominal:8080";
    }

    public async Task<string> ReserveFundsAsync(Guid investorId, decimal amount, string idempotencyKey, CancellationToken ct)
    {
        var request = new
        {
            investorId = investorId.ToString(),
            amount = amount,
            idempotencyKey = idempotencyKey
        };

        using var content = new StringContent(
            JsonSerializer.Serialize(request),
            Encoding.UTF8,
            "application/json");

        _httpClient.DefaultRequestHeaders.Clear();
        _httpClient.DefaultRequestHeaders.Add("Idempotency-Key", idempotencyKey);

        var response = await _httpClient.PostAsync($"{_baseUrl}/nominal/reserve", content, ct);
        
        if (!response.IsSuccessStatusCode)
        {
            var error = await response.Content.ReadAsStringAsync(ct);
            _logger.LogError("Bank nominal reserve failed: {StatusCode} {Error}", response.StatusCode, error);
            throw new InvalidOperationException($"Failed to reserve funds: {response.StatusCode}");
        }

        var result = await response.Content.ReadFromJsonAsync<ReserveFundsResponse>(cancellationToken: ct);
        return result?.TransferId ?? throw new InvalidOperationException("No transfer ID returned");
    }

    private record ReserveFundsResponse
    {
        public string? TransferId { get; init; }
    }
}


```
---
# services/registry/Services/IComplianceService.cs
```cs
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System.Net.Http.Json;

namespace OIS.Registry.Services;

public interface IComplianceService
{
    Task<bool> CheckKycAsync(Guid investorId, CancellationToken ct);
    Task<bool> CheckQualificationAsync(Guid investorId, decimal amount, CancellationToken ct);
}

public class ComplianceServiceClient : IComplianceService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<ComplianceServiceClient> _logger;
    private readonly string _baseUrl;

    public ComplianceServiceClient(
        HttpClient httpClient,
        ILogger<ComplianceServiceClient> logger,
        IConfiguration configuration)
    {
        _httpClient = httpClient;
        _logger = logger;
        _baseUrl = configuration["Compliance:BaseUrl"] ?? "http://compliance-service:8080";
    }

    public async Task<bool> CheckKycAsync(Guid investorId, CancellationToken ct)
    {
        try
        {
            var request = new { investorId = investorId };
            var response = await _httpClient.PostAsJsonAsync($"{_baseUrl}/v1/compliance/kyc/check", request, ct);

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError("KYC check failed for investor {Investor}: {StatusCode}", OIS.Domain.Security.MaskGuid(investorId), response.StatusCode);
                return false;
            }

            var result = await response.Content.ReadFromJsonAsync<KycResult>(cancellationToken: ct);
            return result?.Status == "pass";
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking KYC for investor {Investor}", OIS.Domain.Security.MaskGuid(investorId));
            return false;
        }
    }

    public async Task<bool> CheckQualificationAsync(Guid investorId, decimal amount, CancellationToken ct)
    {
        try
        {
            var request = new { investorId = investorId, amount = amount };
            var response = await _httpClient.PostAsJsonAsync($"{_baseUrl}/v1/compliance/qualification/evaluate", request, ct);

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError("Qualification check failed for investor {Investor}: {StatusCode}", OIS.Domain.Security.MaskGuid(investorId), response.StatusCode);
                return false;
            }

            var result = await response.Content.ReadFromJsonAsync<QualificationResult>(cancellationToken: ct);
            return result?.Allowed == true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking qualification for investor {Investor}", OIS.Domain.Security.MaskGuid(investorId));
            return false;
        }
    }

    private record KycResult
    {
        public string Status { get; init; } = string.Empty;
    }

    private record QualificationResult
    {
        public bool Allowed { get; init; }
    }
}


```
---
# services/registry/Services/ILedgerRegistry.cs
```cs
using Microsoft.Extensions.Configuration;
using Polly;
using Polly.Retry;

namespace OIS.Registry.Services;

public interface ILedgerRegistry
{
    Task<string> TransferAsync(string? from, string to, Guid issuanceId, decimal amount, CancellationToken ct);
    Task<string> RedeemAsync(string holderId, Guid issuanceId, decimal amount, CancellationToken ct);
}

public class LedgerRegistryAdapter : ILedgerRegistry
{
    private readonly ILogger<LedgerRegistryAdapter> _logger;
    private readonly IConfiguration _configuration;
    private readonly HttpClient _httpClient;
    private readonly bool _useMock;
    private readonly string? _chaincodeEndpoint;
    private readonly AsyncRetryPolicy _retryPolicy;

    public LedgerRegistryAdapter(
        ILogger<LedgerRegistryAdapter> logger,
        IConfiguration configuration,
        HttpClient httpClient)
    {
        _logger = logger;
        _configuration = configuration;
        _httpClient = httpClient;
        _chaincodeEndpoint = _configuration["Ledger:ChaincodeEndpoint"];
        _useMock = string.IsNullOrEmpty(_chaincodeEndpoint) || 
                   _configuration.GetValue<bool>("Ledger:UseMock", true);

        if (!_useMock && !string.IsNullOrEmpty(_chaincodeEndpoint))
        {
            _httpClient.BaseAddress = new Uri(_chaincodeEndpoint);
            _httpClient.Timeout = TimeSpan.FromSeconds(30);
        }

        // Retry policy with exponential backoff
        _retryPolicy = Policy
            .Handle<HttpRequestException>()
            .Or<TaskCanceledException>()
            .WaitAndRetryAsync(
                retryCount: 3,
                sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                onRetry: (exception, timeSpan, retryCount, context) =>
                {
                    _logger.LogWarning(
                        "Retry {RetryCount} after {Delay}ms for {Operation}",
                        retryCount, timeSpan.TotalMilliseconds, context.OperationKey);
                });

        if (_useMock)
        {
            _logger.LogWarning("Ledger registry adapter running in MOCK mode");
        }
        else
        {
            _logger.LogInformation("Ledger registry adapter connected to {Endpoint}", _chaincodeEndpoint);
        }
    }

    public async Task<string> TransferAsync(string? from, string to, Guid issuanceId, decimal amount, CancellationToken ct)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            if (_useMock)
            {
                await Task.Delay(50, ct);
                var txHash = GenerateMockTxHash();
                _logger.LogInformation(
                    "MOCK: Transfer {From} -> {To}, issuance {IssuanceId}, amount {Amount}, txHash {TxHash}",
                    from ?? "null", to, issuanceId, amount, txHash);
                return txHash;
            }

            // TODO: Real HLF call
            return await RealTransferAsync(from, to, issuanceId, amount, ct);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Transfer completed in {Duration}ms", stopwatch.ElapsedMilliseconds);
        }
    }

    public async Task<string> RedeemAsync(string holderId, Guid issuanceId, decimal amount, CancellationToken ct)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            if (_useMock)
            {
                await Task.Delay(50, ct);
                var txHash = GenerateMockTxHash();
                _logger.LogInformation(
                    "MOCK: Redeem holder {HolderId}, issuance {IssuanceId}, amount {Amount}, txHash {TxHash}",
                    holderId, issuanceId, amount, txHash);
                return txHash;
            }

            // TODO: Real HLF call
            return await RealRedeemAsync(holderId, issuanceId, amount, ct);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Redeem completed in {Duration}ms", stopwatch.ElapsedMilliseconds);
        }
    }

    private async Task<string> RealTransferAsync(string? from, string to, Guid issuanceId, decimal amount, CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "registry",
                function = "Transfer",
                args = new[]
                {
                    from ?? "",
                    to,
                    issuanceId.ToString(),
                    amount.ToString()
                }
            };

            var json = System.Text.Json.JsonSerializer.Serialize(payload);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/invoke", content, ct);
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var result = System.Text.Json.JsonSerializer.Deserialize<ChaincodeResponse>(responseContent);

            if (result?.TransactionHash == null)
            {
                throw new InvalidOperationException($"Failed to get transaction hash from ledger: {result?.Error ?? "Unknown error"}");
            }

            _logger.LogInformation(
                "Transfer {From} -> {To}, issuance {IssuanceId}, amount {Amount}, txHash {TxHash}",
                from ?? "null", to, issuanceId, amount, result.TransactionHash);

            return result.TransactionHash;
        }, new Context("Transfer"));
    }

    private async Task<string> RealRedeemAsync(string holderId, Guid issuanceId, decimal amount, CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "registry",
                function = "Redeem",
                args = new[]
                {
                    holderId,
                    issuanceId.ToString(),
                    amount.ToString()
                }
            };

            var json = System.Text.Json.JsonSerializer.Serialize(payload);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/invoke", content, ct);
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var result = System.Text.Json.JsonSerializer.Deserialize<ChaincodeResponse>(responseContent);

            if (result?.TransactionHash == null)
            {
                throw new InvalidOperationException($"Failed to get transaction hash from ledger: {result?.Error ?? "Unknown error"}");
            }

            _logger.LogInformation(
                "Redeem holder {HolderId}, issuance {IssuanceId}, amount {Amount}, txHash {TxHash}",
                holderId, issuanceId, amount, result.TransactionHash);

            return result.TransactionHash;
        }, new Context("Redeem"));
    }

    private class ChaincodeResponse
    {
        public string? TransactionHash { get; set; }
        public bool Success { get; set; }
        public string? Error { get; set; }
    }

    private static string GenerateMockTxHash()
    {
        var random = new Random();
        var bytes = new byte[32];
        random.NextBytes(bytes);
        return Convert.ToHexString(bytes).ToLowerInvariant();
    }
}


```
---
# services/registry/Services/RegistryService.cs
```cs
using Microsoft.EntityFrameworkCore;
using OIS.Registry;
using OIS.Registry.DTOs;
using System.Diagnostics;
using System.Text.Json;

namespace OIS.Registry.Services;

public interface IRegistryService
{
    Task<OrderResponse> PlaceOrderAsync(CreateOrderRequest request, string idempotencyKey, CancellationToken ct);
    Task<OrderResponse?> GetOrderAsync(Guid orderId, CancellationToken ct);
    Task<WalletResponse?> GetWalletAsync(Guid investorId, CancellationToken ct);
    Task<RedeemResponse> RedeemAsync(Guid issuanceId, RedeemRequest request, CancellationToken ct);
    Task<OrderResponse> CancelOrderAsync(Guid orderId, CancellationToken ct);
    Task<OrderResponse> MarkPaidAsync(Guid orderId, string? paymentRef, CancellationToken ct);
}

public class RegistryService : IRegistryService
{
    private readonly RegistryDbContext _db;
    private readonly ILogger<RegistryService> _logger;
    private readonly IComplianceService _compliance;
    private readonly IBankNominalService _bank;
    private readonly ILedgerRegistry _ledger;
    private readonly IOutboxService _outbox;

    public RegistryService(
        RegistryDbContext db,
        ILogger<RegistryService> logger,
        IComplianceService compliance,
        IBankNominalService bank,
        ILedgerRegistry ledger,
        IOutboxService outbox)
    {
        _db = db;
        _logger = logger;
        _compliance = compliance;
        _bank = bank;
        _ledger = ledger;
        _outbox = outbox;
    }

    public async Task<OrderResponse> PlaceOrderAsync(CreateOrderRequest request, string idempotencyKey, CancellationToken ct)
    {
        // Check idempotency
        var existingOrder = await _db.Orders
            .FirstOrDefaultAsync(o => o.IdemKey == idempotencyKey, ct);
        
        if (existingOrder != null)
        {
            _logger.LogInformation("Order with idempotency key {IdemKey} already exists: {OrderId}", 
                idempotencyKey, existingOrder.Id);
            return MapToOrderResponse(existingOrder);
        }

        // (a) Validate KYC/qualification
        var kycOk = await _compliance.CheckKycAsync(request.InvestorId, ct);
        if (!kycOk)
            throw new InvalidOperationException($"KYC check failed for investor {request.InvestorId}");

        var qualOk = await _compliance.CheckQualificationAsync(request.InvestorId, request.Amount, ct);
        if (!qualOk)
            throw new InvalidOperationException($"Qualification check failed for investor {request.InvestorId}: limit exceeded or not qualified");

        // Create order (created)
        var order = new OrderEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = request.InvestorId,
            IssuanceId = request.IssuanceId,
            Amount = request.Amount,
            Status = "created",
            IdemKey = idempotencyKey,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _db.Orders.Add(order);
        await _db.SaveChangesAsync(ct);

        // Emit order.created
        await _outbox.AddAsync("ois.order.created", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            createdAt = order.CreatedAt
        }, ct);

        // Emit order.placed (business-level event: order accepted before funds reservation)
        await _outbox.AddAsync("ois.order.placed", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            placedAt = order.CreatedAt
        }, ct);
        await _db.SaveChangesAsync(ct);

        // (b) Reserve funds via bank-nominal (idempotent)
        string transferId;
        try
        {
            transferId = await _bank.ReserveFundsAsync(request.InvestorId, request.Amount, idempotencyKey, ct);
            _logger.LogInformation("Funds reserved: transferId={TransferId}, investor={Investor}, amount={Amount}",
                transferId, OIS.Domain.Security.MaskGuid(request.InvestorId), request.Amount);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to reserve funds for investor {Investor}", OIS.Domain.Security.MaskGuid(request.InvestorId));
            throw new InvalidOperationException($"Failed to reserve funds: {ex.Message}", ex);
        }

        // Update order to reserved
        order.Status = "reserved";
        order.UpdatedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        await _outbox.AddAsync("ois.order.reserved", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            reservedAt = order.UpdatedAt,
            bankTransferId = transferId
        }, ct);

        await _db.SaveChangesAsync(ct);

        return MapToOrderResponse(order);
    }

    public async Task<OrderResponse?> GetOrderAsync(Guid orderId, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct);
        return order != null ? MapToOrderResponse(order) : null;
    }

    public async Task<WalletResponse?> GetWalletAsync(Guid investorId, CancellationToken ct)
    {
        var wallet = await _db.Wallets
            .FirstOrDefaultAsync(w => w.OwnerId == investorId && w.OwnerType == "individual", ct);

        if (wallet == null)
            return null;

        var holdings = await _db.Holdings
            .Where(h => h.InvestorId == investorId)
            .Select(h => new HoldingDto
            {
                IssuanceId = h.IssuanceId,
                Quantity = h.Quantity,
                UpdatedAt = h.UpdatedAt
            })
            .ToListAsync(ct);

        return new WalletResponse
        {
            InvestorId = investorId,
            Balance = wallet.Balance,
            Blocked = wallet.Blocked,
            Holdings = holdings
        };
    }

    public async Task<RedeemResponse> RedeemAsync(Guid issuanceId, RedeemRequest request, CancellationToken ct)
    {
        // TODO: Get investor from context/auth
        var investorId = Guid.NewGuid(); // Placeholder

        var stopwatch = Stopwatch.StartNew();
        string txHash;
        try
        {
            txHash = await _ledger.RedeemAsync(investorId.ToString(), issuanceId, request.Amount, ct);
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Redeem successful: issuanceId={IssuanceId}, txHash={TxHash}, duration={Duration}ms",
                issuanceId, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex, "Ledger Redeem failed for issuance {IssuanceId}", issuanceId);
            throw new InvalidOperationException($"Failed to redeem on ledger: {ex.Message}", ex);
        }

        // Update holding
        var holding = await _db.Holdings
            .FirstOrDefaultAsync(h => h.InvestorId == investorId && h.IssuanceId == issuanceId, ct);
        
        if (holding != null)
        {
            holding.Quantity -= request.Amount;
            holding.UpdatedAt = DateTime.UtcNow;
        }

        await WriteTransactionAsync(Guid.NewGuid(), "redeem", null, null, issuanceId, request.Amount, txHash, ct);
        await _db.SaveChangesAsync(ct);

        return new RedeemResponse
        {
            IssuanceId = issuanceId,
            RedeemedAmount = request.Amount,
            DltTxHash = txHash,
            RedeemedAt = DateTime.UtcNow
        };
    }

    public async Task<OrderResponse> CancelOrderAsync(Guid orderId, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct)
            ?? throw new InvalidOperationException($"Order {orderId} not found");

        if (order.Status is "paid" or "cancelled")
            throw new InvalidOperationException($"Cannot cancel order in status {order.Status}");

        order.Status = "cancelled";
        order.UpdatedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        return MapToOrderResponse(order);
    }

    public async Task<OrderResponse> MarkPaidAsync(Guid orderId, string? paymentRef, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct)
            ?? throw new InvalidOperationException($"Order {orderId} not found");

        // Idempotent: if already paid, return current state
        if (order.Status == "paid")
            return MapToOrderResponse(order);

        if (order.Status != "reserved")
            throw new InvalidOperationException($"Order must be in 'reserved' status to mark paid; actual: {order.Status}");

        // (c) Call ledger registry.Transfer
        var stopwatch = Stopwatch.StartNew();
        string txHash;
        try
        {
            txHash = await _ledger.TransferAsync(null, order.InvestorId.ToString(), order.IssuanceId, order.Amount, ct);
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Transfer successful: orderId={OrderId}, txHash={TxHash}, duration={Duration}ms",
                order.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Transfer failed for order {OrderId} after {Duration}ms",
                order.Id, stopwatch.ElapsedMilliseconds);
            // Keep order in 'reserved' status to allow retry; record failure reason transiently
            order.FailureReason = $"Ledger error: {ex.Message}";
            await _db.SaveChangesAsync(ct);
            throw;
        }

        // Update order -> paid
        order.Status = "paid";
        order.DltTxHash = txHash;
        order.ConfirmedAt = DateTime.UtcNow;
        order.UpdatedAt = DateTime.UtcNow;

        // Wallet + holding
        var wallet = await GetOrCreateWalletAsync(order.InvestorId, "individual", ct);
        order.WalletId = wallet.Id;
        await UpdateHoldingAsync(order.InvestorId, order.IssuanceId, order.Amount, ct);

        // Transactions and events
        await WriteTransactionAsync(order.Id, "transfer", null, wallet.Id, order.IssuanceId, order.Amount, txHash, ct);

        await _outbox.AddAsync("ois.order.paid", new
        {
            orderId = order.Id,
            issuanceId = order.IssuanceId,
            investorId = order.InvestorId,
            amount = order.Amount,
            paidAt = order.ConfirmedAt,
            txHash = txHash
        }, ct);

        await _outbox.AddAsync("ois.order.confirmed", new
        {
            orderId = order.Id,
            confirmedAt = order.ConfirmedAt,
            dltTxHash = txHash,
            walletId = wallet.Id
        }, ct);

        await _outbox.AddAsync("ois.registry.transferred", new
        {
            orderId = order.Id,
            issuanceId = order.IssuanceId,
            investorId = order.InvestorId,
            amount = order.Amount,
            txHash = txHash,
            walletId = wallet.Id,
            transferredAt = order.ConfirmedAt
        }, ct);

        await _db.SaveChangesAsync(ct);
        _logger.LogInformation("Order {OrderId} marked as paid with txHash {TxHash}", order.Id, txHash);

        return MapToOrderResponse(order);
    }

    private async Task<WalletEntity> GetOrCreateWalletAsync(Guid ownerId, string ownerType, CancellationToken ct)
    {
        var wallet = await _db.Wallets
            .FirstOrDefaultAsync(w => w.OwnerId == ownerId && w.OwnerType == ownerType, ct);

        if (wallet == null)
        {
            wallet = new WalletEntity
            {
                Id = Guid.NewGuid(),
                OwnerId = ownerId,
                OwnerType = ownerType,
                Balance = 0,
                Blocked = 0,
                UpdatedAt = DateTime.UtcNow
            };
            _db.Wallets.Add(wallet);
            await _db.SaveChangesAsync(ct);
        }

        return wallet;
    }

    private async Task UpdateHoldingAsync(Guid investorId, Guid issuanceId, decimal quantity, CancellationToken ct)
    {
        var holding = await _db.Holdings
            .FirstOrDefaultAsync(h => h.InvestorId == investorId && h.IssuanceId == issuanceId, ct);

        if (holding == null)
        {
            holding = new HoldingEntity
            {
                Id = Guid.NewGuid(),
                InvestorId = investorId,
                IssuanceId = issuanceId,
                Quantity = 0,
                UpdatedAt = DateTime.UtcNow
            };
            _db.Holdings.Add(holding);
        }

        holding.Quantity += quantity;
        holding.UpdatedAt = DateTime.UtcNow;
    }

    private async Task WriteTransactionAsync(
        Guid id,
        string type,
        Guid? fromWalletId,
        Guid? toWalletId,
        Guid? issuanceId,
        decimal amount,
        string txHash,
        CancellationToken ct)
    {
        var tx = new TransactionEntity
        {
            Id = id,
            Type = type,
            FromWalletId = fromWalletId,
            ToWalletId = toWalletId,
            IssuanceId = issuanceId,
            Amount = amount,
            DltTxHash = txHash,
            Status = "confirmed",
            CreatedAt = DateTime.UtcNow,
            ConfirmedAt = DateTime.UtcNow
        };

        _db.Transactions.Add(tx);
    }

    private static OrderResponse MapToOrderResponse(OrderEntity entity)
    {
        return new OrderResponse
        {
            Id = entity.Id,
            InvestorId = entity.InvestorId,
            IssuanceId = entity.IssuanceId,
            Amount = entity.Amount,
            Status = entity.Status,
            WalletId = entity.WalletId,
            DltTxHash = entity.DltTxHash,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            ConfirmedAt = entity.ConfirmedAt,
            FailureReason = entity.FailureReason
        };
    }
}

public interface IOutboxService
{
    Task AddAsync(string topic, object payload, CancellationToken ct);
}

public class OutboxService : IOutboxService
{
    private readonly RegistryDbContext _db;

    public OutboxService(RegistryDbContext db)
    {
        _db = db;
    }

    public async Task AddAsync(string topic, object payload, CancellationToken ct)
    {
        var message = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            Topic = topic,
            Payload = JsonSerializer.Serialize(payload),
            CreatedAt = DateTime.UtcNow
        };

        _db.OutboxMessages.Add(message);
    }
}

```
---
# services/registry/Validators/CreateOrderRequestValidator.cs
```cs
using FluentValidation;
using OIS.Registry.DTOs;

namespace OIS.Registry.Validators;

public class CreateOrderRequestValidator : AbstractValidator<CreateOrderRequest>
{
    public CreateOrderRequestValidator()
    {
        RuleFor(x => x.InvestorId)
            .NotEmpty()
            .WithMessage("InvestorId is required");

        RuleFor(x => x.IssuanceId)
            .NotEmpty()
            .WithMessage("IssuanceId is required");

        RuleFor(x => x.Amount)
            .GreaterThan(0)
            .WithMessage("Amount must be greater than 0");
    }
}


```
---
# services/registry/appsettings.json
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=ois;Username=ois;Password=ois_dev_password"
  },
  "BankNominal": {
    "BaseUrl": "http://bank-nominal:8080"
  },
  "Compliance": {
    "BaseUrl": "http://compliance-service:8080"
  },
  "Ledger": {
    "UseMock": false,
    "ChaincodeEndpoint": "http://localhost:8080"
  },
  "Fabric": {
    "PeerEndpoint": "http://localhost:7051",
    "ChannelName": "cfa-main",
    "MspId": "OisDevMSP",
    "TlsCertPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/server.crt",
    "TlsKeyPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/server.key",
    "TlsRootCertPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/ca.crt"
  },
  "Serilog": {
    "Using": ["Serilog.Sinks.Console"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  }
}


```
---
# services/registry/registry.Tests/ErrorMappingTests.cs
```cs
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Registry.Services;
using System.Net;
using Xunit;

namespace OIS.Registry.Tests;

public class ErrorMappingTests
{
    [Fact]
    public void InvalidOperationException_MapsToProblemDetails()
    {
        // Arrange
        var exception = new InvalidOperationException("KYC check failed");

        // Act & Assert - verify exception is caught and mapped in endpoint
        // This would be tested in integration tests or via Program.cs endpoint tests
        Assert.NotNull(exception);
        Assert.Equal("KYC check failed", exception.Message);
    }

    [Fact]
    public void ProblemDetails_IncludesRequiredFields()
    {
        // Verify RFC7807 compliance
        var problemDetails = new
        {
            type = "about:blank",
            title = "Bad Request",
            status = 400,
            detail = "KYC check failed for investor"
        };

        Assert.Equal(400, problemDetails.status);
        Assert.NotNull(problemDetails.title);
        Assert.NotNull(problemDetails.detail);
    }
}


```
---
# services/registry/registry.Tests/IdempotencyTests.cs
```cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Registry;
using OIS.Registry.DTOs;
using OIS.Registry.Services;
using Xunit;
using FluentAssertions;

namespace OIS.Registry.Tests;

public class IdempotencyTests
{
    private readonly RegistryDbContext _db;
    private readonly Mock<ILogger<RegistryService>> _logger;
    private readonly Mock<IComplianceService> _compliance;
    private readonly Mock<IBankNominalService> _bank;
    private readonly Mock<ILedgerRegistry> _ledger;
    private readonly Mock<IOutboxService> _outbox;
    private readonly RegistryService _service;

    public IdempotencyTests()
    {
        var options = new DbContextOptionsBuilder<RegistryDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;
        _db = new RegistryDbContext(options);
        _logger = new Mock<ILogger<RegistryService>>();
        _compliance = new Mock<IComplianceService>();
        _bank = new Mock<IBankNominalService>();
        _ledger = new Mock<ILedgerRegistry>();
        _outbox = new Mock<IOutboxService>();

        _service = new RegistryService(
            _db,
            _logger.Object,
            _compliance.Object,
            _bank.Object,
            _ledger.Object,
            _outbox.Object);
    }

    [Fact]
    public async Task PlaceOrder_WithDuplicateIdempotencyKey_ReturnsExistingOrder()
    {
        // Arrange
        var idemKey = "test-idem-key-123";
        var existingOrder = new OrderEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = Guid.NewGuid(),
            IssuanceId = Guid.NewGuid(),
            Amount = 1000,
            Status = "pending",
            IdemKey = idemKey,
            CreatedAt = DateTime.UtcNow,
        };
        _db.Orders.Add(existingOrder);
        await _db.SaveChangesAsync();

        var request = new CreateOrderRequest
        {
            InvestorId = existingOrder.InvestorId,
            IssuanceId = existingOrder.IssuanceId,
            Amount = 1000,
        };

        // Act
        var result = await _service.PlaceOrderAsync(request, idemKey, CancellationToken.None);

        // Assert
        Assert.Equal(existingOrder.Id, result.Id);
        Assert.Equal(existingOrder.Status, result.Status);
        
        // Verify no new order was created
        var orderCount = await _db.Orders.CountAsync();
        Assert.Equal(1, orderCount);
        
        // Verify compliance/bank were not called (idempotent return)
        _compliance.Verify(x => x.CheckKycAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()), Times.Never);
        _bank.Verify(x => x.ReserveFundsAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Never);
    }

    [Fact]
    public async Task PlaceOrder_WithNewIdempotencyKey_CreatesNewOrder()
    {
        // Arrange
        var idemKey = "new-idem-key-456";
        _compliance.Setup(x => x.CheckKycAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>())).ReturnsAsync(true);
        _compliance.Setup(x => x.CheckQualificationAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>())).ReturnsAsync(true);
        _bank.Setup(x => x.ReserveFundsAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<string>(), It.IsAny<CancellationToken>())).ReturnsAsync("transfer-123");

        var request = new CreateOrderRequest
        {
            InvestorId = Guid.NewGuid(),
            IssuanceId = Guid.NewGuid(),
            Amount = 5000,
        };

        // Act
        var result = await _service.PlaceOrderAsync(request, idemKey, CancellationToken.None);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(request.Amount, result.Amount);
        
        var orderCount = await _db.Orders.CountAsync();
        Assert.Equal(1, orderCount);
        
        _compliance.Verify(x => x.CheckKycAsync(request.InvestorId, It.IsAny<CancellationToken>()), Times.Once);
    }
}


```
---
# services/registry/registry.Tests/OrderFlowTests.cs
```cs
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Registry;
using OIS.Registry.DTOs;
using OIS.Registry.Services;
using Xunit;

namespace OIS.Registry.Tests;

public class OrderFlowTests
{
    private readonly RegistryDbContext _db;
    private readonly Mock<IComplianceService> _compliance;
    private readonly Mock<IBankNominalService> _bank;
    private readonly Mock<ILedgerRegistry> _ledger;
    private readonly IRegistryService _service;

    public OrderFlowTests()
    {
        var options = new DbContextOptionsBuilder<RegistryDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        _db = new RegistryDbContext(options);
        _compliance = new Mock<IComplianceService>();
        _bank = new Mock<IBankNominalService>();
        _ledger = new Mock<ILedgerRegistry>();
        _compliance.Setup(x => x.CheckKycAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>())).ReturnsAsync(true);
        _compliance.Setup(x => x.CheckQualificationAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>())).ReturnsAsync(true);
        _bank.Setup(x => x.ReserveFundsAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<string>(), It.IsAny<CancellationToken>())).ReturnsAsync("bank-transfer-1");
        _ledger.Setup(x => x.TransferAsync(It.IsAny<string?>(), It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>())).ReturnsAsync("txhash-abc");

        var logger = new Mock<ILogger<RegistryService>>();
        var outbox = new OutboxService(_db);
        _service = new RegistryService(_db, logger.Object, _compliance.Object, _bank.Object, _ledger.Object, outbox);
    }

    [Fact]
    public async Task PlaceOrder_IsIdempotent_And_Reserved()
    {
        var investor = Guid.NewGuid();
        var issuance = Guid.NewGuid();
        var req = new CreateOrderRequest { InvestorId = investor, IssuanceId = issuance, Amount = 100m };
        var idem = Guid.NewGuid().ToString();

        var r1 = await _service.PlaceOrderAsync(req, idem, CancellationToken.None);
        var r2 = await _service.PlaceOrderAsync(req, idem, CancellationToken.None);

        r1.Id.Should().Be(r2.Id);
        r1.Status.Should().Be("reserved");

        var topics = await _db.OutboxMessages
            .OrderBy(m => m.CreatedAt)
            .Select(m => m.Topic)
            .ToListAsync();

        topics.Should().Contain("ois.order.created");
        topics.Should().Contain("ois.order.placed");
        topics.Should().Contain("ois.order.reserved");
    }

    [Fact]
    public async Task MarkPaid_Moves_To_Paid_And_Writes_Tx()
    {
        var investor = Guid.NewGuid();
        var issuance = Guid.NewGuid();
        var req = new CreateOrderRequest { InvestorId = investor, IssuanceId = issuance, Amount = 55m };
        var idem = Guid.NewGuid().ToString();

        var order = await _service.PlaceOrderAsync(req, idem, CancellationToken.None);
        var paid = await _service.MarkPaidAsync(order.Id, null, CancellationToken.None);

        paid.Status.Should().Be("paid");
        paid.DltTxHash.Should().NotBeNull();
        var tx = await _db.Transactions.FirstOrDefaultAsync(t => t.Id == order.Id);
        tx.Should().NotBeNull();
        tx!.Status.Should().Be("confirmed");

        var topics = await _db.OutboxMessages
            .Where(m => m.Topic.StartsWith("ois.order.") || m.Topic == "ois.registry.transferred")
            .Select(m => m.Topic)
            .ToListAsync();

        topics.Should().Contain("ois.order.paid");
        topics.Should().Contain("ois.registry.transferred");
        topics.Should().Contain("ois.order.confirmed");
    }

    [Fact]
    public async Task MarkPaid_On_Ledger_Error_Stays_Reserved_And_Allows_Retry()
    {
        var investor = Guid.NewGuid();
        var issuance = Guid.NewGuid();
        var req = new CreateOrderRequest { InvestorId = investor, IssuanceId = issuance, Amount = 10m };
        var idem = Guid.NewGuid().ToString();

        var order = await _service.PlaceOrderAsync(req, idem, CancellationToken.None);

        // now make ledger fail
        _ledger.Setup(x => x.TransferAsync(It.IsAny<string?>(), It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>()))
               .ThrowsAsync(new InvalidOperationException("dlterr"));

        await Assert.ThrowsAsync<InvalidOperationException>(() => _service.MarkPaidAsync(order.Id, null, CancellationToken.None));

        var entity = await _db.Orders.FindAsync(order.Id);
        entity!.Status.Should().Be("reserved");

        // restore ledger and retry -> should succeed
        _ledger.Setup(x => x.TransferAsync(It.IsAny<string?>(), It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>()))
               .ReturnsAsync("txhash-retry");

        var paid = await _service.MarkPaidAsync(order.Id, null, CancellationToken.None);
        paid.Status.Should().Be("paid");
        paid.DltTxHash.Should().Be("txhash-retry");
    }
}

```
---
# services/registry/registry.Tests/OutboxPublishTests.cs
```cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Registry;
using OIS.Registry.Services;
using System.Text.Json;
using Xunit;

namespace OIS.Registry.Tests;

public class OutboxPublishTests
{
    private readonly RegistryDbContext _db;
    private readonly OutboxService _outboxService;

    public OutboxPublishTests()
    {
        var options = new DbContextOptionsBuilder<RegistryDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;
        _db = new RegistryDbContext(options);
        _outboxService = new OutboxService(_db);
    }

    [Fact]
    public async Task AddAsync_CreatesOutboxMessage()
    {
        // Arrange
        var eventPayload = new
        {
            orderId = Guid.NewGuid().ToString(),
            investorId = Guid.NewGuid().ToString(),
            amount = 5000,
        };

        // Act
        await _outboxService.AddAsync("ois.order.placed", eventPayload, CancellationToken.None);
        await _db.SaveChangesAsync();

        // Assert
        var messages = await _db.OutboxMessages.ToListAsync();
        Assert.Single(messages);
        Assert.Equal("ois.order.placed", messages[0].Topic);
        Assert.Contains("orderId", messages[0].Payload);
    }

    [Fact]
    public async Task AddAsync_WithMultipleEvents_CreatesAllMessages()
    {
        // Arrange & Act
        await _outboxService.AddAsync("topic1", new { data = "1" }, CancellationToken.None);
        await _outboxService.AddAsync("topic2", new { data = "2" }, CancellationToken.None);
        await _outboxService.AddAsync("topic3", new { data = "3" }, CancellationToken.None);
        await _db.SaveChangesAsync();

        // Assert
        var messages = await _db.OutboxMessages.ToListAsync();
        Assert.Equal(3, messages.Count);
    }
}


```
---
# services/registry/registry.Tests/registry.Tests.csproj
```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Moq" Version="4.20.70" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="FluentAssertions" Version="6.12.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\registry.csproj" />
  </ItemGroup>

</Project>


```
---
# services/registry/registry.csproj
```csproj
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <DefaultItemExcludes>$(DefaultItemExcludes);registry.Tests/**</DefaultItemExcludes>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="registry.Tests/**/*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="1.9.0-beta.1" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.9.0" />
    <PackageReference Include="Polly" Version="8.4.1" />
    <PackageReference Include="System.Net.Http.Json" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="MassTransit" Version="8.2.0" />
    <PackageReference Include="MassTransit.Kafka" Version="8.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Compile Remove="registry.Tests/**/*.cs" />
  </ItemGroup>

</Project>

```