This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  api-gateway/
    Properties/
      launchSettings.json
    api-gateway.csproj
    appsettings.Development.json
    appsettings.json
    Program.cs
  backoffice/
    src/
      app/
        api/
          auth/
            [...nextauth]/
              route.ts
          proxy/
            route.ts
        audit/
          [id]/
            page.tsx
          page.tsx
        auth/
          signin/
            page.tsx
        complaints/
          components/
            ComplaintDetailsPanel.tsx
            ComplaintItem.tsx
          hooks/
            useComplaintMutations.ts
          page.tsx
        kyc/
          components/
            DocumentItem.tsx
            DocumentPreviewModal.tsx
            KycDetails.tsx
            QualificationDecisionForm.tsx
            QualificationDetailsPanel.tsx
            QualificationList.tsx
            QualificationTaskItem.tsx
          hooks/
            useQualificationMutations.ts
          page.tsx
        login/
          page.tsx
        payouts/
          page.tsx
        qualification/
          page.tsx
        users/
          components/
            UserModal.tsx
            UsersTable.tsx
          hooks/
            useUserMutations.ts
          page.tsx
        layout.tsx
        not-found.tsx
        page.tsx
        providers.tsx
      components/
        layout/
          AppShell.tsx
        providers/
          Providers.tsx
      lib/
        api/
          compliance/
            complaints-api.ts
            http-client.ts
            index.ts
            kyc-api.ts
            kyc-documents-api.ts
            mocks.ts
            qualification-api.ts
            types.ts
            users-api.ts
          audit.ts
          compliance.ts
          reports.ts
        constants/
          index.ts
          navigation.ts
          status.ts
        hooks/
          useConfirmDialog.ts
        services/
          audit.ts
          complaints.ts
          dashboard.ts
          users.ts
        utils/
          file.ts
        api-client.ts
        auth.ts
      mocks/
        audit.ts
        complaints.ts
        users.ts
      types/
        next-auth.d.ts
      middleware.ts
    .eslintrc.json
    next-env.d.ts
    next.config.js
    package.json
    postcss.config.js
    README.md
    tailwind.config.ts
    tsconfig.json
    vitest.config.ts
    vitest.setup.ts
  portal-investor/
    src/
      app/
        api/
          auth/
            [...nextauth]/
              route.ts
        auth/
          signin/
            page.tsx
        catalog/
          page.tsx
        history/
          components/
            DateRangeFilter.tsx
            HistoryTabs.tsx
          columns.tsx
          page.tsx
        issuances/
          [id]/
            components/
              DocumentsSection.tsx
              MetricsCard.tsx
              OrderPanel.tsx
              ScheduleSection.tsx
              YieldChartSection.tsx
            page.tsx
        kyc/
          components/
            steps/
              AddressStep.tsx
              ContactsStep.tsx
              DocumentsStep.tsx
              IdentityStep.tsx
              PersonalStep.tsx
            KycStatusCard.tsx
            KycStepper.tsx
          constants.ts
          countries.ts
          page.tsx
          types.ts
          validation.ts
        orders/
          new/
            page.tsx
        portfolio/
          page.tsx
        profile/
          page.tsx
        layout.tsx
        page.tsx
        providers.tsx
      lib/
        api/
          compliance.ts
        api-client.ts
        auth.ts
        format.ts
        mocks.ts
        nav.ts
        navigation.tsx
      types/
        api-client.d.ts
        next-auth.d.ts
      middleware.ts
    .eslintrc.json
    next-env.d.ts
    next.config.js
    package.json
    postcss.config.js
    README.md
    tailwind.config.ts
    tsconfig.json
    vitest.config.ts
    vitest.setup.ts
  portal-issuer/
    src/
      app/
        api/
          auth/
            [...nextauth]/
              route.ts
        auth/
          signin/
            page.tsx
        dashboard/
          page.tsx
        issuances/
          [id]/
            components/
              DocumentsCard.tsx
              PayoutScheduleTable.tsx
              StatusBadges.tsx
            hooks/
              useIssuanceDetail.ts
            page.tsx
          create/
            page.tsx
          page.tsx
        kyc/
          page.tsx
        payouts/
          schedule/
            page.tsx
        profile/
          page.tsx
        reports/
          components/
            IssuancesReportTable.tsx
          hooks/
            useReportsData.ts
          page.tsx
        layout.tsx
        page.tsx
        providers.tsx
      lib/
        api/
          compliance.ts
          issuances.ts
        mocks/
          issuances.test.ts
          issuances.ts
          profile.test.ts
          profile.ts
          reports.ts
        api-client.ts
        auth.ts
        nav.ts
        navigation.tsx
      types/
        next-auth.d.ts
      middleware.ts
    .eslintrc.json
    next-env.d.ts
    next.config.js
    package.json
    postcss.config.js
    README.md
    tailwind.config.ts
    tsconfig.json
    vitest.config.ts
    vitest.setup.ts
docs/
  deploy/
    docker-compose-at-vps/
      00-overview.md
      01-prereqs-and-host-prep.md
      02-env-and-compose.md
      03-infra.md
      04-services.md
      05-gateway.md
      06-keycloak.md
      07-frontends-dev-on-vps.md
      07-frontends.md
      08-smoke-tests.md
      09-troubleshooting.md
      10-eywa1-control-plane-runbook.md
    localhost/
      FRONTEND-STARTUP.md
      KEYCLOAK-SETUP.md
      README.md
    20251113-cloudflare-ingress.md
    API-DOCS-SWAGGER-ASYNCAPI.md
    MULTI_ACCOUNT_SETUP.md
ops/
  scripts/
    auth/
      fix-redirects.sh
    deploy/
      deploy-node.sh
      provision-node.sh
    local-dev/
      backup.sh
      init-db.sh
      README.md
      setup-keycloak.sh
    check-gitlab-jobs-status.sh
    check-gitlab-jobs.sh
    check-gitlab-runners.sh
    check-kubeconfig.sh
    check-runner-status.sh
    cloudflare-dns-upsert.sh
    create-helm-chart.sh
    fix-runner-and-deploy.sh
    force-runner-reregister.sh
    get-runner-token.sh
    gitlab-runner-install.sh
    gitops-sync.sh
    install-helm.sh
    k8s-healthcheck.sh
    README.md
    restore.md
    setup-kubeconfig.sh
    setup-twc-cluster.sh
    test-restore.sh
    validate-specs.sh
packages/
  contracts/
    schemas/
      AuditEvent.json
      BrokerClient.json
      BrokerOrder.json
      CFA.json
      CommissionRow.json
      Complaint.json
      FeedItem.json
      Holding.json
      Issuance.json
      IssuerReportRow.json
      KycDecision.json
      KycDocument.json
      KycResult.json
      MarketIssuanceCard.json
      Order.json
      Payout.json
      PayoutBatch.json
      PayoutItem.json
      QualificationResult.json
      ReconciliationReport.json
      RegistryTx.json
      TxHistoryItem.json
      Wallet.json
    asyncapi.yaml
    openapi-compliance.yaml
    openapi-gateway.yaml
    openapi-identity.yaml
    openapi-integrations-bank.yaml
    openapi-integrations-edo.yaml
    openapi-integrations-esia.yaml
    openapi-issuance.yaml
    openapi-registry.yaml
    openapi-settlement.yaml
    README.md
scripts/
  git/
    zip_branches.sh
services/
  compliance/
    Background/
      OutboxPublisher.cs
    compliance.Tests/
      AuditApiTests.cs
      AuthorizationTests.cs
      compliance.Tests.csproj
      KycWorkflowTests.cs
      QualificationLimitTests.cs
      QualificationPolicyTests.cs
    DTOs/
      ComplaintActionDtos.cs
      ComplaintResponse.cs
      InvestorStatusResponse.cs
      KycApplicationRequest.cs
      KycDocumentDto.cs
      KycRequestDto.cs
      KycResult.cs
      QualificationResult.cs
      QualificationTaskDto.cs
    Infrastructure/
      Metrics.cs
    Migrations/
      20250104000000_InitialCreate.cs
      20250104110000_AddKycTasks.cs
      20250104120000_AddKycDocsAndQualification.cs
    Properties/
      launchSettings.json
    Services/
      ComplianceService.cs
      IWatchlistsService.cs
      QualificationPolicyService.cs
    appsettings.json
    compliance.csproj
    ComplianceDbContext.cs
    Program.cs
  identity/
    Properties/
      launchSettings.json
    appsettings.json
    identity.csproj
    Program.cs
  issuance/
    Background/
      OutboxPublisher.cs
    DTOs/
      CreateIssuanceRequest.cs
      IssuanceResponse.cs
      IssuerIssuancesReportResponse.cs
    Infrastructure/
      Metrics.cs
    issuance.Tests/
      Services/
        IssuanceServiceTests.cs
      README.md
    Migrations/
      20250101000000_InitialCreate.cs
    Properties/
      launchSettings.json
    Services/
      ILedgerIssuance.cs
      IssuanceService.cs
      LedgerIssuanceAdapter.cs
      OutboxService.cs
    Validators/
      CreateIssuanceRequestValidator.cs
    appsettings.json
    issuance.csproj
    issuance.Tests.csproj
    IssuanceDbContext.cs
    Program.cs
  registry/
    Background/
      OutboxPublisher.cs
    DTOs/
      CreateOrderRequest.cs
      OrderResponse.cs
      RedeemRequest.cs
      RedeemResponse.cs
      WalletResponse.cs
    Infrastructure/
      Metrics.cs
    Migrations/
      20250102000000_InitialCreate.cs
    Properties/
      launchSettings.json
    registry.Tests/
      ErrorMappingTests.cs
      IdempotencyTests.cs
      OrderFlowTests.cs
      OutboxPublishTests.cs
      registry.Tests.csproj
    Services/
      IBankNominalService.cs
      IComplianceService.cs
      ILedgerRegistry.cs
      RegistryService.cs
    Validators/
      CreateOrderRequestValidator.cs
    appsettings.json
    Program.cs
    registry.csproj
    RegistryDbContext.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/api-gateway/api-gateway.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <InvariantGlobalization>true</InvariantGlobalization>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.9.0" />
    <PackageReference Include="Yarp.ReverseProxy" Version="2.2.0" />
    <!-- Rate limiting available in shared framework; explicit package not required for net9.0 -->
  </ItemGroup>

</Project>
</file>

<file path="apps/backoffice/src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
</file>

<file path="apps/backoffice/src/app/providers.tsx">
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from '@ois/shared-ui';
import { useState } from 'react';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <ThemeProvider defaultTheme="light">
      <SessionProvider>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </SessionProvider>
    </ThemeProvider>
  );
}
</file>

<file path="apps/backoffice/src/lib/api/reports.ts">
const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

export type PayoutReportItem = {
  id: string;
  dueDate?: string;
  amount: number;
  currency?: string;
  status: 'scheduled' | 'executed' | 'failed';
};

export type PayoutReport = {
  totalAmount: number;
  totalItems: number;
  items: PayoutReportItem[];
};

export type SettlementJob = {
  status: 'queued' | 'started' | 'failed';
  scheduledFor?: string;
  referenceId?: string;
};

const FALLBACK_REPORT: PayoutReport = {
  totalAmount: 0,
  totalItems: 0,
  items: [],
};

async function callReports<T>(path: string, init?: RequestInit): Promise<T> {
  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    throw new Error(`Reports API error ${response.status}`);
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return (await response.json()) as T;
}

export async function getPayoutsReport(params: { from: string; to: string }): Promise<PayoutReport> {
  const search = new URLSearchParams({ from: params.from, to: params.to });

  try {
    const data = await callReports<PayoutReport>(`/v1/reports/payouts?${search.toString()}`);
    return {
      totalAmount: data.totalAmount ?? data.items?.reduce((sum, item) => sum + (item.amount ?? 0), 0) ?? 0,
      totalItems: data.totalItems ?? data.items?.length ?? 0,
      items: data.items ?? [],
    };
  } catch {
    return FALLBACK_REPORT;
  }
}

export async function runSettlement(params?: { date?: string }): Promise<SettlementJob> {
  const search = params?.date ? `?date=${encodeURIComponent(params.date)}` : '';

  try {
    return await callReports<SettlementJob>(`/v1/settlement/run${search}`, {
      method: 'POST',
    });
  } catch {
    return { status: 'queued', referenceId: 'mock-job' };
  }
}
</file>

<file path="apps/backoffice/.eslintrc.json">
{
  "extends": [
    "next/core-web-vitals",
    "next/typescript",
    "prettier"
  ],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": [
      "warn",
      {
        "argsIgnorePattern": "^_",
        "varsIgnorePattern": "^_",
        "caughtErrorsIgnorePattern": "^_"
      }
    ],
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "react-hooks/exhaustive-deps": "warn",
    "prefer-const": "warn"
  },
  "ignorePatterns": [
    "node_modules/",
    ".next/",
    "out/",
    "dist/"
  ]
}
</file>

<file path="apps/backoffice/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
</file>

<file path="apps/backoffice/postcss.config.js">
module.exports = {
  plugins: {
    'postcss-import': {},
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="apps/backoffice/README.md">
# Backoffice

Next.js 15 админ-панель.

## Pages

- `/kyc` - KYC проверки
- `/qualification` - Квалификация инвесторов
- `/audit` - Журнал аудита
- `/payouts` - Управление выплатами

## TODO

- [ ] Initialize Next.js 15 project
- [ ] Setup Tailwind + shadcn
- [ ] Implement pages
- [ ] Use generated SDK
</file>

<file path="apps/backoffice/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/portal-investor/src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
</file>

<file path="apps/portal-investor/src/app/page.tsx">
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export default async function Home() {
  const session = await getServerSession(authOptions);
  
  if (!session) {
    redirect('/auth/signin');
  }

  redirect('/catalog');
}
</file>

<file path="apps/portal-investor/src/app/providers.tsx">
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from '@ois/shared-ui';
import { useState } from 'react';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <ThemeProvider defaultTheme="light">
      <SessionProvider>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </SessionProvider>
    </ThemeProvider>
  );
}
</file>

<file path="apps/portal-investor/src/types/next-auth.d.ts">
import 'next-auth';
import 'next-auth/jwt';
import { DefaultSession } from 'next-auth';

declare module 'next-auth' {
  interface Session {
    user: {
      roles?: string[];
    } & DefaultSession['user'];
    accessToken?: string;
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    roles?: string[];
    accessToken?: string;
  }
}
</file>

<file path="apps/portal-investor/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
</file>

<file path="apps/portal-investor/next.config.js">
/** @type {import('next').NextConfig} */
const path = require('path');
const nextConfig = {
  reactStrictMode: true,
  experimental: { externalDir: true },
  webpack: (config) => {
    config.resolve.alias['@'] = path.join(__dirname, 'src');
    config.resolve.modules = [
      path.join(__dirname, 'node_modules'),
      path.join(__dirname, '../shared-ui/node_modules'),
      'node_modules'
    ];
    return config;
  },
  env: {
    NEXT_PUBLIC_API_BASE_URL: process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000',
    NEXT_PUBLIC_KEYCLOAK_URL: process.env.NEXT_PUBLIC_KEYCLOAK_URL || 'http://localhost:8080',
    NEXT_PUBLIC_KEYCLOAK_REALM: process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'ois-dev',
    NEXT_PUBLIC_KEYCLOAK_CLIENT_ID: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'portal-investor'
  }
};

module.exports = nextConfig;
</file>

<file path="apps/portal-investor/postcss.config.js">
module.exports = {
  plugins: {
    'postcss-import': {},
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="apps/portal-investor/README.md">
# Portal Investor

Next.js 15 портал для инвесторов.

## Pages

- `/portfolio` - Портфель
- `/orders` - Заказы
- `/orders/buy` - Купить ЦФА
- `/history` - История операций

## TODO

- [ ] Initialize Next.js 15 project
- [ ] Setup Tailwind + shadcn
- [ ] Implement pages
- [ ] Use generated SDK
</file>

<file path="apps/portal-investor/tailwind.config.ts">
import type { Config } from 'tailwindcss';
import preset from '../_theme/tailwind-preset.js';

const config: Config = {
  presets: [preset],
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
    '../shared-ui/src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;
</file>

<file path="apps/portal-investor/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/portal-issuer/src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
</file>

<file path="apps/portal-issuer/src/app/layout.tsx">
import type { Metadata } from 'next';
import './globals.css';
import { Providers } from './providers';
import { Toaster } from 'sonner';

export const metadata: Metadata = {
  title: 'OIS Portal - Issuer',
  description: 'Portal for CFA issuers',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="ru">
      <body className="font-sans">
        <Providers>
          {children}
          <Toaster />
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="apps/portal-issuer/src/app/page.tsx">
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export default async function Home() {
  const session = await getServerSession(authOptions);
  
  if (!session) {
    redirect('/auth/signin');
  }

  redirect('/dashboard');
}
</file>

<file path="apps/portal-issuer/src/app/providers.tsx">
'use client';

import { SessionProvider } from 'next-auth/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ThemeProvider } from '@ois/shared-ui';
import { useState } from 'react';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <ThemeProvider defaultTheme="light">
      <SessionProvider>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </SessionProvider>
    </ThemeProvider>
  );
}
</file>

<file path="apps/portal-issuer/.eslintrc.json">
{
  "extends": [
    "next/core-web-vitals",
    "next/typescript",
    "prettier"
  ],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": [
      "warn",
      {
        "argsIgnorePattern": "^_",
        "varsIgnorePattern": "^_",
        "caughtErrorsIgnorePattern": "^_"
      }
    ],
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "react-hooks/exhaustive-deps": "warn",
    "prefer-const": "warn"
  },
  "ignorePatterns": [
    "node_modules/",
    ".next/",
    "out/",
    "dist/"
  ]
}
</file>

<file path="apps/portal-issuer/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
</file>

<file path="apps/portal-issuer/next.config.js">
/** @type {import('next').NextConfig} */
const path = require('path');
const nextConfig = {
  reactStrictMode: true,
  experimental: { externalDir: true },
  transpilePackages: ['@ois/shared-ui'],
  webpack: (config) => {
    config.resolve.alias['@'] = path.join(__dirname, 'src');
    return config;
  },
  env: {
    NEXT_PUBLIC_API_BASE_URL: process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000',
    NEXT_PUBLIC_KEYCLOAK_URL: process.env.NEXT_PUBLIC_KEYCLOAK_URL || 'http://localhost:8080',
    NEXT_PUBLIC_KEYCLOAK_REALM: process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'ois-dev',
    NEXT_PUBLIC_KEYCLOAK_CLIENT_ID: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'portal-issuer'
  }
};

module.exports = nextConfig;
</file>

<file path="apps/portal-issuer/postcss.config.js">
module.exports = {
  plugins: {
    'postcss-import': {},
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="apps/portal-issuer/README.md">
# Portal Issuer

Next.js 15 портал для эмитентов.

## Pages

- `/dashboard` - Дашборд
- `/issuances` - Список выпусков
- `/issuances/create` - Создать выпуск
- `/issuances/[id]/publish` - Опубликовать
- `/issuances/[id]/close` - Закрыть
- `/reports` - Отчёты

## TODO

- [ ] Initialize Next.js 15 project
- [ ] Setup Tailwind + shadcn
- [ ] Implement pages
- [ ] Use generated SDK
</file>

<file path="apps/portal-issuer/tailwind.config.ts">
import type { Config } from 'tailwindcss';
import preset from '../_theme/tailwind-preset.js';

const config: Config = {
  presets: [preset],
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
    '../shared-ui/src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;
</file>

<file path="apps/portal-issuer/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="docs/deploy/docker-compose-at-vps/00-overview.md">
---
created: 2025-11-11 15:20
updated: 2025-11-11 15:20
type: runbook
sphere: [devops]
topic: [deploy, docker-compose, vps]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [compose, linux, dotnet, keycloak]
---

# OIS‑CFA · Deploy на VPS (Docker Compose) — Обзор

Цель: поднять полный dev‑контур на VPS с Docker Compose: инфраструктура, .NET‑сервисы, API‑шлюз, Keycloak, и (опционально) веб‑клиенты.

Ключевые принципы
- [ ] Используем non‑standard порты, чтобы не конфликтовать с окружением
- [ ] Сборка выполняется поэтапно (низкая RAM) — «infra → services → gateway → web»
- [ ] Миграции БД включаем флагом `MIGRATE_ON_STARTUP=true` (по умолчанию off)
- [ ] Логи читаем через `docker logs`, готовность через `/health`

Состав контура (порты по умолчанию)
- API Gateway: `55000`
- Identity: `55001`
- Issuance: `55005`
- Registry: `55006`
- Settlement: `55007`
- Compliance: `55008`
- PostgreSQL: `55432`
- Kafka: `59092`, ZooKeeper: `52181`
- Keycloak: `58080`
- Minio: `59000` (S3), `59001` (Console)

Структура документации
- 01 — Подготовка VPS и Docker
- 02 — Настройка `.env` и Compose
- 03 — Инфраструктура
- 04 — .NET‑сервисы
- 05 — API‑шлюз
- 06 — Keycloak (realm/clients)
- 07 — Веб‑клиенты (Next.js)
- 08 — Smoke‑тесты
- 09 — Траблшутинг
</file>

<file path="docs/deploy/docker-compose-at-vps/01-prereqs-and-host-prep.md">
---
created: 2025-11-11 15:20
updated: 2025-11-11 15:20
type: runbook
sphere: [devops]
topic: [prereqs, host-prep]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [linux, docker, swap]
---

# 01 — Подготовка VPS (Ubuntu) и Docker

Аппаратные требования (dev)
- [ ] CPU 2 vCPU+
- [ ] RAM 2–4 ГБ (на 2 ГБ добавить swap, см. ниже)
- [ ] Диск 20+ ГБ

Проверка ОС и ресурсов
- [ ] `uname -a`
- [ ] `df -hT`
- [ ] `free -m`

Установка Docker + Compose
- [ ] ```bash
  curl -fsSL https://get.docker.com | sh
  ```
- [ ] Проверка версий: `docker --version && docker compose version`

Swap 2 ГБ (для стабильной сборки .NET/Node)
- [ ] ```bash
  sudo fallocate -l 2G /swapfile || sudo dd if=/dev/zero of=/swapfile bs=1M count=2048
  sudo chmod 600 /swapfile
  sudo mkswap /swapfile
  sudo swapon /swapfile
  echo "/swapfile none swap sw 0 0" | sudo tee -a /etc/fstab
  free -m
  ```

Сетевые порты (если нужен внешний доступ)
- [ ] На сервере UFW может быть выключен (ок): `sudo ufw status`
- [ ] Часто блок на стороне провайдера: открыть TCP 55000/1/5/6/7/8, 58080, 59000/59001, 55432, 59092, 52181
- [ ] Альтернатива — SSH‑туннели (см. раздел 07 и 09)
</file>

<file path="docs/deploy/docker-compose-at-vps/02-env-and-compose.md">
---
created: 2025-11-11 15:21
updated: 2025-11-11 15:21
type: runbook
sphere: [devops]
topic: [env, compose]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [compose, env]
---

# 02 — Настройка `.env` и Compose файлов

Репозиторий и путь
- [ ] Код расположен в `/opt/ois-cfa`
- [ ] Файлы Compose:
  - `docker-compose.yml` (инфраструктура)
  - `docker-compose.override.yml` (порты/переменные из `.env`)
  - `docker-compose.kafka.override.yml` (Kafka образ для dev)
  - `docker-compose.services.yml` (.NET сервисы + API gateway)
  - `docker-compose.apps.yml` (опционально: фронтенды Next.js)

Переменные окружения (`.env`)
- [ ] Открыть `./ois-cfa/.env` и проверить:
  - [ ] Порты сервисов: `GATEWAY_HOST_PORT=55000`, `IDENTITY_HOST_PORT=55001`, `ISSUANCE_HOST_PORT=55005`, `REGISTRY_HOST_PORT=55006`, `SETTLEMENT_HOST_PORT=55007`, `COMPLIANCE_HOST_PORT=55008`
  - [ ] Инфра: `POSTGRES_HOST_PORT=55432`, `KAFKA_HOST_PORT=59092`, `ZOOKEEPER_HOST_PORT=52181`, `KEYCLOAK_HOST_PORT=58080`, `MINIO_HOST_PORT=59000`, `MINIO_CONSOLE_PORT=59001`
  - [ ] Соединения: `SERVICE_DB_CONN=Host=postgres;Port=5432;Database=ois;Username=ois;Password=ois_dev_password`
  - [ ] Kafka bootstrap: `KAFKA_BOOTSTRAP=kafka:9092`
  - [ ] (Опционально для фронтов) `API_PUBLIC_URL`, `KEYCLOAK_PUBLIC_URL`, `KEYCLOAK_REALM`, `ISSUER_HOST_PORT`, `INVESTOR_HOST_PORT`, `BACKOFFICE_HOST_PORT`

Git/синхронизация кода на VPS
- [ ] Если нужно обновить код из локали: 
  ```bash
  rsync -az --delete --exclude '.git' --exclude 'node_modules' ././ois-cfa/ cfa1:/opt/ois-cfa/
  ```
</file>

<file path="docs/deploy/docker-compose-at-vps/03-infra.md">
---
created: 2025-11-11 15:21
updated: 2025-11-11 15:21
type: runbook
sphere: [devops]
topic: [infra, postgres, kafka, keycloak, minio]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [compose, infra]
---

# 03 — Инфраструктура (Postgres, Kafka/ZK, Keycloak, Minio)

Запуск инфраструктуры
- [ ] ```bash
  cd /opt/ois-cfa
  docker compose -f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml up -d
  ```
- [ ] Проверить контейнеры: 
  - `docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"`

Health/порты (локально на сервере)
- [ ] Postgres: `docker exec -it ois-postgres pg_isready -U ois`
- [ ] Keycloak: порт `58080` (админ admin/admin123), URL: `http://localhost:58080`
- [ ] Minio: `http://localhost:59001` (minioadmin/minioadmin)

Примечание по Kafka
- [ ] В dev используем образ `confluentinc/cp-kafka:7.5.0` (через override)
</file>

<file path="docs/deploy/docker-compose-at-vps/04-services.md">
---
created: 2025-11-11 15:22
updated: 2025-11-11 15:22
type: runbook
sphere: [devops]
topic: [services, dotnet]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [dotnet, compose]
---

# 04 — .NET‑сервисы (поэтапный запуск)

Общие правила
- [ ] На малых VPS собирать по одному сервису (RAM 2 ГБ)
- [ ] Миграции БД — через флаг `MIGRATE_ON_STARTUP=true` (по умолчанию не применяются)
- [ ] Проверка готовности: `/health` на соответствующем порту

Identity Service
- [ ] ```bash
  cd /opt/ois-cfa
  C="-f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml -f docker-compose.services.yml"
  docker compose $C build identity-service && docker compose $C up -d identity-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55001/health
  ```

Registry Service
- [ ] ```bash
  docker compose $C build --no-cache registry-service
  MIGRATE_ON_STARTUP=false docker compose $C up -d registry-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55006/health
  ```

Issuance Service (dev‑правки учтены)
- [ ] Примечание: в dev отключены Prometheus‑экспортер и scraping endpoint, авто‑валидация временно выключена
- [ ] ```bash
  docker compose $C build --no-cache issuance-service
  MIGRATE_ON_STARTUP=false docker compose $C up -d issuance-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55005/health
  ```

Settlement Service
- [ ] ```bash
  docker compose $C build settlement-service
  MIGRATE_ON_STARTUP=false docker compose $C up -d settlement-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55007/health
  ```

Compliance Service
- [ ] ```bash
  docker compose $C build compliance-service
  MIGRATE_ON_STARTUP=false docker compose $C up -d compliance-service
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55008/health
  ```

Логи и статус
- [ ] `docker compose $C ps`
- [ ] `docker logs -f <service>`
</file>

<file path="docs/deploy/docker-compose-at-vps/05-gateway.md">
---
created: 2025-11-11 15:22
updated: 2025-11-11 15:22
type: runbook
sphere: [devops]
topic: [gateway, yarp]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [yarp, reverse-proxy]
---

# 05 — API Gateway (YARP)

Сборка и запуск
- [ ] ```bash
  cd /opt/ois-cfa
  C="-f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml -f docker-compose.services.yml"
  docker compose $C build api-gateway && docker compose $C up -d api-gateway
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55000/health
  ```

Примечания по маршрутам
- [ ] Маршруты читаются из `apps/api-gateway/appsettings.json` (секция `ReverseProxy`)
- [ ] Исправлено правило redeem: `"/v1/issuances/{id}/redeem"` (catch‑all в середине запрещён)

Проверки
- [ ] `/health` → 200
- [ ] Запросы на `/v1/orders/{id}`, `/v1/wallets/{investorId}` возвращают 404 (NotFound), если нет данных — это нормальная реакция
</file>

<file path="docs/deploy/docker-compose-at-vps/06-keycloak.md">
---
created: 2025-11-11 15:23
updated: 2025-11-21 12:30
type: runbook
sphere: [devops]
topic: [keycloak, oidc]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.1
tags: [keycloak, oidc]
---

# 06 — Keycloak (realm/clients)

Параметры
- [ ] URL (внутри compose сети): `http://keycloak:8080`
- [ ] URL (на хосте): `http://localhost:58080`
- [ ] Админ: `admin/admin123`
- [ ] Realm: `ois`

Бутстрап realm и клиентов (issuer, investor, backoffice)
- [ ] ```bash
  cd /opt/ois-cfa
  chmod +x ops/keycloak/bootstrap-realm.sh
  docker exec ois-keycloak bash -lc "bash -s" < ops/keycloak/bootstrap-realm.sh
  ```
- [ ] Скрипт создаёт клиентов с redirect URIs по публичным URL (редактируем переменные в начале при необходимости)
- [ ] Демо‑пользователи: `investor/Passw0rd!`, `issuer/Passw0rd!`, `backoffice/Passw0rd!`

Внешний доступ
- [ ] Если 58080 недоступен снаружи — это, вероятно, фаервол провайдера
- [ ] Временное решение: SSH‑туннель (см. 07 и 09)

## CFA1 login recovery (2025-11-21)
- Убедиться, что контейнер запущен: `docker ps | grep ois-keycloak`
- Сбросить пароль тестового пользователя (realm `ois-dev`):  
  `docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh config credentials --server http://localhost:8080 --realm master --user admin --password admin123`  
  `docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh set-password -r ois-dev --username alexabook1 --new-password 'zdwouE$ybQ!4!hCHRtG!ML76HHuA2p' --temporary=false`
- Принудительно включить/подтвердить почту при проблемах с логином:  
  `docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh update users/$(docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh get users -r ois-dev -q username=alexabook1 --fields id --format csv | tr -d '\r\n') -r ois-dev -s enabled=true -s emailVerified=true`
- Админ логин: `https://auth.cfa1.llmneighbors.com/admin` (admin/admin123 по умолчанию).
</file>

<file path="docs/deploy/docker-compose-at-vps/07-frontends-dev-on-vps.md">
# Frontends on VPS (Dev mode)

## ✅ TL;DR
- Запускаем фронтенды в dev-режиме на VPS (без Docker)
- Порты: 3001 (issuer), 3002 (investor), 3003 (backoffice)
- Для доступа с Mac используйте SSH-туннели (см. ниже)

## 1) Предусловия (host)
- [x] Docker/Compose для бэкендов уже подняты (gateway 5000, keycloak 8080)
- [x] Node.js 20 LTS установлен
  ```bash
  curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
  apt-get update -y && apt-get install -y nodejs build-essential
  node -v && npm -v
  npm i -g pm2@latest
  ```

## 2) Keycloak (realm и клиенты)
- [x] Убедитесь, что Keycloak запущен и доступен
  ```bash
  docker compose -f docker-compose.yml -f docker-compose.override.yml up -d keycloak
  curl -I http://localhost:8080/admin   # 302
  ```
- [x] Бутстрап реалма и клиентов (PUBLIC)
  ```bash
  docker cp ops/keycloak/bootstrap-realm.sh ois-keycloak:/tmp/bootstrap.sh
  docker exec ois-keycloak bash -lc \
    'KC_USER=admin KC_PASS=admin123 REALM=ois-dev \
     ISSUER_URL=http://localhost:3001 INVESTOR_URL=http://localhost:3002 BACKOFFICE_URL=http://localhost:3003 \
     ISSUER_TUNNEL_URL=http://localhost:15301 INVESTOR_TUNNEL_URL=http://localhost:15302 BACKOFFICE_TUNNEL_URL=http://localhost:15303 \
     bash /tmp/bootstrap.sh'
  ```

## 3) Env для фронтов
- [x] Создайте `.env.local` в каждой из папок:
  - `apps/portal-issuer/.env.local`
  - `apps/portal-investor/.env.local`
  - `apps/backoffice/.env.local`

  Содержимое:
  ```dotenv
  NEXT_PUBLIC_API_BASE_URL=http://localhost:5000
  NEXT_PUBLIC_KEYCLOAK_URL=http://localhost:8080
  NEXT_PUBLIC_KEYCLOAK_REALM=ois-dev
  NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=<portal-issuer|portal-investor|backoffice>
  NEXTAUTH_URL=http://localhost:<3001|3002|3003>
  ```

## 4) Установка зависимостей
- [x] Сначала SDK и shared-ui:
  ```bash
  cd /opt/ois-cfa/packages/sdks/ts && npm install --no-audit --no-fund --include=dev && npm run build
  cd /opt/ois-cfa/apps/shared-ui && npm install --no-audit --no-fund --include=dev
  ```
- [x] Затем каждый фронт:
  ```bash
  cd /opt/ois-cfa/apps/portal-issuer && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/portal-investor && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/backoffice && npm install --no-audit --no-fund --include=dev
  ```

## 5) Старт в dev-режиме (pm2)
- [x] Запуск и автосохранение:
  ```bash
  pm2 start npm --name portal-issuer --cwd /opt/ois-cfa/apps/portal-issuer -- run dev
  pm2 start npm --name portal-investor --cwd /opt/ois-cfa/apps/portal-investor -- run dev
  pm2 start npm --name backoffice    --cwd /opt/ois-cfa/apps/backoffice    -- run dev
  pm2 save
  pm2 ls
  ```

## 6) Проверки (обязательные)
- [x] Слушатели:
  ```bash
  ss -ltnp | egrep ":5000|:8080|:3001|:3002|:3003"
  ```
- [x] Коды ответов:
  ```bash
  curl -s -o /dev/null -w "GATEWAY:%{http_code}\n" http://localhost:5000/health
  curl -s -o /dev/null -w "KC:/admin %{http_code}\n" http://localhost:8080/admin
  for p in 3001 3002 3003; do curl -s -o /dev/null -w ":$p => %{http_code}\n" http://localhost:$p/; done
  ```

## 7) SSH‑туннели (Mac)
```bash
ssh -N \
  -L 15500:localhost:5000 \
  -L 15808:localhost:8080 \
  -L 15301:localhost:3001 \
  -L 15302:localhost:3002 \
  -L 15303:localhost:3003 \
  cfa1-mux
```
- Gateway: http://localhost:15500/health
- Keycloak: http://localhost:15808/admin (admin/admin123)
- Issuer: http://localhost:15301
- Investor: http://localhost:15302
- Backoffice: http://localhost:15303

## 8) Примечания
- Для временной разработки модульные зависимости `shared-ui` резолвятся через `next.config.js` (modules: `../shared-ui/node_modules`).
- В перспективе лучше перейти на workspaces (hoist deps на корень).

## CFA1 hotfix (2025-11-21) — missing deps & pm2 restart
- Установить зависимости в Sharedui/порталах (от пользователя `user`):  
  ```
  cd /opt/ois-cfa/apps/shared-ui && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/portal-issuer && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/portal-investor && npm install --no-audit --no-fund --include=dev
  cd /opt/ois-cfa/apps/backoffice && npm install --no-audit --no-fund --include=dev
  ```
- Построить, чтобы поймать типовые ошибки: `npm run build` в portal-issuer/portal-investor.
- Перезапустить dev-серверы: `PM2_HOME=/home/user/.pm2 pm2 restart portal-issuer portal-investor backoffice`.
</file>

<file path="docs/deploy/docker-compose-at-vps/07-frontends.md">
---
created: 2025-11-11 15:23
updated: 2025-11-11 15:23
type: runbook
sphere: [devops]
topic: [nextjs, web]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [nextjs, docker]
---

# 07 — Веб‑клиенты (Next.js)

Сервисы
- [ ] Portal Issuer (порт по умолчанию 53001)
- [ ] Portal Investor (порт по умолчанию 53002)
- [ ] Backoffice (порт по умолчанию 53003)

Зависимости monorepo
- [ ] Некоторые приложения импортируют `shared-ui` и `@ois/api-client`
- [ ] Для корректной сборки нужен «корневой» install и сборка пакетов (или простая альтернатива ниже)

Альтернатива (минимальный путь на dev)
- [ ] Сборка Portal Issuer/Investor из своих папок (Dockerfiles добавлены)
- [ ] Backoffice можно отложить (ошибки резолва модулей при отсутствии сборки shared‑ui/sdk)

Запуск (issuer + investor)
- [ ] ```bash
  cd /opt/ois-cfa
  C="-f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml -f docker-compose.services.yml -f docker-compose.apps.yml"
  docker compose $C build portal-issuer portal-investor
  docker compose $C up -d portal-issuer portal-investor
  for p in 53001 53002; do curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:${p}/; done
  ```

Переменные окружения для фронтов
- [ ] `API_PUBLIC_URL=http://<host-ip>:55000`
- [ ] `KEYCLOAK_PUBLIC_URL=http://<host-ip>:58080` (или локальный туннель)
- [ ] `KEYCLOAK_REALM=ois`
- [ ] `NEXTAUTH_URL` для каждого фронта на свой URL (см. docker-compose.apps.yml)

Логин через Keycloak
- [ ] Убедиться, что клиенты в Keycloak созданы (см. 06)
- [ ] Проверить redirect URIs и web origins под ваши адреса

- SSH‑туннели (если внешний фаервол закрыт)
- [ ] Порты должны быть ≤ 65535. Пример корректного туннеля:
  ```bash
  ssh -N \
    -L 15500:localhost:55000 \
    -L 15501:localhost:55001 \
    -L 15506:localhost:55006 \
    -L 15808:localhost:58080 \
    -L 15301:localhost:53001 \
    -L 15302:localhost:53002 \
    cfa1-mux
  ```
- [ ] Открыть в браузере: 
  - Gateway: `http://localhost:15500/health`
  - Issuer app: `http://localhost:15301/`
  - Investor app: `http://localhost:15302/`
  - Keycloak: `http://localhost:15808/`
</file>

<file path="docs/deploy/docker-compose-at-vps/08-smoke-tests.md">
---
created: 2025-11-11 15:24
updated: 2025-11-11 15:24
type: runbook
sphere: [devops]
topic: [smoke, curl]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [testing]
---

# 08 — Smoke‑тесты (через Gateway)

Health
- [ ] `curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55000/health` → 200
- [ ] `curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55001/health` → 200
- [ ] `curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55006/health` → 200

Прокси маршруты (без данных ожидаемо 404)
- [ ] `curl -i http://localhost:55000/v1/orders/$(uuidgen)` → 404
- [ ] `curl -i http://localhost:55000/v1/wallets/$(uuidgen)` → 404

Создание выпуска (как пример, после сидирования)
- [ ] ```bash
  cat > /tmp/issuance.json <<JSON
  {
    "assetId": "$(uuidgen)",
    "issuerId": "$(uuidgen)",
    "totalAmount": 1000000,
    "nominal": 1000,
    "issueDate": "2025-01-01",
    "maturityDate": "2026-01-01",
    "scheduleJson": {"coupons": []}
  }
  JSON
  curl -sS -H "Content-Type: application/json" -d @/tmp/issuance.json -i http://localhost:55000/v1/issuances
  ```

Примечание
- [ ] Для полного сквозного сценария потребуется сид‑данные и/или dev‑упрощения для compliance/bank‑nominal
</file>

<file path="docs/deploy/docker-compose-at-vps/09-troubleshooting.md">
---
created: 2025-11-11 15:24
updated: 2025-11-11 15:24
type: runbook
sphere: [devops]
topic: [troubleshooting]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [troubleshooting, logs]
---

# 09 — Траблшутинг

Типовые проверки
- [ ] `docker compose -f ... ps` — статусы
- [ ] `docker logs -f <name>` — логи
- [ ] `ss -ltnp` — порты слушаются на хосте
- [ ] `curl -i http://localhost:<port>/health` — готовность

Нехватка памяти при сборке
- [ ] Добавить swap (см. 01)
- [ ] Собирайте по одному сервису: `docker compose ... build <service>`

Проблемы миграций БД при старте
- [ ] Запускать без миграций: `MIGRATE_ON_STARTUP=false docker compose ... up -d <service>`
- [ ] Для разового применения — на время старта: `MIGRATE_ON_STARTUP=true ...`

Gateway не стартует, ошибка YARP
- [ ] Проверить `appsettings.json` — маршрут `redeem` должен быть `"/v1/issuances/{id}/redeem"`

Keycloak недоступен снаружи
- [ ] Проверить провайдерский фаервол (58080 TCP). На самом сервере UFW может быть выключен, но у провайдера порт может быть закрыт.
- [ ] Временно использовать SSH‑туннель (см. 07); пример: `ssh -N -L 15808:localhost:58080 cfa1-mux`

Next.js фронты не собираются
- [ ] Требуют сборки `shared-ui` и SDK: сделать корневой install и сборку пакетов (workspaces)
- [ ] Минимальный путь — собирать issuer/investor; backoffice перенести на следующий этап

Очистка образов/кэша
- [ ] `docker system df`, `docker image prune -f`, `docker builder prune -f`
</file>

<file path="docs/deploy/docker-compose-at-vps/10-eywa1-control-plane-runbook.md">
---
created: 2025-11-19 18:30
updated: 2025-11-19 21:10
type: runbook
sphere: [devops]
topic: [deploy, control-plane, vps]
author: alex-a
agentID: co-76ca
partAgentID: [co-76ca, co-7b1b]
version: 0.3.0
tags: [eywa1, tmux, ssh, cloudflare, docker-compose]
---

# OIS‑CFA · Eywa1 Control Plane — Multi‑VPS Runbook

Цель: превратить `eywa1` в управляющий узел (Control Plane) для однотипного деплоя OIS‑CFA на VPS (`cfa1`, `fin2`, `germ1`, …), не ломая рабочий UK1.

## Scope
- Workspace: `eywa1`, директория проекта `~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets`.
- Код: рабочий `worktree` `repositories/customer-gitlab/wt__ois-cfa__NX01` (ветка `tasks/NX-01-spec-validate-and-matrix` / `infra.defis.deploy`).
- Целевые узлы: `cfa1`, `fin2`, `germ1`, … (UK1 — только как референс, без изменений).
- DNS: Cloudflare для `*.cfa.llmneighbors.com`, `*.cfa{1,2,3}.llmneighbors.com`.

## TL;DR
- Eywa1 становится единым Control Plane: все операции — через SSH + `tmux` на целевых узлах, логи сохраняются в сессии `p-cfa`.
- На каждом VPS создаётся пользователь `user` с sudo, базовый стек (Docker, Node 20, tmux, nginx, postfix) и директория `/srv/cfa`.
- Новый деплой стандартизирован через два скрипта в `wt__ois-cfa__NX01`: `ops/scripts/deploy/provision-node.sh` (bootstrap) и `ops/scripts/deploy/deploy-node.sh` (деплой стека).
- UK1 остаётся каноническим демо‑стендом (см. `docs/deploy/20251113-cloudflare-ingress.md` и `docker-compose-at-vps/*`); на нём ничего не меняем без отдельного плана.
- Для NX‑05/06 рабочим окружением для кода считаем `wt__ois-cfa__NX01`, а для проверок UI/flows — новые VPS, развернутые по этому runbook’у.

## Architecture (High‑Level)

```mermaid
flowchart LR
  subgraph Eywa1["eywa1 · Control Plane"]
    Agent[CLI agent / user]
    Repo[prj_Cifra-rwa-exachange-assets\nwt__ois-cfa__NX01]
    CF[Cloudflare CLI/API]
    SSHKeys[SSH keys]
  end

  subgraph Nodes["Target VPS nodes"]
    subgraph Node1["cfa1"]
      User1[user sudo]
      Tmux1[tmux session\np-cfa]
      Stack1[OIS-CFA stack\nDocker + PM2]
    end
    subgraph Node2["fin2"]
      User2[user sudo]
      Tmux2[tmux session\np-cfa]
      Stack2[OIS-CFA stack\nDocker + PM2]
    end
  end

  Agent --> Repo
  Agent --> CF
  Agent --> SSHKeys

  SSHKeys --> User1
  SSHKeys --> User2

  Agent -->|provision-node.sh| Node1
  Agent -->|deploy-node.sh| Node1
  Agent -->|provision-node.sh| Node2
  Agent -->|deploy-node.sh| Node2
```

## Phases Overview

1. **Phase 0 — Rules & Safety**: фиксируем запреты и инварианты UK1 не трогаем, только `user`, только `/srv/cfa`).
2. **Phase 1 — Prepare Eywa1**: убеждаемся, что есть SSH‑ключи, Cloudflare CLI, актуальный `wt__ois-cfa__NX01`.
3. **Phase 2 — Provision Node**: подготавливаем VPS (user, SSH, базовые пакеты, tmux, `/srv/cfa`, сессия `p-cfa`).
4. **Phase 3 — Deploy OIS‑CFA Stack**: клонируем `ois-cfa`, включаем docker‑compose, подключаем фронты через PM2 и nginx.
5. **Phase 4 — Verify & Handover**: health‑чеки, smoke‑тесты, фиксация итогового состояния в memory‑bank.

---

## Phase 0 — Rules & Safety

Why  
- Минимизировать риск сломать единственный рабочий стенд и превратить деплой в «необратимый эксперимент».

What  
- Описать инварианты, которые агент/инженер не имеет права нарушать.

How  
- Перед запуском любых скриптов проговорить/прописать ограничения.

Result  
- Любые действия по bootstrap/deploy выполняются только в рамках согласованных узлов и веток.

### Invariants
- **UK1 не трогаем** — используем только как эталон (см. `docs/deploy/20251113-cloudflare-ingress.md` и `docker-compose-at-vps/*`).
- **Только пользователь `user`** для приложений и деплоя (никаких сервисов от `root`).
- **Единый путь проекта**: `/srv/cfa` на всех узлах.
- **Все длительные команды** — только внутри `tmux`‑сессии `p-cfa` на целевом VPS.
- **Только зафиксированные ветки**: для деплоя используем `infra.defis.deploy` (или явно согласованную ветку), код для NX‑05/06 — из `wt__ois-cfa__NX01`.

---

## Phase 1 — Prepare Eywa1 (Control Plane)

Why  
- Без корректного состояния на `eywa1` невозможен безопасный bootstrap узлов.

What  
- Проверяем наличие SSH‑ключей, Cloudflare‑кредов, актуальной копии репо и утилит.

How  
- Ручной чеклист + точечные команды.

Result  
- `eywa1` готов отдавать команды на `cfa1`/`fin2` и управлять DNS.

### Checklist
- [ ] SSH‑ключ `~/.ssh/id_rsa` (или другой) привязан к `root`/`user` на целевых VPS (`ssh cfa1`, `ssh fin2` работает без пароля).
- [ ] В `~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets` актуален `git pull` для монорепо.
- [ ] В `repositories/customer-gitlab/wt__ois-cfa__NX01` подтянуты последние изменения ветки `infra.defis.deploy` / `tasks/NX-01-spec-...`.
- [ ] На `eywa1` установлен Cloudflare CLI или подготовлен `curl` + `.env` с `CLOUDFLARE_API_TOKEN` (см. `docs/deploy/20251113-cloudflare-ingress.md`).
- [ ] Установлены базовые утилиты: `jq`, `tmux`, `git`, `docker` (на `eywa1` только если нужно).

---

## Phase 2 — Provision Node (Bootstrap VPS)

Why  
- Нужно стандартизировать базовый образ сервера, чтобы все последующие шаги не превращались в «каждый VPS по‑своему».

What  
- Скрипт `ops/scripts/deploy/provision-node.sh` выполняет bootstrap: пользователь `user`, пакеты, Docker, Node, tmux, `p-cfa`.

How  
- Запускаем скрипт с `eywa1`, который через SSH конфигурирует целевой VPS.

Result  
- На `cfa1`/`fin2` есть готовый «пустой, но правильный» хост для деплоя OIS‑CFA.

### Minimal usage

```bash
cd ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets/repositories/customer-gitlab/wt__ois-cfa__NX01
ops/scripts/deploy/provision-node.sh cfa1
ops/scripts/deploy/provision-node.sh fin2
```

### What it standardizes
- Создаёт (если нет) пользователя `user` с группой `sudo`.
- Настраивает базовые пакеты: `curl`, `git`, `tmux`, `jq`, `ufw`, `docker`, `docker-compose-plugin`, `nginx`, `postfix`.
- Устанавливает Node.js 20 для `user` (через `nvm` или системный пакет, зависит от окружения).
- Создаёт `/srv/cfa`, назначает владельца `user:user`.
- Добавляет в `~user/.tmux.conf` параметр `set-option -g history-limit 1000000`.
- Создаёт (если нет) `tmux`‑сессию `p-cfa`, рабочий каталог `/srv/cfa`.

---

## Phase 3 — Deploy OIS‑CFA Stack

Why  
- Поддерживать один сценарий деплоя для всех узлов, чтобы не плодить «уникальные» стенды.

What  
- Скрипт `ops/scripts/deploy/deploy-node.sh` клонирует `ois-cfa`, подтягивает ветку и запускает docker‑compose + фронты.

How  
- Из `eywa1` вызываем скрипт для выбранного узла; скрипт отправляет команды в `tmux`‑сессию `p-cfa` на VPS.

Result  
- На целевом VPS развёрнут стек OIS‑CFA, готовый к smoke‑тестам NX‑05/06.

### Minimal usage

```bash
cd ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets/repositories/customer-gitlab/wt__ois-cfa__NX01
OIS_CFA_BRANCH=infra.defis.deploy ops/scripts/deploy/deploy-node.sh cfa1
OIS_CFA_BRANCH=infra.defis.deploy ops/scripts/deploy/deploy-node.sh fin2
```

### Notes
- По умолчанию используется репозиторий `git@git.telex.global:npk/ois-cfa.git` и ветка `infra.defis.deploy` (можно переопределить переменными окружения).
- Скрипт **не заполняет секреты** — `.env`‑файлы должны быть подготовлены отдельно (см. `docs/deploy/docker-compose-at-vps/02-env-and-compose.md`).
- Для фронтендов (Next.js) скрипт создаёт базовый scaffold команд в `tmux`, но конкретные `pm2`‑процессы и `env.local` лучше выровнять по UK1 (см. сессии `co-3dd7` и `20251113-cloudflare-ingress.md`).

---

## Phase 4 — Verify & Handover

Why  
- Без чётких health‑чеков легко получить «оно где‑то крутится, но не факт, что работает».

What  
- Проверяем `/health` и ключевые UI‑флоу, фиксируем результаты и риски.

How  
- Команды curl, базовый UI walkthrough, при возможности — Playwright e2e.

Result  
- Описанный, воспроизводимый стенд с понятным статусом готовности.

### Basic health
- [ ] `curl http://<host>:55000/health` (gateway) → `200 OK`.
- [ ] `curl http://<host>:55005/health` (issuance), `55006` (registry), `55007` (settlement), `55008` (compliance).
- [ ] Keycloak доступен по HTTP (до настройки ingress/TLS).

### Smoke‑flows (минимум)
- [ ] Issuer портал открывается (локальный порт или домен через nginx/Cloudflare).
- [ ] Базовый issuance‑flow (создание простого выпуска без сложного payout schedule).
- [ ] Просмотр отчётности `/reports` (после NX‑05 implementation).

### Memory‑bank / Logging
- [ ] Создан файл в `memory-bank/Scrum/<date>/<timestamp>-<host>-bootstrap.session.md` с кратким логом команд и ссылками на tmux‑сессии.

---

## Troubleshooting / Lessons Learned

- **Права на код (`chown -R user:user`).**  
  При переносе `/opt/ois-cfa` или клонировании репозитория от `root` фронты (Next.js) и `npm install` под `user` ломаются с `EACCES` на `package-lock.json`/`node_modules`.  
  Решение: после bootstrap/деплоя привести права в порядок:
  - Для Control Plane‑пути: `chown -R user:user /srv/cfa/ois-cfa` (если репо там).  
  - Для старых UK1‑образов (как на cfa1): `chown -R user:user /opt/ois-cfa`.

- **NEXTAUTH_URL и Redirect URIs в Keycloak.**  
  Если `NEXTAUTH_URL`/публичные URL фронтов (`issuer|investor|backoffice.cfa{N}.llmneighbors.com`) не совпадают с `redirectUris`/`webOrigins` в Keycloak, логин/регистрация падают (loop, `invalid redirect`, пустой экран).  
  Решение:
  - Для клиентов `portal-issuer`, `portal-investor`, `backoffice` в realm `ois-dev` держать:
    - `rootUrl = https://<app>.cfa{N}.llmneighbors.com`
    - `redirectUris = ["https://<app>.cfa{N}.llmneighbors.com/*"]`
    - `webOrigins = ["https://<app>.cfa{N}.llmneighbors.com"]`
  - В `.env.local` фронтов `NEXTAUTH_URL` должен быть ровно тем же публичным https‑URL.

- **Playwright как канонический smoke для ingress.**  
  E2E‑тесты (`tests/e2e-playwright`) с доменами `issuer|investor|backoffice.cfa1.llmneighbors.com` и логином через Keycloak — лучший индикатор, что весь стек (DNS/TLS/nginx + backend + фронты + почта) работает end‑to‑end. Скриншоты живут под `artifacts/tests/e2e/playwright/*.e2e.png` с timestamp и run id.

---

## Definition of Done (DoD)

### 1. Control Plane & Scripts
- [x] Runbook `10-eywa1-control-plane-runbook.md` и скрипты `ops/scripts/deploy/*` зафиксированы в текущей ветке (`deploy`/`tasks/NX-01-*`) и описаны в `README`/manifests.
- [x] Для узлов `cfa1` и `fin2` успешно выполнены Phases 1–3 (Control Plane baseline):
  - [x] Создан пользователь `user` (sudo + docker), настроен SSH по ключам.
  - [x] Создана директория `/srv/cfa`, настроена `tmux`‑сессия `p-cfa`.
  - [x] Репозиторий `npk/ois-cfa` клонирован в `/srv/cfa/ois-cfa` с нужной веткой (work3) или перенесён из UK1‑образа.
- [ ] Состояние UK1 **не изменено** в процессе работ (используется только как референс).

### 2. Parity с UK1 по docker-compose runbook’ам (00–09)
Для каждого активного окружения (`uk1`, `cfa1`, `cfa2`/`fin2`) должны быть закрыты шаги из `docker-compose-at-vps`:

- [ ] 00–02: `00-overview.md`, `01-prereqs-and-host-prep.md`, `02-env-and-compose.md` — выполнены, `.env` и compose‑файлы задокументированы.
- [ ] 03–04: `03-infra.md`, `04-services.md` — базовая инфраструктура (Postgres, Kafka, Minio) и .NET‑сервисы подняты через `docker compose`.
- [ ] 05–06: `05-gateway.md`, `06-keycloak.md` — API gateway и Keycloak работают, health‑эндпоинты и логин проверены.
- [ ] 07–08: `07-frontends*.md`, `08-smoke-tests.md` — порталы (Issuer/Investor/Backoffice) подняты (PM2 или dev), basic UX‑флоу и e2e smoke‑тесты проходят.

Фактический прогресс по узлам фиксируется в отдельных DoD/отчётах в `memory-bank` (например, `*-cfa1-fin2-deploy-DoD.md`), а не через изменение этого чеклиста.

### 3. DNS, TLS и Ingress (Cloudflare + nginx)
- [ ] Для UK1: актуальны записи `auth|issuer|investor|backoffice|api.cfa.llmneighbors.com` и wildcard‑сертификат `*.cfa.llmneighbors.com` (см. `20251113-cloudflare-ingress.md`).
- [x] Для `cfa1`: созданы A‑записи в Cloudflare `auth|issuer|investor|backoffice|api.cfa1.llmneighbors.com` с IP `cfa1`; выпущен и установлен LE‑сертификат `*.cfa1.llmneighbors.com`, nginx‑конфиг задокументирован.
- [ ] Для `cfa2` (fin2): аналогично `cfa1`, но с доменами `*.cfa2.llmneighbors.com` и IP `fin2`, при этом UK1 не затронут.
- [ ] Для каждого окружения описана таблица `Service → URL → Health endpoint → Notes` (в docs/или memory‑bank).

### 3a. Multi‑account Cloudflare / domains
- [ ] Для разных узлов (например, `cfa1` и `cfa2/fin2`) поддерживается конфигурация **разных** Cloudflare‑аккаунтов и доменов (см. `docs/deploy/MULTI_ACCOUNT_SETUP.md`), без жёсткой привязки ко всем `*.cfa{N}.llmneighbors.com` в одном аккаунте.

### 4. NX‑05 / NX‑06 Readiness
- [x] Зафиксировано, на каких стендах (`uk1`, `cfa1`, `cfa2/fin2`) будет выполняться разработка и проверка NX‑05/NX‑06 (issuer dashboard, reports, payout schedule).
- [x] Минимум один стенд (предпочтительно `cfa1`) имеет:
  - [x] Рабочий issuer‑портал с доступом через домен (`issuer.cfa1.llmneighbors.com`).
  - [x] Базовый issuance‑флоу и отчётность `/reports`, проверенные по runbook’у `08-smoke-tests.md` и e2e‑тестам Playwright.
  - [x] Задокументированное состояние (ссылки на realm/URL‑ы/тест‑учётки) для быстрого включения backend/FE инженеров и агентов (см. e2e `.env` и memory‑bank DoD для cfa1).

### CFA1 — текущий статус (2025‑11‑19)
- [x] Control Plane: `user` + `/srv/cfa` + `tmux p-cfa` + клон `ois-cfa` (work3).
- [x] Backend: Postgres, Kafka/ZK, Minio, Keycloak, все .NET‑сервисы и API Gateway запущены; все `/health` → `200`.
- [x] Ingress: DNS/TLS/nginx настроены для `auth|issuer|investor|backoffice|api.cfa1.llmneighbors.com`; `https://api.cfa1.../health` → `200`.
- [x] Frontends: Issuer/Investor/Backoffice подняты в dev‑режиме PM2; `curl -I https://issuer|investor|backoffice.cfa1...` → 30x → приложения.
- [x] E2E: Playwright‑тесты (`public-auth`, `backoffice-auth`, `self-registration`) проходят против cfa1‑домена; скриншоты флоу лежат в `artifacts/tests/e2e/playwright`.

---

## Agent Kickoff Prompt (Codex/Claude/Gemini)

Ниже — заготовка промпта для CLI‑агента, заточенная под этот runbook и `wt__ois-cfa__NX01`. Её можно адаптировать под конкретную задачу (например, «подними cfa1» или «подготовь fin2 для NX‑05/06»).

```text
You are a DevOps/Backend engineer working on the OIS-CFA project.

Workspace:
- You are running on host "eywa1".
- Local repo: ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets
- Main backend worktree: repositories/customer-gitlab/wt__ois-cfa__NX01 (branch tasks/NX-01-spec-validate-and-matrix / infra.defis.deploy)

Goal:
- Provision and deploy the OIS-CFA stack to a target VPS (e.g. cfa1 or fin2)
  using the "Eywa1 Control Plane" approach described in:
  - docs/deploy/docker-compose-at-vps/00-overview.md
  - docs/deploy/docker-compose-at-vps/10-eywa1-control-plane-runbook.md

Hard rules:
- DO NOT touch or modify the existing UK1 environment (prod demo).
- Use only the "user" account with sudo on target nodes (no root-only services).
- Use /srv/cfa as the project root on all nodes.
- Run all long-running commands inside tmux session "p-cfa" on the target node.
- For code changes and NX-05/06 work, treat wt__ois-cfa__NX01 as the primary tree.

Phases:
1) Phase 1 – validate Eywa1: SSH keys, Cloudflare token, local repo state.
2) Phase 2 – run ops/scripts/deploy/provision-node.sh <host> to bootstrap the node.
3) Phase 3 – run ops/scripts/deploy/deploy-node.sh <host> with the correct branch.
4) Phase 4 – run health checks (/health, Keycloak, portals) and record results in memory-bank.

Output expectations:
- Follow Why → What → How → Result structure.
- Use numbered steps and small tables where helpful.
- Explicitly call out any deviations from the runbook (SPEC DIFF-like).
```
</file>

<file path="docs/deploy/localhost/FRONTEND-STARTUP.md">
# Frontend - Запуск

## URLs

| Приложение | URL | Порт |
|------------|-----|------|
| Portal Issuer | http://localhost:3001 | 3001 |
| Portal Investor | http://localhost:3002 | 3002 |
| Backoffice | http://localhost:3003 | 3003 |

## Зависимости

```bash
# SDK (обязательно перед запуском порталов)
cd packages/sdks/ts && npm install && npm run build

# Порталы
cd apps/portal-issuer && npm install
cd apps/portal-investor && npm install
cd apps/backoffice && npm install
```

## Запуск

В отдельных терминалах:

```bash
# Terminal 1
cd apps/portal-issuer && npm run dev

# Terminal 2
cd apps/portal-investor && npm run dev

# Terminal 3
cd apps/backoffice && npm run dev
```

## Учетные данные

| User | Password | Роли |
|------|----------|------|
| testuser | testpass123 | issuer, investor, backoffice |

## Роли и доступ

| Портал | Требуемая роль |
|--------|----------------|
| Portal Issuer | `issuer` |
| Portal Investor | `investor` |
| Backoffice | `backoffice` или `admin` |

## E2E тесты

```bash
cd tests/e2e
npm install
npx playwright test
```

## Troubleshooting

**Module not found: @ois/api-client**
```bash
cd packages/sdks/ts && npm run build
```

**Редирект на логин после авторизации**
- Проверьте роли пользователя в Keycloak
- Выйдите из Keycloak и войдите заново
</file>

<file path="docs/deploy/localhost/KEYCLOAK-SETUP.md">
# Keycloak - Ручная настройка

> Для автоматической настройки используйте `./ops/scripts/local-dev/setup-keycloak.sh`

## Доступ к админке

- **URL:** http://localhost:58080/admin
- **Username:** `admin`
- **Password:** `admin123`

## Realm: `ois`

1. Dropdown вверху слева (показывает "Master") → **Create Realm**
2. Name: `ois`
3. **Create**

## Clients

### portal-issuer
1. **Clients** → **Create Client**
2. Client ID: `portal-issuer`
3. Client authentication: **ON**
4. Valid Redirect URIs: `http://localhost:3001/*`
5. Web Origins: `http://localhost:3001`
6. Credentials tab → Client secret: `secret`

### portal-investor
- Client ID: `portal-investor`
- Redirect URIs: `http://localhost:3002/*`
- Web Origins: `http://localhost:3002`
- Secret: `secret`

### portal-backoffice
- Client ID: `portal-backoffice`
- Redirect URIs: `http://localhost:3003/*`
- Web Origins: `http://localhost:3003`
- Secret: `secret`

## Roles

**Realm Roles** → **Create Role**:
- `issuer`
- `investor`
- `backoffice`

## Test User

1. **Users** → **Create User**
2. Username: `testuser`
3. Email: `testuser@example.com`
4. Email Verified: **ON**
5. **Create**
6. **Credentials** tab: Password `testpass123`, Temporary: **OFF**
7. **Role Mappings** tab: Assign roles `issuer`, `investor`, `backoffice`

## Troubleshooting

```bash
# Проверить логи
docker logs ois-keycloak --tail 50

# Health check
curl http://localhost:58080/health/ready
```
</file>

<file path="docs/deploy/localhost/README.md">
# Локальная разработка - Быстрый старт

## Требования

- Docker / OrbStack
- Node.js 20+
- npm 10+

## 1. Инфраструктура

```bash
# Запуск всех сервисов
docker-compose up -d

# Проверка статуса
docker ps
```

**Порты:**
| Сервис | Порт |
|--------|------|
| PostgreSQL | 55432 |
| Keycloak | 58080 |
| Kafka | 59092 |
| MinIO | 59000, 59001 |
| Redis | 56379 |

## 2. Keycloak

```bash
# Автоматическая настройка (realm, clients, roles, test user)
./ops/scripts/local-dev/setup-keycloak.sh
```

Детали конфигурации: [KEYCLOAK-SETUP.md](./KEYCLOAK-SETUP.md)

**Realm:** `ois`
**Clients:** `portal-issuer`, `portal-investor`, `portal-backoffice`

## 3. Сборка SDK

```bash
cd packages/sdks/ts
npm install && npm run build
```

## 4. Запуск порталов

```bash
# Portal Issuer
cd apps/portal-issuer && npm install && npm run dev

# Portal Investor
cd apps/portal-investor && npm install && npm run dev

# Backoffice
cd apps/backoffice && npm install && npm run dev
```

**URL:**
| Портал | URL | Роль |
|--------|-----|------|
| Portal Issuer | http://localhost:3001 | issuer |
| Portal Investor | http://localhost:3002 | investor |
| Backoffice | http://localhost:3003 | backoffice |

## 5. Вход

**Test User:** `testuser` / `testpass123`

Пользователь имеет все роли и может входить в любой портал.

## Остановка

```bash
docker-compose down
```

## См. также

- [KEYCLOAK-SETUP.md](./KEYCLOAK-SETUP.md) - ручная настройка Keycloak
- [FRONTEND-STARTUP.md](./FRONTEND-STARTUP.md) - запуск фронтенда
- [ops/scripts/local-dev/README.md](../../../ops/scripts/local-dev/README.md) - скрипты настройки
</file>

<file path="docs/deploy/20251113-cloudflare-ingress.md">
created: 2025-11-13 13:45
updated: 2025-11-13 17:05
type: operations-runbook
sphere: devops
topic: uk1 cloudflare ingress
author: Alex (co-76ca)
agentID: co-76ca
partAgentID: [co-76ca]
version: 0.2.0
tags: [cloudflare, nginx, keycloak, demo, smtp]
---

# Goal
Обеспечить публичный доступ к UK1-стенду (Keycloak + порталы + API) по доменам `*.cfa.llmneighbors.com`, используя Cloudflare (DNS + TLS), системный nginx и docker-compose override для Keycloak.

# Scope
- Сервера UK1 (`185.168.192.214`, Ubuntu, `/opt/ois-cfa`).
- Cloudflare аккаунт `llmneighbors.com` (CLI/Token уже лежит в `/home/user/__Repositories/cloudflare__developerisnow/.env`).
- Keycloak + порталы (pm2) + API gateway, без модификации .NET compose.

- # Checklist
- [x] Cloudflare DNS: A-записи `auth|issuer|investor|backoffice|api.cfa.llmneighbors.com → 185.168.192.214` (DNS only).
- [x] Cloudflare SSL Mode = `Full`.
- [x] Wildcard LE-сертификат `*.cfa.llmneighbors.com` выпущен в `/etc/letsencrypt/live/cfa.llmneighbors.com/`.
- [x] `/etc/nginx/sites-available/cfa-portals.conf` развернут и nginx перезапущен.
- [x] Docker override `ops/infra/uk1/docker-compose.keycloak-proxy.yml` активирован (`KEYCLOAK_PUBLIC_URL=https://auth.cfa.llmneighbors.com`).
- [x] `.env.local` порталов обновлены, pm2 перезапущен.
- [x] Keycloak clients/realm откорректированы (redirects, webOrigins, self-registration ON, verifyEmail ON).
- [x] Playwright e2e (issuer/investor + self-registration + backoffice admin) проходит, отчёты в `tests/e2e-playwright/test-results/`.
- [x] VPN `x-ui` выключен (порт 443 свободен).
- [x] SMTP стек (Postfix + OpenDKIM) + SPF/DKIM/DMARC настроены; Keycloak использует локальный relay.
- [x] Postfix слушает только `127.0.0.1` и `172.18.0.1` (docker bridge); внешний 25 порт закрыт.

# Why → What → How → Result

## Why
- Демки должны открываться из браузера без SSH-туннелей.
- Клиенты хотят использовать собственный домен (`*.cfa.llmneighbors.com`).
- Надо иметь повторяемый чеклист для второго DevOps (Саша О.).

## What
- Cloudflare управляет DNS и выпускает wildcard сертификат (через DNS challenge).
- Nginx на UK1 выполняет offload TLS + проксирует на локальные порты (Keycloak 8081, pm2 порталы 300x, API 5000).
- docker-compose override поднимает Keycloak с правильным `KC_HOSTNAME_URL`.
- `.env.local` порталов и Keycloak clients должны ссылаться на публичные URL.

## How
1. **DNS + SSL (Cloudflare CLI):**
   ```bash
   cd /home/user/__Repositories/cloudflare__developerisnow
   source .env  # экспортирует CLOUDFLARE_API_TOKEN
   CF_API_TOKEN="$CLOUDFLARE_API_TOKEN" flarectl dns create-or-update --zone llmneighbors.com --name auth.cfa --type A --content 185.168.192.214 --ttl 1
   # повторить для issuer / investor / backoffice / api (DNS only)
   # SSL mode
   curl -sX PATCH "https://api.cloudflare.com/client/v4/zones/2f4591aa91796b09311095cfee03d817/settings/ssl" \
     -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" -H "Content-Type: application/json" \
     --data '{"value":"full"}'
   ```
2. **Wildcard сертификат:**
   ```bash
   ssh -p 51821 root@185.168.192.214
   mkdir -p /root/.secrets && chmod 700 /root/.secrets
   cat > /root/.secrets/cloudflare.ini <<'EOF'
   dns_cloudflare_api_token = ${CLOUDFLARE_API_TOKEN}
   EOF
   chmod 600 /root/.secrets/cloudflare.ini
   certbot certonly --dns-cloudflare --dns-cloudflare-credentials /root/.secrets/cloudflare.ini \
     --dns-cloudflare-propagation-seconds 45 \
     -d "*.cfa.llmneighbors.com" -d "cfa.llmneighbors.com" \
     --agree-tos --email <ops@developerisnow.com> --non-interactive
   ```
3. **nginx:**
   ```bash
   apt-get install -y nginx
   systemctl stop x-ui && systemctl disable x-ui   # освободить 443 (пересадим позже)
   cd /opt/ois-cfa
   env CFA_BASE_DOMAIN=cfa.llmneighbors.com \
       AUTH_HOST=auth.cfa.llmneighbors.com \
       ISSUER_HOST=issuer.cfa.llmneighbors.com \
       INVESTOR_HOST=investor.cfa.llmneighbors.com \
       BACKOFFICE_HOST=backoffice.cfa.llmneighbors.com \
       API_HOST=api.cfa.llmneighbors.com \
       envsubst < ops/infra/uk1/nginx-cfa-portals.conf > /etc/nginx/sites-available/cfa-portals.conf
   ln -sf /etc/nginx/sites-available/cfa-portals.conf /etc/nginx/sites-enabled/cfa-portals.conf
   rm -f /etc/nginx/sites-enabled/default
   nginx -t && systemctl reload nginx
   ```
4. **docker-compose override:**
   ```bash
   cd /opt/ois-cfa
   KEYCLOAK_PUBLIC_URL=https://auth.cfa.llmneighbors.com \
   docker compose -f docker-compose.yml -f docker-compose.override.yml \
     -f ops/infra/uk1/docker-compose.keycloak-proxy.yml up -d keycloak keycloak-proxy
   ```
5. **Клиенты + пользователи:**
   ```bash
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh config credentials --server http://localhost:8080 --realm master --user admin --password admin123
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh update clients/<id> -r ois-dev -s "redirectUris=[\"https://issuer.cfa.llmneighbors.com/*\"]" -s "webOrigins=[\"https://issuer.cfa.llmneighbors.com\"]"
   # повторить для investor/backoffice
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh update realms/ois-dev/authentication/required-actions/VERIFY_PROFILE -s enabled=false -s defaultAction=false
   ```
6. **Порталы:**
   ```bash
   cat > /opt/ois-cfa/apps/portal-issuer/.env.local <<'EOF'
   NEXT_PUBLIC_API_BASE_URL=https://api.cfa.llmneighbors.com
   NEXT_PUBLIC_KEYCLOAK_URL=https://auth.cfa.llmneighbors.com
   NEXT_PUBLIC_KEYCLOAK_REALM=ois-dev
   NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=portal-issuer
   NEXTAUTH_URL=https://issuer.cfa.llmneighbors.com
   NEXTAUTH_SECRET=...
   KEYCLOAK_CLIENT_SECRET=...
   EOF
   # аналогично для investor/backoffice
   source /root/.nvm/nvm.sh && pm2 restart portal-issuer portal-investor portal-backoffice --update-env
   ```
7. **Проверка:**
   ```bash
   curl -I https://auth.cfa.llmneighbors.com
   curl https://api.cfa.llmneighbors.com/health
   cd tests/e2e-playwright && npm test
   ```

## Result
- Пользовательские порталы и Keycloak доступны по HTTPS без SSH-туннелей.
- Playwright обеспечивает «доказательство» логина (issuer/investor + self-registration).
- SMTP цепочка (Postfix + OpenDKIM) выдаёт проверочные письма; Keycloak self-registration завершает flow без ручных действий.
- Вся конфигурация задокументирована и может быть переиспользована для других VPS.

## Email / SMTP / DKIM
1. **Postfix + OpenDKIM**
   ```bash
   apt-get install -y postfix mailutils opendkim opendkim-tools
   postconf -e 'inet_interfaces = all'
   postconf -e 'mynetworks = 127.0.0.0/8 172.17.0.0/16 172.18.0.0/16'
   postconf -e 'smtpd_recipient_restrictions = permit_mynetworks, reject_unauth_destination'
   postconf -e 'smtpd_relay_restrictions = permit_mynetworks, reject_unauth_destination'
   systemctl enable --now opendkim postfix
   ```

   `/etc/opendkim.conf` (основное):
   ```conf
   UserID                  opendkim:opendkim
   Socket                  inet:8891@127.0.0.1
   KeyTable                refile:/etc/opendkim/KeyTable
   SigningTable            refile:/etc/opendkim/SigningTable
   InternalHosts           /etc/opendkim/TrustedHosts
   ```
   Ключ `mail._domainkey.cfa.llmneighbors.com` → TXT (см. Cloudflare ниже).

2. **Cloudflare DNS для почты**
   ```bash
   # A-запись
   curl -sX POST ... --data '{"type":"A","name":"mail.cfa.llmneighbors.com","content":"185.168.192.214","proxied":false}'
   # MX
   curl -sX POST ... --data '{"type":"MX","name":"cfa.llmneighbors.com","content":"mail.cfa.llmneighbors.com","priority":10}'
   # SPF
   curl -sX POST ... --data '{"type":"TXT","name":"cfa.llmneighbors.com","content":"v=spf1 ip4:185.168.192.214 ~all"}'
   # DKIM
   curl -sX POST ... --data '{"type":"TXT","name":"mail._domainkey.cfa.llmneighbors.com","content":"v=DKIM1; ..."}'
   # DMARC
   curl -sX POST ... --data '{"type":"TXT","name":"_dmarc.cfa.llmneighbors.com","content":"v=DMARC1; p=none; rua=mailto:ops@llmneighbors.com; fo=1"}'
   ```

3. **Keycloak realm SMTP**
   ```bash
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh config credentials --server http://localhost:8080 --realm master --user admin --password admin123
   docker exec ois-keycloak /opt/keycloak/bin/kcadm.sh update realms/ois-dev \
     -s verifyEmail=true -s registrationAllowed=true \
     -s "smtpServer.host=172.18.0.1" \
     -s "smtpServer.port=25" \
     -s "smtpServer.from=no-reply@cfa.llmneighbors.com" \
     -s "smtpServer.replyTo=ops@llmneighbors.com" \
     -s "smtpServer.envelopeFrom=no-reply@cfa.llmneighbors.com" \
     -s "smtpServer.starttls=false" -s "smtpServer.ssl=false" -s "smtpServer.auth=false"
   ```

4. **Smoke**
   ```bash
   echo "SMTP ok" | mail -s "Test" cfa+demo@2200freefonts.com
   tail -f /var/log/mail.log  # подтверждаем delivery
   TOKEN=$(curl -s -X POST https://api.mail.tm/token ...)
   curl -H "Authorization: Bearer $TOKEN" https://api.mail.tm/messages
   ```
   Playwright self-registration (`tests/e2e-playwright/tests/self-registration.spec.ts`) и backoffice spec (`tests/e2e-playwright/tests/backoffice-auth.spec.ts`) используют те же домены/SMTP.

# Notes
- `x-ui` (VPN) был отключён из-за конфликтов порта 443. При переносе на другой порт добавьте `sudo sed -i 's/:443/:<new_port>/' /etc/systemd/system/x-ui.service` и перезапустите nginx.
- IaC артефакты: `ops/infra/uk1/nginx-cfa-portals.conf` и `ops/infra/uk1/docker-compose.keycloak-proxy.yml`.
- Инструменты: `flarectl`, `wrangler`, `certbot-dns-cloudflare`, `pm2`, `playwright`, `mail.tm`.
</file>

<file path="docs/deploy/MULTI_ACCOUNT_SETUP.md">
---
created: 2025-11-19 21:05
updated: 2025-11-19 21:05
type: runbook
sphere: [devops]
topic: [cloudflare, multi-account, domains]
author: alex-a
agentID: co-76ca
partAgentID: [co-76ca, co-7b1b]
version: 0.1.0
tags: [cloudflare, dns, tls, zones, eywa1]
---

# Multi‑Account Cloudflare / Domains Setup (eywa1 Control Plane)

Цель: позволить `eywa1` управлять несколькими Cloudflare‑аккаунтами и доменами (например, `*.cfa.llmneighbors.com` для UK1/cfa1 и отдельный домен/аккаунт для fin2/cfa2 или `*.cfa{n}.telex.global`) без жёсткого хардкода токенов и zone id.

## 1. Где сейчас зашиты домены и токены

- `docs/deploy/20251113-cloudflare-ingress.md`
  - Жёстко использует зону `llmneighbors.com` и конкретный `zone_id` + `CLOUDFLARE_API_TOKEN` из `/home/user/__Repositories/cloudflare__developerisnow/.env`.
- `docs/deploy/docker-compose-at-vps/10-eywa1-control-plane-runbook.md`
  - Описывает DNS/TLS для `*.cfa.llmneighbors.com` и `*.cfa{1,2,3}.llmneighbors.com` как основной сценарий.
- Скрипты `ops/scripts/deploy/provision-node.sh` и `ops/scripts/deploy/deploy-node.sh`
  - **Не** содержат Cloudflare‑логики и доменов; работают только с SSH, Docker, tmux и git.
- Практические команды на `eywa1`
  - В текущих сессиях использовались одноразовые `curl`/`certbot` команды, где токен/zone id подтягивались из `.env` в репо `cloudflare__developerisnow`.

Вывод: на данный момент Cloudflare‑детали находятся только в документации и ad‑hoc командах, что позволяет относительно безболезненно параметризовать их. Для новых зон (например, `telex.global`) используем отдельные `.env.*` с нужными `ACCOUNT_ID/ZONE_ID/TOKEN`.

## 2. Принцип: конфигурируемость per‑node

Для поддержки разных аккаунтов/доменов для разных нод (например, `cfa1.llmneighbors.com` в одном CF‑аккаунте и `cfa2.otherdomain.com` в другом) вводим явный конфиг на `eywa1`:

- Отдельный `.env`/config per домен/аккаунт:
  - Пример: `/home/user/__Repositories/cloudflare__developerisnow/.env.cfa1`
  - Пример: `/home/user/__Repositories/cloudflare__developerisnow/.env.cfa2`
- В них явным образом задаются:
  - `CF_ZONE_NAME`
  - `CF_ZONE_ID`
  - `CF_API_TOKEN`
  - (опционально) набор префиксов/хостов (`CF_HOST_PREFIXES=auth,issuer,investor,backoffice,api`).

Эти файлы **не** коммитятся в репозиторий и живут только на `eywa1` (как и сейчас `.env` для llmneighbors).

## 3. Пример: два разных домена/аккаунта (llmneighbors + telex.global)

```bash
# /home/user/__Repositories/cloudflare__developerisnow/.env.cfa1
CF_ZONE_NAME=llmneighbors.com
CF_ZONE_ID=<zone-id-cfa1>
CF_API_TOKEN=<token-for-llmneighbors-account>
CF_HOST_PREFIXES=auth,issuer,investor,backoffice,api
CF_BASE_LABEL=cfa1

# /home/user/__Repositories/cloudflare__developerisnow/.env.cfa2.telex
CF_ZONE_NAME=telex.global
CF_ZONE_ID=<zone-id-telex>
CF_API_TOKEN=<token-for-telex-account>
CF_ACCOUNT_ID=<account-id-telex>
CF_HOST_PREFIXES=auth,issuer,investor,backoffice,api
CF_BASE_LABEL=cfa2
```

Тогда сценарий на `eywa1` для cfa1:

```bash
cd /home/user/__Repositories/cloudflare__developerisnow
set -a && source .env.cfa1 && set +a

for host in ${CF_HOST_PREFIXES//,/ }; do
  NAME=\"${host}.${CF_BASE_LABEL}\"
  # auth.cfa1.llmneighbors.com, issuer.cfa1.llmneighbors.com, ...
  # используем CF_ZONE_NAME/CF_ZONE_ID/CF_API_TOKEN для upsert
done
```

А для fin2/cfa2:

```bash
set -a && source .env.cfa2.telex && set +a

for host in ${CF_HOST_PREFIXES//,/ }; do
  NAME=\"${host}.${CF_BASE_LABEL}\"
  # auth.cfa2.telex.global, issuer.cfa2.telex.global, ...
done
```

## 4. Интеграция с runbook’ами и скриптами

- Runbook `20251113-cloudflare-ingress.md`
  - Оставляем как UK1‑специализированный (llmneighbors), но добавляем ссылку на этот документ как на общий план для других зон.
- Runbook `10-eywa1-control-plane-runbook.md`
  - Подразумевает, что DNS/TLS можно поднять не только для `*.cfa{N}.llmneighbors.com`, но и для других доменов, если заданы соответствующие `.env.*` файлы.
- Скрипты `provision-node.sh`/`deploy-node.sh`
  - Осознанно **не** привязываем к Cloudflare, чтобы не шить в них секреты и zone id.
  - DNS/TLS остаются шагами уровня runbook/оператора, а не «автоматической магией» в скриптах.

### 4.1 Cloudflare helper script

Для унификации работы с Cloudflare добавлен вспомогательный скрипт:

- `ops/scripts/cloudflare-dns-upsert.sh`
  - Аргументы:
    - `$1` — путь к env‑файлу (`.env.cfa1`, `.env.cfa2`, …).
    - `$2` — IP‑адрес целевого узла.
  - Использует переменные из env‑файла:
    - `CF_ZONE_NAME`, `CF_ZONE_ID`, `CF_API_TOKEN`
    - `CF_HOST_PREFIXES` (например, `auth,issuer,investor,backoffice,api`)
    - `CF_BASE_LABEL` (например, `cfa1` / `demo`).
  - Для каждого префикса upsert‑ит A‑запись вида `<prefix>.<CF_BASE_LABEL>.<CF_ZONE_NAME>`.

Примеры:

```bash
# cfa1 (llmneighbors)
./ops/scripts/cloudflare-dns-upsert.sh \
  /home/user/__Repositories/cloudflare__developerisnow/.env.cfa1 \
  87.249.49.56

# fin2 / cfa2 (telex.global)
./ops/scripts/cloudflare-dns-upsert.sh \
  /home/user/__Repositories/cloudflare__developerisnow/.env.cfa2.telex \
  65.109.171.138
```

## 5. DoD для multi‑account Cloudflare

- Для каждого окружения (`cfa1`, `cfa2/fin2`, будущие us1/germ1):
  - Есть отдельный `.env.<env>` с `CF_ZONE_NAME`, `CF_ZONE_ID`, `CF_API_TOKEN`.
  - Документация (этот файл и `10-eywa1-control-plane-runbook.md`) описывает, как выбирать нужный `.env.<env>` перед запуском DNS/TLS шагов.
  - Нет жёстко зашитых zone id/token’ов в коде скриптов; все секреты подтягиваются из локальных `.env` на `eywa1`.
</file>

<file path="ops/scripts/auth/fix-redirects.sh">
#!/bin/bash
set -euo pipefail

# OIS-CFA · Keycloak redirects/webOrigins fixer for cfa1
# Runs inside the ois-keycloak container via kcadm.sh
#
# Usage:
#   BASE_DOMAIN=cfa1.llmneighbors.com ./ops/scripts/auth/fix-redirects.sh
#
# Env (optional):
#   KC_CONTAINER   - keycloak container name (default: ois-keycloak)
#   KC_URL         - Keycloak admin URL (default: http://localhost:8080)
#   KC_USER        - admin user (default: admin)
#   KC_PASS        - admin password (default: admin123)
#   REALM          - target realm (default: ois-dev)
#   BASE_DOMAIN    - base domain (default: cfa1.llmneighbors.com)

KC_CONTAINER="${KC_CONTAINER:-ois-keycloak}"
KC_URL="${KC_URL:-http://localhost:8080}"
KC_USER="${KC_USER:-admin}"
KC_PASS="${KC_PASS:-admin123}"
REALM="${REALM:-ois-dev}"
BASE_DOMAIN="${BASE_DOMAIN:-cfa1.llmneighbors.com}"

echo ">>> Fix Keycloak redirects for realm='${REALM}' domain='${BASE_DOMAIN}' in container='${KC_CONTAINER}'"

docker exec \
  -e KC_URL="$KC_URL" \
  -e KC_USER="$KC_USER" \
  -e KC_PASS="$KC_PASS" \
  -e REALM="$REALM" \
  -e BASE_DOMAIN="$BASE_DOMAIN" \
  "${KC_CONTAINER}" bash -lc '
set -euo pipefail

KC_URL="${KC_URL:-http://localhost:8080}"
KC_USER="${KC_USER:-admin}"
KC_PASS="${KC_PASS:-admin123}"
REALM="${REALM:-ois-dev}"
BASE_DOMAIN="${BASE_DOMAIN:-cfa1.llmneighbors.com}"
KCADM=/opt/keycloak/bin/kcadm.sh

clients=(
  "portal-issuer:issuer"
  "portal-investor:investor"
  "backoffice:backoffice"
)

echo ">> Authenticating to ${KC_URL} (realm master) ..."
"${KCADM}" config credentials --server "${KC_URL}" --realm master --user "${KC_USER}" --password "${KC_PASS}"

update_client() {
  local client_id="$1"
  local host_prefix="$2"
  local host="${host_prefix}.${BASE_DOMAIN}"
  local root_url="https://${host}"
  local redirects="[\"${root_url}/*\"]"
  local origins="[\"${root_url}\"]"

  local rid
  rid=$("${KCADM}" get clients -r "${REALM}" -q clientId="${client_id}" | sed -n '\''s/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p'\'' | head -1 || true)
  if [ -z "${rid:-}" ]; then
    echo "WARN: client_id=${client_id} not found in realm ${REALM}, skipping"
    return
  fi

  echo ">> Updating ${client_id} for host ${host}"
  "${KCADM}" update "clients/${rid}" -r "${REALM}" \
    -s "rootUrl=${root_url}" \
    -s "redirectUris=${redirects}" \
    -s "webOrigins=${origins}"
}

for entry in "${clients[@]}"; do
  IFS=":" read -r cid prefix <<< "${entry}"
  update_client "${cid}" "${prefix}"
done

echo ">> Done."
'

echo ">>> Keycloak client redirect/webOrigins update completed."
</file>

<file path="ops/scripts/deploy/deploy-node.sh">
#!/bin/bash
set -euo pipefail

# OIS-CFA · Deploy Node Script
# Usage:
#   ./ops/scripts/deploy/deploy-node.sh <host>
#
# Responsibilities:
#   - Ensure tmux session "p-cfa" exists on target host
#   - Clone or update ois-cfa repo under /srv/cfa (or REMOTE_PROJECT_ROOT)
#   - Checkout desired branch (infra.defis.deploy by default)
#   - Run docker compose to start backend stack
#   - Prepare basic commands for frontends (Next.js + PM2) inside tmux
#   - Hint: after clone, ensure the project tree is writable by SSH_USER (e.g. chown -R user:user /srv/cfa/ois-cfa)
#   - Optional: set DEPLOY_FIX_PERMS=1 to force chown even if already cloned (avoids npm/pm2 EACCES)

usage() {
  echo "Usage: $0 <host>" >&2
  echo "Environment (optional):" >&2
  echo "  SSH_USER             - SSH user for connection (default: user)" >&2
  echo "  REMOTE_PROJECT_ROOT  - Project root on target (default: /srv/cfa)" >&2
  echo "  OIS_CFA_GIT_URL      - Git URL for ois-cfa (default: git@git.telex.global:npk/ois-cfa.git)" >&2
  echo "  OIS_CFA_BRANCH       - Branch to checkout (default: infra.defis.deploy)" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

TARGET_HOST="${1:-}"
if [ -z "$TARGET_HOST" ]; then
  usage
fi

SSH_USER="${SSH_USER:-user}"
REMOTE_PROJECT_ROOT="${REMOTE_PROJECT_ROOT:-/srv/cfa}"
OIS_CFA_GIT_URL="${OIS_CFA_GIT_URL:-git@git.telex.global:npk/ois-cfa.git}"
OIS_CFA_BRANCH="${OIS_CFA_BRANCH:-infra.defis.deploy}"
SSH_OPTS="-o StrictHostKeyChecking=accept-new"
FIX_PERMS="${DEPLOY_FIX_PERMS:-0}"

echo ">>> Deploying OIS-CFA to host '${TARGET_HOST}' as ${SSH_USER}"
echo "    REMOTE_PROJECT_ROOT=${REMOTE_PROJECT_ROOT}"
echo "    OIS_CFA_GIT_URL=${OIS_CFA_GIT_URL}"
echo "    OIS_CFA_BRANCH=${OIS_CFA_BRANCH}"

SSH_CMD="ssh -A ${SSH_OPTS} ${SSH_USER}@${TARGET_HOST}"

$SSH_CMD bash -s << EOF
set -euo pipefail

echo ">>> [\$(hostname)] Phase 3 · Deploy OIS-CFA Stack"

if ! command -v tmux >/dev/null 2>&1; then
  echo "ERROR: tmux is not installed. Run provision-node.sh first." >&2
  exit 1
fi

mkdir -p "${REMOTE_PROJECT_ROOT}"
cd "${REMOTE_PROJECT_ROOT}"

if ! tmux has-session -t p-cfa 2>/dev/null; then
  echo ">>> Creating tmux session 'p-cfa'"
  tmux new-session -d -s p-cfa -c "${REMOTE_PROJECT_ROOT}"
else
  echo ">>> Reusing existing tmux session 'p-cfa'"
fi

tmux send-keys -t p-cfa "set -euo pipefail" C-m
tmux send-keys -t p-cfa "cd '${REMOTE_PROJECT_ROOT}'" C-m

if [ ! -d "${REMOTE_PROJECT_ROOT}/ois-cfa/.git" ]; then
  echo ">>> Cloning ois-cfa repo"
  tmux send-keys -t p-cfa "git clone '${OIS_CFA_GIT_URL}' ois-cfa" C-m
  tmux send-keys -t p-cfa "cd ois-cfa" C-m
else
  echo ">>> Updating existing ois-cfa repo"
  tmux send-keys -t p-cfa "cd ois-cfa" C-m
fi

tmux send-keys -t p-cfa "git fetch origin" C-m
tmux send-keys -t p-cfa "git checkout '${OIS_CFA_BRANCH}'" C-m
tmux send-keys -t p-cfa "git pull --ff-only origin '${OIS_CFA_BRANCH}'" C-m

if [ "$FIX_PERMS" = "1" ]; then
  tmux send-keys -t p-cfa "echo '>>> Fixing permissions for ${SSH_USER} on ${REMOTE_PROJECT_ROOT}/ois-cfa (DEPLOY_FIX_PERMS=1)'" C-m
  tmux send-keys -t p-cfa "sudo chown -R ${SSH_USER}:${SSH_USER} '${REMOTE_PROJECT_ROOT}/ois-cfa' || echo 'WARNING: chown failed, check permissions or sudo rights'" C-m
else
  tmux send-keys -t p-cfa "echo '>>> NOTE: permissions not changed (set DEPLOY_FIX_PERMS=1 to force chown if npm/pm2 EACCES)'" C-m
fi

tmux send-keys -t p-cfa "echo '>>> NOTE: ensure .env files are prepared as per docs/deploy/docker-compose-at-vps/02-env-and-compose.md'" C-m

tmux send-keys -t p-cfa "docker compose -f docker-compose.yml -f docker-compose.override.yml up -d" C-m

tmux send-keys -t p-cfa "echo '>>> Backend stack started. Next steps: configure Keycloak, nginx, and PM2 frontends as per docs/deploy/docker-compose-at-vps/* and 20251113-cloudflare-ingress.md'" C-m

echo ">>> Commands sent to tmux session 'p-cfa'. Attach with: tmux attach -t p-cfa"
EOF

echo ">>> Deploy commands dispatched to host '${TARGET_HOST}'"
</file>

<file path="ops/scripts/deploy/provision-node.sh">
#!/bin/bash
set -euo pipefail

# OIS-CFA · Provision Node Script
# Usage:
#   ./ops/scripts/deploy/provision-node.sh <host>
#
# Responsibilities (idempotent as much as possible):
#   - Ensure sudo user "user" exists on target host
#   - Install base packages (curl, git, tmux, jq, docker, docker-compose plugin, nginx, postfix)
#   - Install Node.js 20 for "user" (via nvm or system package)
#   - Create /srv/cfa and set ownership to user:user
#   - Configure tmux history-limit (1_000_000) for user
#   - Create tmux session "p-cfa" with working dir /srv/cfa

usage() {
  echo "Usage: $0 <host>" >&2
  echo "Environment (optional):" >&2
  echo "  SSH_USER         - SSH user for initial connection (default: root)" >&2
  echo "  REMOTE_USER      - App user to create/use (default: user)" >&2
  echo "  REMOTE_PROJECT_ROOT - Project root on target (default: /srv/cfa)" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

TARGET_HOST="${1:-}"
if [ -z "$TARGET_HOST" ]; then
  usage
fi

SSH_USER="${SSH_USER:-root}"
REMOTE_USER="${REMOTE_USER:-user}"
REMOTE_PROJECT_ROOT="${REMOTE_PROJECT_ROOT:-/srv/cfa}"

SSH_OPTS="-o StrictHostKeyChecking=accept-new"

echo ">>> Provisioning host '${TARGET_HOST}' via ${SSH_USER}"

ssh $SSH_OPTS "${SSH_USER}@${TARGET_HOST}" \
  REMOTE_USER="$REMOTE_USER" REMOTE_PROJECT_ROOT="$REMOTE_PROJECT_ROOT" bash -s << 'EOF'
set -euo pipefail

echo ">>> [$(hostname)] Phase 2 · Provision Node"
echo "    REMOTE_USER=${REMOTE_USER}"
echo "    REMOTE_PROJECT_ROOT=${REMOTE_PROJECT_ROOT}"

if ! id "${REMOTE_USER}" >/dev/null 2>&1; then
  echo ">>> Creating user '${REMOTE_USER}' with sudo"
  useradd -m -s /bin/bash "${REMOTE_USER}"
  usermod -aG sudo "${REMOTE_USER}"
else
  echo ">>> User '${REMOTE_USER}' already exists, skipping creation"
fi

echo ">>> Propagating SSH authorized_keys to '${REMOTE_USER}' (if available)"
SRC_AUTH_KEYS=""
if [ -f /root/.ssh/authorized_keys ]; then
  SRC_AUTH_KEYS="/root/.ssh/authorized_keys"
fi

if [ -n "$SRC_AUTH_KEYS" ]; then
  install -d -m 700 "/home/${REMOTE_USER}/.ssh"
  cp "$SRC_AUTH_KEYS" "/home/${REMOTE_USER}/.ssh/authorized_keys"
  chown -R "${REMOTE_USER}:${REMOTE_USER}" "/home/${REMOTE_USER}/.ssh"
  chmod 700 "/home/${REMOTE_USER}/.ssh"
  chmod 600 "/home/${REMOTE_USER}/.ssh/authorized_keys"
else
  echo ">>> WARNING: no source authorized_keys found, SSH key-based login for '${REMOTE_USER}' must be configured manually" >&2
fi

echo ">>> Installing base packages (curl, git, tmux, jq, ufw, docker, nginx, postfix)"
export DEBIAN_FRONTEND=noninteractive
apt-get update -y
apt-get install -y \
  ca-certificates curl git tmux jq ufw \
  nginx postfix

if ! command -v docker >/dev/null 2>&1; then
  echo ">>> Installing Docker Engine + compose plugin"
  install -m 0755 -d /etc/apt/keyrings
  if [ ! -f /etc/apt/keyrings/docker.gpg ]; then
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg
  fi
  . /etc/os-release
  echo "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  "$VERSION_CODENAME" stable" >/etc/apt/sources.list.d/docker.list
  apt-get update -y
  apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
  systemctl enable --now docker
else
  echo ">>> Docker already installed, skipping"
fi

echo ">>> Ensuring '${REMOTE_USER}' is in 'docker' group"
if getent group docker >/dev/null 2>&1; then
  usermod -aG docker "${REMOTE_USER}" || echo ">>> WARNING: failed to add ${REMOTE_USER} to docker group" >&2
else
  echo ">>> WARNING: docker group not found; Docker permissions for ${REMOTE_USER} may need manual adjustment" >&2
fi

echo ">>> Ensuring ${REMOTE_PROJECT_ROOT} exists"
mkdir -p "${REMOTE_PROJECT_ROOT}"
chown -R "${REMOTE_USER}:${REMOTE_USER}" "${REMOTE_PROJECT_ROOT}"

echo ">>> Installing Node.js 20 for ${REMOTE_USER} (via nvm if not present)"
su - "${REMOTE_USER}" -c 'bash -s' << 'EONVM'
set -euo pipefail
if [ ! -d "$HOME/.nvm" ]; then
  echo ">>> Installing nvm for ${USER}"
  curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
fi

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"

if ! nvm ls 20 >/dev/null 2>&1; then
  echo ">>> Installing Node.js 20 via nvm"
  nvm install 20
fi
nvm alias default 20
EONVM

TMUX_CONF="/home/${REMOTE_USER}/.tmux.conf"
if [ -f "\$TMUX_CONF" ]; then
  if ! grep -q 'history-limit' "\$TMUX_CONF"; then
    echo "set-option -g history-limit 1000000" >> "\$TMUX_CONF"
  fi
else
  echo "set-option -g history-limit 1000000" > "\$TMUX_CONF"
fi
chown "${REMOTE_USER}:${REMOTE_USER}" "\$TMUX_CONF"

echo ">>> Creating tmux session 'p-cfa' (if not exists)"
su - "${REMOTE_USER}" -c "tmux has-session -t p-cfa 2>/dev/null || tmux new-session -d -s p-cfa -c '${REMOTE_PROJECT_ROOT}'"

echo ">>> Provisioning done on \$(hostname)"
EOF

echo ">>> Host '${TARGET_HOST}' provisioned successfully"
</file>

<file path="ops/scripts/local-dev/backup.sh">
#!/bin/bash
# backup.sh - Backup PostgreSQL databases
set -e

BACKUP_DIR="${1:-/backups}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

echo "Starting backup at $TIMESTAMP..."

# Backup ois database
pg_dump -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB" | gzip > "$BACKUP_DIR/ois_$TIMESTAMP.sql.gz"

# Backup keycloak database
pg_dump -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d keycloak | gzip > "$BACKUP_DIR/keycloak_$TIMESTAMP.sql.gz"

# Keep only last 7 backups
find "$BACKUP_DIR" -name "*.sql.gz" -mtime +7 -delete

echo "Backup complete: $BACKUP_DIR/ois_$TIMESTAMP.sql.gz"
echo "Backup complete: $BACKUP_DIR/keycloak_$TIMESTAMP.sql.gz"
</file>

<file path="ops/scripts/local-dev/init-db.sh">
#!/bin/bash
# init-db.sh - Create additional databases for OIS CFA
set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    -- Create keycloak database if not exists
    SELECT 'CREATE DATABASE keycloak'
    WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'keycloak')\gexec

    -- Grant privileges
    GRANT ALL PRIVILEGES ON DATABASE keycloak TO $POSTGRES_USER;

    -- Create schemas for services (optional, services can use default schema)
    -- \c ois
    -- CREATE SCHEMA IF NOT EXISTS issuance;
    -- CREATE SCHEMA IF NOT EXISTS registry;
    -- CREATE SCHEMA IF NOT EXISTS settlement;
    -- CREATE SCHEMA IF NOT EXISTS compliance;
EOSQL

echo "Database initialization complete: ois, keycloak"
</file>

<file path="ops/scripts/local-dev/README.md">
# Local Development Scripts

Scripts for setting up and managing local development environment.

## Scripts

### setup-keycloak.sh

Sets up Keycloak for local development:
- Creates `ois` realm
- Creates clients: `portal-issuer`, `portal-investor`, `portal-backoffice`
- Creates roles: `issuer`, `investor`, `backoffice`
- Creates test user: `testuser` / `testpass123` (with all roles)

```bash
./ops/scripts/local-dev/setup-keycloak.sh
```

### init-db.sh

PostgreSQL initialization script that creates the `keycloak` database. This script is mounted into the PostgreSQL container and runs on first startup.

### backup.sh

Creates a backup of the PostgreSQL database.

```bash
./ops/scripts/local-dev/backup.sh
```

## Usage

After starting Docker services:

```bash
# Start infrastructure
docker-compose up -d

# Wait for Keycloak to be healthy, then setup
./ops/scripts/local-dev/setup-keycloak.sh
```

## Test Credentials

| Service | Username | Password |
|---------|----------|----------|
| Keycloak Admin | admin | admin123 |
| Test User | testuser | testpass123 |
</file>

<file path="ops/scripts/local-dev/setup-keycloak.sh">
#!/bin/bash
# setup-keycloak.sh - Setup Keycloak realm, clients, and test user for OIS CFA
set -e

KEYCLOAK_URL="${KEYCLOAK_URL:-http://localhost:58080}"
ADMIN_USER="${KEYCLOAK_ADMIN:-admin}"
ADMIN_PASS="${KEYCLOAK_ADMIN_PASSWORD:-admin123}"

echo "Getting admin token from Keycloak..."
TOKEN=$(curl -s -X POST "${KEYCLOAK_URL}/realms/master/protocol/openid-connect/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=${ADMIN_USER}&password=${ADMIN_PASS}&grant_type=password&client_id=admin-cli" | jq -r '.access_token')

if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
  echo "Failed to get admin token"
  exit 1
fi

echo "Creating realm 'ois'..."
curl -s -X POST "${KEYCLOAK_URL}/admin/realms" \
  -H "Authorization: Bearer ${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "realm": "ois",
    "enabled": true,
    "registrationAllowed": true,
    "loginWithEmailAllowed": true,
    "duplicateEmailsAllowed": false,
    "accessTokenLifespan": 3600
  }' || echo "Realm may already exist"

echo "Creating client 'portal-issuer'..."
curl -s -X POST "${KEYCLOAK_URL}/admin/realms/ois/clients" \
  -H "Authorization: Bearer ${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "clientId": "portal-issuer",
    "enabled": true,
    "protocol": "openid-connect",
    "publicClient": false,
    "secret": "secret",
    "redirectUris": ["http://localhost:3001/*", "http://localhost:3001/api/auth/callback/keycloak"],
    "webOrigins": ["http://localhost:3001"],
    "standardFlowEnabled": true,
    "directAccessGrantsEnabled": true,
    "serviceAccountsEnabled": false
  }' || echo "Client may already exist"

echo "Creating client 'portal-investor'..."
curl -s -X POST "${KEYCLOAK_URL}/admin/realms/ois/clients" \
  -H "Authorization: Bearer ${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "clientId": "portal-investor",
    "enabled": true,
    "protocol": "openid-connect",
    "publicClient": false,
    "secret": "secret",
    "redirectUris": ["http://localhost:3002/*", "http://localhost:3002/api/auth/callback/keycloak"],
    "webOrigins": ["http://localhost:3002"],
    "standardFlowEnabled": true,
    "directAccessGrantsEnabled": true,
    "serviceAccountsEnabled": false
  }' || echo "Client may already exist"

echo "Creating client 'portal-backoffice'..."
curl -s -X POST "${KEYCLOAK_URL}/admin/realms/ois/clients" \
  -H "Authorization: Bearer ${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "clientId": "portal-backoffice",
    "enabled": true,
    "protocol": "openid-connect",
    "publicClient": false,
    "secret": "secret",
    "redirectUris": ["http://localhost:3003/*", "http://localhost:3003/api/auth/callback/keycloak"],
    "webOrigins": ["http://localhost:3003"],
    "standardFlowEnabled": true,
    "directAccessGrantsEnabled": true,
    "serviceAccountsEnabled": false
  }' || echo "Client may already exist"

echo "Creating test user 'testuser'..."
curl -s -X POST "${KEYCLOAK_URL}/admin/realms/ois/users" \
  -H "Authorization: Bearer ${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "email": "testuser@example.com",
    "enabled": true,
    "emailVerified": true,
    "firstName": "Test",
    "lastName": "User",
    "credentials": [{
      "type": "password",
      "value": "testpass123",
      "temporary": false
    }]
  }' || echo "User may already exist"

echo "Creating realm roles..."
for ROLE in issuer investor backoffice; do
  curl -s -X POST "${KEYCLOAK_URL}/admin/realms/ois/roles" \
    -H "Authorization: Bearer ${TOKEN}" \
    -H "Content-Type: application/json" \
    -d "{\"name\": \"${ROLE}\", \"description\": \"${ROLE} role for portal-${ROLE}\"}" || echo "Role ${ROLE} may already exist"
done

echo "Getting user ID for testuser..."
USER_ID=$(curl -s "${KEYCLOAK_URL}/admin/realms/ois/users?username=testuser" \
  -H "Authorization: Bearer ${TOKEN}" | jq -r '.[0].id')

if [ -n "$USER_ID" ] && [ "$USER_ID" != "null" ]; then
  echo "Assigning roles to testuser..."
  for ROLE in issuer investor backoffice; do
    ROLE_REP=$(curl -s "${KEYCLOAK_URL}/admin/realms/ois/roles/${ROLE}" \
      -H "Authorization: Bearer ${TOKEN}")
    curl -s -X POST "${KEYCLOAK_URL}/admin/realms/ois/users/${USER_ID}/role-mappings/realm" \
      -H "Authorization: Bearer ${TOKEN}" \
      -H "Content-Type: application/json" \
      -d "[${ROLE_REP}]" || echo "Role ${ROLE} assignment may have failed"
  done
  echo "Roles assigned to testuser: issuer, investor, backoffice"
fi

echo ""
echo "Keycloak setup complete!"
echo "  Realm: ois"
echo "  Clients: portal-issuer, portal-investor, portal-backoffice"
echo "  Roles: issuer, investor, backoffice"
echo "  Test user: testuser / testpass123 (with all roles)"
echo "  Keycloak URL: ${KEYCLOAK_URL}"
</file>

<file path="ops/scripts/check-gitlab-jobs-status.sh">
#!/usr/bin/env bash
# Check GitLab CI jobs status via API and Kubernetes
# Usage: ./ops/scripts/check-gitlab-jobs-status.sh

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

GITLAB_URL="${GITLAB_URL:-https://git.telex.global}"
PROJECT_ID="${PROJECT_ID:-npk/ois-cfa}"
KUBECONFIG_FILE="${KUBECONFIG:-}"

if [ -z "${KUBECONFIG_FILE}" ] && [ -f "ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="$(pwd)/ops/infra/timeweb/kubeconfig.yaml"
fi

echo -e "${BLUE}=== GitLab CI Jobs Status Check ===${NC}"
echo ""

# Check Kubernetes pods
if [ -n "${KUBECONFIG_FILE}" ] && [ -f "${KUBECONFIG_FILE}" ]; then
    export KUBECONFIG="${KUBECONFIG_FILE}"
    
    echo -e "${BLUE}=== Kubernetes Job Pods ===${NC}"
    kubectl get pods -n gitlab-runner --no-headers 2>/dev/null | grep "runner-" | while read -r line; do
        NAME=$(echo "$line" | awk '{print $1}')
        STATUS=$(echo "$line" | awk '{print $3}')
        RESTARTS=$(echo "$line" | awk '{print $4}')
        AGE=$(echo "$line" | awk '{print $5}')
        
        if [ "$STATUS" = "Running" ]; then
            echo -e "${GREEN}✓${NC} $NAME: $STATUS (restarts: $RESTARTS, age: $AGE)"
        elif [ "$STATUS" = "Pending" ]; then
            echo -e "${YELLOW}⚠${NC} $NAME: $STATUS (restarts: $RESTARTS, age: $AGE)"
            # Get reason
            REASON=$(kubectl get pod -n gitlab-runner "$NAME" -o jsonpath='{.status.conditions[?(@.type=="PodScheduled")].message}' 2>/dev/null || echo "")
            if [ -n "$REASON" ]; then
                echo "    Reason: $REASON"
            fi
        elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Error" ]; then
            echo -e "${RED}✗${NC} $NAME: $STATUS (restarts: $RESTARTS, age: $AGE)"
        else
            echo "  $NAME: $STATUS (restarts: $RESTARTS, age: $AGE)"
        fi
    done
    
    echo ""
    echo -e "${BLUE}=== Runner Pods ===${NC}"
    kubectl get pods -n gitlab-runner -l app=gitlab-runner --no-headers 2>/dev/null | while read -r line; do
        NAME=$(echo "$line" | awk '{print $1}')
        STATUS=$(echo "$line" | awk '{print $3}')
        READY=$(echo "$line" | awk '{print $2}')
        
        if [ "$STATUS" = "Running" ] && [[ "$READY" == "1/1" ]]; then
            echo -e "${GREEN}✓${NC} $NAME: $STATUS ($READY)"
        else
            echo -e "${YELLOW}⚠${NC} $NAME: $STATUS ($READY)"
        fi
    done
    
    echo ""
fi

# Check GitLab API if token available
if [ -n "${GITLAB_TOKEN:-}" ]; then
    echo -e "${BLUE}=== GitLab API: Running Jobs ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/jobs?scope=running" 2>/dev/null | \
        jq -r '.[] | "\(.id) | \(.name) | \(.status) | \(.stage) | Runner: \(.runner.description // "none")"' 2>/dev/null || \
        echo "Нет запущенных jobs или ошибка API"
    
    echo ""
    echo -e "${BLUE}=== GitLab API: Pending Jobs ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/jobs?scope=pending" 2>/dev/null | \
        jq -r '.[] | "\(.id) | \(.name) | \(.status) | \(.stage)"' 2>/dev/null || \
        echo "Нет ожидающих jobs или ошибка API"
    
    echo ""
    echo -e "${BLUE}=== GitLab API: Latest Pipelines ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/pipelines?per_page=3" 2>/dev/null | \
        jq -r '.[] | "\(.id) | \(.status) | \(.ref) | \(.created_at)"' 2>/dev/null || \
        echo "Ошибка получения pipelines"
else
    echo -e "${YELLOW}⚠ GITLAB_TOKEN не установлен, пропуск API проверки${NC}"
    echo "Для проверки через API установите:"
    echo "  export GITLAB_TOKEN='ваш-токен'"
fi

echo ""
echo -e "${BLUE}=== Check Complete ===${NC}"
</file>

<file path="ops/scripts/check-gitlab-jobs.sh">
#!/usr/bin/env bash
# Check GitLab CI jobs status
# Usage: ./ops/scripts/check-gitlab-jobs.sh

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}=== GitLab CI Jobs Status Check ===${NC}"
echo ""

# Check if we have GitLab token
GITLAB_TOKEN="${GITLAB_TOKEN:-}"
GITLAB_URL="${GITLAB_URL:-https://git.telex.global}"
PROJECT_ID="${PROJECT_ID:-npk/ois-cfa}"

if [ -z "${GITLAB_TOKEN}" ]; then
    echo -e "${YELLOW}⚠ GITLAB_TOKEN not set${NC}"
    echo "Set it with: export GITLAB_TOKEN='your-token'"
    echo ""
    echo "Checking runner status instead..."
    echo ""
else
    echo -e "${GREEN}✓ GITLAB_TOKEN set${NC}"
    echo "GitLab URL: ${GITLAB_URL}"
    echo "Project: ${PROJECT_ID}"
    echo ""
    
    # Get latest pipelines
    echo -e "${BLUE}=== Latest Pipelines ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/pipelines?per_page=5" | \
        jq -r '.[] | "\(.id) | \(.status) | \(.ref) | \(.created_at)"' || echo "Failed to get pipelines"
    echo ""
    
    # Get running jobs
    echo -e "${BLUE}=== Running Jobs ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/jobs?scope=running" | \
        jq -r '.[] | "\(.id) | \(.name) | \(.status) | \(.stage) | Runner: \(.runner.description // "none")"' || echo "No running jobs or failed to get jobs"
    echo ""
    
    # Get pending jobs
    echo -e "${BLUE}=== Pending Jobs ===${NC}"
    curl -sS -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}/jobs?scope=pending" | \
        jq -r '.[] | "\(.id) | \(.name) | \(.status) | \(.stage) | Runner: \(.runner.description // "none")"' || echo "No pending jobs or failed to get jobs"
    echo ""
fi

# Check runner status
echo -e "${BLUE}=== Runner Status (Kubernetes) ===${NC}"
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="$(pwd)/ops/infra/timeweb/kubeconfig.yaml"
fi

if [ -n "${KUBECONFIG_FILE}" ] && [ -f "${KUBECONFIG_FILE}" ]; then
    export KUBECONFIG="${KUBECONFIG_FILE}"
    kubectl get pods -n gitlab-runner -l app=gitlab-runner 2>/dev/null || echo "Cannot connect to cluster"
    echo ""
    echo "Runner logs (last 20 lines):"
    kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=20 2>/dev/null | tail -20 || echo "Cannot get logs"
else
    echo "KUBECONFIG not configured"
fi

echo ""
echo -e "${BLUE}=== Check Complete ===${NC}"
</file>

<file path="ops/scripts/check-gitlab-runners.sh">
#!/bin/bash
# Check GitLab runners via API
# Usage: ./ops/scripts/check-gitlab-runners.sh [GITLAB_TOKEN] [PROJECT_ID]

set -euo pipefail

GITLAB_URL="${GITLAB_URL:-https://git.telex.global}"
GITLAB_TOKEN="${1:-${GITLAB_TOKEN:-}}"
PROJECT_ID="${2:-${CI_PROJECT_ID:-npk/ois-cfa}}"

if [ -z "${GITLAB_TOKEN}" ]; then
    echo "Error: GITLAB_TOKEN not set"
    echo "Usage: $0 <gitlab-token> [project-id]"
    echo "Or set: export GITLAB_TOKEN='your-token'"
    exit 1
fi

echo "=== GitLab Runners Status ==="
echo "GitLab URL: ${GITLAB_URL}"
echo "Project: ${PROJECT_ID}"
echo ""

# Try to get project ID if path provided
if [[ "${PROJECT_ID}" == *"/"* ]]; then
    echo "Resolving project ID from path: ${PROJECT_ID}"
    PROJECT_ID=$(curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        "${GITLAB_URL}/api/v4/projects/${PROJECT_ID//\//%2F}" | \
        jq -r '.id // empty' 2>/dev/null || echo "")
    
    if [ -z "${PROJECT_ID}" ] || [ "${PROJECT_ID}" == "null" ]; then
        echo "Error: Cannot resolve project ID. Using path directly."
        PROJECT_PATH="${PROJECT_ID}"
    else
        echo "Project ID: ${PROJECT_ID}"
        PROJECT_PATH="${PROJECT_ID}"
    fi
else
    PROJECT_PATH="${PROJECT_ID}"
fi

echo ""
echo "=== Project Runners ==="
curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
    "${GITLAB_URL}/api/v4/projects/${PROJECT_PATH}/runners" | \
    jq -r '.[] | "\(.id) | \(.name) | \(.description // "N/A") | \(.online) | \(.active) | \(.tag_list | join(",") // "none")"' 2>/dev/null || \
    echo "Error: Cannot fetch runners. Check token permissions."

echo ""
echo "=== Instance/Group Runners ==="
curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
    "${GITLAB_URL}/api/v4/runners/all" | \
    jq -r '.[] | select(.project_ids == [] or (.project_ids | length > 0)) | "\(.id) | \(.name) | \(.description // "N/A") | \(.online) | \(.active) | \(.tag_list | join(",") // "none")"' 2>/dev/null || \
    echo "Error: Cannot fetch instance runners. Check token permissions."

echo ""
echo "=== Runner Registration Token ==="
echo "To get registration token:"
echo "1. Open: ${GITLAB_URL}/${PROJECT_PATH}/-/settings/ci_cd"
echo "2. Expand 'Runners' section"
echo "3. Copy 'Registration token'"
echo ""
echo "Or via API (if token has admin rights):"
echo "curl --header \"PRIVATE-TOKEN: \${GITLAB_TOKEN}\" \\"
echo "  \"${GITLAB_URL}/api/v4/projects/${PROJECT_PATH}/runners_token\""
</file>

<file path="ops/scripts/check-kubeconfig.sh">
#!/bin/bash
# Check if kubeconfig is configured and accessible
# Usage: ./ops/scripts/check-kubeconfig.sh

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "=== Checking kubeconfig ==="

# Check kubectl
if ! command -v kubectl &> /dev/null; then
    echo -e "${RED}✗ kubectl is not installed${NC}"
    echo "Install kubectl: https://kubernetes.io/docs/tasks/tools/"
    exit 1
fi

echo -e "${GREEN}✓ kubectl is installed${NC}"

# Check kubeconfig
if ! kubectl cluster-info &>/dev/null; then
    echo -e "${RED}✗ kubectl cannot connect to cluster${NC}"
    echo ""
    echo "Kubeconfig is not configured or cluster is not accessible."
    echo ""
    echo "To configure kubeconfig:"
    echo ""
    echo "1. If using Timeweb Cloud:"
    echo "   export TWC_TOKEN='your-token'"
    echo "   ./tools/timeweb/kubeconfig-export.sh ois-cfa-k8s"
    echo "   export KUBECONFIG=\"\$(pwd)/ops/infra/timeweb/kubeconfig.yaml\""
    echo ""
    echo "2. If you have existing kubeconfig:"
    echo "   export KUBECONFIG=\"/path/to/kubeconfig.yaml\""
    echo ""
    echo "3. Or copy to default location:"
    echo "   mkdir -p ~/.kube"
    echo "   cp kubeconfig.yaml ~/.kube/config"
    echo ""
    echo "See: docs/ops/timeweb/kubeconfig.md"
    exit 1
fi

echo -e "${GREEN}✓ kubectl can connect to cluster${NC}"

# Show cluster info
echo ""
echo "=== Cluster Information ==="
kubectl cluster-info | head -3
echo ""
kubectl get nodes 2>/dev/null | head -5 || echo "Cannot get nodes (may need permissions)"

echo ""
echo -e "${GREEN}✓ Kubeconfig is properly configured${NC}"
</file>

<file path="ops/scripts/check-runner-status.sh">
#!/bin/bash
# Check GitLab Runner status and configuration
# Usage: ./ops/scripts/check-runner-status.sh

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

echo "=== GitLab Runner Status Check ==="
echo ""

# Check kubeconfig
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
elif [ -n "${KUBECONFIG_FILE}" ] && [ ! -f "${KUBECONFIG_FILE}" ]; then
    # If relative path, try to resolve it
    if [ ! "${KUBECONFIG_FILE}" = /* ]; then
        ABS_PATH="${PROJECT_ROOT}/${KUBECONFIG_FILE}"
        if [ -f "${ABS_PATH}" ]; then
            KUBECONFIG_FILE="${ABS_PATH}"
        fi
    fi
fi

if [ -z "${KUBECONFIG_FILE}" ] || [ ! -f "${KUBECONFIG_FILE}" ]; then
    echo "⚠ Warning: KUBECONFIG not set or file not found"
    echo "Set it with: export KUBECONFIG=\$(pwd)/ops/infra/timeweb/kubeconfig.yaml"
    echo "Or run: make setup-kubeconfig"
    echo ""
    if [ -z "${KUBECONFIG_FILE}" ]; then
        exit 1
    fi
else
    export KUBECONFIG="${KUBECONFIG_FILE}"
    echo "✓ Using KUBECONFIG: ${KUBECONFIG_FILE}"
fi

# Check kubectl
if ! command -v kubectl &> /dev/null; then
    echo "Error: kubectl not found"
    exit 1
fi

# Check cluster connection
if ! kubectl cluster-info &>/dev/null; then
    echo "⚠ Warning: Cannot connect to cluster"
    echo "Check kubeconfig: kubectl cluster-info"
    exit 1
fi

echo "✓ Cluster connection OK"
echo ""

# Check namespace
if ! kubectl get namespace gitlab-runner &>/dev/null; then
    echo "⚠ Warning: gitlab-runner namespace not found"
    echo "Install runner: make gitlab-runner-install"
    exit 1
fi

echo "=== Runner Pods ==="
kubectl get pods -n gitlab-runner
echo ""

# Check pod status
RUNNING_PODS=$(kubectl get pods -n gitlab-runner -l app=gitlab-runner --no-headers 2>/dev/null | grep -c " Running " || echo "0")
TOTAL_PODS=$(kubectl get pods -n gitlab-runner -l app=gitlab-runner --no-headers 2>/dev/null | wc -l || echo "0")

if [ "${RUNNING_PODS}" -eq 0 ]; then
    echo "❌ Error: No running runner pods"
    echo "Check logs: make gitlab-runner-logs"
    exit 1
elif [ "${RUNNING_PODS}" -lt "${TOTAL_PODS}" ]; then
    echo "⚠ Warning: Not all pods are running (${RUNNING_PODS}/${TOTAL_PODS})"
else
    echo "✓ All runner pods running (${RUNNING_PODS}/${TOTAL_PODS})"
fi

echo ""
echo "=== Runner Configuration ==="
kubectl get configmap gitlab-runner-config -n gitlab-runner -o yaml | grep -A 5 "name = " || echo "ConfigMap not found"

echo ""
echo "=== Runner Logs (last 10 lines) ==="
kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=10 || echo "Cannot get logs"

echo ""
echo "=== Next Steps ==="
echo "1. Check runner in GitLab UI: Settings → CI/CD → Runners"
echo "2. Verify runner is 'Online' (green indicator)"
echo "3. Check runner tags (should be empty or match job tags)"
echo "4. Try running debug:deploy job manually"
echo ""
echo "To view full logs: make gitlab-runner-logs"
echo "To restart runner: make gitlab-runner-restart"
</file>

<file path="ops/scripts/cloudflare-dns-upsert.sh">
#!/bin/bash
set -euo pipefail

# OIS-CFA · Cloudflare DNS Upsert Helper
#
# Purpose:
#   Upsert A-records for a given host label set in a Cloudflare zone.
#   Used from eywa1 to configure DNS for cfa1/cfa2/etc with different accounts/domains.
#
# Usage:
#   ./ops/scripts/cloudflare-dns-upsert.sh <config-env-file> <ip-address>
#
# Where <config-env-file> exports:
#   CF_ZONE_NAME     - Cloudflare zone name (e.g. llmneighbors.com)
#   CF_ZONE_ID       - Cloudflare zone id
#   CF_API_TOKEN     - API token with DNS edit permission for this zone
#   CF_HOST_PREFIXES - Comma-separated host prefixes (e.g. "auth,issuer,investor,backoffice,api")
#   CF_BASE_LABEL    - Base label for this environment (e.g. "cfa1" => auth.cfa1.<zone>)
#
# Example:
#   ./ops/scripts/cloudflare-dns-upsert.sh \
#     /home/user/__Repositories/cloudflare__developerisnow/.env.cfa1 \
#     87.249.49.56

usage() {
  echo "Usage: $0 <config-env-file> <ip-address>" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

CONFIG_FILE="${1:-}"
TARGET_IP="${2:-}"

if [ -z "$CONFIG_FILE" ] || [ -z "$TARGET_IP" ]; then
  usage
fi

if [ ! -f "$CONFIG_FILE" ]; then
  echo "ERROR: config-env-file '$CONFIG_FILE' not found" >&2
  exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
  echo "ERROR: jq is required for parsing Cloudflare responses (apt-get install jq)" >&2
  exit 1
fi

# shellcheck disable=SC1090
set -a && source "$CONFIG_FILE" && set +a

: "${CF_ZONE_NAME:?CF_ZONE_NAME is required in config-env-file}"
: "${CF_ZONE_ID:?CF_ZONE_ID is required in config-env-file}"
: "${CF_API_TOKEN:?CF_API_TOKEN is required in config-env-file}"
: "${CF_HOST_PREFIXES:?CF_HOST_PREFIXES is required in config-env-file}"
: "${CF_BASE_LABEL:?CF_BASE_LABEL is required in config-env-file}"

echo ">>> Cloudflare DNS upsert"
echo "    Zone:   ${CF_ZONE_NAME} (${CF_ZONE_ID})"
echo "    IP:     ${TARGET_IP}"
echo "    Prefix: ${CF_HOST_PREFIXES}"
echo "    Label:  ${CF_BASE_LABEL}"

CF_API_BASE="https://api.cloudflare.com/client/v4"

create_or_update() {
  local HOST_PREFIX="$1"
  local NAME="${HOST_PREFIX}.${CF_BASE_LABEL}"
  local FQDN="${NAME}.${CF_ZONE_NAME}"

  echo "-- upsert ${FQDN} -> ${TARGET_IP}"

  local EXIST_ID
  EXIST_ID=$(
    curl -s -X GET "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records?type=A&name=${FQDN}" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" |
      jq -r '.result[0].id // empty'
  )

  local PAYLOAD
  PAYLOAD=$(jq -n \
    --arg type "A" \
    --arg name "${FQDN}" \
    --arg content "${TARGET_IP}" \
    --argjson ttl 1 \
    --argjson proxied false \
    '{type: $type, name: $name, content: $content, ttl: $ttl, proxied: $proxied}')

  if [ -n "$EXIST_ID" ] && [ "$EXIST_ID" != "null" ]; then
    curl -s -X PATCH "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records/${EXIST_ID}" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" \
      --data "$PAYLOAD" >/dev/null
  else
    curl -s -X POST "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" \
      --data "$PAYLOAD" >/dev/null
  fi
}

IFS=',' read -r -a PREFIXES <<<"$CF_HOST_PREFIXES"
for prefix in "${PREFIXES[@]}"; do
  prefix_trimmed="${prefix//[[:space:]]/}"
  [ -z "$prefix_trimmed" ] && continue
  create_or_update "$prefix_trimmed"
done

echo ">>> DNS upsert completed."
</file>

<file path="ops/scripts/create-helm-chart.sh">
#!/bin/bash
# Script to create Helm chart from api-gateway template
# Usage: ./ops/scripts/create-helm-chart.sh <chart-name>

set -euo pipefail

CHART_NAME="${1:-}"
if [ -z "$CHART_NAME" ]; then
  echo "Usage: $0 <chart-name>"
  echo "Example: $0 identity"
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
TEMPLATE_CHART="api-gateway"
CHART_DIR="${PROJECT_ROOT}/ops/infra/helm/${CHART_NAME}"

if [ -d "$CHART_DIR" ]; then
  echo "Error: Chart $CHART_NAME already exists at $CHART_DIR"
  exit 1
fi

echo "Creating Helm chart: $CHART_NAME"
echo "Template: $TEMPLATE_CHART"
echo "Target: $CHART_DIR"

# Create directory structure
mkdir -p "${CHART_DIR}/templates"

# Copy files from template
cp "${PROJECT_ROOT}/ops/infra/helm/${TEMPLATE_CHART}/Chart.yaml" "${CHART_DIR}/"
cp "${PROJECT_ROOT}/ops/infra/helm/${TEMPLATE_CHART}/values.yaml" "${CHART_DIR}/"
cp "${PROJECT_ROOT}/ops/infra/helm/${TEMPLATE_CHART}/values-"*.yaml "${CHART_DIR}/" 2>/dev/null || true
cp "${PROJECT_ROOT}/ops/infra/helm/${TEMPLATE_CHART}/templates/"* "${CHART_DIR}/templates/"

# Replace chart name in all files
find "${CHART_DIR}" -type f \( -name "*.yaml" -o -name "*.tpl" \) -exec sed -i "s/${TEMPLATE_CHART}/${CHART_NAME}/g" {} \;

# Update Chart.yaml name
sed -i "s/name: ${TEMPLATE_CHART}/name: ${CHART_NAME}/" "${CHART_DIR}/Chart.yaml"

echo "✓ Created Helm chart: $CHART_DIR"
echo ""
echo "Next steps:"
echo "1. Review and update values.yaml with service-specific settings"
echo "2. Update values-*.yaml for environment-specific configurations"
echo "3. Test with: helm template $CHART_NAME $CHART_DIR"
</file>

<file path="ops/scripts/fix-runner-and-deploy.sh">
#!/bin/bash
# Master script: Fix Runner and Deploy Test Pod
# Usage: ./ops/scripts/fix-runner-and-deploy.sh [RUNNER_TOKEN]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${GREEN}=== Мастер-скрипт: Исправление Runner и выкатка тестового pod ===${NC}"
echo ""

# Setup kubeconfig
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
    export KUBECONFIG="${KUBECONFIG_FILE}"
fi

if [ -z "${KUBECONFIG_FILE}" ] || [ ! -f "${KUBECONFIG_FILE}" ]; then
    echo -e "${RED}Error: KUBECONFIG not found${NC}"
    echo "Run: make setup-kubeconfig"
    exit 1
fi

export KUBECONFIG="${KUBECONFIG_FILE}"
echo -e "${GREEN}✓ Using KUBECONFIG: ${KUBECONFIG_FILE}${NC}"
echo ""

# Step 1: Fix Runner
RUNNER_TOKEN="${1:-${RUNNER_TOKEN:-}}"
if [ -n "${RUNNER_TOKEN}" ]; then
    echo -e "${YELLOW}=== ШАГ 1: Исправление GitLab Runner ===${NC}"
    echo "Updating runner token..."
    
    # Update ConfigMap
    sed -e "s/__REPLACE_WITH_RUNNER_TOKEN__/${RUNNER_TOKEN}/g" \
        -e "s/token = \".*\"/token = \"${RUNNER_TOKEN}\"/g" \
        "${PROJECT_ROOT}/ops/infra/k8s/gitlab-runner/configmap.yaml" | \
        kubectl apply -f -
    
    # Restart pods
    echo "Restarting runner pods..."
    kubectl rollout restart deployment/gitlab-runner -n gitlab-runner
    kubectl wait --for=condition=Ready pod -l app=gitlab-runner -n gitlab-runner --timeout=120s || true
    
    echo -e "${GREEN}✓ Runner token updated${NC}"
    echo ""
else
    echo -e "${YELLOW}⚠ RUNNER_TOKEN not provided, skipping runner update${NC}"
    echo "To update runner: export RUNNER_TOKEN='token' && $0"
    echo ""
fi

# Step 2: Deploy test pod
echo -e "${YELLOW}=== ШАГ 2: Выкатка тестового pod ===${NC}"
kubectl apply -f "${PROJECT_ROOT}/ops/infra/k8s/test-pod.yaml"

echo "Waiting for pod to be ready..."
kubectl wait --for=condition=Ready pod -l app=test-nginx -n ois-cfa --timeout=60s || {
    echo -e "${YELLOW}⚠ Pod may still be starting${NC}"
}

echo ""
echo -e "${GREEN}=== Статус развёртывания ===${NC}"
kubectl get pods -n ois-cfa
echo ""
kubectl get svc -n ois-cfa
echo ""
kubectl get ingress -n ois-cfa
echo ""

# Step 3: Get access info
NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null || \
          kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')

echo -e "${GREEN}=== Информация для доступа ===${NC}"
echo "Node IP: ${NODE_IP}"
echo ""
echo "Доступ к тестовому pod:"
echo "1. Через Ingress (если DNS настроен): http://cfa.capital"
echo "2. По IP узла (если настроен NodePort): http://${NODE_IP}"
echo ""
echo "Проверка:"
echo "  curl http://cfa.capital"
echo "  или"
echo "  curl http://${NODE_IP} -H 'Host: cfa.capital'"
echo ""

echo -e "${GREEN}✓ Тестовый pod выкачен${NC}"
</file>

<file path="ops/scripts/force-runner-reregister.sh">
#!/bin/bash
# Force GitLab Runner to re-register by clearing saved state
# Usage: ./ops/scripts/force-runner-reregister.sh

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${GREEN}=== Принудительная перерегистрация GitLab Runner ===${NC}"
echo ""

# Setup kubeconfig
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
    export KUBECONFIG="${KUBECONFIG_FILE}"
fi

if [ -z "${KUBECONFIG_FILE}" ] || [ ! -f "${KUBECONFIG_FILE}" ]; then
    echo -e "${RED}Error: KUBECONFIG not found${NC}"
    exit 1
fi

export KUBECONFIG="${KUBECONFIG_FILE}"
echo -e "${GREEN}✓ Using KUBECONFIG: ${KUBECONFIG_FILE}${NC}"
echo ""

# Step 1: Get pods
echo -e "${YELLOW}=== ШАГ 1: Поиск pods GitLab Runner ===${NC}"
PODS=$(kubectl get pods -n gitlab-runner -l app=gitlab-runner -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

if [ -z "${PODS}" ]; then
    echo -e "${RED}Error: No GitLab Runner pods found${NC}"
    exit 1
fi

echo "Найдено pods: ${PODS}"
echo ""

# Step 2: Clear runner state in pods (if possible)
echo -e "${YELLOW}=== ШАГ 2: Очистка сохраненной конфигурации ===${NC}"
for POD in ${PODS}; do
    echo "Обработка pod: ${POD}"
    
    # Try to clear runner state files (may fail if ConfigMap is read-only)
    kubectl exec -n gitlab-runner "${POD}" -- sh -c "
        rm -f /etc/gitlab-runner/.runner_system_id 2>/dev/null || true
        rm -f /etc/gitlab-runner/.runner_* 2>/dev/null || true
        echo 'State files cleared (if writable)'
    " 2>&1 || echo "Не удалось очистить state files (ConfigMap read-only - это нормально)"
done
echo ""

# Step 3: Delete pods to force re-registration
echo -e "${YELLOW}=== ШАГ 3: Удаление pods для перерегистрации ===${NC}"
echo "Удаление pods..."
kubectl delete pods -n gitlab-runner -l app=gitlab-runner

echo "Ожидание пересоздания pods..."
sleep 10

# Step 4: Wait for pods to be ready
echo -e "${YELLOW}=== ШАГ 4: Ожидание готовности pods ===${NC}"
kubectl wait --for=condition=Ready pod -l app=gitlab-runner -n gitlab-runner --timeout=120s || {
    echo -e "${YELLOW}⚠ Pods могут еще запускаться${NC}"
}

echo ""
echo -e "${GREEN}=== Статус pods ===${NC}"
kubectl get pods -n gitlab-runner
echo ""

# Step 5: Check logs
echo -e "${YELLOW}=== ШАГ 5: Проверка логов ===${NC}"
sleep 5
kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=30 2>&1 | tail -30
echo ""

echo -e "${GREEN}=== ИНСТРУКЦИИ ===${NC}"
echo ""
echo "⚠️  ВАЖНО: Если runner все еще получает 403 Forbidden:"
echo ""
echo "1. Удалите старый runner из GitLab UI:"
echo "   https://git.telex.global/npk/ois-cfa/-/settings/ci_cd"
echo "   → Runners → Удалить runner с ID HYErDk_6w"
echo ""
echo "2. Перезапустите pods еще раз:"
echo "   kubectl delete pods -n gitlab-runner -l app=gitlab-runner"
echo ""
echo "3. Проверьте логи:"
echo "   kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=50"
echo ""

echo -e "${GREEN}✓ Скрипт выполнен${NC}"
</file>

<file path="ops/scripts/get-runner-token.sh">
#!/bin/bash
# Get GitLab Runner Registration Token via API
# Usage: ./ops/scripts/get-runner-token.sh [GITLAB_TOKEN] [PROJECT_PATH]

set -euo pipefail

GITLAB_URL="${GITLAB_URL:-https://git.telex.global}"
GITLAB_TOKEN="${1:-${GITLAB_TOKEN:-}}"
PROJECT_PATH="${2:-${CI_PROJECT_PATH:-npk/ois-cfa}}"

if [ -z "${GITLAB_TOKEN}" ]; then
    echo "Error: GITLAB_TOKEN not set"
    echo "Usage: $0 <gitlab-token> [project-path]"
    echo "Or set: export GITLAB_TOKEN='your-token'"
    exit 1
fi

echo "Getting Runner Registration Token for project: ${PROJECT_PATH}"
echo ""

# Encode project path for URL
PROJECT_PATH_ENCODED=$(echo "${PROJECT_PATH}" | sed 's/\//%2F/g')

# Try to get runner token via API
RESPONSE=$(curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
    "${GITLAB_URL}/api/v4/projects/${PROJECT_PATH_ENCODED}/runners_token" 2>/dev/null)

if [ $? -eq 0 ] && [ -n "${RESPONSE}" ]; then
    TOKEN=$(echo "${RESPONSE}" | jq -r '.token // .' 2>/dev/null || echo "${RESPONSE}")
    
    if [ "${TOKEN}" != "null" ] && [ "${TOKEN}" != "" ] && [ "${TOKEN}" != "${RESPONSE}" ]; then
        echo "✓ Runner Registration Token получен:"
        echo "${TOKEN}"
        echo ""
        echo "Для обновления раннера:"
        echo "  export RUNNER_TOKEN=\"${TOKEN}\""
        echo "  make gitlab-runner-update-token"
        exit 0
    fi
fi

echo "⚠ Не удалось получить токен через API"
echo ""
echo "Получите токен вручную из GitLab UI:"
echo "1. Откройте: ${GITLAB_URL}/${PROJECT_PATH}/-/settings/ci_cd"
echo "2. Раздел: Runners"
echo "3. Скопируйте Registration token"
echo ""
echo "Или используйте групповой/instance runner token:"
echo "  Settings → CI/CD → Runners → Expand 'Runners' → Registration token"
</file>

<file path="ops/scripts/gitlab-runner-install.sh">
#!/bin/bash
# Install GitLab Runner in Kubernetes
# Usage: ./ops/scripts/gitlab-runner-install.sh [RUNNER_TOKEN]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check kubectl
if ! command -v kubectl &> /dev/null; then
    echo -e "${RED}Error: kubectl is not installed${NC}"
    exit 1
fi

# Get runner token
RUNNER_TOKEN="${1:-${RUNNER_TOKEN:-}}"

if [ -z "$RUNNER_TOKEN" ]; then
    echo -e "${YELLOW}Runner token not provided.${NC}"
    echo "Getting token from GitLab API..."
    
    if [ -z "${GITLAB_TOKEN:-}" ]; then
        echo -e "${RED}Error: GITLAB_TOKEN not set${NC}"
        echo "Set it with: export GITLAB_TOKEN='your-token'"
        echo ""
        echo "Or provide runner token directly:"
        echo "  $0 <runner-token>"
        echo ""
        echo "To get token from GitLab UI:"
        echo "  Settings → CI/CD → Runners → Registration token"
        exit 1
    fi
    
    echo -e "${RED}Cannot get runner token from API (endpoint not available)${NC}"
    echo "Please get token from GitLab UI:"
    echo "  1. Open: https://git.telex.global/npk/ois-cfa/-/settings/ci_cd"
    echo "  2. Expand 'Runners' section"
    echo "  3. Copy 'Registration token'"
    echo ""
    echo "Then run:"
    echo "  $0 <runner-token>"
    exit 1
fi

# Runner directory
RUNNER_DIR="${PROJECT_ROOT}/ops/infra/k8s/gitlab-runner"

echo -e "${GREEN}=== Installing GitLab Runner ===${NC}"
echo "Runner token: ${RUNNER_TOKEN:0:10}...${RUNNER_TOKEN: -10}"
echo ""

# Check if namespace exists
if kubectl get namespace gitlab-runner &>/dev/null; then
    echo -e "${YELLOW}Namespace gitlab-runner already exists${NC}"
else
    echo "Creating namespace..."
    kubectl apply -f "${RUNNER_DIR}/namespace.yaml"
fi

# Apply RBAC
echo "Applying RBAC..."
kubectl apply -f "${RUNNER_DIR}/rbac.yaml"

# Update configmap with token
echo "Updating configmap with runner token..."
TEMP_CONFIGMAP=$(mktemp)
sed "s/__REPLACE_WITH_RUNNER_TOKEN__/$RUNNER_TOKEN/g" \
    "${RUNNER_DIR}/configmap.yaml" > "$TEMP_CONFIGMAP"
kubectl apply -f "$TEMP_CONFIGMAP"
rm "$TEMP_CONFIGMAP"

# Apply deployment and service
echo "Applying deployment..."
kubectl apply -f "${RUNNER_DIR}/deployment.yaml"
kubectl apply -f "${RUNNER_DIR}/service.yaml"

# Wait for pods
echo ""
echo "Waiting for pods to be ready..."
if kubectl wait --for=condition=Ready pod -l app=gitlab-runner -n gitlab-runner --timeout=120s 2>/dev/null; then
    echo -e "${GREEN}✓ GitLab Runner pods are ready${NC}"
else
    echo -e "${YELLOW}⚠ Pods may still be starting. Check status:${NC}"
    echo "  kubectl get pods -n gitlab-runner"
fi

# Show status
echo ""
echo -e "${GREEN}=== GitLab Runner Status ===${NC}"
kubectl get pods -n gitlab-runner
echo ""
echo "Runner logs (last 10 lines):"
kubectl logs -n gitlab-runner -l app=gitlab-runner --tail=10 || true

echo ""
echo -e "${GREEN}=== Installation Complete ===${NC}"
echo "Check runners in GitLab UI:"
echo "  https://git.telex.global/npk/ois-cfa/-/settings/ci_cd"
echo ""
echo "Useful commands:"
echo "  kubectl logs -n gitlab-runner -l app=gitlab-runner -f  # Watch logs"
echo "  kubectl get pods -n gitlab-runner                      # Check pods"
echo "  make gitlab-runner-status                              # Show status"
</file>

<file path="ops/scripts/gitops-sync.sh">
#!/bin/bash
# GitOps Sync Script for GitLab Agent
# Usage: ./ops/scripts/gitops-sync.sh [env]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

ENV="${1:-dev}"

echo -e "${GREEN}=== GitOps Sync: GitLab Agent ===${NC}"
echo "Environment: ${ENV}"
echo ""

# Setup kubeconfig
KUBECONFIG_FILE="${KUBECONFIG:-}"
if [ -z "${KUBECONFIG_FILE}" ] && [ -f "${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml" ]; then
    KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
    export KUBECONFIG="${KUBECONFIG_FILE}"
fi

if [ -z "${KUBECONFIG_FILE}" ] || [ ! -f "${KUBECONFIG_FILE}" ]; then
    echo -e "${RED}Error: KUBECONFIG not found${NC}"
    exit 1
fi

export KUBECONFIG="${KUBECONFIG_FILE}"
echo -e "${GREEN}✓ Using KUBECONFIG: ${KUBECONFIG_FILE}${NC}"
echo ""

# Step 1: Check GitLab Agent status
echo -e "${YELLOW}=== ШАГ 1: Проверка GitLab Agent ===${NC}"
AGENT_PODS=$(kubectl get pods -n gitlab-agent -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

if [ -z "${AGENT_PODS}" ]; then
    echo -e "${YELLOW}⚠ GitLab Agent pods not found, but continuing...${NC}"
    echo "Install agent: make gitlab-agent-install"
else
    echo "GitLab Agent pods: ${AGENT_PODS}"
fi

echo "GitLab Agent pods: ${AGENT_PODS}"
for POD in ${AGENT_PODS}; do
    STATUS=$(kubectl get pod -n gitlab-agent "${POD}" -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
    echo "  - ${POD}: ${STATUS}"
done
echo ""

# Step 2: Check agent configuration
echo -e "${YELLOW}=== ШАГ 2: Проверка конфигурации агента ===${NC}"
if [ ! -f "${PROJECT_ROOT}/.gitlab/agents/ois-cfa-agent/config.yaml" ]; then
    echo -e "${YELLOW}⚠ Конфигурация агента не найдена, создаю...${NC}"
    mkdir -p "${PROJECT_ROOT}/.gitlab/agents/ois-cfa-agent"
    cp "${PROJECT_ROOT}/ops/gitops/gitlab-agent/agent-config.yaml" \
       "${PROJECT_ROOT}/.gitlab/agents/ois-cfa-agent/config.yaml"
    echo -e "${GREEN}✓ Конфигурация создана${NC}"
else
    echo -e "${GREEN}✓ Конфигурация найдена${NC}"
fi
echo ""

# Step 3: Check manifests
echo -e "${YELLOW}=== ШАГ 3: Проверка манифестов ===${NC}"
MANIFEST_DIRS=(
    "ops/gitops/gitlab-agent/manifests/system"
    "ops/gitops/gitlab-agent/manifests/platform"
    "ops/gitops/gitlab-agent/manifests/business"
)

for DIR in "${MANIFEST_DIRS[@]}"; do
    if [ -d "${PROJECT_ROOT}/${DIR}" ]; then
        MANIFEST_COUNT=$(find "${PROJECT_ROOT}/${DIR}" -name "*.yaml" -o -name "*.yml" | wc -l)
        echo "  ${DIR}: ${MANIFEST_COUNT} манифестов"
    else
        echo -e "${YELLOW}  ⚠ ${DIR}: не найдено${NC}"
    fi
done
echo ""

# Step 4: Apply manifests manually (for testing)
echo -e "${YELLOW}=== ШАГ 4: Применение манифестов ===${NC}"
echo "Применяю манифесты в порядке: system → platform → business"
echo ""

# System manifests
if [ -d "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/system" ]; then
    echo -e "${BLUE}→ System manifests${NC}"
    kubectl apply -f "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/system/" --recursive || true
    sleep 2
fi

# Platform manifests
if [ -d "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/platform" ]; then
    echo -e "${BLUE}→ Platform manifests${NC}"
    kubectl apply -f "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/platform/" --recursive || true
    sleep 2
fi

# Business manifests
if [ -d "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/business" ]; then
    echo -e "${BLUE}→ Business manifests${NC}"
    kubectl apply -f "${PROJECT_ROOT}/ops/gitops/gitlab-agent/manifests/business/" --recursive || true
    sleep 2
fi

echo ""

# Step 5: Check applied resources
echo -e "${YELLOW}=== ШАГ 5: Проверка примененных ресурсов ===${NC}"
echo "Namespaces:"
kubectl get namespaces | grep -E "(ois-cfa|default)" || echo "  (нет соответствующих namespace)"
echo ""

echo "Deployments в ois-cfa:"
kubectl get deployments -n ois-cfa 2>/dev/null || echo "  Namespace ois-cfa не существует или пуст"
echo ""

echo "Services в ois-cfa:"
kubectl get services -n ois-cfa 2>/dev/null || echo "  Namespace ois-cfa не существует или пуст"
echo ""

echo "Ingress в ois-cfa:"
kubectl get ingress -n ois-cfa 2>/dev/null || echo "  Namespace ois-cfa не существует или пуст"
echo ""

# Step 6: Summary
echo -e "${GREEN}=== ИТОГОВЫЙ СТАТУС ===${NC}"
echo ""
echo "✅ GitLab Agent: Running"
echo "✅ Конфигурация: ${PROJECT_ROOT}/.gitlab/agents/ois-cfa-agent/config.yaml"
echo "✅ Манифесты применены"
echo ""
echo -e "${YELLOW}Следующие шаги:${NC}"
echo "1. Проверить статус в GitLab UI:"
echo "   Infrastructure → Kubernetes clusters → ваш кластер → Connected agents"
echo ""
echo "2. Создать MR с изменениями манифестов (если нужно)"
echo ""
echo "3. GitLab Agent автоматически синхронизирует изменения из Git"
echo ""
echo -e "${GREEN}✓ GitOps sync выполнен${NC}"
</file>

<file path="ops/scripts/install-helm.sh">
#!/bin/bash
# Install Helm package manager for Kubernetes
# Usage: ./ops/scripts/install-helm.sh

set -euo pipefail

HELM_VERSION="${HELM_VERSION:-3.14.0}"

echo "=== Installing Helm ${HELM_VERSION} ==="

# Check if helm is already installed
if command -v helm &> /dev/null; then
    CURRENT_VERSION=$(helm version --template '{{.Version}}' 2>/dev/null | sed 's/v//' || echo "")
    if [ -n "${CURRENT_VERSION}" ]; then
        echo "✓ Helm already installed: v${CURRENT_VERSION}"
        echo "To reinstall, remove existing helm first: sudo rm -f $(which helm)"
        exit 0
    fi
fi

# Detect OS and architecture
OS=$(uname -s | tr '[:upper:]' '[:lower:]')
ARCH=$(uname -m)

case "${ARCH}" in
    x86_64)
        ARCH="amd64"
        ;;
    aarch64|arm64)
        ARCH="arm64"
        ;;
    *)
        echo "Error: Unsupported architecture: ${ARCH}"
        exit 1
        ;;
esac

echo "Detected OS: ${OS}, Architecture: ${ARCH}"

# Download Helm
HELM_URL="https://get.helm.sh/helm-v${HELM_VERSION}-${OS}-${ARCH}.tar.gz"
TMP_DIR=$(mktemp -d)
TAR_FILE="${TMP_DIR}/helm.tar.gz"

echo "Downloading Helm from ${HELM_URL}..."
curl -L -o "${TAR_FILE}" "${HELM_URL}" || {
    echo "Error: Failed to download Helm"
    rm -rf "${TMP_DIR}"
    exit 1
}

# Extract and install
echo "Extracting Helm..."
tar -xzf "${TAR_FILE}" -C "${TMP_DIR}"

# Install to /usr/local/bin (requires sudo) or ~/.local/bin
INSTALL_DIR="${HOME}/.local/bin"
mkdir -p "${INSTALL_DIR}"

if [ -w "/usr/local/bin" ]; then
    INSTALL_DIR="/usr/local/bin"
    echo "Installing to ${INSTALL_DIR}..."
    sudo cp "${TMP_DIR}/${OS}-${ARCH}/helm" "${INSTALL_DIR}/helm" || {
        echo "Error: Failed to install helm to ${INSTALL_DIR}"
        rm -rf "${TMP_DIR}"
        exit 1
    }
else
    echo "Installing to ${INSTALL_DIR}..."
    cp "${TMP_DIR}/${OS}-${ARCH}/helm" "${INSTALL_DIR}/helm" || {
        echo "Error: Failed to install helm to ${INSTALL_DIR}"
        rm -rf "${TMP_DIR}"
        exit 1
    }
    
    # Add to PATH if not already there
    if [[ ":$PATH:" != *":${INSTALL_DIR}:"* ]]; then
        echo ""
        echo "⚠ Add ${INSTALL_DIR} to PATH:"
        echo "  export PATH=\"\${PATH}:${INSTALL_DIR}\""
        echo ""
        echo "Or add to ~/.bashrc:"
        echo "  echo 'export PATH=\"\${PATH}:${INSTALL_DIR}\"' >> ~/.bashrc"
    fi
fi

# Cleanup
rm -rf "${TMP_DIR}"

# Verify installation
if command -v helm &> /dev/null || [ -f "${INSTALL_DIR}/helm" ]; then
    if [ -f "${INSTALL_DIR}/helm" ]; then
        "${INSTALL_DIR}/helm" version --client
    else
        helm version --client
    fi
    echo ""
    echo "✓ Helm installed successfully"
    echo "Version: $("${INSTALL_DIR}/helm" version --template '{{.Version}}' 2>/dev/null || helm version --template '{{.Version}}')"
else
    echo "Error: Helm installation verification failed"
    exit 1
fi
</file>

<file path="ops/scripts/k8s-healthcheck.sh">
#!/bin/bash
# Kubernetes Cluster Health Check
# Generates HTML report with cluster status, checks, and action items

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OUTPUT_DIR="${OUTPUT_DIR:-/tmp/k8s-healthcheck}"
ARTIFACTS_DIR="${ARTIFACTS_DIR:-/tmp/artifacts}"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
REPORT_FILE="${OUTPUT_DIR}/healthcheck-report-${TIMESTAMP}.html"
JSON_FILE="${OUTPUT_DIR}/healthcheck-${TIMESTAMP}.json"

mkdir -p "${OUTPUT_DIR}"
mkdir -p "${ARTIFACTS_DIR}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Initialize results
declare -A CHECKS
declare -a ACTION_ITEMS
declare -a WARNINGS
declare -a ERRORS

# Helper functions
check_pass() {
    local name="$1"
    local message="$2"
    CHECKS["${name}"]="PASS"
    echo -e "${GREEN}✓${NC} ${name}: ${message}"
}

check_fail() {
    local name="$1"
    local message="$2"
    local fix_cmd="${3:-}"
    CHECKS["${name}"]="FAIL"
    ERRORS+=("${name}: ${message}")
    if [ -n "${fix_cmd}" ]; then
        ACTION_ITEMS+=("${name}|${message}|${fix_cmd}")
    else
        ACTION_ITEMS+=("${name}|${message}|N/A")
    fi
    echo -e "${RED}✗${NC} ${name}: ${message}"
}

check_warn() {
    local name="$1"
    local message="$2"
    CHECKS["${name}"]="WARN"
    WARNINGS+=("${name}: ${message}")
    echo -e "${YELLOW}⚠${NC} ${name}: ${message}"
}

# Check if kubectl is available
if ! command -v kubectl &> /dev/null; then
    echo "Error: kubectl not found. Please install kubectl."
    exit 1
fi

# Check if cluster is accessible
if ! kubectl cluster-info &> /dev/null; then
    check_fail "cluster-access" "Cannot access Kubernetes cluster" "kubectl cluster-info"
    exit 1
fi

echo "=== Kubernetes Cluster Health Check ==="
echo "Timestamp: ${TIMESTAMP}"
echo ""

# 1. Check Nodes
echo "=== Checking Nodes ==="
NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l || echo "0")
if [ "${NODES}" -eq 0 ]; then
    check_fail "nodes-count" "No nodes found in cluster" "kubectl get nodes"
else
    check_pass "nodes-count" "${NODES} node(s) found"
fi

# Check node status
READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c " Ready " || echo "0")
NOT_READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -v " Ready " | wc -l || echo "0")

if [ "${NOT_READY_NODES}" -gt 0 ]; then
    check_fail "nodes-ready" "${NOT_READY_NODES} node(s) not ready" "kubectl get nodes; kubectl describe node <node-name>"
else
    check_pass "nodes-ready" "All ${READY_NODES} node(s) ready"
fi

# Get node versions
NODE_VERSIONS=$(kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}: {.status.nodeInfo.kubeletVersion}{"\n"}{end}' 2>/dev/null || echo "")
if [ -n "${NODE_VERSIONS}" ]; then
    echo "Node versions:"
    echo "${NODE_VERSIONS}" | while IFS= read -r line; do
        echo "  - ${line}"
    done
fi

# Check node resources
echo ""
echo "Node resources:"
kubectl top nodes 2>/dev/null || check_warn "node-metrics" "Metrics server not available (kubectl top nodes)"

# 2. Check Ingress Controller
echo ""
echo "=== Checking Ingress Controller ==="
INGRESS_NS="ingress-nginx"
if kubectl get namespace "${INGRESS_NS}" &>/dev/null; then
    INGRESS_PODS=$(kubectl get pods -n "${INGRESS_NS}" --no-headers 2>/dev/null | grep -c " Running " || echo "0")
    if [ "${INGRESS_PODS}" -gt 0 ]; then
        check_pass "ingress-controller" "Ingress controller running (${INGRESS_PODS} pod(s))"
    else
        check_fail "ingress-controller" "Ingress controller pods not running" "kubectl get pods -n ${INGRESS_NS}; kubectl describe pod -n ${INGRESS_NS}"
    fi
else
    check_warn "ingress-controller" "Ingress namespace not found (${INGRESS_NS})"
fi

# Check ingress service
INGRESS_SVC=$(kubectl get svc -n "${INGRESS_NS}" -l app.kubernetes.io/component=controller 2>/dev/null | grep -v "^NAME" | head -1 | awk '{print $1}' || echo "")
if [ -n "${INGRESS_SVC}" ]; then
    INGRESS_IP=$(kubectl get svc -n "${INGRESS_NS}" "${INGRESS_SVC}" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
    if [ -n "${INGRESS_IP}" ]; then
        check_pass "ingress-lb" "Ingress LoadBalancer IP: ${INGRESS_IP}"
    else
        check_warn "ingress-lb" "Ingress LoadBalancer IP not assigned"
    fi
fi

# 3. Check Cert-Manager
echo ""
echo "=== Checking Cert-Manager ==="
CERT_MANAGER_NS="cert-manager"
if kubectl get namespace "${CERT_MANAGER_NS}" &>/dev/null; then
    CERT_MANAGER_PODS=$(kubectl get pods -n "${CERT_MANAGER_NS}" --no-headers 2>/dev/null | grep -c " Running " || echo "0")
    if [ "${CERT_MANAGER_PODS}" -gt 0 ]; then
        check_pass "cert-manager-pods" "Cert-Manager running (${CERT_MANAGER_PODS} pod(s))"
    else
        check_fail "cert-manager-pods" "Cert-Manager pods not running" "kubectl get pods -n ${CERT_MANAGER_NS}; kubectl describe pod -n ${CERT_MANAGER_NS}"
    fi
    
    # Check certificates
    CERT_COUNT=$(kubectl get certificates -A --no-headers 2>/dev/null | wc -l || echo "0")
    if [ "${CERT_COUNT}" -gt 0 ]; then
        READY_CERTS=$(kubectl get certificates -A --no-headers 2>/dev/null | grep -c " True " || echo "0")
        NOT_READY_CERTS=$(kubectl get certificates -A --no-headers 2>/dev/null | grep -v " True " | wc -l || echo "0")
        
        if [ "${NOT_READY_CERTS}" -gt 0 ]; then
            check_fail "certificates-ready" "${NOT_READY_CERTS} certificate(s) not ready" "kubectl get certificates -A; kubectl describe certificate -n <namespace> <cert-name>"
        else
            check_pass "certificates-ready" "All ${READY_CERTS} certificate(s) ready"
        fi
    else
        check_warn "certificates" "No certificates found"
    fi
    
    # Check certificate issuers
    ISSUER_COUNT=$(kubectl get clusterissuers,issuers -A --no-headers 2>/dev/null | wc -l || echo "0")
    if [ "${ISSUER_COUNT}" -gt 0 ]; then
        READY_ISSUERS=$(kubectl get clusterissuers,issuers -A --no-headers 2>/dev/null | grep -c " True " || echo "0")
        check_pass "issuers" "${READY_ISSUERS} issuer(s) ready"
    else
        check_warn "issuers" "No certificate issuers found"
    fi
else
    check_warn "cert-manager" "Cert-Manager namespace not found (${CERT_MANAGER_NS})"
fi

# 4. Check DNS
echo ""
echo "=== Checking DNS ==="
# Check CoreDNS
COREDNS_NS="kube-system"
COREDNS_PODS=$(kubectl get pods -n "${COREDNS_NS}" -l k8s-app=kube-dns --no-headers 2>/dev/null | grep -c " Running " || echo "0")
if [ "${COREDNS_PODS}" -gt 0 ]; then
    check_pass "coredns" "CoreDNS running (${COREDNS_PODS} pod(s))"
else
    check_fail "coredns" "CoreDNS pods not running" "kubectl get pods -n ${COREDNS_NS} -l k8s-app=kube-dns"
fi

# Test DNS resolution (if test pod can be created)
# Use timeout to prevent hanging
DNS_TEST_OUTPUT=$(timeout 15 kubectl run dns-test-${TIMESTAMP} --image=busybox:1.36 --rm -i --restart=Never -- nslookup kubernetes.default 2>&1 || echo "FAIL")
if echo "${DNS_TEST_OUTPUT}" | grep -q "kubernetes.default"; then
    check_pass "dns-resolution" "DNS resolution working"
else
    # Cleanup pod if it wasn't cleaned up automatically
    kubectl delete pod dns-test-${TIMESTAMP} --ignore-not-found=true &>/dev/null || true
    check_warn "dns-resolution" "DNS resolution test inconclusive (may require manual verification)"
fi

# 5. Check critical namespaces
echo ""
echo "=== Checking Critical Namespaces ==="
CRITICAL_NS=("kube-system" "kube-public" "kube-node-lease")
for ns in "${CRITICAL_NS[@]}"; do
    if kubectl get namespace "${ns}" &>/dev/null; then
        check_pass "namespace-${ns}" "Namespace ${ns} exists"
    else
        check_fail "namespace-${ns}" "Namespace ${ns} not found" "kubectl create namespace ${ns}"
    fi
done

# 6. Check system pods
echo ""
echo "=== Checking System Pods ==="
SYSTEM_PODS_NOT_READY=$(kubectl get pods -n kube-system --no-headers 2>/dev/null | grep -v " Running " | grep -v " Completed " | wc -l || echo "0")
if [ "${SYSTEM_PODS_NOT_READY}" -gt 0 ]; then
    check_fail "system-pods" "${SYSTEM_PODS_NOT_READY} system pod(s) not ready" "kubectl get pods -n kube-system; kubectl describe pod -n kube-system <pod-name>"
else
    check_pass "system-pods" "All system pods ready"
fi

# 7. Check API server
echo ""
echo "=== Checking API Server ==="
API_SERVER=$(kubectl cluster-info | grep "Kubernetes control plane" | awk '{print $NF}' || echo "")
if [ -n "${API_SERVER}" ]; then
    if curl -k -s -o /dev/null -w "%{http_code}" "${API_SERVER}/healthz" | grep -q "200"; then
        check_pass "api-server" "API server healthy"
    else
        check_fail "api-server" "API server health check failed" "kubectl cluster-info"
    fi
else
    check_warn "api-server" "Cannot determine API server URL"
fi

# Generate JSON report
cat > "${JSON_FILE}" <<EOF
{
  "timestamp": "${TIMESTAMP}",
  "cluster": "$(kubectl config current-context 2>/dev/null || echo 'unknown')",
  "checks": {
$(for key in "${!CHECKS[@]}"; do
    echo "    \"${key}\": \"${CHECKS[$key]}\","
done | sed '$ s/,$//')
  },
  "summary": {
    "total": ${#CHECKS[@]},
    "passed": $(echo "${CHECKS[@]}" | grep -o "PASS" | wc -l),
    "failed": $(echo "${CHECKS[@]}" | grep -o "FAIL" | wc -l),
    "warnings": $(echo "${CHECKS[@]}" | grep -o "WARN" | wc -l)
  },
  "errors": [
$(for error in "${ERRORS[@]}"; do
    echo "    \"${error}\","
done | sed '$ s/,$//')
  ],
  "warnings": [
$(for warning in "${WARNINGS[@]}"; do
    echo "    \"${warning}\","
done | sed '$ s/,$//')
  ],
  "action_items": [
$(for item in "${ACTION_ITEMS[@]}"; do
    IFS='|' read -r name message cmd <<< "${item}"
    echo "    {\"check\": \"${name}\", \"message\": \"${message}\", \"command\": \"${cmd}\"},"
done | sed '$ s/,$//')
  ]
}
EOF

# Generate HTML report
cat > "${REPORT_FILE}" <<EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kubernetes Cluster Health Check Report</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
        }
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .summary-card {
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .summary-card.total { background-color: #e3f2fd; }
        .summary-card.passed { background-color: #e8f5e9; }
        .summary-card.failed { background-color: #ffebee; }
        .summary-card.warnings { background-color: #fff3e0; }
        .summary-card h3 {
            margin: 0;
            font-size: 2em;
            color: #333;
        }
        .summary-card p {
            margin: 5px 0 0 0;
            color: #666;
        }
        .check-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
        }
        .check-item.pass {
            background-color: #e8f5e9;
            border-left: 4px solid #4CAF50;
        }
        .check-item.fail {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
        }
        .check-item.warn {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
        }
        .status-icon {
            font-size: 1.5em;
            margin-right: 10px;
        }
        .action-items {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }
        .action-items h3 {
            margin-top: 0;
            color: #856404;
        }
        .action-item {
            background: white;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 3px solid #ff9800;
        }
        .action-item strong {
            color: #f44336;
        }
        .command {
            background-color: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-top: 5px;
            word-break: break-all;
        }
        .timestamp {
            color: #666;
            font-size: 0.9em;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kubernetes Cluster Health Check Report</h1>
        <p class="timestamp">Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")</p>
        <p class="timestamp">Cluster: $(kubectl config current-context 2>/dev/null || echo 'unknown')</p>
        
        <div class="summary">
            <div class="summary-card total">
                <h3>${#CHECKS[@]}</h3>
                <p>Total Checks</p>
            </div>
            <div class="summary-card passed">
                <h3>$(echo "${CHECKS[@]}" | grep -o "PASS" | wc -l)</h3>
                <p>Passed</p>
            </div>
            <div class="summary-card failed">
                <h3>$(echo "${CHECKS[@]}" | grep -o "FAIL" | wc -l)</h3>
                <p>Failed</p>
            </div>
            <div class="summary-card warnings">
                <h3>$(echo "${CHECKS[@]}" | grep -o "WARN" | wc -l)</h3>
                <p>Warnings</p>
            </div>
        </div>
        
        <h2>Check Results</h2>
        <table>
            <thead>
                <tr>
                    <th>Check</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
$(for key in $(printf '%s\n' "${!CHECKS[@]}" | sort); do
    status="${CHECKS[$key]}"
    case "${status}" in
        PASS)
            echo "                <tr><td>${key}</td><td><span class=\"status-icon\">✓</span> Pass</td></tr>"
            ;;
        FAIL)
            echo "                <tr><td>${key}</td><td><span class=\"status-icon\">✗</span> Fail</td></tr>"
            ;;
        WARN)
            echo "                <tr><td>${key}</td><td><span class=\"status-icon\">⚠</span> Warning</td></tr>"
            ;;
    esac
done)
            </tbody>
        </table>
        
$(if [ ${#ACTION_ITEMS[@]} -gt 0 ]; then
cat <<ACTION_EOF
        <div class="action-items">
            <h3>Action Items</h3>
            <p>The following issues were detected and require attention:</p>
$(for item in "${ACTION_ITEMS[@]}"; do
    IFS='|' read -r name message cmd <<< "${item}"
    echo "            <div class=\"action-item\">"
    echo "                <strong>${name}</strong>: ${message}"
    if [ "${cmd}" != "N/A" ]; then
        echo "                <div class=\"command\">${cmd}</div>"
    fi
    echo "            </div>"
done)
        </div>
ACTION_EOF
fi)

$(if [ ${#WARNINGS[@]} -gt 0 ]; then
cat <<WARN_EOF
        <h2>Warnings</h2>
        <ul>
$(for warning in "${WARNINGS[@]}"; do
    echo "            <li>${warning}</li>"
done)
        </ul>
WARN_EOF
fi)

        <h2>Cluster Information</h2>
        <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto;">
$(kubectl cluster-info 2>/dev/null || echo "Cluster info not available")
        </pre>
        
        <h2>Node Information</h2>
        <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto;">
$(kubectl get nodes -o wide 2>/dev/null || echo "Node info not available")
        </pre>
    </div>
</body>
</html>
EOF

# Copy reports to artifacts
cp "${REPORT_FILE}" "${ARTIFACTS_DIR}/" || true
cp "${JSON_FILE}" "${ARTIFACTS_DIR}/" || true

echo ""
echo "=== Health Check Complete ==="
echo "HTML Report: ${REPORT_FILE}"
echo "JSON Report: ${JSON_FILE}"
echo "Artifacts: ${ARTIFACTS_DIR}/"

# Exit with error code if there are failures
if [ ${#ERRORS[@]} -gt 0 ]; then
    echo ""
    echo "Health check completed with ${#ERRORS[@]} error(s). See report for details."
    exit 1
else
    echo ""
    echo "All health checks passed!"
    exit 0
fi
</file>

<file path="ops/scripts/README.md">
# Operations Scripts

Скрипты для операций и диагностики Kubernetes кластера.

## k8s-healthcheck.sh

Комплексная проверка здоровья Kubernetes кластера с генерацией HTML-отчёта.

### Использование

```bash
# Локально
./ops/scripts/k8s-healthcheck.sh

# Через Makefile
make k8s-healthcheck

# Из debug toolbox pod
make k8s-healthcheck-debug
```

### Проверки

1. **Nodes** — количество и статус узлов, версии, ресурсы
2. **Ingress Controller** — статус pods и LoadBalancer
3. **Cert-Manager** — статус pods, сертификатов и issuers
4. **DNS** — CoreDNS pods и разрешение DNS
5. **Critical Namespaces** — наличие системных namespace'ов
6. **System Pods** — статус системных pods
7. **API Server** — проверка доступности API сервера

### Отчёты

Скрипт генерирует:
- **HTML-отчёт** (`healthcheck-report-*.html`) — визуальный отчёт с результатами проверок
- **JSON-отчёт** (`healthcheck-*.json`) — структурированные данные для автоматизации

### Action Items

При обнаружении проблем скрипт формирует список действий с командами для исправления.

### GitLab CI

Интегрирован в GitLab CI как manual job `k8s:healthcheck`. Отчёты сохраняются в artifacts и доступны в UI.

## setup-twc-cluster.sh

Автоматическая настройка доступа к Kubernetes кластеру в Timeweb Cloud.

### Использование

```bash
# Настроить доступ к кластеру ois-cfa-k8s
./ops/scripts/setup-twc-cluster.sh

# Или указать имя кластера
./ops/scripts/setup-twc-cluster.sh my-cluster-name
```

### Что делает скрипт

1. Проверяет установку `twc` CLI
2. Находит токен (из переменной окружения или terraform.tfvars)
3. Проверяет аутентификацию с Timeweb Cloud
4. Находит кластер по имени
5. Показывает детали кластера и node groups
6. Экспортирует kubeconfig
7. Проверяет подключение к кластеру

### Требования

- Установленный `twc` CLI (см. `tools/timeweb/install.sh`)
- Токен Timeweb Cloud API (см. `docs/ops/timeweb/twc-setup.md`)
- `kubectl` (опционально, для проверки подключения)
- `jq` (опционально, для парсинга JSON)

### Пример вывода

```
=== Timeweb Cloud Cluster Setup ===
Cluster name: ois-cfa-k8s

=== Verifying twc configuration ===
✓ Authentication successful

=== Available Kubernetes Clusters ===
ID          Name           Status    Version
12345       ois-cfa-k8s   active    1.28

=== Finding cluster: ois-cfa-k8s ===
✓ Found cluster ID: 12345

=== Cluster Details ===
...

=== Exporting Kubeconfig ===
✓ Kubeconfig exported to: ops/infra/timeweb/kubeconfig.yaml

=== Verifying Kubeconfig ===
✓ Successfully connected to cluster
```

### Troubleshooting

**Ошибка: "TWC_TOKEN is not set"**
- Установите токен: `export TWC_TOKEN='your-token'`
- Или создайте `terraform.tfvars` с токеном

**Ошибка: "Cluster not found"**
- Проверьте список кластеров: `twc k8s list`
- Создайте кластер через Terraform: `cd ops/infra/timeweb && terraform apply`

**Ошибка: "Failed to authenticate"**
- Проверьте правильность токена
- Убедитесь, что токен имеет права `k8s:read` и `k8s:write`

## Другие скрипты

- `backup.sh` — резервное копирование
- `create-helm-chart.sh` — создание Helm charts
- `test-restore.sh` — тестирование восстановления
</file>

<file path="ops/scripts/restore.md">
# PostgreSQL Restore Guide

## Prerequisites

- PostgreSQL client tools installed (`pg_dump`, `psql`)
- Access to backup file (`.sql.gz`)
- Database credentials

## Restore Steps

### 1. Prepare Environment

```bash
export POSTGRES_HOST=postgres
export POSTGRES_PORT=5432
export POSTGRES_DB=ois
export POSTGRES_USER=ois
export POSTGRES_PASSWORD=ois_dev_password
```

### 2. Stop Application Services (Optional)

```bash
docker-compose stop api-gateway issuance-service registry-service settlement-service compliance-service
```

### 3. Restore Backup

```bash
# Restore from compressed backup
gunzip < backups/ois_backup_YYYYMMDD_HHMMSS.sql.gz | \
    PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d $POSTGRES_DB

# Or restore from uncompressed
PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d $POSTGRES_DB < backup.sql
```

### 4. Verify Restore

```bash
# Check table count
PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d $POSTGRES_DB \
    -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';"

# Check sample data
PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d $POSTGRES_DB \
    -c "SELECT COUNT(*) FROM issuances;"
```

### 5. Restart Services

```bash
docker-compose start api-gateway issuance-service registry-service settlement-service compliance-service
```

## Restore to Fresh Database Container

### 1. Create Fresh Container

```bash
docker-compose stop postgres
docker volume rm capital_postgres_data  # WARNING: Deletes existing data
docker-compose up -d postgres
```

### 2. Wait for PostgreSQL to be Ready

```bash
docker-compose exec postgres pg_isready -U ois
```

### 3. Restore Backup

```bash
./ops/scripts/restore.sh backups/ois_backup_YYYYMMDD_HHMMSS.sql.gz
```

## Automated Test Restore Script

See `ops/scripts/test-restore.sh` for automated restore testing.
</file>

<file path="ops/scripts/setup-kubeconfig.sh">
#!/bin/bash
# Setup kubeconfig for Kubernetes cluster
# Usage: ./ops/scripts/setup-kubeconfig.sh

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"

echo -e "${BLUE}=== Kubernetes Kubeconfig Setup ===${NC}"
echo ""

# Check kubectl
if ! command -v kubectl &> /dev/null; then
    echo -e "${RED}✗ kubectl is not installed${NC}"
    echo "Install kubectl: https://kubernetes.io/docs/tasks/tools/"
    exit 1
fi
echo -e "${GREEN}✓ kubectl is installed${NC}"

# Check if kubeconfig already works
if kubectl cluster-info &>/dev/null 2>&1; then
    echo -e "${GREEN}✓ kubeconfig is already configured and working${NC}"
    echo ""
    echo "Current cluster:"
    kubectl cluster-info | head -1
    echo ""
    echo "Nodes:"
    kubectl get nodes 2>/dev/null | head -3 || echo "  (Cannot list nodes - may need permissions)"
    exit 0
fi

echo -e "${YELLOW}⚠ kubeconfig is not configured${NC}"
echo ""

# Check if kubeconfig file exists
if [ -f "$KUBECONFIG_FILE" ]; then
    echo -e "${GREEN}✓ Found kubeconfig file: $KUBECONFIG_FILE${NC}"
    echo ""
    echo "Setting KUBECONFIG environment variable..."
    export KUBECONFIG="$KUBECONFIG_FILE"
    
    if kubectl cluster-info &>/dev/null 2>&1; then
        echo -e "${GREEN}✓ kubeconfig file is valid and working!${NC}"
        echo ""
        echo "To use this kubeconfig in current session:"
        echo -e "${BLUE}  export KUBECONFIG=\"$KUBECONFIG_FILE\"${NC}"
        echo ""
        echo "To make it permanent, add to ~/.bashrc or ~/.zshrc:"
        echo -e "${BLUE}  echo 'export KUBECONFIG=\"$KUBECONFIG_FILE\"' >> ~/.bashrc${NC}"
        exit 0
    else
        echo -e "${YELLOW}⚠ kubeconfig file exists but cannot connect to cluster${NC}"
        echo "  File may be outdated or cluster may be unavailable"
    fi
fi

# Try to export from Timeweb Cloud
echo "Attempting to export kubeconfig from Timeweb Cloud..."
echo ""

# Check twc CLI
if ! command -v twc &> /dev/null; then
    if [ -f "${HOME}/.local/bin/twc" ]; then
        export PATH="${HOME}/.local/bin:${PATH}"
    else
        echo -e "${RED}✗ twc CLI is not installed${NC}"
        echo ""
        echo "To install twc CLI:"
        echo "  ./tools/timeweb/install.sh"
        echo ""
        echo "Or manually:"
        echo "  pip install --user twc-cli"
        echo "  export PATH=\"\${HOME}/.local/bin:\${PATH}\""
        exit 1
    fi
fi
echo -e "${GREEN}✓ twc CLI is installed${NC}"

# Check TWC_TOKEN or twc config
if [ -z "${TWC_TOKEN:-}" ]; then
    # Check if twc can work without explicit token (may be configured via twc config)
    if ! twc k8s list &>/dev/null; then
        echo -e "${YELLOW}⚠ TWC_TOKEN is not set and twc config is not configured${NC}"
        echo ""
        echo "To get TWC_TOKEN:"
        echo "  1. Go to https://timeweb.cloud"
        echo "  2. API → Токены доступа"
        echo "  3. Create new token with permissions: k8s:read, k8s:write"
        echo ""
        echo "Then set it:"
        echo -e "${BLUE}  export TWC_TOKEN='your-token-here'${NC}"
        echo ""
        echo "Or configure twc:"
        echo -e "${BLUE}  twc config set token 'your-token-here'${NC}"
        exit 1
    else
        echo -e "${GREEN}✓ twc CLI is configured (token via twc config)${NC}"
    fi
else
    echo -e "${GREEN}✓ TWC_TOKEN is set${NC}"
fi

# Try to export kubeconfig
echo ""
echo "Exporting kubeconfig..."
if [ -f "${PROJECT_ROOT}/tools/timeweb/kubeconfig-export.sh" ]; then
    "${PROJECT_ROOT}/tools/timeweb/kubeconfig-export.sh" ois-cfa-k8s
else
    echo -e "${RED}✗ kubeconfig-export.sh not found${NC}"
    exit 1
fi

# Set KUBECONFIG
if [ -f "$KUBECONFIG_FILE" ]; then
    export KUBECONFIG="$KUBECONFIG_FILE"
    echo ""
    echo -e "${GREEN}✓ Kubeconfig exported successfully${NC}"
    echo ""
    echo "Testing connection..."
    if kubectl cluster-info &>/dev/null 2>&1; then
        echo -e "${GREEN}✓ Successfully connected to cluster!${NC}"
        echo ""
        echo "Cluster info:"
        kubectl cluster-info | head -3
        echo ""
        echo "To use this kubeconfig in current session:"
        echo -e "${BLUE}  export KUBECONFIG=\"$KUBECONFIG_FILE\"${NC}"
        echo ""
        echo "To make it permanent, add to ~/.bashrc or ~/.zshrc:"
        echo -e "${BLUE}  echo 'export KUBECONFIG=\"$KUBECONFIG_FILE\"' >> ~/.bashrc${NC}"
    else
        echo -e "${YELLOW}⚠ Kubeconfig exported but cannot connect to cluster${NC}"
        echo "  Cluster may be still provisioning or unavailable"
        echo ""
        echo "You can still use the kubeconfig file:"
        echo -e "${BLUE}  export KUBECONFIG=\"$KUBECONFIG_FILE\"${NC}"
    fi
else
    echo -e "${RED}✗ Failed to export kubeconfig${NC}"
    exit 1
fi
</file>

<file path="ops/scripts/setup-twc-cluster.sh">
#!/bin/bash
# Setup Timeweb Cloud cluster access and get configuration
# Usage: ./ops/scripts/setup-twc-cluster.sh [cluster-name]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
CLUSTER_NAME="${1:-ois-cfa-k8s}"

# Ensure twc is in PATH
export PATH="${HOME}/.local/bin:${PATH}"

echo "=== Timeweb Cloud Cluster Setup ==="
echo "Cluster name: ${CLUSTER_NAME}"
echo ""

# Check if twc is installed
if ! command -v twc &> /dev/null; then
    echo "Error: twc CLI is not installed."
    echo "Installing twc..."
    "${PROJECT_ROOT}/tools/timeweb/install.sh"
    export PATH="${HOME}/.local/bin:${PATH}"
fi

# Check for token
TWC_TOKEN="${TWC_TOKEN:-}"
if [ -z "${TWC_TOKEN}" ]; then
    # Try to get from terraform.tfvars
    if [ -f "${PROJECT_ROOT}/ops/infra/timeweb/terraform.tfvars" ]; then
        echo "Reading token from terraform.tfvars..."
        TWC_TOKEN=$(grep -E "^twc_token" "${PROJECT_ROOT}/ops/infra/timeweb/terraform.tfvars" | sed 's/twc_token = "\(.*\)"/\1/' | tr -d ' ')
    fi
fi

if [ -z "${TWC_TOKEN}" ]; then
    echo "Error: TWC_TOKEN is not set."
    echo ""
    echo "Please set it using one of the following methods:"
    echo "1. Environment variable:"
    echo "   export TWC_TOKEN='your-token-here'"
    echo ""
    echo "2. Configure twc:"
    echo "   twc config set token 'your-token-here'"
    echo ""
    echo "3. Or create terraform.tfvars with token:"
    echo "   cp ops/infra/timeweb/terraform.tfvars.example ops/infra/timeweb/terraform.tfvars"
    echo "   # Edit terraform.tfvars and set twc_token"
    exit 1
fi

# Set token for twc
export TWC_TOKEN="${TWC_TOKEN}"

echo "=== Verifying twc configuration ==="
if ! twc k8s list &>/dev/null; then
    echo "Error: Failed to authenticate with Timeweb Cloud."
    echo "Please check your TWC_TOKEN."
    exit 1
fi

echo "✓ Authentication successful"
echo ""

# List clusters
echo "=== Available Kubernetes Clusters ==="
twc k8s list
echo ""

# Get cluster ID
echo "=== Finding cluster: ${CLUSTER_NAME} ==="
CLUSTER_ID=$(twc k8s list --format json 2>/dev/null | jq -r ".[] | select(.name == \"${CLUSTER_NAME}\") | .id" 2>/dev/null || echo "")

if [ -z "${CLUSTER_ID}" ] || [ "${CLUSTER_ID}" == "null" ]; then
    echo "Warning: Cluster '${CLUSTER_NAME}' not found."
    echo ""
    echo "Available clusters:"
    twc k8s list
    echo ""
    echo "To create a new cluster, use Terraform:"
    echo "  cd ops/infra/timeweb"
    echo "  terraform init"
    echo "  terraform plan"
    echo "  terraform apply"
    exit 1
fi

echo "✓ Found cluster ID: ${CLUSTER_ID}"
echo ""

# Get cluster details
echo "=== Cluster Details ==="
twc k8s show "${CLUSTER_ID}" 2>/dev/null || twc k8s list --format json | jq ".[] | select(.id == \"${CLUSTER_ID}\")"
echo ""

# Get node groups
echo "=== Node Groups ==="
twc k8s group list --cluster-id "${CLUSTER_ID}" 2>/dev/null || echo "No node groups found or command not available"
echo ""

# Export kubeconfig
echo "=== Exporting Kubeconfig ==="
KUBECONFIG_FILE="${PROJECT_ROOT}/ops/infra/timeweb/kubeconfig.yaml"
twc k8s kubeconfig "${CLUSTER_ID}" > "${KUBECONFIG_FILE}" 2>/dev/null || \
twc k8s cluster kubeconfig "${CLUSTER_ID}" > "${KUBECONFIG_FILE}" 2>/dev/null || \
(twc k8s cluster get-kubeconfig "${CLUSTER_ID}" > "${KUBECONFIG_FILE}" 2>/dev/null && echo "Using get-kubeconfig command")

if [ $? -eq 0 ] && [ -f "${KUBECONFIG_FILE}" ]; then
    chmod 600 "${KUBECONFIG_FILE}"
    echo "✓ Kubeconfig exported to: ${KUBECONFIG_FILE}"
    echo ""
    
    # Verify kubeconfig
    if command -v kubectl &> /dev/null; then
        echo "=== Verifying Kubeconfig ==="
        export KUBECONFIG="${KUBECONFIG_FILE}"
        if kubectl cluster-info --request-timeout=10s &>/dev/null; then
            echo "✓ Successfully connected to cluster"
            echo ""
            echo "Cluster information:"
            kubectl cluster-info | head -3
            echo ""
            echo "Nodes:"
            kubectl get nodes
            echo ""
            echo "To use this kubeconfig:"
            echo "  export KUBECONFIG=\"${KUBECONFIG_FILE}\""
            echo "  kubectl get nodes"
        else
            echo "⚠ Warning: Could not connect to cluster (may be still provisioning)"
        fi
    else
        echo "kubectl not found. Install kubectl to verify connection."
    fi
else
    echo "Error: Failed to export kubeconfig"
    echo "Trying alternative method..."
    "${PROJECT_ROOT}/tools/timeweb/kubeconfig-export.sh" "${CLUSTER_NAME}" "${KUBECONFIG_FILE}"
fi

echo ""
echo "=== Setup Complete ==="
echo "Kubeconfig: ${KUBECONFIG_FILE}"
echo "Cluster ID: ${CLUSTER_ID}"
echo "Cluster Name: ${CLUSTER_NAME}"
</file>

<file path="ops/scripts/test-restore.sh">
#!/bin/bash
set -euo pipefail

# Test restore into fresh DB container
# Usage: ./test-restore.sh <backup_file>

BACKUP_FILE="${1:-}"
if [ -z "$BACKUP_FILE" ]; then
    echo "Usage: $0 <backup_file>"
    exit 1
fi

if [ ! -f "$BACKUP_FILE" ]; then
    echo "Error: Backup file not found: $BACKUP_FILE"
    exit 1
fi

echo "Testing restore of $BACKUP_FILE"

# Export connection params
export POSTGRES_HOST=localhost
export POSTGRES_PORT=5432
export POSTGRES_DB=ois_test
export POSTGRES_USER=ois
export POSTGRES_PASSWORD=ois_dev_password

export PGPASSWORD="$POSTGRES_PASSWORD"

# Create test database (if using existing container)
psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d postgres \
    -c "DROP DATABASE IF EXISTS $POSTGRES_DB;" || true

psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d postgres \
    -c "CREATE DATABASE $POSTGRES_DB;"

# Restore
echo "Restoring backup..."
gunzip < "$BACKUP_FILE" | \
    psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB"

# Verify
echo "Verifying restore..."
TABLE_COUNT=$(psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB" \
    -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")

if [ "$TABLE_COUNT" -gt 0 ]; then
    echo "✅ Restore successful! Found $TABLE_COUNT tables."
    exit 0
else
    echo "❌ Restore failed: No tables found"
    exit 1
fi
</file>

<file path="ops/scripts/validate-specs.sh">
#!/usr/bin/env bash
set -euo pipefail

# Validate OpenAPI, AsyncAPI, and JSON Schemas without requiring global installs.
# It bootstraps a local Node.js (v20) toolchain in .tools if needed.

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
TOOLS_DIR="$ROOT_DIR/.tools"
NODE_VERSION="v20.17.0"
NODE_DIR="$TOOLS_DIR/node-${NODE_VERSION}-linux-x64"
NODE_BIN="$NODE_DIR/bin"

mkdir -p "$TOOLS_DIR"

need_node_install() {
  if [ -x "$NODE_BIN/node" ]; then
    # Check version >= 18
    local v
    v=$($NODE_BIN/node -v | sed 's/v//; s/\..*//')
    if [ "$v" -ge 18 ]; then
      return 1 # no install needed
    fi
  fi
  return 0
}

if need_node_install; then
  echo "Bootstrapping Node.js v20 locally under $NODE_DIR ..."
  OS="linux"
  ARCH="x64"
  URL="https://nodejs.org/dist/${NODE_VERSION}/node-${NODE_VERSION}-${OS}-${ARCH}.tar.xz"
  TMP_TAR="$TOOLS_DIR/node-${NODE_VERSION}-${OS}-${ARCH}.tar.xz"

  rm -rf "$NODE_DIR"
  curl -fsSL "$URL" -o "$TMP_TAR"
  tar -xJf "$TMP_TAR" -C "$TOOLS_DIR"
  rm -f "$TMP_TAR"
fi

export PATH="$NODE_BIN:$PATH"

echo "Using Node: $(node -v)" >&2
echo "Using npm:  $(npm -v)" >&2

cd "$ROOT_DIR"

echo "\n[1/3] Spectral: lint OpenAPI specs (custom minimal ruleset)" >&2
npx -y @stoplight/spectral-cli@6 lint -r .spectral.yaml packages/contracts/openapi-*.yaml

echo "\n[2/3] AsyncAPI: validate asyncapi.yaml" >&2
npx -y @asyncapi/cli@2 validate packages/contracts/asyncapi.yaml

echo "\n[3/3] AJV: compile JSON Schemas" >&2
AJV_OK=true
for schema in packages/contracts/schemas/*.json; do
  echo "Compiling $schema" >&2
  if ! npx -y ajv-cli@5 compile --validate-formats=false --strict=false -s "$schema"; then
    AJV_OK=false
    break
  fi
done

if [ "$AJV_OK" != true ]; then
  echo "AJV schema compilation failed" >&2
  exit 1
fi

echo "\nAll spec validations passed." >&2
</file>

<file path="packages/contracts/schemas/AuditEvent.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "AuditEvent",
  "description": "Схема события аудита",
  "type": "object",
  "required": ["id", "actorId", "action", "entity", "timestamp"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор события аудита"
    },
    "actorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор пользователя, выполнившего действие"
    },
    "action": {
      "type": "string",
      "enum": ["create", "update", "delete", "read", "execute"],
      "description": "Тип действия"
    },
    "entity": {
      "type": "string",
      "enum": ["issuance", "order", "wallet", "payout", "user", "asset", "transfer"],
      "description": "Тип сущности"
    },
    "entityId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор сущности"
    },
    "payload": {
      "type": ["object", "null"],
      "description": "Дополнительные данные события (изменённые поля, значения и т.д.)"
    },
    "ip": {
      "type": ["string", "null"],
      "format": "ipv4",
      "description": "IP-адрес источника запроса"
    },
    "userAgent": {
      "type": ["string", "null"],
      "description": "User-Agent браузера/клиента"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "Временная метка события"
    },
    "correlationId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор корреляции запроса"
    },
    "result": {
      "type": ["string", "null"],
      "enum": ["success", "failure", "denied"],
      "description": "Результат действия"
    },
    "errorMessage": {
      "type": ["string", "null"],
      "description": "Сообщение об ошибке (если результат failure)"
    }
  }
}
</file>

<file path="packages/contracts/schemas/BrokerClient.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "BrokerClient",
  "description": "Клиент брокера",
  "type": "object",
  "required": ["id", "name", "email", "kycStatus", "qualificationStatus"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "name": {
      "type": "string",
      "description": "Имя клиента"
    },
    "email": {
      "type": "string",
      "format": "email"
    },
    "inn": {
      "type": "string",
      "description": "ИНН (для юридических лиц)"
    },
    "type": {
      "type": "string",
      "enum": ["individual", "legal_entity"],
      "description": "Тип клиента"
    },
    "kycStatus": {
      "type": "string",
      "enum": ["pending", "approved", "rejected"],
      "description": "Статус KYC"
    },
    "qualificationStatus": {
      "type": "string",
      "enum": ["none", "qualified", "unqualified"],
      "description": "Статус квалификации инвестора"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time"
    },
    "lastActivityAt": {
      "type": ["string", "null"],
      "format": "date-time"
    }
  }
}
</file>

<file path="packages/contracts/schemas/BrokerOrder.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "BrokerOrder",
  "description": "Заявка брокера от имени клиента",
  "type": "object",
  "required": ["id", "clientId", "issuanceId", "amount", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "clientId": {
      "type": "string",
      "format": "uuid"
    },
    "issuanceId": {
      "type": "string",
      "format": "uuid"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0
    },
    "status": {
      "type": "string",
      "enum": ["pending", "confirmed", "failed", "cancelled"]
    },
    "commission": {
      "type": "number",
      "format": "decimal",
      "description": "Сумма комиссии"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time"
    },
    "brokerId": {
      "type": "string",
      "format": "uuid",
      "description": "ID брокера, создавшего заявку"
    }
  }
}
</file>

<file path="packages/contracts/schemas/CFA.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CFA (Digital Financial Asset)",
  "description": "Схема цифрового финансового актива",
  "type": "object",
  "required": ["id", "code", "name", "type", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор ЦФА"
    },
    "code": {
      "type": "string",
      "pattern": "^[A-Z0-9]{3,20}$",
      "description": "Код ЦФА (символ)"
    },
    "name": {
      "type": "string",
      "minLength": 1,
      "maxLength": 200,
      "description": "Наименование ЦФА"
    },
    "type": {
      "type": "string",
      "enum": ["TOKEN", "BOND", "SHARE", "MONETARY_CLAIM", "OTHER"],
      "description": "Тип ЦФА"
    },
    "description": {
      "type": "string",
      "maxLength": 5000,
      "description": "Описание ЦФА"
    },
    "issuerId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор эмитента"
    },
    "totalSupply": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Общий объём выпуска"
    },
    "issuedAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Выпущенный объём"
    },
    "status": {
      "type": "string",
      "enum": ["DRAFT", "ACTIVE", "SUSPENDED", "CANCELLED"],
      "description": "Статус ЦФА"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата обновления"
    },
    "activatedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата активации"
    }
  }
}
</file>

<file path="packages/contracts/schemas/CommissionRow.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CommissionRow",
  "description": "Строка отчета по комиссиям брокера",
  "type": "object",
  "required": ["period", "totalAmount", "commissionAmount", "ordersCount"],
  "properties": {
    "period": {
      "type": "string",
      "description": "Период (YYYY-MM или YYYY-MM-DD)"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Общая сумма заявок"
    },
    "commissionAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Заработанная комиссия"
    },
    "ordersCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество заявок"
    },
    "clientsCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество уникальных клиентов"
    }
  }
}
</file>

<file path="packages/contracts/schemas/Complaint.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Complaint",
  "description": "Схема жалобы",
  "type": "object",
  "required": ["id", "category", "text", "status", "createdAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор жалобы"
    },
    "investorId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор инвестора (null для анонимных)"
    },
    "category": {
      "type": "string",
      "enum": ["fraud", "service", "technical", "other"],
      "description": "Категория жалобы"
    },
    "text": {
      "type": "string",
      "minLength": 10,
      "maxLength": 5000,
      "description": "Текст жалобы"
    },
    "status": {
      "type": "string",
      "enum": ["open", "in_progress", "resolved", "closed"],
      "description": "Статус обработки"
    },
    "slaDue": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Срок SLA"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания"
    },
    "resolvedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата разрешения"
    }
  }
}
</file>

<file path="packages/contracts/schemas/FeedItem.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "FeedItem",
  "description": "Элемент ленты активности брокера",
  "type": "object",
  "required": ["id", "type", "timestamp"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "type": {
      "type": "string",
      "enum": ["order", "transfer", "payout", "kyc", "qualification"],
      "description": "Тип события"
    },
    "title": {
      "type": "string",
      "description": "Заголовок события"
    },
    "description": {
      "type": "string",
      "description": "Описание события"
    },
    "clientId": {
      "type": ["string", "null"],
      "format": "uuid"
    },
    "clientName": {
      "type": ["string", "null"]
    },
    "issuanceId": {
      "type": ["string", "null"],
      "format": "uuid"
    },
    "amount": {
      "type": ["number", "null"],
      "format": "decimal"
    },
    "status": {
      "type": ["string", "null"],
      "enum": ["pending", "completed", "failed"]
    },
    "timestamp": {
      "type": "string",
      "format": "date-time"
    },
    "metadata": {
      "type": "object",
      "description": "Дополнительные данные события",
      "additionalProperties": true
    }
  }
}
</file>

<file path="packages/contracts/schemas/Holding.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Holding",
  "description": "Схема владения ЦФА",
  "type": "object",
  "required": ["issuanceId", "quantity"],
  "properties": {
    "issuanceId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор выпуска"
    },
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "quantity": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Количество ЦФА"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата последнего обновления"
    }
  }
}
</file>

<file path="packages/contracts/schemas/Issuance.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Issuance",
  "description": "Схема выпуска ЦФА",
  "type": "object",
  "required": ["id", "assetId", "issuerId", "totalAmount", "nominal", "issueDate", "maturityDate", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор выпуска"
    },
    "assetId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор ЦФА"
    },
    "issuerId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор эмитента"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Общая сумма выпуска"
    },
    "nominal": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Номинальная стоимость единицы"
    },
    "issueDate": {
      "type": "string",
      "format": "date",
      "description": "Дата выпуска"
    },
    "maturityDate": {
      "type": "string",
      "format": "date",
      "description": "Дата погашения"
    },
    "status": {
      "type": "string",
      "enum": ["draft", "published", "closed", "redeemed"],
      "description": "Статус выпуска"
    },
    "scheduleJson": {
      "type": ["object", "null"],
      "description": "График выплат (JSON объект)"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата обновления"
    },
    "publishedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата публикации"
    },
    "closedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата закрытия"
    }
  }
}
</file>

<file path="packages/contracts/schemas/IssuerReportRow.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "IssuerReportRow",
  "description": "Строка отчета эмитента по выпускам",
  "type": "object",
  "required": ["issuanceId", "assetCode", "assetName", "totalAmount", "soldAmount", "investorsCount", "status", "issueDate", "maturityDate"],
  "properties": {
    "issuanceId": {
      "type": "string",
      "format": "uuid"
    },
    "assetCode": {
      "type": "string"
    },
    "assetName": {
      "type": "string"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0
    },
    "soldAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Проданная сумма"
    },
    "investorsCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество инвесторов"
    },
    "status": {
      "type": "string",
      "enum": ["draft", "published", "closed", "redeemed"]
    },
    "issueDate": {
      "type": "string",
      "format": "date"
    },
    "maturityDate": {
      "type": "string",
      "format": "date"
    },
    "publishedAt": {
      "type": ["string", "null"],
      "format": "date-time"
    }
  }
}
</file>

<file path="packages/contracts/schemas/KycDecision.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "KycDecision",
  "description": "Решение по KYC",
  "type": "object",
  "required": ["id", "investorId", "status", "comment", "decisionBy", "decisionAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "investorId": {
      "type": "string",
      "format": "uuid"
    },
    "status": {
      "type": "string",
      "enum": ["approved", "rejected"],
      "description": "Статус решения"
    },
    "comment": {
      "type": "string",
      "description": "Комментарий к решению"
    },
    "decisionBy": {
      "type": "string",
      "format": "uuid",
      "description": "ID пользователя, принявшего решение"
    },
    "decisionAt": {
      "type": "string",
      "format": "date-time"
    }
  }
}
</file>

<file path="packages/contracts/schemas/KycDocument.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "KycDocument",
  "description": "Документ KYC",
  "type": "object",
  "required": ["id", "investorId", "documentType", "fileName", "storageUrl", "uploadedAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "investorId": {
      "type": "string",
      "format": "uuid"
    },
    "documentType": {
      "type": "string",
      "enum": ["passport", "inn", "snils", "address_proof", "income_proof", "other"],
      "description": "Тип документа"
    },
    "fileName": {
      "type": "string",
      "description": "Имя файла"
    },
    "fileSize": {
      "type": "integer",
      "minimum": 0,
      "description": "Размер файла в байтах"
    },
    "mimeType": {
      "type": "string",
      "description": "MIME тип файла"
    },
    "storageUrl": {
      "type": "string",
      "format": "uri",
      "description": "URL в хранилище (S3/MinIO)"
    },
    "uploadedAt": {
      "type": "string",
      "format": "date-time"
    },
    "uploadedBy": {
      "type": "string",
      "format": "uuid",
      "description": "ID пользователя, загрузившего документ"
    },
    "comment": {
      "type": ["string", "null"],
      "description": "Комментарий к документу"
    }
  }
}
</file>

<file path="packages/contracts/schemas/KycResult.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "KycResult",
  "description": "Результат проверки KYC",
  "type": "object",
  "required": ["investorId", "status"],
  "properties": {
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "status": {
      "type": "string",
      "enum": ["pass", "fail", "pending", "review"],
      "description": "Статус KYC"
    },
    "checkedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Время проверки"
    },
    "reason": {
      "type": ["string", "null"],
      "description": "Причина (если status=fail или review)"
    }
  }
}
</file>

<file path="packages/contracts/schemas/MarketIssuanceCard.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "MarketIssuanceCard",
  "description": "Карточка выпуска для каталога",
  "type": "object",
  "required": ["id", "assetCode", "assetName", "issuerName", "totalAmount", "nominal", "issueDate", "maturityDate", "yield", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "assetCode": {
      "type": "string",
      "description": "Код актива"
    },
    "assetName": {
      "type": "string",
      "description": "Название актива"
    },
    "issuerName": {
      "type": "string",
      "description": "Название эмитента"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0
    },
    "nominal": {
      "type": "number",
      "format": "decimal",
      "minimum": 0
    },
    "availableAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Доступная для покупки сумма"
    },
    "issueDate": {
      "type": "string",
      "format": "date"
    },
    "maturityDate": {
      "type": "string",
      "format": "date"
    },
    "yield": {
      "type": "number",
      "format": "decimal",
      "description": "Годовая доходность в процентах"
    },
    "status": {
      "type": "string",
      "enum": ["open", "closed"],
      "description": "Статус выпуска на рынке"
    },
    "publishedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата публикации"
    },
    "scheduleJson": {
      "type": ["object", "null"],
      "description": "График выплат"
    }
  }
}
</file>

<file path="packages/contracts/schemas/Order.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Order",
  "description": "Схема заказа на покупку ЦФА",
  "type": "object",
  "required": ["id", "investorId", "issuanceId", "amount", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор заказа"
    },
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "issuanceId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор выпуска"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Сумма заказа"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "confirmed", "failed", "cancelled"],
      "description": "Статус заказа"
    },
    "walletId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор кошелька после подтверждения"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания заказа"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата обновления"
    },
    "confirmedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата подтверждения"
    },
    "failureReason": {
      "type": ["string", "null"],
      "description": "Причина отказа (если статус failed)"
    },
    "idemKey": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Ключ идемпотентности"
    }
  }
}
</file>

<file path="packages/contracts/schemas/Payout.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Payout",
  "description": "Схема выплаты по ЦФА",
  "type": "object",
  "required": ["id", "batchId", "issuanceId", "investorId", "amount", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор выплаты"
    },
    "batchId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор пакета выплат"
    },
    "issuanceId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор выпуска"
    },
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Сумма выплаты"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "executed", "failed"],
      "description": "Статус выплаты"
    },
    "scheduledFor": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Запланированная дата выплаты"
    },
    "executedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата выполнения выплаты"
    },
    "bankTransferId": {
      "type": ["string", "null"],
      "description": "Идентификатор банковского перевода"
    },
    "failureReason": {
      "type": ["string", "null"],
      "description": "Причина ошибки (если статус failed)"
    },
    "metadata": {
      "type": ["object", "null"],
      "description": "Дополнительные данные выплаты"
    }
  }
}
</file>

<file path="packages/contracts/schemas/PayoutBatch.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "PayoutBatch",
  "description": "Схема batch payout",
  "type": "object",
  "required": ["id", "runDate", "totalAmount", "status", "createdAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор batch"
    },
    "runDate": {
      "type": "string",
      "format": "date",
      "description": "Дата выполнения settlement"
    },
    "issuanceId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор выпуска (null если batch для нескольких)"
    },
    "totalAmount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Общая сумма выплат"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "processing", "completed", "failed"],
      "description": "Статус batch"
    },
    "itemCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество items в batch"
    },
    "completedCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество успешно выполненных items"
    },
    "failedCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Количество failed items"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания batch"
    }
  }
}
</file>

<file path="packages/contracts/schemas/PayoutItem.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "PayoutItem",
  "description": "Схема item в batch payout",
  "type": "object",
  "required": ["id", "investorId", "amount", "status"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор item"
    },
    "batchId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор batch"
    },
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Сумма выплаты"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "completed", "failed"],
      "description": "Статус выплаты"
    },
    "bankRef": {
      "type": ["string", "null"],
      "description": "Ссылка на банковскую операцию"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "failureReason": {
      "type": ["string", "null"],
      "description": "Причина ошибки (если status=failed)"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания item"
    }
  }
}
</file>

<file path="packages/contracts/schemas/QualificationResult.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "QualificationResult",
  "description": "Результат оценки квалификации инвестора",
  "type": "object",
  "required": ["investorId", "tier", "allowed"],
  "properties": {
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "tier": {
      "type": "string",
      "enum": ["unqualified", "qualified", "professional"],
      "description": "Уровень квалификации"
    },
    "limit": {
      "type": ["number", "null"],
      "format": "decimal",
      "minimum": 0,
      "description": "Лимит инвестирования (null для unqualified)"
    },
    "used": {
      "type": ["number", "null"],
      "format": "decimal",
      "minimum": 0,
      "description": "Использованный лимит"
    },
    "allowed": {
      "type": "boolean",
      "description": "Разрешена ли операция"
    },
    "reason": {
      "type": ["string", "null"],
      "description": "Причина отказа (если allowed=false)"
    },
    "evaluatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "Время оценки"
    }
  }
}
</file>

<file path="packages/contracts/schemas/ReconciliationReport.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ReconciliationReport",
  "description": "Схема отчёта по reconciliation",
  "type": "object",
  "required": ["batchId", "runDate", "reconciledAt"],
  "properties": {
    "batchId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор batch"
    },
    "runDate": {
      "type": "string",
      "format": "date",
      "description": "Дата settlement"
    },
    "reconciledAt": {
      "type": "string",
      "format": "date-time",
      "description": "Время reconciliation"
    },
    "payload": {
      "type": "object",
      "description": "JSON payload с деталями reconciliation",
      "additionalProperties": true
    },
    "status": {
      "type": "string",
      "enum": ["matched", "mismatch", "partial"],
      "description": "Статус reconciliation"
    }
  }
}
</file>

<file path="packages/contracts/schemas/RegistryTx.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "RegistryTx",
  "description": "Схема транзакции в реестре",
  "type": "object",
  "required": ["id", "type", "amount", "status", "createdAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Уникальный идентификатор транзакции"
    },
    "type": {
      "type": "string",
      "enum": ["transfer", "redeem", "issue"],
      "description": "Тип транзакции"
    },
    "fromWalletId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор кошелька отправителя (null для issue)"
    },
    "toWalletId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор кошелька получателя (null для redeem)"
    },
    "issuanceId": {
      "type": ["string", "null"],
      "format": "uuid",
      "description": "Идентификатор выпуска"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "exclusiveMinimum": 0,
      "description": "Сумма транзакции"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "confirmed", "failed"],
      "description": "Статус транзакции"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "Дата создания транзакции"
    },
    "confirmedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата подтверждения транзакции"
    }
  }
}
</file>

<file path="packages/contracts/schemas/TxHistoryItem.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "TxHistoryItem",
  "description": "Элемент истории транзакций инвестора",
  "type": "object",
  "required": ["id", "type", "issuanceId", "issuanceCode", "amount", "status", "createdAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "type": {
      "type": "string",
      "enum": ["transfer", "redeem", "issue"],
      "description": "Тип транзакции"
    },
    "issuanceId": {
      "type": "string",
      "format": "uuid"
    },
    "issuanceCode": {
      "type": "string",
      "description": "Код выпуска для отображения"
    },
    "amount": {
      "type": "number",
      "format": "decimal",
      "minimum": 0
    },
    "status": {
      "type": "string",
      "enum": ["pending", "confirmed", "failed"],
      "description": "Статус транзакции"
    },
    "dltTxHash": {
      "type": ["string", "null"],
      "pattern": "^[0-9a-fA-F]{64}$",
      "description": "Хеш транзакции в DLT"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time"
    },
    "confirmedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Дата подтверждения"
    }
  }
}
</file>

<file path="packages/contracts/schemas/Wallet.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Wallet",
  "description": "Схема кошелька инвестора",
  "type": "object",
  "required": ["investorId", "balance", "blocked", "holdings"],
  "properties": {
    "investorId": {
      "type": "string",
      "format": "uuid",
      "description": "Идентификатор инвестора"
    },
    "balance": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Баланс кошелька"
    },
    "blocked": {
      "type": "number",
      "format": "decimal",
      "minimum": 0,
      "description": "Заблокированные средства"
    },
    "holdings": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Holding"
      },
      "description": "Владения ЦФА"
    }
  },
  "definitions": {
    "Holding": {
      "type": "object",
      "required": ["issuanceId", "quantity"],
      "properties": {
        "issuanceId": {
          "type": "string",
          "format": "uuid",
          "description": "Идентификатор выпуска"
        },
        "quantity": {
          "type": "number",
          "format": "decimal",
          "exclusiveMinimum": 0,
          "description": "Количество ЦФА"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Дата последнего обновления"
        }
      }
    }
  }
}
</file>

<file path="packages/contracts/openapi-identity.yaml">
openapi: 3.1.0
info:
  title: Identity Service API
  version: 1.0.0
  description: Identity and authentication service (OIDC proxy)
servers:
  - url: http://localhost:5001
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, unhealthy]
  
  /.well-known/openid-configuration:
    get:
      summary: OpenID Connect configuration
      operationId: getOidcConfig
      tags:
        - OIDC
      responses:
        '200':
          description: OIDC configuration
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OidcConfiguration'
  
  /authorize:
    get:
      summary: OAuth2/OIDC authorization endpoint
      operationId: authorize
      tags:
        - OIDC
      parameters:
        - name: response_type
          in: query
          required: true
          schema:
            type: string
            enum: [code]
        - name: client_id
          in: query
          required: true
          schema:
            type: string
        - name: redirect_uri
          in: query
          required: true
          schema:
            type: string
            format: uri
        - name: scope
          in: query
          schema:
            type: string
            default: openid profile email
        - name: state
          in: query
          schema:
            type: string
      responses:
        '302':
          description: Redirect to ESIA or callback
        '400':
          description: Invalid request
  
  /token:
    post:
      summary: OAuth2 token endpoint
      operationId: token
      tags:
        - OIDC
      requestBody:
        required: true
        content:
          application/x-www-form-urlencoded:
            schema:
              type: object
              required:
                - grant_type
                - code
                - redirect_uri
                - client_id
              properties:
                grant_type:
                  type: string
                  enum: [authorization_code]
                code:
                  type: string
                redirect_uri:
                  type: string
                client_id:
                  type: string
      responses:
        '200':
          description: Token response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TokenResponse'
        '400':
          description: Invalid request
        '401':
          description: Unauthorized
  
  /userinfo:
    get:
      summary: Get user info
      operationId: getUserInfo
      tags:
        - OIDC
      security:
        - BearerAuth: []
      responses:
        '200':
          description: User information
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserInfo'
        '401':
          description: Unauthorized
  
  /users:
    get:
      summary: List users
      operationId: listUsers
      tags:
        - Users
      security:
        - BearerAuth: []
      parameters:
        - name: email
          in: query
          schema:
            type: string
        - name: role
          in: query
          schema:
            type: string
            enum: [issuer, investor, admin]
        - name: status
          in: query
          schema:
            type: string
            enum: [active, inactive, suspended, blocked]
      responses:
        '200':
          description: List of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
        '401':
          description: Unauthorized
  
  /users/{id}:
    get:
      summary: Get user by ID
      operationId: getUser
      tags:
        - Users
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: User details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          description: User not found

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    OidcConfiguration:
      type: object
      properties:
        issuer:
          type: string
          format: uri
        authorization_endpoint:
          type: string
          format: uri
        token_endpoint:
          type: string
          format: uri
        userinfo_endpoint:
          type: string
          format: uri
        jwks_uri:
          type: string
          format: uri
        response_types_supported:
          type: array
          items:
            type: string
        scopes_supported:
          type: array
          items:
            type: string
    
    TokenResponse:
      type: object
      properties:
        access_token:
          type: string
        token_type:
          type: string
          default: Bearer
        expires_in:
          type: integer
        refresh_token:
          type: string
        id_token:
          type: string
        scope:
          type: string
    
    UserInfo:
      type: object
      properties:
        sub:
          type: string
          description: Subject (user ID)
        email:
          type: string
          format: email
        email_verified:
          type: boolean
        name:
          type: string
        given_name:
          type: string
        family_name:
          type: string
        middle_name:
          type: string
        picture:
          type: string
          format: uri
    
    User:
      type: object
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        role:
          type: string
          enum: [issuer, investor, admin]
        status:
          type: string
          enum: [active, inactive, suspended, blocked]
        createdAt:
          type: string
          format: date-time
        lastLogin:
          type: string
          format: date-time
</file>

<file path="packages/contracts/openapi-integrations-bank.yaml">
openapi: 3.1.0
info:
  title: Bank Nominal Account API
  version: 1.0.0
  description: Адаптер номинального счёта и аналитического учёта (mock)
servers:
  - url: http://localhost:5003
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, unhealthy]
  
  /nominal/accounts:
    post:
      summary: Открыть номинальный счёт
      operationId: createNominalAccount
      tags:
        - Nominal Accounts
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateNominalAccountRequest'
      responses:
        '201':
          description: Счёт создан
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NominalAccountResponse'
        '400':
          description: Bad request
        '409':
          description: Account already exists
  
  /nominal/accounts/{accountId}:
    get:
      summary: Get nominal account
      operationId: getNominalAccount
      tags:
        - Nominal Accounts
      security:
        - BearerAuth: []
      parameters:
        - name: accountId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Account details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NominalAccountResponse'
        '404':
          description: Account not found
  
  /nominal/transfer:
    post:
      summary: Перевод средств (с идемпотентностью)
      operationId: transfer
      tags:
        - Transfers
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TransferRequest'
      responses:
        '200':
          description: Перевод проведён
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TransferResponse'
        '400':
          description: Bad request
        '409':
          description: Idempotency key conflict (already processed)
        '422':
          description: Insufficient funds or invalid account

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    CreateNominalAccountRequest:
      type: object
      required:
        - issuerId
        - accountType
      properties:
        issuerId:
          type: string
          format: uuid
        accountType:
          type: string
          enum: [nominal, analytical]
        currency:
          type: string
          default: RUB
        metadata:
          type: object
          description: Additional account metadata
    
    NominalAccountResponse:
      type: object
      properties:
        accountId:
          type: string
        issuerId:
          type: string
          format: uuid
        accountType:
          type: string
          enum: [nominal, analytical]
        currency:
          type: string
        balance:
          type: number
          format: decimal
        status:
          type: string
          enum: [active, frozen, closed]
        createdAt:
          type: string
          format: date-time
    
    TransferRequest:
      type: object
      required:
        - fromAccountId
        - toAccountId
        - amount
        - idempotencyKey
      properties:
        fromAccountId:
          type: string
        toAccountId:
          type: string
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        currency:
          type: string
          default: RUB
        idempotencyKey:
          type: string
          format: uuid
          description: Unique key for idempotency
        description:
          type: string
        metadata:
          type: object
    
    TransferResponse:
      type: object
      properties:
        transferId:
          type: string
          format: uuid
        fromAccountId:
          type: string
        toAccountId:
          type: string
        amount:
          type: number
          format: decimal
        currency:
          type: string
        status:
          type: string
          enum: [completed, pending, failed]
        executedAt:
          type: string
          format: date-time
        idempotencyKey:
          type: string
          format: uuid
</file>

<file path="packages/contracts/openapi-integrations-edo.yaml">
openapi: 3.1.0
info:
  title: EDO Connector API
  version: 1.0.0
  description: Интеграция с ЭДО (Диадок/СБИС/1С) - mock UKEP
servers:
  - url: http://localhost:5004
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, unhealthy]
  
  /documents:
    post:
      summary: Отправить документ на подпись (UKEP)
      operationId: uploadDocument
      tags:
        - Documents
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              required:
                - file
                - documentType
              properties:
                file:
                  type: string
                  format: binary
                documentType:
                  type: string
                  enum: [rules, issuance_decision, payout_schedule]
                metadata:
                  type: object
                  description: Additional document metadata
      responses:
        '202':
          description: Документ принят на обработку
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentResponse'
        '400':
          description: Bad request
  
  /documents/{id}:
    get:
      summary: Get document by ID
      operationId: getDocument
      tags:
        - Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Document details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentResponse'
        '404':
          description: Document not found
  
  /documents/{id}/status:
    get:
      summary: Статус документа
      operationId: getDocumentStatus
      tags:
        - Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Document status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentStatusResponse'
        '404':
          description: Document not found
  
  /documents/{id}/sign:
    post:
      summary: Подписать документ (mock UKEP)
      operationId: signDocument
      tags:
        - Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                signerId:
                  type: string
                  format: uuid
                signatureType:
                  type: string
                  enum: [ukep, simple]
      responses:
        '200':
          description: Document signed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SignedDocumentResponse'
        '400':
          description: Bad request
        '404':
          description: Document not found

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    DocumentResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        documentType:
          type: string
          enum: [rules, issuance_decision, payout_schedule]
        fileName:
          type: string
        fileSize:
          type: integer
        status:
          type: string
          enum: [uploaded, processing, signed, failed]
        uploadedAt:
          type: string
          format: date-time
        signedAt:
          type: string
          format: date-time
          nullable: true
        metadata:
          type: object
    
    DocumentStatusResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        status:
          type: string
          enum: [uploaded, processing, signed, failed]
        signature:
          type: object
          nullable: true
          properties:
            signerId:
              type: string
              format: uuid
            signedAt:
              type: string
              format: date-time
            signatureType:
              type: string
              enum: [ukep, simple]
            signatureValue:
              type: string
        error:
          type: string
          nullable: true
    
    SignedDocumentResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        status:
          type: string
          enum: [signed]
        signature:
          type: object
          properties:
            signerId:
              type: string
              format: uuid
            signedAt:
              type: string
              format: date-time
            signatureType:
              type: string
              enum: [ukep, simple]
            signatureValue:
              type: string
            certificateInfo:
              type: object
              properties:
                serialNumber:
                  type: string
                issuer:
                  type: string
                validFrom:
                  type: string
                  format: date-time
                validTo:
                  type: string
                  format: date-time
</file>

<file path="packages/contracts/openapi-integrations-esia.yaml">
openapi: 3.1.0
info:
  title: ESIA Adapter API
  version: 1.0.0
  description: ЕСИА адаптер - OIDC и профиль пользователя (mock для dev)
servers:
  - url: http://localhost:5002
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, unhealthy]
  
  /oidc/authorize:
    get:
      summary: OIDC authorization (redirect to ESIA or mock)
      operationId: authorize
      tags:
        - OIDC
      parameters:
        - name: response_type
          in: query
          required: true
          schema:
            type: string
        - name: client_id
          in: query
          required: true
          schema:
            type: string
        - name: redirect_uri
          in: query
          required: true
          schema:
            type: string
            format: uri
        - name: scope
          in: query
          schema:
            type: string
        - name: state
          in: query
          schema:
            type: string
      responses:
        '302':
          description: Redirect to ESIA or mock callback
        '400':
          description: Invalid request
  
  /oidc/callback:
    post:
      summary: OIDC callback handler
      operationId: callback
      tags:
        - OIDC
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                code:
                  type: string
                state:
                  type: string
      responses:
        '200':
          description: Callback processed
          content:
            application/json:
              schema:
                type: object
                properties:
                  code:
                    type: string
                  state:
                    type: string
        '400':
          description: Invalid callback
  
  /profile:
    get:
      summary: Get ESIA profile (mock)
      operationId: getProfile
      tags:
        - Profile
      security:
        - BearerAuth: []
      parameters:
        - name: snils
          in: query
          schema:
            type: string
            description: СНИЛС для поиска
      responses:
        '200':
          description: ESIA profile
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EsiaProfile'
        '401':
          description: Unauthorized
        '404':
          description: Profile not found

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    EsiaProfile:
      type: object
      properties:
        snils:
          type: string
          description: СНИЛС
        firstName:
          type: string
        lastName:
          type: string
        middleName:
          type: string
        birthDate:
          type: string
          format: date
        passport:
          type: object
          properties:
            series:
              type: string
            number:
              type: string
            issuedBy:
              type: string
            issuedDate:
              type: string
              format: date
        address:
          type: object
          properties:
            registration:
              type: string
            residence:
              type: string
        contacts:
          type: object
          properties:
            email:
              type: string
              format: email
            phone:
              type: string
</file>

<file path="packages/contracts/openapi-issuance.yaml">
openapi: 3.1.0
info:
  title: Issuance Service API
  version: 1.0.0
  description: Issuance service для управления выпусками ЦФА
servers:
  - url: http://localhost:5005
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
  
  /v1/issuances:
    post:
      summary: Create draft issuance
      operationId: createIssuance
      tags:
        - Issuances
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateIssuanceRequest'
      responses:
        '201':
          description: Issuance created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/issuances/{id}:
    get:
      summary: Get issuance by ID
      operationId: getIssuance
      tags:
        - Issuances
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Issuance details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/publish:
    post:
      summary: Publish issuance
      operationId: publishIssuance
      tags:
        - Issuances
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Issuance published
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/close:
    post:
      summary: Close issuance
      operationId: closeIssuance
      tags:
        - Issuances
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Issuance closed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    CreateIssuanceRequest:
      type: object
      required:
        - assetId
        - issuerId
        - totalAmount
        - nominal
        - issueDate
        - maturityDate
      properties:
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        nominal:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        scheduleJson:
          type: object
          additionalProperties: true
    
    IssuanceResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
        nominal:
          type: number
          format: decimal
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        status:
          type: string
          enum: [draft, published, closed, redeemed]
        scheduleJson:
          type: object
          additionalProperties: true
          nullable: true
        dltTxHash:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
        publishedAt:
          type: string
          format: date-time
          nullable: true
        closedAt:
          type: string
          format: date-time
          nullable: true
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
</file>

<file path="packages/contracts/openapi-registry.yaml">
openapi: 3.1.0
info:
  title: Registry Service API
  version: 1.0.0
  description: Registry service для управления заказами, кошельками и операциями с ЦФА
servers:
  - url: http://localhost:5006
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
  
  /v1/orders:
    post:
      summary: Place buy order
      operationId: placeOrder
      tags:
        - Orders
      parameters:
        - name: Idempotency-Key
          in: header
          required: true
          schema:
            type: string
            format: uuid
          description: Idempotency key to prevent duplicate orders
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        '202':
          description: Order accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '409':
          description: Order with this idempotency key already exists
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProblemDetails'
  
  /v1/orders/{id}:
    get:
      summary: Get order by ID
      operationId: getOrder
      tags:
        - Orders
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/orders/{id}/cancel:
    post:
      summary: Cancel order
      operationId: cancelOrder
      tags:
        - Orders
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order cancelled
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/orders/{id}/mark-paid:
    post:
      summary: Mark order as paid
      operationId: markOrderPaid
      tags:
        - Orders
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order paid
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/wallets/{investorId}:
    get:
      summary: Get wallet portfolio
      operationId: getWallet
      tags:
        - Wallets
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Wallet portfolio
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WalletResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/redeem:
    post:
      summary: Redeem issuance
      operationId: redeemIssuance
      tags:
        - Issuances
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RedeemRequest'
      responses:
        '200':
          description: Issuance redeemed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RedeemResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    CreateOrderRequest:
      type: object
      required:
        - investorId
        - issuanceId
        - amount
      properties:
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    OrderResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [created, reserved, paid, failed, cancelled]
        walletId:
          type: string
          format: uuid
          nullable: true
        dltTxHash:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
        confirmedAt:
          type: string
          format: date-time
          nullable: true
        failureReason:
          type: string
          nullable: true
    
    WalletResponse:
      type: object
      properties:
        investorId:
          type: string
          format: uuid
        balance:
          type: number
          format: decimal
        blocked:
          type: number
          format: decimal
        holdings:
          type: array
          items:
            $ref: '#/components/schemas/Holding'
    
    Holding:
      type: object
      properties:
        issuanceId:
          type: string
          format: uuid
        quantity:
          type: number
          format: decimal
        updatedAt:
          type: string
          format: date-time
    
    RedeemRequest:
      type: object
      required:
        - amount
      properties:
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    RedeemResponse:
      type: object
      properties:
        issuanceId:
          type: string
          format: uuid
        redeemedAmount:
          type: number
          format: decimal
        dltTxHash:
          type: string
        redeemedAt:
          type: string
          format: date-time
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
</file>

<file path="packages/contracts/openapi-settlement.yaml">
openapi: 3.1.0
info:
  title: Settlement Service API
  version: 1.0.0
  description: Settlement service для batch payouts и reconciliation
servers:
  - url: http://localhost:5007
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
  
  /v1/settlement/run:
    post:
      summary: Run settlement for a specific date
      operationId: runSettlement
      tags:
        - Settlement
      parameters:
        - name: date
          in: query
          schema:
            type: string
            format: date
          description: Date to run settlement for (YYYY-MM-DD). Defaults to today.
      responses:
        '202':
          description: Settlement accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SettlementResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/reports/payouts:
    get:
      summary: Get payouts report
      operationId: getPayoutsReport
      tags:
        - Reports
      parameters:
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Payouts report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PayoutsReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'

components:
  schemas:
    SettlementResponse:
      type: object
      properties:
        batchId:
          type: string
          format: uuid
        runDate:
          type: string
          format: date
        issuanceId:
          type: string
          format: uuid
          nullable: true
        totalAmount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, processing, completed, failed]
        itemCount:
          type: integer
        createdAt:
          type: string
          format: date-time
    
    PayoutsReportResponse:
      type: object
      properties:
        from:
          type: string
          format: date
        to:
          type: string
          format: date
        totalBatches:
          type: integer
        totalAmount:
          type: number
          format: decimal
        totalItems:
          type: integer
        completedItems:
          type: integer
        failedItems:
          type: integer
        batches:
          type: array
          items:
            $ref: '#/components/schemas/PayoutBatch'
    
    PayoutBatch:
      type: object
      properties:
        id:
          type: string
          format: uuid
        runDate:
          type: string
          format: date
        issuanceId:
          type: string
          format: uuid
          nullable: true
        totalAmount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, processing, completed, failed]
        itemCount:
          type: integer
        completedCount:
          type: integer
        failedCount:
          type: integer
        createdAt:
          type: string
          format: date-time
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
</file>

<file path="packages/contracts/README.md">
# Contracts Package

API контракты (OpenAPI/AsyncAPI/JSON Schemas) для ОИС ЦФА.

## Структура

```
packages/contracts/
├── openapi-gateway.yaml          # Gateway API
├── openapi-identity.yaml          # Identity Service
├── openapi-integrations-esia.yaml # ESIA Adapter
├── openapi-integrations-bank.yaml # Bank Nominal
├── openapi-integrations-edo.yaml  # EDO Connector
├── asyncapi.yaml                  # Kafka Events
└── schemas/
    ├── CFA.json
    ├── Issuance.json
    ├── Order.json
    ├── Payout.json
    └── AuditEvent.json
```

## Валидация

```bash
# OpenAPI
spectral lint openapi-*.yaml

# AsyncAPI
asyncapi validate asyncapi.yaml

# JSON Schemas
ajv validate -s schemas/CFA.json -d <data>
```

## Генерация SDK

См. `/Makefile` target `generate-sdks`.
</file>

<file path="scripts/git/zip_branches.sh">
#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <branches-file> [base-branch]" >&2
  exit 1
fi

branches_file="$1"
base_branch="${2:-infra.defis.deploy}"

if [[ ! -f "$branches_file" ]]; then
  echo "Branch list file not found: $branches_file" >&2
  exit 1
fi

repo_root="$(git rev-parse --show-toplevel)"
cd "$repo_root"

git fetch origin --prune >/dev/null 2>&1 || true

cleanup_worktree() {
  local branch="$1"
  local path
  path=$(git worktree list --porcelain | awk -v b="$branch" '
    $1 == "worktree" { wt=$2 }
    $1 == "branch" {
      gsub("refs/heads/", "", $2)
      if ($2 == b) {
        print wt
      }
    }
  ' | head -n1)

  if [[ -n "$path" ]]; then
    if [[ -n "$(git -C "$path" status --porcelain)" ]]; then
      echo "[SKIP] Worktree $path for $branch has uncommitted changes" >&2
      return 1
    fi
    git worktree remove "$path"
  fi
  return 0
}

while IFS= read -r raw_branch || [[ -n "$raw_branch" ]]; do
  branch="$(echo "$raw_branch" | xargs)"
  [[ -z "$branch" || "$branch" =~ ^# ]] && continue

  echo "--- Archiving $branch ---"

  if ! git show-ref --verify --quiet "refs/heads/$branch"; then
    if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
      git fetch origin "$branch:$branch"
    else
      echo "[SKIP] Branch $branch not found locally or on origin" >&2
      continue
    fi
  fi

  if ! git show-ref --verify --quiet "refs/heads/$base_branch"; then
    git fetch origin "$base_branch:$base_branch"
  fi

  if ! git merge-base --is-ancestor "$branch" "$base_branch"; then
    echo "[SKIP] $branch is not merged into $base_branch" >&2
    continue
  fi

  if ! cleanup_worktree "$branch"; then
    continue
  fi

  tag_name="zip/$branch"
  if git rev-parse --verify --quiet "refs/tags/$tag_name"; then
    echo "[INFO] Tag $tag_name already exists, skipping tag creation"
  else
    git tag "$tag_name" "$branch"
    git push origin "$tag_name"
  fi

  if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
    git push origin --delete "$branch" || true
  fi

  git branch -D "$branch"
  echo "[DONE] $branch archived as $tag_name"
done < "$branches_file"
</file>

<file path="services/compliance/compliance.Tests/compliance.Tests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Moq" Version="4.20.70" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="FluentAssertions" Version="6.12.0" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="9.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\compliance.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="services/compliance/compliance.Tests/KycWorkflowTests.cs">
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using OIS.Compliance.Services;
using Xunit;

namespace OIS.Compliance.Tests;

public class KycWorkflowTests
{
    private readonly ComplianceDbContext _db;
    private readonly ComplianceService _service;

    public KycWorkflowTests()
    {
        var options = new DbContextOptionsBuilder<ComplianceDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        _db = new ComplianceDbContext(options);
        var logger = new Mock<ILogger<ComplianceService>>();
        var watchlists = new Mock<IWatchlistsService>();
        var policy = new Mock<IQualificationPolicyService>();
        var outbox = new OutboxService(_db);
        _service = new ComplianceService(_db, logger.Object, watchlists.Object, policy.Object, outbox);
    }

    [Fact]
    public async Task UpdateKycStatus_Changes_Status_And_Writes_Outbox()
    {
        var investorId = Guid.NewGuid();
        var res = await _service.UpdateKycStatusAsync(investorId, "pass", Guid.NewGuid(), "manual approve", CancellationToken.None);
        res.Status.Should().Be("pass");
        var outbox = await _db.OutboxMessages.ToListAsync();
        outbox.Should().NotBeEmpty();
        outbox.Any(m => m.Topic == "ois.kyc.updated").Should().BeTrue();
        outbox.Any(m => m.Topic == "ois.audit.logged").Should().BeTrue();
    }

    [Fact]
    public async Task KycTasks_Create_Approve_Updates_Investor()
    {
        var investorId = Guid.NewGuid();
        var task = await _service.CreateKycTaskAsync(investorId, "doc review", CancellationToken.None);
        task.Status.Should().Be("open");

        var resolved = await _service.ResolveKycTaskAsync(task.Id, "approve", Guid.NewGuid(), null, CancellationToken.None);
        resolved!.Status.Should().Be("approved");
        var status = await _service.GetInvestorStatusAsync(investorId, CancellationToken.None);
        status!.Kyc.Should().Be("pass");
    }
}
</file>

<file path="services/compliance/DTOs/ComplaintResponse.cs">
namespace OIS.Compliance.DTOs;

public record ComplaintResponse
{
    public Guid Id { get; init; }
    public Guid? InvestorId { get; init; }
    public string Category { get; init; } = string.Empty;
    public string Text { get; init; } = string.Empty;
    public string Status { get; init; } = string.Empty;
    public DateTime? SlaDue { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime? ResolvedAt { get; init; }
}

public record CreateComplaintRequest
{
    public Guid? InvestorId { get; init; }
    public string Category { get; init; } = string.Empty;
    public string Text { get; init; } = string.Empty;
}
</file>

<file path="services/compliance/DTOs/KycRequestDto.cs">
namespace OIS.Compliance.DTOs;

public record KycRequestDto
{
    public Guid Id { get; init; }
    public Guid InvestorId { get; init; }
    public string Status { get; init; } = "pending"; // pending | approved | rejected
    public string? Reason { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime? ResolvedAt { get; init; }
}

public record KycDecisionRequest
{
    public string Decision { get; init; } = string.Empty; // approved | rejected
    public string? Comment { get; init; }
}
</file>

<file path="services/compliance/DTOs/KycResult.cs">
namespace OIS.Compliance.DTOs;

public record KycResult
{
    public Guid InvestorId { get; init; }
    public string Status { get; init; } = string.Empty; // pass, fail, pending, review
    public DateTime CheckedAt { get; init; }
    public string? Reason { get; init; }
}

public record KycCheckRequest
{
    public Guid InvestorId { get; init; }
}
</file>

<file path="services/compliance/DTOs/QualificationResult.cs">
namespace OIS.Compliance.DTOs;

public record QualificationResult
{
    public Guid InvestorId { get; init; }
    public string Tier { get; init; } = string.Empty; // unqualified, qualified, professional
    public decimal? Limit { get; init; }
    public decimal? Used { get; init; }
    public bool Allowed { get; init; }
    public string? Reason { get; init; }
    public DateTime EvaluatedAt { get; init; }
}

public record QualificationEvaluateRequest
{
    public Guid InvestorId { get; init; }
    public decimal Amount { get; init; }
}
</file>

<file path="services/compliance/Infrastructure/Metrics.cs">
using System.Diagnostics.Metrics;

namespace OIS.Compliance.Infrastructure;

public static class Metrics
{
    public const string MeterName = "compliance-service";
    private static readonly Meter Meter = new(MeterName);

    public static readonly Histogram<double> RequestDurationMs = Meter.CreateHistogram<double>(
        name: "request_duration_ms",
        unit: "ms",
        description: "API request latency in milliseconds");

    public static readonly Counter<long> RequestErrors = Meter.CreateCounter<long>(
        name: "request_errors_total",
        unit: "requests",
        description: "Number of API requests resulting in 5xx");
}
</file>

<file path="services/compliance/Migrations/20250104000000_InitialCreate.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace OIS.Compliance.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "investors_compliance",
                columns: table => new
                {
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    kyc = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    qualification_tier = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    qual_limit = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: true),
                    qual_used = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: true),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_investors_compliance", x => x.investor_id);
                });

            migrationBuilder.CreateTable(
                name: "complaints",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: true),
                    category = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    text = table.Column<string>(type: "text", nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    sla_due = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    resolved_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    idem_key = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_complaints", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_complaints_idem_key",
                table: "complaints",
                column: "idem_key",
                unique: true,
                filter: "\"idem_key\" IS NOT NULL");

            migrationBuilder.CreateIndex(
                name: "ix_complaints_investor_id",
                table: "complaints",
                column: "investor_id");

            migrationBuilder.CreateIndex(
                name: "ix_complaints_status",
                table: "complaints",
                column: "status");

            migrationBuilder.CreateIndex(
                name: "ix_complaints_category",
                table: "complaints",
                column: "category");

            migrationBuilder.CreateTable(
                name: "outbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    topic = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    payload = table.Column<string>(type: "jsonb", nullable: false),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    processed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_outbox_messages", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_outbox_messages_processed_at_created_at",
                table: "outbox_messages",
                columns: new[] { "processed_at", "created_at" });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "complaints");

            migrationBuilder.DropTable(
                name: "outbox_messages");

            migrationBuilder.DropTable(
                name: "investors_compliance");
        }
    }
}
</file>

<file path="services/compliance/Migrations/20250104110000_AddKycTasks.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace OIS.Compliance.Migrations
{
    /// <inheritdoc />
    public partial class AddKycTasks : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "kyc_tasks",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    reason = table.Column<string>(type: "text", nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    resolved_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_kyc_tasks", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_kyc_tasks_investor_id",
                table: "kyc_tasks",
                column: "investor_id");

            migrationBuilder.CreateIndex(
                name: "ix_kyc_tasks_status",
                table: "kyc_tasks",
                column: "status");
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "kyc_tasks");
        }
    }
}
</file>

<file path="services/compliance/Properties/launchSettings.json">
{
  "profiles": {
    "compliance": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:53979;http://localhost:53986"
    }
  }
}
</file>

<file path="services/compliance/Services/IWatchlistsService.cs">
namespace OIS.Compliance.Services;

public interface IWatchlistsService
{
    Task<WatchlistCheckResult> CheckAsync(Guid investorId, CancellationToken ct);
}

public record WatchlistCheckResult
{
    public bool Matched { get; init; }
    public string? Reason { get; init; }
    public string Severity { get; init; } = "low"; // low, medium, high, critical
}

public class WatchlistsServiceStub : IWatchlistsService
{
    private readonly ILogger<WatchlistsServiceStub> _logger;

    public WatchlistsServiceStub(ILogger<WatchlistsServiceStub> logger)
    {
        _logger = logger;
    }

    public Task<WatchlistCheckResult> CheckAsync(Guid investorId, CancellationToken ct)
    {
        // Deterministic demo: check last byte of GUID
        var lastByte = investorId.ToByteArray().Last();
        var matched = lastByte % 10 == 0; // ~10% match rate

        _logger.LogInformation("Watchlists check for investor {Investor}: matched={Matched}", OIS.Domain.Security.MaskGuid(investorId), matched);

        return Task.FromResult(new WatchlistCheckResult
        {
            Matched = matched,
            Reason = matched ? "Demo watchlist match" : null,
            Severity = matched ? "medium" : "low"
        });
    }
}
</file>

<file path="services/compliance/Services/QualificationPolicyService.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace OIS.Compliance.Services;

public interface IQualificationPolicyService
{
    Task<QualificationTier> EvaluateTierAsync(Guid investorId, CancellationToken ct);
    decimal? GetLimitForTier(string tier);
}

public enum QualificationTier
{
    Unqualified,
    Qualified,
    Professional
}

public class QualificationPolicyService : IQualificationPolicyService
{
    private readonly ILogger<QualificationPolicyService> _logger;
    private readonly IConfiguration _configuration;

    public QualificationPolicyService(ILogger<QualificationPolicyService> logger, IConfiguration configuration)
    {
        _logger = logger;
        _configuration = configuration;
    }

    public Task<QualificationTier> EvaluateTierAsync(Guid investorId, CancellationToken ct)
    {
        // Config-driven policy evaluation
        // For demo: deterministic based on investor ID
        var lastByte = investorId.ToByteArray().Last();
        var tier = lastByte switch
        {
            >= 200 => QualificationTier.Professional,
            >= 100 => QualificationTier.Qualified,
            _ => QualificationTier.Unqualified
        };

        _logger.LogInformation("Evaluated tier for investor {Investor}: {Tier}", OIS.Domain.Security.MaskGuid(investorId), tier);
        return Task.FromResult(tier);
    }

    public decimal? GetLimitForTier(string tier)
    {
        var limits = _configuration.GetSection("Qualification:Limits").Get<Dictionary<string, decimal?>>()
            ?? new Dictionary<string, decimal?>
            {
                { "unqualified", null },
                { "qualified", 60000m },
                { "professional", null } // unlimited
            };

        return limits.GetValueOrDefault(tier.ToLowerInvariant(), null);
    }
}
</file>

<file path="services/identity/Properties/launchSettings.json">
{
  "profiles": {
    "identity": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:53981;http://localhost:53987"
    }
  }
}
</file>

<file path="services/identity/identity.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <Compile Remove="identity.Tests/**/*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
  </ItemGroup>

</Project>
</file>

<file path="services/issuance/Background/OutboxPublisher.cs">
using MassTransit;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using OIS.Contracts.Events;
using Polly;

namespace OIS.Issuance.Background;

public class OutboxPublisher : BackgroundService
{
    private readonly IServiceProvider _services;
    private readonly ILogger<OutboxPublisher> _logger;

    public OutboxPublisher(IServiceProvider services, ILogger<OutboxPublisher> logger)
    {
        _services = services;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _services.CreateScope();
                var db = scope.ServiceProvider.GetRequiredService<IssuanceDbContext>();
                var publisher = scope.ServiceProvider.GetRequiredService<IPublishEndpoint>();

                var messages = await db.OutboxMessages
                    .Where(x => x.ProcessedAt == null)
                    .OrderBy(x => x.CreatedAt)
                    .Take(50)
                    .ToListAsync(stoppingToken);

                foreach (var msg in messages)
                {
                    var retry = Polly.Policy
                        .Handle<Exception>()
                        .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)));

                    await retry.ExecuteAsync(async () =>
                    {
                        await PublishTypedAsync(publisher, msg, stoppingToken);
                    });

                    msg.ProcessedAt = DateTime.UtcNow;
                }

                await db.SaveChangesAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken);
            }
            catch (OperationCanceledException) { break; }
            catch (Exception ex)
            {
                _logger.LogError(ex, "OutboxPublisher (Issuance) failed");
                await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
            }
        }
    }

    private static async Task PublishTypedAsync(IPublishEndpoint publisher, OutboxMessage msg, CancellationToken ct)
    {
        switch (msg.Topic)
        {
            case "ois.issuance.published":
                if (System.Text.Json.JsonSerializer.Deserialize<IssuancePublished>(msg.Payload) is { } ip)
                { await publisher.Publish(ip, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.issuance.closed":
                if (System.Text.Json.JsonSerializer.Deserialize<IssuanceClosed>(msg.Payload) is { } ic)
                { await publisher.Publish(ic, x => x.MessageId = msg.Id, ct); return; }
                break;
        }

        if (System.Text.Json.JsonSerializer.Deserialize<AuditLogged>(msg.Payload) is { } audit)
            await publisher.Publish(audit, x => x.MessageId = msg.Id, ct);
    }
}
</file>

<file path="services/issuance/DTOs/CreateIssuanceRequest.cs">
using System.ComponentModel.DataAnnotations;

namespace OIS.Issuance.DTOs;

public record CreateIssuanceRequest
{
    [Required]
    public Guid AssetId { get; init; }

    [Required]
    public Guid IssuerId { get; init; }

    [Required]
    [Range(0.00000001, double.MaxValue)]
    public decimal TotalAmount { get; init; }

    [Required]
    [Range(0.00000001, double.MaxValue)]
    public decimal Nominal { get; init; }

    [Required]
    public DateOnly IssueDate { get; init; }

    [Required]
    public DateOnly MaturityDate { get; init; }

    public Dictionary<string, object>? ScheduleJson { get; init; }
}
</file>

<file path="services/issuance/DTOs/IssuanceResponse.cs">
namespace OIS.Issuance.DTOs;

public record IssuanceResponse
{
    public Guid Id { get; init; }
    public Guid AssetId { get; init; }
    public Guid IssuerId { get; init; }
    public decimal TotalAmount { get; init; }
    public decimal Nominal { get; init; }
    public DateOnly IssueDate { get; init; }
    public DateOnly MaturityDate { get; init; }
    public string Status { get; init; } = string.Empty;
    public Dictionary<string, object>? ScheduleJson { get; init; }
    public string? DltTxHash { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime UpdatedAt { get; init; }
    public DateTime? PublishedAt { get; init; }
    public DateTime? ClosedAt { get; init; }
}
</file>

<file path="services/issuance/DTOs/IssuerIssuancesReportResponse.cs">
using System.ComponentModel.DataAnnotations;

namespace OIS.Issuance.DTOs;

public record IssuerIssuancesReportResponse
{
    [Required]
    public Guid IssuerId { get; init; }

    public IssuerIssuancesReportPeriod? Period { get; init; }

    [Required]
    public IReadOnlyList<IssuerReportRow> Items { get; init; } = Array.Empty<IssuerReportRow>();

    public IssuerIssuancesReportSummary? Summary { get; init; }
}

public record IssuerIssuancesReportPeriod
{
    public DateOnly? From { get; init; }
    public DateOnly? To { get; init; }
}

public record IssuerIssuancesReportSummary
{
    public int TotalIssuances { get; init; }
    public decimal TotalAmount { get; init; }
    public decimal TotalSold { get; init; }
    public int TotalInvestors { get; init; }
}

public record IssuerReportRow
{
    public Guid IssuanceId { get; init; }
    public string AssetCode { get; init; } = string.Empty;
    public string AssetName { get; init; } = string.Empty;
    public decimal TotalAmount { get; init; }
    public decimal SoldAmount { get; init; }
    public int InvestorsCount { get; init; }
    public string Status { get; init; } = string.Empty;
    public DateOnly IssueDate { get; init; }
    public DateOnly MaturityDate { get; init; }
    public DateTime? PublishedAt { get; init; }
}
</file>

<file path="services/issuance/Infrastructure/Metrics.cs">
using System.Diagnostics.Metrics;

namespace OIS.Issuance.Infrastructure;

public static class Metrics
{
    public const string MeterName = "issuance-service";
    private static readonly Meter Meter = new(MeterName);

    public static readonly Histogram<double> RequestDurationMs = Meter.CreateHistogram<double>(
        name: "request_duration_ms",
        unit: "ms",
        description: "API request latency in milliseconds");

    public static readonly Counter<long> RequestErrors = Meter.CreateCounter<long>(
        name: "request_errors_total",
        unit: "requests",
        description: "Number of API requests resulting in 5xx");
}
</file>

<file path="services/issuance/issuance.Tests/README.md">
# Issuance.Tests Notes

## EF Core provider in WebApplicationFactory

Use **only one** provider in test host. The in-memory host must not register Npgsql alongside InMemory, otherwise tests throw:

```
InvalidOperationException: Services for database providers 'Npgsql.EntityFrameworkCore.PostgreSQL' and 'Microsoft.EntityFrameworkCore.InMemory' have been registered in the service provider. Only a single database provider can be registered in a service provider.
```

In `Program` (test bootstrapping) ensure:

- `UseInMemoryDatabase("IssuanceTestsDb")` in tests;
- No `UseNpgsql` registration for tests.

## How to run

```bash
cd services/issuance
dotnet test issuance.Tests/issuance.Tests.csproj -v minimal
```

Place latest test output in `artifacts/issuance-test-report.txt` when available.
</file>

<file path="services/issuance/Migrations/20250101000000_InitialCreate.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace OIS.Issuance.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "issuances",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false),
                    asset_id = table.Column<Guid>(type: "uuid", nullable: false),
                    issuer_id = table.Column<Guid>(type: "uuid", nullable: false),
                    total_amount = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    nominal = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    issue_date = table.Column<DateOnly>(type: "date", nullable: false),
                    maturity_date = table.Column<DateOnly>(type: "date", nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    schedule_json = table.Column<string>(type: "jsonb", nullable: true),
                    dlt_tx_hash = table.Column<string>(type: "character varying(64)", maxLength: 64, nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    published_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    closed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_issuances", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_issuances_asset_id",
                table: "issuances",
                column: "asset_id");

            migrationBuilder.CreateIndex(
                name: "ix_issuances_issuer_id",
                table: "issuances",
                column: "issuer_id");

            migrationBuilder.CreateIndex(
                name: "ix_issuances_status",
                table: "issuances",
                column: "status");

            migrationBuilder.CreateTable(
                name: "outbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    topic = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    payload = table.Column<string>(type: "jsonb", nullable: false),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    processed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_outbox_messages", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_outbox_messages_processed_at_created_at",
                table: "outbox_messages",
                columns: new[] { "processed_at", "created_at" });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "issuances");

            migrationBuilder.DropTable(
                name: "outbox_messages");
        }
    }
}
</file>

<file path="services/issuance/Properties/launchSettings.json">
{
  "profiles": {
    "issuance": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:53978;http://localhost:53983"
    }
  }
}
</file>

<file path="services/issuance/Services/ILedgerIssuance.cs">
namespace OIS.Issuance.Services;

/// <summary>
/// Interface for ledger operations (Hyperledger Fabric chaincode)
/// </summary>
public interface ILedgerIssuance
{
    /// <summary>
    /// Issue an issuance on the ledger
    /// </summary>
    Task<string> IssueAsync(
        Guid id,
        Guid assetId,
        Guid issuerId,
        decimal totalAmount,
        decimal nominal,
        DateOnly issueDate,
        DateOnly maturityDate,
        string? scheduleJson,
        CancellationToken ct);

    /// <summary>
    /// Close an issuance on the ledger
    /// </summary>
    Task<string> CloseAsync(Guid id, CancellationToken ct);

    /// <summary>
    /// Get issuance from ledger
    /// </summary>
    Task<LedgerIssuanceInfo?> GetAsync(Guid id, CancellationToken ct);
}

public record LedgerIssuanceInfo
{
    public string Status { get; init; } = string.Empty;
    public int Version { get; init; }
    public string? TransactionHash { get; init; }
}
</file>

<file path="services/issuance/Services/LedgerIssuanceAdapter.cs">
using System.Diagnostics;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Polly;
using Polly.Retry;

namespace OIS.Issuance.Services;

/// <summary>
/// Adapter for Hyperledger Fabric chaincode (with mock mode)
/// </summary>
public class LedgerIssuanceAdapter : ILedgerIssuance
{
    private readonly ILogger<LedgerIssuanceAdapter> _logger;
    private readonly IConfiguration _configuration;
    private readonly HttpClient _httpClient;
    private readonly bool _useMock;
    private readonly string? _chaincodeEndpoint;
    private readonly AsyncRetryPolicy _retryPolicy;

    public LedgerIssuanceAdapter(
        ILogger<LedgerIssuanceAdapter> logger,
        IConfiguration configuration,
        HttpClient httpClient)
    {
        _logger = logger;
        _configuration = configuration;
        _httpClient = httpClient;
        _chaincodeEndpoint = _configuration["Ledger:ChaincodeEndpoint"];
        _useMock = string.IsNullOrEmpty(_chaincodeEndpoint) || 
                   _configuration.GetValue<bool>("Ledger:UseMock", true);

        if (!_useMock && !string.IsNullOrEmpty(_chaincodeEndpoint))
        {
            _httpClient.BaseAddress = new Uri(_chaincodeEndpoint);
            _httpClient.Timeout = TimeSpan.FromSeconds(30);
        }

        // Retry policy with exponential backoff
        _retryPolicy = Policy
            .Handle<HttpRequestException>()
            .Or<TaskCanceledException>()
            .WaitAndRetryAsync(
                retryCount: 3,
                sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                onRetry: (exception, timeSpan, retryCount, context) =>
                {
                    _logger.LogWarning(
                        "Retry {RetryCount} after {Delay}ms for {Operation}",
                        retryCount, timeSpan.TotalMilliseconds, context.OperationKey);
                });

        if (_useMock)
        {
            _logger.LogWarning("Ledger adapter running in MOCK mode");
        }
        else
        {
            _logger.LogInformation("Ledger adapter connected to {Endpoint}", _chaincodeEndpoint);
        }
    }

    public async Task<string> IssueAsync(
        Guid id,
        Guid assetId,
        Guid issuerId,
        decimal totalAmount,
        decimal nominal,
        DateOnly issueDate,
        DateOnly maturityDate,
        string? scheduleJson,
        CancellationToken ct)
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            if (_useMock)
            {
                return await MockIssueAsync(id, ct);
            }

            return await RealIssueAsync(id, assetId, issuerId, totalAmount, nominal, issueDate, maturityDate, scheduleJson, ct);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Issue completed for {IssuanceId} in {Duration}ms",
                id, stopwatch.ElapsedMilliseconds);
        }
    }

    public async Task<string> CloseAsync(Guid id, CancellationToken ct)
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            if (_useMock)
            {
                return await MockCloseAsync(id, ct);
            }

            return await RealCloseAsync(id, ct);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Close completed for {IssuanceId} in {Duration}ms",
                id, stopwatch.ElapsedMilliseconds);
        }
    }

    public async Task<LedgerIssuanceInfo?> GetAsync(Guid id, CancellationToken ct)
    {
        if (_useMock)
        {
            return await MockGetAsync(id, ct);
        }

        return await RealGetAsync(id, ct);
    }

    private async Task<string> MockIssueAsync(Guid id, CancellationToken ct)
    {
        // Simulate network delay
        await Task.Delay(50, ct);

        // Generate mock transaction hash
        var txHash = GenerateMockTxHash();
        
        _logger.LogInformation("MOCK: Issued issuance {IssuanceId} with txHash {TxHash}", id, txHash);
        
        return txHash;
    }

    private async Task<string> MockCloseAsync(Guid id, CancellationToken ct)
    {
        // Simulate network delay
        await Task.Delay(50, ct);

        // Generate mock transaction hash
        var txHash = GenerateMockTxHash();
        
        _logger.LogInformation("MOCK: Closed issuance {IssuanceId} with txHash {TxHash}", id, txHash);
        
        return txHash;
    }

    private async Task<LedgerIssuanceInfo?> MockGetAsync(Guid id, CancellationToken ct)
    {
        await Task.Delay(30, ct);
        
        // Mock: assume issuance exists and is published
        return new LedgerIssuanceInfo
        {
            Status = "published",
            Version = 1,
            TransactionHash = GenerateMockTxHash()
        };
    }

    private async Task<string> RealIssueAsync(
        Guid id,
        Guid assetId,
        Guid issuerId,
        decimal totalAmount,
        decimal nominal,
        DateOnly issueDate,
        DateOnly maturityDate,
        string? scheduleJson,
        CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "issuance",
                function = "Issue",
                args = new[]
                {
                    id.ToString(),
                    assetId.ToString(),
                    issuerId.ToString(),
                    totalAmount.ToString(),
                    nominal.ToString(),
                    issueDate.ToString("yyyy-MM-dd"),
                    maturityDate.ToString("yyyy-MM-dd"),
                    scheduleJson ?? "{}"
                }
            };

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/invoke", content, ct);
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var result = JsonSerializer.Deserialize<ChaincodeResponse>(responseContent);

            if (result?.TransactionHash == null)
            {
                throw new InvalidOperationException($"Failed to get transaction hash from ledger: {result?.Error ?? "Unknown error"}");
            }

            _logger.LogInformation("Issued issuance {IssuanceId} on ledger with txHash {TxHash}", id, result.TransactionHash);

            return result.TransactionHash;
        }, new Context("Issue"));
    }

    private async Task<string> RealCloseAsync(Guid id, CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "issuance",
                function = "Close",
                args = new[] { id.ToString() }
            };

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/invoke", content, ct);
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var result = JsonSerializer.Deserialize<ChaincodeResponse>(responseContent);

            if (result?.TransactionHash == null)
            {
                throw new InvalidOperationException($"Failed to get transaction hash from ledger: {result?.Error ?? "Unknown error"}");
            }

            _logger.LogInformation("Closed issuance {IssuanceId} on ledger with txHash {TxHash}", id, result.TransactionHash);

            return result.TransactionHash;
        }, new Context("Close"));
    }

    private async Task<LedgerIssuanceInfo?> RealGetAsync(Guid id, CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "issuance",
                function = "Get",
                args = new[] { id.ToString() }
            };

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/query", content, ct);
            
            if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                return null;
            }

            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var issuance = JsonSerializer.Deserialize<ChaincodeIssuance>(responseContent);

            if (issuance == null)
            {
                return null;
            }

            return new LedgerIssuanceInfo
            {
                Status = issuance.Status ?? "unknown",
                Version = issuance.Version,
                TransactionHash = issuance.TransactionHash
            };
        }, new Context("Get"));
    }

    private static string GenerateMockTxHash()
    {
        // Generate a mock transaction hash (64 hex characters)
        var random = new Random();
        var bytes = new byte[32];
        random.NextBytes(bytes);
        return Convert.ToHexString(bytes).ToLowerInvariant();
    }

    private class ChaincodeResponse
    {
        public string? TransactionHash { get; set; }
        public bool Success { get; set; }
        public string? Error { get; set; }
    }

    private class ChaincodeIssuance
    {
        public string? Status { get; set; }
        public int Version { get; set; }
        public string? TransactionHash { get; set; }
    }
}
</file>

<file path="services/issuance/Services/OutboxService.cs">
using System.Text.Json;

namespace OIS.Issuance.Services;

public interface IOutboxService
{
    Task AddAsync(string topic, object payload, CancellationToken ct);
}

public class OutboxService : IOutboxService
{
    private readonly IssuanceDbContext _db;

    public OutboxService(IssuanceDbContext db)
    {
        _db = db;
    }

    public async Task AddAsync(string topic, object payload, CancellationToken ct)
    {
        var message = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            Topic = topic,
            Payload = JsonSerializer.Serialize(payload),
            CreatedAt = DateTime.UtcNow
        };

        _db.OutboxMessages.Add(message);
    }
}
</file>

<file path="services/issuance/Validators/CreateIssuanceRequestValidator.cs">
using FluentValidation;
using OIS.Issuance.DTOs;

namespace OIS.Issuance.Validators;

public class CreateIssuanceRequestValidator : AbstractValidator<CreateIssuanceRequest>
{
    public CreateIssuanceRequestValidator()
    {
        RuleFor(x => x.AssetId)
            .NotEmpty()
            .WithMessage("AssetId is required");

        RuleFor(x => x.IssuerId)
            .NotEmpty()
            .WithMessage("IssuerId is required");

        RuleFor(x => x.TotalAmount)
            .GreaterThan(0)
            .WithMessage("TotalAmount must be greater than 0");

        RuleFor(x => x.Nominal)
            .GreaterThan(0)
            .WithMessage("Nominal must be greater than 0");

        RuleFor(x => x.IssueDate)
            .NotEmpty()
            .WithMessage("IssueDate is required");

        RuleFor(x => x.MaturityDate)
            .NotEmpty()
            .WithMessage("MaturityDate is required")
            .GreaterThan(x => x.IssueDate)
            .WithMessage("MaturityDate must be after IssueDate");
    }
}
</file>

<file path="services/issuance/issuance.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <DefaultItemExcludes>$(DefaultItemExcludes);issuance.Tests/**</DefaultItemExcludes>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="issuance.Tests/**/*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="1.9.0-beta.1" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.9.0" />
    <PackageReference Include="Confluent.Kafka" Version="2.5.3" />
    <PackageReference Include="System.Text.Json" Version="9.0.0" />
    <PackageReference Include="Polly" Version="8.4.1" />
    <PackageReference Include="MassTransit" Version="8.2.0" />
    <PackageReference Include="MassTransit.Kafka" Version="8.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>
</Project>
</file>

<file path="services/issuance/issuance.Tests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <IsPackable>false</IsPackable>
    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.0" />
    <PackageReference Include="Microsoft.TestPlatform.TestHost" Version="17.11.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="FluentAssertions" Version="6.12.1" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="Moq" Version="4.20.70" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="9.0.0" />
  </ItemGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="issuance.csproj" />
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>

  <!-- Limit compile scope to test files only -->
  <ItemGroup>
    <Compile Include="issuance.Tests/**/*.cs" />
  </ItemGroup>

</Project>
</file>

<file path="services/issuance/IssuanceDbContext.cs">
using Microsoft.EntityFrameworkCore;
using OIS.Domain;
using System.Text.Json;

namespace OIS.Issuance;

public class IssuanceDbContext : DbContext
{
    public IssuanceDbContext(DbContextOptions<IssuanceDbContext> options) : base(options) { }

    public DbSet<IssuanceEntity> Issuances => Set<IssuanceEntity>();
    public DbSet<OutboxMessage> OutboxMessages => Set<OutboxMessage>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity<IssuanceEntity>(entity =>
        {
            entity.ToTable("issuances");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.AssetId)
                .HasColumnName("asset_id")
                .IsRequired();

            entity.Property(e => e.IssuerId)
                .HasColumnName("issuer_id")
                .IsRequired();

            entity.Property(e => e.TotalAmount)
                .HasColumnName("total_amount")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.Nominal)
                .HasColumnName("nominal")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.IssueDate)
                .HasColumnName("issue_date")
                .HasColumnType("date")
                .IsRequired();

            entity.Property(e => e.MaturityDate)
                .HasColumnName("maturity_date")
                .HasColumnType("date")
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .HasConversion(
                    v => v.ToStringValue(),
                    v => IssuanceStatusExtensions.FromString(v))
                .IsRequired();

            entity.Property(e => e.ScheduleJson)
                .HasColumnName("schedule_json")
                .HasColumnType("jsonb");

            entity.Property(e => e.DltTxHash)
                .HasColumnName("dlt_tx_hash")
                .HasMaxLength(64);

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();

            entity.Property(e => e.PublishedAt)
                .HasColumnName("published_at");

            entity.Property(e => e.ClosedAt)
                .HasColumnName("closed_at");

            entity.HasIndex(e => e.AssetId);
            entity.HasIndex(e => e.IssuerId);
            entity.HasIndex(e => e.Status);
        });

        modelBuilder.Entity<OutboxMessage>(entity =>
        {
            entity.ToTable("outbox_messages");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.Topic)
                .HasColumnName("topic")
                .HasMaxLength(255)
                .IsRequired();

            entity.Property(e => e.Payload)
                .HasColumnName("payload")
                .HasColumnType("jsonb")
                .IsRequired();

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ProcessedAt)
                .HasColumnName("processed_at");

            entity.HasIndex(e => new { e.ProcessedAt, e.CreatedAt });
        });
    }
}

public class IssuanceEntity
{
    public Guid Id { get; set; }
    public Guid AssetId { get; set; }
    public Guid IssuerId { get; set; }
    public decimal TotalAmount { get; set; }
    public decimal Nominal { get; set; }
    public DateOnly IssueDate { get; set; }
    public DateOnly MaturityDate { get; set; }
    public IssuanceStatus Status { get; set; }
    public string? ScheduleJson { get; set; }
    public string? DltTxHash { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public DateTime? PublishedAt { get; set; }
    public DateTime? ClosedAt { get; set; }
}

public class OutboxMessage
{
    public Guid Id { get; set; }
    public string Topic { get; set; } = string.Empty;
    public string Payload { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
}
</file>

<file path="services/registry/Background/OutboxPublisher.cs">
using MassTransit;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using OIS.Contracts.Events;
using Polly;

namespace OIS.Registry.Background;

public class OutboxPublisher : BackgroundService
{
    private readonly IServiceProvider _services;
    private readonly ILogger<OutboxPublisher> _logger;

    public OutboxPublisher(IServiceProvider services, ILogger<OutboxPublisher> logger)
    {
        _services = services;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _services.CreateScope();
                var db = scope.ServiceProvider.GetRequiredService<RegistryDbContext>();
                var publisher = scope.ServiceProvider.GetRequiredService<IPublishEndpoint>();

                var messages = await db.OutboxMessages
                    .Where(x => x.ProcessedAt == null)
                    .OrderBy(x => x.CreatedAt)
                    .Take(50)
                    .ToListAsync(stoppingToken);

                foreach (var msg in messages)
                {
                    var retry = Policy
                        .Handle<Exception>()
                        .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)));

                    await retry.ExecuteAsync(async () =>
                    {
                        await PublishTypedAsync(publisher, msg, stoppingToken);
                    });

                    msg.ProcessedAt = DateTime.UtcNow;
                }

                await db.SaveChangesAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken);
            }
            catch (OperationCanceledException) { break; }
            catch (Exception ex)
            {
                _logger.LogError(ex, "OutboxPublisher (Registry) failed");
                await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
            }
        }
    }

    private static async Task PublishTypedAsync(IPublishEndpoint publisher, OutboxMessage msg, CancellationToken ct)
    {
        switch (msg.Topic)
        {
            case "ois.order.created":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderCreated>(msg.Payload) is { } oc)
                { await publisher.Publish(oc, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.order.placed":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderPlaced>(msg.Payload) is { } placed)
                { await publisher.Publish(placed, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.order.reserved":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderReserved>(msg.Payload) is { } or)
                { await publisher.Publish(or, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.order.paid":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderPaid>(msg.Payload) is { } paid)
                { await publisher.Publish(paid, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.order.confirmed":
                if (System.Text.Json.JsonSerializer.Deserialize<OrderConfirmed>(msg.Payload) is { } ocf)
                { await publisher.Publish(ocf, x => x.MessageId = msg.Id, ct); return; }
                break;
            case "ois.registry.transferred":
                if (System.Text.Json.JsonSerializer.Deserialize<RegistryTransferred>(msg.Payload) is { } rt)
                { await publisher.Publish(rt, x => x.MessageId = msg.Id, ct); return; }
                break;
        }

        // Fallback to audit
        if (System.Text.Json.JsonSerializer.Deserialize<AuditLogged>(msg.Payload) is { } audit)
            await publisher.Publish(audit, x => x.MessageId = msg.Id, ct);
    }
}
</file>

<file path="services/registry/DTOs/CreateOrderRequest.cs">
using System.ComponentModel.DataAnnotations;

namespace OIS.Registry.DTOs;

public record CreateOrderRequest
{
    [Required]
    public Guid InvestorId { get; init; }

    [Required]
    public Guid IssuanceId { get; init; }

    [Required]
    [Range(0.00000001, double.MaxValue)]
    public decimal Amount { get; init; }
}
</file>

<file path="services/registry/DTOs/OrderResponse.cs">
namespace OIS.Registry.DTOs;

public record OrderResponse
{
    public Guid Id { get; init; }
    public Guid InvestorId { get; init; }
    public Guid IssuanceId { get; init; }
    public decimal Amount { get; init; }
    public string Status { get; init; } = string.Empty;
    public Guid? WalletId { get; init; }
    public string? DltTxHash { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime UpdatedAt { get; init; }
    public DateTime? ConfirmedAt { get; init; }
    public string? FailureReason { get; init; }
}
</file>

<file path="services/registry/DTOs/RedeemRequest.cs">
using System.ComponentModel.DataAnnotations;

namespace OIS.Registry.DTOs;

public record RedeemRequest
{
    [Required]
    [Range(0.00000001, double.MaxValue)]
    public decimal Amount { get; init; }
}
</file>

<file path="services/registry/DTOs/RedeemResponse.cs">
namespace OIS.Registry.DTOs;

public record RedeemResponse
{
    public Guid IssuanceId { get; init; }
    public decimal RedeemedAmount { get; init; }
    public string DltTxHash { get; init; } = string.Empty;
    public DateTime RedeemedAt { get; init; }
}
</file>

<file path="services/registry/DTOs/WalletResponse.cs">
namespace OIS.Registry.DTOs;

public record WalletResponse
{
    public Guid InvestorId { get; init; }
    public decimal Balance { get; init; }
    public decimal Blocked { get; init; }
    public IReadOnlyList<HoldingDto> Holdings { get; init; } = Array.Empty<HoldingDto>();
}

public record HoldingDto
{
    public Guid IssuanceId { get; init; }
    public decimal Quantity { get; init; }
    public DateTime UpdatedAt { get; init; }
}
</file>

<file path="services/registry/Infrastructure/Metrics.cs">
using System.Diagnostics.Metrics;

namespace OIS.Registry.Infrastructure;

public static class Metrics
{
    public const string MeterName = "registry-service";
    private static readonly Meter Meter = new(MeterName);

    public static readonly Histogram<double> RequestDurationMs = Meter.CreateHistogram<double>(
        name: "request_duration_ms",
        unit: "ms",
        description: "API request latency in milliseconds");

    public static readonly Counter<long> RequestErrors = Meter.CreateCounter<long>(
        name: "request_errors_total",
        unit: "requests",
        description: "Number of API requests resulting in 5xx");
}
</file>

<file path="services/registry/Migrations/20250102000000_InitialCreate.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace OIS.Registry.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "wallets",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    owner_type = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    owner_id = table.Column<Guid>(type: "uuid", nullable: false),
                    balance = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    blocked = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_wallets", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_wallets_owner_type_owner_id",
                table: "wallets",
                columns: new[] { "owner_type", "owner_id" },
                unique: true);

            migrationBuilder.CreateTable(
                name: "holdings",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false),
                    issuance_id = table.Column<Guid>(type: "uuid", nullable: false),
                    quantity = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_holdings", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_holdings_investor_id_issuance_id",
                table: "holdings",
                columns: new[] { "investor_id", "issuance_id" },
                unique: true);

            migrationBuilder.CreateTable(
                name: "orders",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false),
                    issuance_id = table.Column<Guid>(type: "uuid", nullable: false),
                    amount = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    idem_key = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true),
                    wallet_id = table.Column<Guid>(type: "uuid", nullable: true),
                    dlt_tx_hash = table.Column<string>(type: "character varying(64)", maxLength: 64, nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    updated_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    confirmed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    failure_reason = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_orders", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_orders_idem_key",
                table: "orders",
                column: "idem_key",
                unique: true,
                filter: "\"idem_key\" IS NOT NULL");

            migrationBuilder.CreateIndex(
                name: "ix_orders_investor_id",
                table: "orders",
                column: "investor_id");

            migrationBuilder.CreateIndex(
                name: "ix_orders_issuance_id",
                table: "orders",
                column: "issuance_id");

            migrationBuilder.CreateIndex(
                name: "ix_orders_status",
                table: "orders",
                column: "status");

            migrationBuilder.CreateTable(
                name: "tx",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    type = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    from_wallet_id = table.Column<Guid>(type: "uuid", nullable: true),
                    to_wallet_id = table.Column<Guid>(type: "uuid", nullable: true),
                    issuance_id = table.Column<Guid>(type: "uuid", nullable: true),
                    amount = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: false),
                    dlt_tx_hash = table.Column<string>(type: "character varying(64)", maxLength: 64, nullable: true),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    confirmed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_tx", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_tx_issuance_id",
                table: "tx",
                column: "issuance_id");

            migrationBuilder.CreateIndex(
                name: "ix_tx_from_wallet_id",
                table: "tx",
                column: "from_wallet_id");

            migrationBuilder.CreateIndex(
                name: "ix_tx_to_wallet_id",
                table: "tx",
                column: "to_wallet_id");

            migrationBuilder.CreateIndex(
                name: "ix_tx_status",
                table: "tx",
                column: "status");

            migrationBuilder.CreateTable(
                name: "outbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    topic = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    payload = table.Column<string>(type: "jsonb", nullable: false),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    processed_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_outbox_messages", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_outbox_messages_processed_at_created_at",
                table: "outbox_messages",
                columns: new[] { "processed_at", "created_at" });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "holdings");

            migrationBuilder.DropTable(
                name: "orders");

            migrationBuilder.DropTable(
                name: "outbox_messages");

            migrationBuilder.DropTable(
                name: "tx");

            migrationBuilder.DropTable(
                name: "wallets");
        }
    }
}
</file>

<file path="services/registry/Properties/launchSettings.json">
{
  "profiles": {
    "registry": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:53980;http://localhost:53988"
    }
  }
}
</file>

<file path="services/registry/registry.Tests/ErrorMappingTests.cs">
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Registry.Services;
using System.Net;
using Xunit;

namespace OIS.Registry.Tests;

public class ErrorMappingTests
{
    [Fact]
    public void InvalidOperationException_MapsToProblemDetails()
    {
        // Arrange
        var exception = new InvalidOperationException("KYC check failed");

        // Act & Assert - verify exception is caught and mapped in endpoint
        // This would be tested in integration tests or via Program.cs endpoint tests
        Assert.NotNull(exception);
        Assert.Equal("KYC check failed", exception.Message);
    }

    [Fact]
    public void ProblemDetails_IncludesRequiredFields()
    {
        // Verify RFC7807 compliance
        var problemDetails = new
        {
            type = "about:blank",
            title = "Bad Request",
            status = 400,
            detail = "KYC check failed for investor"
        };

        Assert.Equal(400, problemDetails.status);
        Assert.NotNull(problemDetails.title);
        Assert.NotNull(problemDetails.detail);
    }
}
</file>

<file path="services/registry/registry.Tests/IdempotencyTests.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Registry;
using OIS.Registry.DTOs;
using OIS.Registry.Services;
using Xunit;
using FluentAssertions;

namespace OIS.Registry.Tests;

public class IdempotencyTests
{
    private readonly RegistryDbContext _db;
    private readonly Mock<ILogger<RegistryService>> _logger;
    private readonly Mock<IComplianceService> _compliance;
    private readonly Mock<IBankNominalService> _bank;
    private readonly Mock<ILedgerRegistry> _ledger;
    private readonly Mock<IOutboxService> _outbox;
    private readonly RegistryService _service;

    public IdempotencyTests()
    {
        var options = new DbContextOptionsBuilder<RegistryDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;
        _db = new RegistryDbContext(options);
        _logger = new Mock<ILogger<RegistryService>>();
        _compliance = new Mock<IComplianceService>();
        _bank = new Mock<IBankNominalService>();
        _ledger = new Mock<ILedgerRegistry>();
        _outbox = new Mock<IOutboxService>();

        _service = new RegistryService(
            _db,
            _logger.Object,
            _compliance.Object,
            _bank.Object,
            _ledger.Object,
            _outbox.Object);
    }

    [Fact]
    public async Task PlaceOrder_WithDuplicateIdempotencyKey_ReturnsExistingOrder()
    {
        // Arrange
        var idemKey = "test-idem-key-123";
        var existingOrder = new OrderEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = Guid.NewGuid(),
            IssuanceId = Guid.NewGuid(),
            Amount = 1000,
            Status = "pending",
            IdemKey = idemKey,
            CreatedAt = DateTime.UtcNow,
        };
        _db.Orders.Add(existingOrder);
        await _db.SaveChangesAsync();

        var request = new CreateOrderRequest
        {
            InvestorId = existingOrder.InvestorId,
            IssuanceId = existingOrder.IssuanceId,
            Amount = 1000,
        };

        // Act
        var result = await _service.PlaceOrderAsync(request, idemKey, CancellationToken.None);

        // Assert
        Assert.Equal(existingOrder.Id, result.Id);
        Assert.Equal(existingOrder.Status, result.Status);
        
        // Verify no new order was created
        var orderCount = await _db.Orders.CountAsync();
        Assert.Equal(1, orderCount);
        
        // Verify compliance/bank were not called (idempotent return)
        _compliance.Verify(x => x.CheckKycAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()), Times.Never);
        _bank.Verify(x => x.ReserveFundsAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Never);
    }

    [Fact]
    public async Task PlaceOrder_WithNewIdempotencyKey_CreatesNewOrder()
    {
        // Arrange
        var idemKey = "new-idem-key-456";
        _compliance.Setup(x => x.CheckKycAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>())).ReturnsAsync(true);
        _compliance.Setup(x => x.CheckQualificationAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>())).ReturnsAsync(true);
        _bank.Setup(x => x.ReserveFundsAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<string>(), It.IsAny<CancellationToken>())).ReturnsAsync("transfer-123");

        var request = new CreateOrderRequest
        {
            InvestorId = Guid.NewGuid(),
            IssuanceId = Guid.NewGuid(),
            Amount = 5000,
        };

        // Act
        var result = await _service.PlaceOrderAsync(request, idemKey, CancellationToken.None);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(request.Amount, result.Amount);
        
        var orderCount = await _db.Orders.CountAsync();
        Assert.Equal(1, orderCount);
        
        _compliance.Verify(x => x.CheckKycAsync(request.InvestorId, It.IsAny<CancellationToken>()), Times.Once);
    }
}
</file>

<file path="services/registry/registry.Tests/OrderFlowTests.cs">
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Registry;
using OIS.Registry.DTOs;
using OIS.Registry.Services;
using Xunit;

namespace OIS.Registry.Tests;

public class OrderFlowTests
{
    private readonly RegistryDbContext _db;
    private readonly Mock<IComplianceService> _compliance;
    private readonly Mock<IBankNominalService> _bank;
    private readonly Mock<ILedgerRegistry> _ledger;
    private readonly IRegistryService _service;

    public OrderFlowTests()
    {
        var options = new DbContextOptionsBuilder<RegistryDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        _db = new RegistryDbContext(options);
        _compliance = new Mock<IComplianceService>();
        _bank = new Mock<IBankNominalService>();
        _ledger = new Mock<ILedgerRegistry>();
        _compliance.Setup(x => x.CheckKycAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>())).ReturnsAsync(true);
        _compliance.Setup(x => x.CheckQualificationAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>())).ReturnsAsync(true);
        _bank.Setup(x => x.ReserveFundsAsync(It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<string>(), It.IsAny<CancellationToken>())).ReturnsAsync("bank-transfer-1");
        _ledger.Setup(x => x.TransferAsync(It.IsAny<string?>(), It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>())).ReturnsAsync("txhash-abc");

        var logger = new Mock<ILogger<RegistryService>>();
        var outbox = new OutboxService(_db);
        _service = new RegistryService(_db, logger.Object, _compliance.Object, _bank.Object, _ledger.Object, outbox);
    }

    [Fact]
    public async Task PlaceOrder_IsIdempotent_And_Reserved()
    {
        var investor = Guid.NewGuid();
        var issuance = Guid.NewGuid();
        var req = new CreateOrderRequest { InvestorId = investor, IssuanceId = issuance, Amount = 100m };
        var idem = Guid.NewGuid().ToString();

        var r1 = await _service.PlaceOrderAsync(req, idem, CancellationToken.None);
        var r2 = await _service.PlaceOrderAsync(req, idem, CancellationToken.None);

        r1.Id.Should().Be(r2.Id);
        r1.Status.Should().Be("reserved");

        var topics = await _db.OutboxMessages
            .OrderBy(m => m.CreatedAt)
            .Select(m => m.Topic)
            .ToListAsync();

        topics.Should().Contain("ois.order.created");
        topics.Should().Contain("ois.order.placed");
        topics.Should().Contain("ois.order.reserved");
    }

    [Fact]
    public async Task MarkPaid_Moves_To_Paid_And_Writes_Tx()
    {
        var investor = Guid.NewGuid();
        var issuance = Guid.NewGuid();
        var req = new CreateOrderRequest { InvestorId = investor, IssuanceId = issuance, Amount = 55m };
        var idem = Guid.NewGuid().ToString();

        var order = await _service.PlaceOrderAsync(req, idem, CancellationToken.None);
        var paid = await _service.MarkPaidAsync(order.Id, null, CancellationToken.None);

        paid.Status.Should().Be("paid");
        paid.DltTxHash.Should().NotBeNull();
        var tx = await _db.Transactions.FirstOrDefaultAsync(t => t.Id == order.Id);
        tx.Should().NotBeNull();
        tx!.Status.Should().Be("confirmed");

        var topics = await _db.OutboxMessages
            .Where(m => m.Topic.StartsWith("ois.order.") || m.Topic == "ois.registry.transferred")
            .Select(m => m.Topic)
            .ToListAsync();

        topics.Should().Contain("ois.order.paid");
        topics.Should().Contain("ois.registry.transferred");
        topics.Should().Contain("ois.order.confirmed");
    }

    [Fact]
    public async Task MarkPaid_On_Ledger_Error_Stays_Reserved_And_Allows_Retry()
    {
        var investor = Guid.NewGuid();
        var issuance = Guid.NewGuid();
        var req = new CreateOrderRequest { InvestorId = investor, IssuanceId = issuance, Amount = 10m };
        var idem = Guid.NewGuid().ToString();

        var order = await _service.PlaceOrderAsync(req, idem, CancellationToken.None);

        // now make ledger fail
        _ledger.Setup(x => x.TransferAsync(It.IsAny<string?>(), It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>()))
               .ThrowsAsync(new InvalidOperationException("dlterr"));

        await Assert.ThrowsAsync<InvalidOperationException>(() => _service.MarkPaidAsync(order.Id, null, CancellationToken.None));

        var entity = await _db.Orders.FindAsync(order.Id);
        entity!.Status.Should().Be("reserved");

        // restore ledger and retry -> should succeed
        _ledger.Setup(x => x.TransferAsync(It.IsAny<string?>(), It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<decimal>(), It.IsAny<CancellationToken>()))
               .ReturnsAsync("txhash-retry");

        var paid = await _service.MarkPaidAsync(order.Id, null, CancellationToken.None);
        paid.Status.Should().Be("paid");
        paid.DltTxHash.Should().Be("txhash-retry");
    }
}
</file>

<file path="services/registry/registry.Tests/OutboxPublishTests.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Registry;
using OIS.Registry.Services;
using System.Text.Json;
using Xunit;

namespace OIS.Registry.Tests;

public class OutboxPublishTests
{
    private readonly RegistryDbContext _db;
    private readonly OutboxService _outboxService;

    public OutboxPublishTests()
    {
        var options = new DbContextOptionsBuilder<RegistryDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;
        _db = new RegistryDbContext(options);
        _outboxService = new OutboxService(_db);
    }

    [Fact]
    public async Task AddAsync_CreatesOutboxMessage()
    {
        // Arrange
        var eventPayload = new
        {
            orderId = Guid.NewGuid().ToString(),
            investorId = Guid.NewGuid().ToString(),
            amount = 5000,
        };

        // Act
        await _outboxService.AddAsync("ois.order.placed", eventPayload, CancellationToken.None);
        await _db.SaveChangesAsync();

        // Assert
        var messages = await _db.OutboxMessages.ToListAsync();
        Assert.Single(messages);
        Assert.Equal("ois.order.placed", messages[0].Topic);
        Assert.Contains("orderId", messages[0].Payload);
    }

    [Fact]
    public async Task AddAsync_WithMultipleEvents_CreatesAllMessages()
    {
        // Arrange & Act
        await _outboxService.AddAsync("topic1", new { data = "1" }, CancellationToken.None);
        await _outboxService.AddAsync("topic2", new { data = "2" }, CancellationToken.None);
        await _outboxService.AddAsync("topic3", new { data = "3" }, CancellationToken.None);
        await _db.SaveChangesAsync();

        // Assert
        var messages = await _db.OutboxMessages.ToListAsync();
        Assert.Equal(3, messages.Count);
    }
}
</file>

<file path="services/registry/registry.Tests/registry.Tests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Moq" Version="4.20.70" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="FluentAssertions" Version="6.12.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\registry.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="services/registry/Services/IBankNominalService.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System.Net.Http.Json;
using System.Text;
using System.Text.Json;

namespace OIS.Registry.Services;

public interface IBankNominalService
{
    Task<string> ReserveFundsAsync(Guid investorId, decimal amount, string idempotencyKey, CancellationToken ct);
}

public class BankNominalServiceClient : IBankNominalService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<BankNominalServiceClient> _logger;
    private readonly string _baseUrl;

    public BankNominalServiceClient(
        HttpClient httpClient,
        ILogger<BankNominalServiceClient> logger,
        IConfiguration configuration)
    {
        _httpClient = httpClient;
        _logger = logger;
        _baseUrl = configuration["BankNominal:BaseUrl"] ?? "http://bank-nominal:8080";
    }

    public async Task<string> ReserveFundsAsync(Guid investorId, decimal amount, string idempotencyKey, CancellationToken ct)
    {
        var request = new
        {
            investorId = investorId.ToString(),
            amount = amount,
            idempotencyKey = idempotencyKey
        };

        using var content = new StringContent(
            JsonSerializer.Serialize(request),
            Encoding.UTF8,
            "application/json");

        _httpClient.DefaultRequestHeaders.Clear();
        _httpClient.DefaultRequestHeaders.Add("Idempotency-Key", idempotencyKey);

        var response = await _httpClient.PostAsync($"{_baseUrl}/nominal/reserve", content, ct);
        
        if (!response.IsSuccessStatusCode)
        {
            var error = await response.Content.ReadAsStringAsync(ct);
            _logger.LogError("Bank nominal reserve failed: {StatusCode} {Error}", response.StatusCode, error);
            throw new InvalidOperationException($"Failed to reserve funds: {response.StatusCode}");
        }

        var result = await response.Content.ReadFromJsonAsync<ReserveFundsResponse>(cancellationToken: ct);
        return result?.TransferId ?? throw new InvalidOperationException("No transfer ID returned");
    }

    private record ReserveFundsResponse
    {
        public string? TransferId { get; init; }
    }
}
</file>

<file path="services/registry/Services/IComplianceService.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System.Net.Http.Json;

namespace OIS.Registry.Services;

public interface IComplianceService
{
    Task<bool> CheckKycAsync(Guid investorId, CancellationToken ct);
    Task<bool> CheckQualificationAsync(Guid investorId, decimal amount, CancellationToken ct);
}

public class ComplianceServiceClient : IComplianceService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<ComplianceServiceClient> _logger;
    private readonly string _baseUrl;

    public ComplianceServiceClient(
        HttpClient httpClient,
        ILogger<ComplianceServiceClient> logger,
        IConfiguration configuration)
    {
        _httpClient = httpClient;
        _logger = logger;
        _baseUrl = configuration["Compliance:BaseUrl"] ?? "http://compliance-service:8080";
    }

    public async Task<bool> CheckKycAsync(Guid investorId, CancellationToken ct)
    {
        try
        {
            var request = new { investorId = investorId };
            var response = await _httpClient.PostAsJsonAsync($"{_baseUrl}/v1/compliance/kyc/check", request, ct);

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError("KYC check failed for investor {Investor}: {StatusCode}", OIS.Domain.Security.MaskGuid(investorId), response.StatusCode);
                return false;
            }

            var result = await response.Content.ReadFromJsonAsync<KycResult>(cancellationToken: ct);
            return result?.Status == "pass";
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking KYC for investor {Investor}", OIS.Domain.Security.MaskGuid(investorId));
            return false;
        }
    }

    public async Task<bool> CheckQualificationAsync(Guid investorId, decimal amount, CancellationToken ct)
    {
        try
        {
            var request = new { investorId = investorId, amount = amount };
            var response = await _httpClient.PostAsJsonAsync($"{_baseUrl}/v1/compliance/qualification/evaluate", request, ct);

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError("Qualification check failed for investor {Investor}: {StatusCode}", OIS.Domain.Security.MaskGuid(investorId), response.StatusCode);
                return false;
            }

            var result = await response.Content.ReadFromJsonAsync<QualificationResult>(cancellationToken: ct);
            return result?.Allowed == true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking qualification for investor {Investor}", OIS.Domain.Security.MaskGuid(investorId));
            return false;
        }
    }

    private record KycResult
    {
        public string Status { get; init; } = string.Empty;
    }

    private record QualificationResult
    {
        public bool Allowed { get; init; }
    }
}
</file>

<file path="services/registry/Services/ILedgerRegistry.cs">
using Microsoft.Extensions.Configuration;
using Polly;
using Polly.Retry;

namespace OIS.Registry.Services;

public interface ILedgerRegistry
{
    Task<string> TransferAsync(string? from, string to, Guid issuanceId, decimal amount, CancellationToken ct);
    Task<string> RedeemAsync(string holderId, Guid issuanceId, decimal amount, CancellationToken ct);
}

public class LedgerRegistryAdapter : ILedgerRegistry
{
    private readonly ILogger<LedgerRegistryAdapter> _logger;
    private readonly IConfiguration _configuration;
    private readonly HttpClient _httpClient;
    private readonly bool _useMock;
    private readonly string? _chaincodeEndpoint;
    private readonly AsyncRetryPolicy _retryPolicy;

    public LedgerRegistryAdapter(
        ILogger<LedgerRegistryAdapter> logger,
        IConfiguration configuration,
        HttpClient httpClient)
    {
        _logger = logger;
        _configuration = configuration;
        _httpClient = httpClient;
        _chaincodeEndpoint = _configuration["Ledger:ChaincodeEndpoint"];
        _useMock = string.IsNullOrEmpty(_chaincodeEndpoint) || 
                   _configuration.GetValue<bool>("Ledger:UseMock", true);

        if (!_useMock && !string.IsNullOrEmpty(_chaincodeEndpoint))
        {
            _httpClient.BaseAddress = new Uri(_chaincodeEndpoint);
            _httpClient.Timeout = TimeSpan.FromSeconds(30);
        }

        // Retry policy with exponential backoff
        _retryPolicy = Policy
            .Handle<HttpRequestException>()
            .Or<TaskCanceledException>()
            .WaitAndRetryAsync(
                retryCount: 3,
                sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                onRetry: (exception, timeSpan, retryCount, context) =>
                {
                    _logger.LogWarning(
                        "Retry {RetryCount} after {Delay}ms for {Operation}",
                        retryCount, timeSpan.TotalMilliseconds, context.OperationKey);
                });

        if (_useMock)
        {
            _logger.LogWarning("Ledger registry adapter running in MOCK mode");
        }
        else
        {
            _logger.LogInformation("Ledger registry adapter connected to {Endpoint}", _chaincodeEndpoint);
        }
    }

    public async Task<string> TransferAsync(string? from, string to, Guid issuanceId, decimal amount, CancellationToken ct)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            if (_useMock)
            {
                await Task.Delay(50, ct);
                var txHash = GenerateMockTxHash();
                _logger.LogInformation(
                    "MOCK: Transfer {From} -> {To}, issuance {IssuanceId}, amount {Amount}, txHash {TxHash}",
                    from ?? "null", to, issuanceId, amount, txHash);
                return txHash;
            }

            // TODO: Real HLF call
            return await RealTransferAsync(from, to, issuanceId, amount, ct);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Transfer completed in {Duration}ms", stopwatch.ElapsedMilliseconds);
        }
    }

    public async Task<string> RedeemAsync(string holderId, Guid issuanceId, decimal amount, CancellationToken ct)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            if (_useMock)
            {
                await Task.Delay(50, ct);
                var txHash = GenerateMockTxHash();
                _logger.LogInformation(
                    "MOCK: Redeem holder {HolderId}, issuance {IssuanceId}, amount {Amount}, txHash {TxHash}",
                    holderId, issuanceId, amount, txHash);
                return txHash;
            }

            // TODO: Real HLF call
            return await RealRedeemAsync(holderId, issuanceId, amount, ct);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Redeem completed in {Duration}ms", stopwatch.ElapsedMilliseconds);
        }
    }

    private async Task<string> RealTransferAsync(string? from, string to, Guid issuanceId, decimal amount, CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "registry",
                function = "Transfer",
                args = new[]
                {
                    from ?? "",
                    to,
                    issuanceId.ToString(),
                    amount.ToString()
                }
            };

            var json = System.Text.Json.JsonSerializer.Serialize(payload);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/invoke", content, ct);
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var result = System.Text.Json.JsonSerializer.Deserialize<ChaincodeResponse>(responseContent);

            if (result?.TransactionHash == null)
            {
                throw new InvalidOperationException($"Failed to get transaction hash from ledger: {result?.Error ?? "Unknown error"}");
            }

            _logger.LogInformation(
                "Transfer {From} -> {To}, issuance {IssuanceId}, amount {Amount}, txHash {TxHash}",
                from ?? "null", to, issuanceId, amount, result.TransactionHash);

            return result.TransactionHash;
        }, new Context("Transfer"));
    }

    private async Task<string> RealRedeemAsync(string holderId, Guid issuanceId, decimal amount, CancellationToken ct)
    {
        return await _retryPolicy.ExecuteAsync(async (context) =>
        {
            var payload = new
            {
                chaincode = "registry",
                function = "Redeem",
                args = new[]
                {
                    holderId,
                    issuanceId.ToString(),
                    amount.ToString()
                }
            };

            var json = System.Text.Json.JsonSerializer.Serialize(payload);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/chaincode/invoke", content, ct);
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync(ct);
            var result = System.Text.Json.JsonSerializer.Deserialize<ChaincodeResponse>(responseContent);

            if (result?.TransactionHash == null)
            {
                throw new InvalidOperationException($"Failed to get transaction hash from ledger: {result?.Error ?? "Unknown error"}");
            }

            _logger.LogInformation(
                "Redeem holder {HolderId}, issuance {IssuanceId}, amount {Amount}, txHash {TxHash}",
                holderId, issuanceId, amount, result.TransactionHash);

            return result.TransactionHash;
        }, new Context("Redeem"));
    }

    private class ChaincodeResponse
    {
        public string? TransactionHash { get; set; }
        public bool Success { get; set; }
        public string? Error { get; set; }
    }

    private static string GenerateMockTxHash()
    {
        var random = new Random();
        var bytes = new byte[32];
        random.NextBytes(bytes);
        return Convert.ToHexString(bytes).ToLowerInvariant();
    }
}
</file>

<file path="services/registry/Services/RegistryService.cs">
using Microsoft.EntityFrameworkCore;
using OIS.Registry;
using OIS.Registry.DTOs;
using System.Diagnostics;
using System.Text.Json;

namespace OIS.Registry.Services;

public interface IRegistryService
{
    Task<OrderResponse> PlaceOrderAsync(CreateOrderRequest request, string idempotencyKey, CancellationToken ct);
    Task<OrderResponse?> GetOrderAsync(Guid orderId, CancellationToken ct);
    Task<WalletResponse?> GetWalletAsync(Guid investorId, CancellationToken ct);
    Task<RedeemResponse> RedeemAsync(Guid issuanceId, RedeemRequest request, CancellationToken ct);
    Task<OrderResponse> CancelOrderAsync(Guid orderId, CancellationToken ct);
    Task<OrderResponse> MarkPaidAsync(Guid orderId, string? paymentRef, CancellationToken ct);
}

public class RegistryService : IRegistryService
{
    private readonly RegistryDbContext _db;
    private readonly ILogger<RegistryService> _logger;
    private readonly IComplianceService _compliance;
    private readonly IBankNominalService _bank;
    private readonly ILedgerRegistry _ledger;
    private readonly IOutboxService _outbox;

    public RegistryService(
        RegistryDbContext db,
        ILogger<RegistryService> logger,
        IComplianceService compliance,
        IBankNominalService bank,
        ILedgerRegistry ledger,
        IOutboxService outbox)
    {
        _db = db;
        _logger = logger;
        _compliance = compliance;
        _bank = bank;
        _ledger = ledger;
        _outbox = outbox;
    }

    public async Task<OrderResponse> PlaceOrderAsync(CreateOrderRequest request, string idempotencyKey, CancellationToken ct)
    {
        // Check idempotency
        var existingOrder = await _db.Orders
            .FirstOrDefaultAsync(o => o.IdemKey == idempotencyKey, ct);
        
        if (existingOrder != null)
        {
            _logger.LogInformation("Order with idempotency key {IdemKey} already exists: {OrderId}", 
                idempotencyKey, existingOrder.Id);
            return MapToOrderResponse(existingOrder);
        }

        // (a) Validate KYC/qualification
        var kycOk = await _compliance.CheckKycAsync(request.InvestorId, ct);
        if (!kycOk)
            throw new InvalidOperationException($"KYC check failed for investor {request.InvestorId}");

        var qualOk = await _compliance.CheckQualificationAsync(request.InvestorId, request.Amount, ct);
        if (!qualOk)
            throw new InvalidOperationException($"Qualification check failed for investor {request.InvestorId}: limit exceeded or not qualified");

        // Create order (created)
        var order = new OrderEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = request.InvestorId,
            IssuanceId = request.IssuanceId,
            Amount = request.Amount,
            Status = "created",
            IdemKey = idempotencyKey,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _db.Orders.Add(order);
        await _db.SaveChangesAsync(ct);

        // Emit order.created
        await _outbox.AddAsync("ois.order.created", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            createdAt = order.CreatedAt
        }, ct);

        // Emit order.placed (business-level event: order accepted before funds reservation)
        await _outbox.AddAsync("ois.order.placed", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            placedAt = order.CreatedAt
        }, ct);
        await _db.SaveChangesAsync(ct);

        // (b) Reserve funds via bank-nominal (idempotent)
        string transferId;
        try
        {
            transferId = await _bank.ReserveFundsAsync(request.InvestorId, request.Amount, idempotencyKey, ct);
            _logger.LogInformation("Funds reserved: transferId={TransferId}, investor={Investor}, amount={Amount}",
                transferId, OIS.Domain.Security.MaskGuid(request.InvestorId), request.Amount);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to reserve funds for investor {Investor}", OIS.Domain.Security.MaskGuid(request.InvestorId));
            throw new InvalidOperationException($"Failed to reserve funds: {ex.Message}", ex);
        }

        // Update order to reserved
        order.Status = "reserved";
        order.UpdatedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        await _outbox.AddAsync("ois.order.reserved", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            reservedAt = order.UpdatedAt,
            bankTransferId = transferId
        }, ct);

        await _db.SaveChangesAsync(ct);

        return MapToOrderResponse(order);
    }

    public async Task<OrderResponse?> GetOrderAsync(Guid orderId, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct);
        return order != null ? MapToOrderResponse(order) : null;
    }

    public async Task<WalletResponse?> GetWalletAsync(Guid investorId, CancellationToken ct)
    {
        var wallet = await _db.Wallets
            .FirstOrDefaultAsync(w => w.OwnerId == investorId && w.OwnerType == "individual", ct);

        if (wallet == null)
            return null;

        var holdings = await _db.Holdings
            .Where(h => h.InvestorId == investorId)
            .Select(h => new HoldingDto
            {
                IssuanceId = h.IssuanceId,
                Quantity = h.Quantity,
                UpdatedAt = h.UpdatedAt
            })
            .ToListAsync(ct);

        return new WalletResponse
        {
            InvestorId = investorId,
            Balance = wallet.Balance,
            Blocked = wallet.Blocked,
            Holdings = holdings
        };
    }

    public async Task<RedeemResponse> RedeemAsync(Guid issuanceId, RedeemRequest request, CancellationToken ct)
    {
        // TODO: Get investor from context/auth
        var investorId = Guid.NewGuid(); // Placeholder

        var stopwatch = Stopwatch.StartNew();
        string txHash;
        try
        {
            txHash = await _ledger.RedeemAsync(investorId.ToString(), issuanceId, request.Amount, ct);
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Redeem successful: issuanceId={IssuanceId}, txHash={TxHash}, duration={Duration}ms",
                issuanceId, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex, "Ledger Redeem failed for issuance {IssuanceId}", issuanceId);
            throw new InvalidOperationException($"Failed to redeem on ledger: {ex.Message}", ex);
        }

        // Update holding
        var holding = await _db.Holdings
            .FirstOrDefaultAsync(h => h.InvestorId == investorId && h.IssuanceId == issuanceId, ct);
        
        if (holding != null)
        {
            holding.Quantity -= request.Amount;
            holding.UpdatedAt = DateTime.UtcNow;
        }

        await WriteTransactionAsync(Guid.NewGuid(), "redeem", null, null, issuanceId, request.Amount, txHash, ct);
        await _db.SaveChangesAsync(ct);

        return new RedeemResponse
        {
            IssuanceId = issuanceId,
            RedeemedAmount = request.Amount,
            DltTxHash = txHash,
            RedeemedAt = DateTime.UtcNow
        };
    }

    public async Task<OrderResponse> CancelOrderAsync(Guid orderId, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct)
            ?? throw new InvalidOperationException($"Order {orderId} not found");

        if (order.Status is "paid" or "cancelled")
            throw new InvalidOperationException($"Cannot cancel order in status {order.Status}");

        order.Status = "cancelled";
        order.UpdatedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        return MapToOrderResponse(order);
    }

    public async Task<OrderResponse> MarkPaidAsync(Guid orderId, string? paymentRef, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct)
            ?? throw new InvalidOperationException($"Order {orderId} not found");

        // Idempotent: if already paid, return current state
        if (order.Status == "paid")
            return MapToOrderResponse(order);

        if (order.Status != "reserved")
            throw new InvalidOperationException($"Order must be in 'reserved' status to mark paid; actual: {order.Status}");

        // (c) Call ledger registry.Transfer
        var stopwatch = Stopwatch.StartNew();
        string txHash;
        try
        {
            txHash = await _ledger.TransferAsync(null, order.InvestorId.ToString(), order.IssuanceId, order.Amount, ct);
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Transfer successful: orderId={OrderId}, txHash={TxHash}, duration={Duration}ms",
                order.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Transfer failed for order {OrderId} after {Duration}ms",
                order.Id, stopwatch.ElapsedMilliseconds);
            // Keep order in 'reserved' status to allow retry; record failure reason transiently
            order.FailureReason = $"Ledger error: {ex.Message}";
            await _db.SaveChangesAsync(ct);
            throw;
        }

        // Update order -> paid
        order.Status = "paid";
        order.DltTxHash = txHash;
        order.ConfirmedAt = DateTime.UtcNow;
        order.UpdatedAt = DateTime.UtcNow;

        // Wallet + holding
        var wallet = await GetOrCreateWalletAsync(order.InvestorId, "individual", ct);
        order.WalletId = wallet.Id;
        await UpdateHoldingAsync(order.InvestorId, order.IssuanceId, order.Amount, ct);

        // Transactions and events
        await WriteTransactionAsync(order.Id, "transfer", null, wallet.Id, order.IssuanceId, order.Amount, txHash, ct);

        await _outbox.AddAsync("ois.order.paid", new
        {
            orderId = order.Id,
            issuanceId = order.IssuanceId,
            investorId = order.InvestorId,
            amount = order.Amount,
            paidAt = order.ConfirmedAt,
            txHash = txHash
        }, ct);

        await _outbox.AddAsync("ois.order.confirmed", new
        {
            orderId = order.Id,
            confirmedAt = order.ConfirmedAt,
            dltTxHash = txHash,
            walletId = wallet.Id
        }, ct);

        await _outbox.AddAsync("ois.registry.transferred", new
        {
            orderId = order.Id,
            issuanceId = order.IssuanceId,
            investorId = order.InvestorId,
            amount = order.Amount,
            txHash = txHash,
            walletId = wallet.Id,
            transferredAt = order.ConfirmedAt
        }, ct);

        await _db.SaveChangesAsync(ct);
        _logger.LogInformation("Order {OrderId} marked as paid with txHash {TxHash}", order.Id, txHash);

        return MapToOrderResponse(order);
    }

    private async Task<WalletEntity> GetOrCreateWalletAsync(Guid ownerId, string ownerType, CancellationToken ct)
    {
        var wallet = await _db.Wallets
            .FirstOrDefaultAsync(w => w.OwnerId == ownerId && w.OwnerType == ownerType, ct);

        if (wallet == null)
        {
            wallet = new WalletEntity
            {
                Id = Guid.NewGuid(),
                OwnerId = ownerId,
                OwnerType = ownerType,
                Balance = 0,
                Blocked = 0,
                UpdatedAt = DateTime.UtcNow
            };
            _db.Wallets.Add(wallet);
            await _db.SaveChangesAsync(ct);
        }

        return wallet;
    }

    private async Task UpdateHoldingAsync(Guid investorId, Guid issuanceId, decimal quantity, CancellationToken ct)
    {
        var holding = await _db.Holdings
            .FirstOrDefaultAsync(h => h.InvestorId == investorId && h.IssuanceId == issuanceId, ct);

        if (holding == null)
        {
            holding = new HoldingEntity
            {
                Id = Guid.NewGuid(),
                InvestorId = investorId,
                IssuanceId = issuanceId,
                Quantity = 0,
                UpdatedAt = DateTime.UtcNow
            };
            _db.Holdings.Add(holding);
        }

        holding.Quantity += quantity;
        holding.UpdatedAt = DateTime.UtcNow;
    }

    private async Task WriteTransactionAsync(
        Guid id,
        string type,
        Guid? fromWalletId,
        Guid? toWalletId,
        Guid? issuanceId,
        decimal amount,
        string txHash,
        CancellationToken ct)
    {
        var tx = new TransactionEntity
        {
            Id = id,
            Type = type,
            FromWalletId = fromWalletId,
            ToWalletId = toWalletId,
            IssuanceId = issuanceId,
            Amount = amount,
            DltTxHash = txHash,
            Status = "confirmed",
            CreatedAt = DateTime.UtcNow,
            ConfirmedAt = DateTime.UtcNow
        };

        _db.Transactions.Add(tx);
    }

    private static OrderResponse MapToOrderResponse(OrderEntity entity)
    {
        return new OrderResponse
        {
            Id = entity.Id,
            InvestorId = entity.InvestorId,
            IssuanceId = entity.IssuanceId,
            Amount = entity.Amount,
            Status = entity.Status,
            WalletId = entity.WalletId,
            DltTxHash = entity.DltTxHash,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            ConfirmedAt = entity.ConfirmedAt,
            FailureReason = entity.FailureReason
        };
    }
}

public interface IOutboxService
{
    Task AddAsync(string topic, object payload, CancellationToken ct);
}

public class OutboxService : IOutboxService
{
    private readonly RegistryDbContext _db;

    public OutboxService(RegistryDbContext db)
    {
        _db = db;
    }

    public async Task AddAsync(string topic, object payload, CancellationToken ct)
    {
        var message = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            Topic = topic,
            Payload = JsonSerializer.Serialize(payload),
            CreatedAt = DateTime.UtcNow
        };

        _db.OutboxMessages.Add(message);
    }
}
</file>

<file path="services/registry/Validators/CreateOrderRequestValidator.cs">
using FluentValidation;
using OIS.Registry.DTOs;

namespace OIS.Registry.Validators;

public class CreateOrderRequestValidator : AbstractValidator<CreateOrderRequest>
{
    public CreateOrderRequestValidator()
    {
        RuleFor(x => x.InvestorId)
            .NotEmpty()
            .WithMessage("InvestorId is required");

        RuleFor(x => x.IssuanceId)
            .NotEmpty()
            .WithMessage("IssuanceId is required");

        RuleFor(x => x.Amount)
            .GreaterThan(0)
            .WithMessage("Amount must be greater than 0");
    }
}
</file>

<file path="services/registry/registry.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <DefaultItemExcludes>$(DefaultItemExcludes);registry.Tests/**</DefaultItemExcludes>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="registry.Tests/**/*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="1.9.0-beta.1" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.9.0" />
    <PackageReference Include="Polly" Version="8.4.1" />
    <PackageReference Include="System.Net.Http.Json" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="MassTransit" Version="8.2.0" />
    <PackageReference Include="MassTransit.Kafka" Version="8.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Compile Remove="registry.Tests/**/*.cs" />
  </ItemGroup>

</Project>
</file>

<file path="services/registry/RegistryDbContext.cs">
using Microsoft.EntityFrameworkCore;

namespace OIS.Registry;

public class RegistryDbContext : DbContext
{
    public RegistryDbContext(DbContextOptions<RegistryDbContext> options) : base(options) { }

    public DbSet<WalletEntity> Wallets => Set<WalletEntity>();
    public DbSet<HoldingEntity> Holdings => Set<HoldingEntity>();
    public DbSet<OrderEntity> Orders => Set<OrderEntity>();
    public DbSet<TransactionEntity> Transactions => Set<TransactionEntity>();
    public DbSet<OutboxMessage> OutboxMessages => Set<OutboxMessage>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity<WalletEntity>(entity =>
        {
            entity.ToTable("wallets");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.OwnerType)
                .HasColumnName("owner_type")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.OwnerId)
                .HasColumnName("owner_id")
                .IsRequired();

            entity.Property(e => e.Balance)
                .HasColumnName("balance")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.Blocked)
                .HasColumnName("blocked")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();

            entity.HasIndex(e => new { e.OwnerType, e.OwnerId }).IsUnique();
        });

        modelBuilder.Entity<HoldingEntity>(entity =>
        {
            entity.ToTable("holdings");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .IsRequired();

            entity.Property(e => e.IssuanceId)
                .HasColumnName("issuance_id")
                .IsRequired();

            entity.Property(e => e.Quantity)
                .HasColumnName("quantity")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();

            entity.HasIndex(e => new { e.InvestorId, e.IssuanceId }).IsUnique();
        });

        modelBuilder.Entity<OrderEntity>(entity =>
        {
            entity.ToTable("orders");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .IsRequired();

            entity.Property(e => e.IssuanceId)
                .HasColumnName("issuance_id")
                .IsRequired();

            entity.Property(e => e.Amount)
                .HasColumnName("amount")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.IdemKey)
                .HasColumnName("idem_key")
                .HasMaxLength(255);

            entity.Property(e => e.WalletId)
                .HasColumnName("wallet_id");

            entity.Property(e => e.DltTxHash)
                .HasColumnName("dlt_tx_hash")
                .HasMaxLength(64);

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();

            entity.Property(e => e.ConfirmedAt)
                .HasColumnName("confirmed_at");

            entity.Property(e => e.FailureReason)
                .HasColumnName("failure_reason");

            entity.HasIndex(e => e.IdemKey).IsUnique()
                .HasFilter("\"idem_key\" IS NOT NULL");
            entity.HasIndex(e => e.InvestorId);
            entity.HasIndex(e => e.IssuanceId);
            entity.HasIndex(e => e.Status);
        });

        modelBuilder.Entity<TransactionEntity>(entity =>
        {
            entity.ToTable("tx");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.Type)
                .HasColumnName("type")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.FromWalletId)
                .HasColumnName("from_wallet_id");

            entity.Property(e => e.ToWalletId)
                .HasColumnName("to_wallet_id");

            entity.Property(e => e.IssuanceId)
                .HasColumnName("issuance_id");

            entity.Property(e => e.Amount)
                .HasColumnName("amount")
                .HasPrecision(20, 8)
                .IsRequired();

            entity.Property(e => e.DltTxHash)
                .HasColumnName("dlt_tx_hash")
                .HasMaxLength(64);

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ConfirmedAt)
                .HasColumnName("confirmed_at");

            entity.HasIndex(e => e.IssuanceId);
            entity.HasIndex(e => e.FromWalletId);
            entity.HasIndex(e => e.ToWalletId);
            entity.HasIndex(e => e.Status);
        });

        modelBuilder.Entity<OutboxMessage>(entity =>
        {
            entity.ToTable("outbox_messages");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.Topic)
                .HasColumnName("topic")
                .HasMaxLength(255)
                .IsRequired();

            entity.Property(e => e.Payload)
                .HasColumnName("payload")
                .HasColumnType("jsonb")
                .IsRequired();

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ProcessedAt)
                .HasColumnName("processed_at");

            entity.HasIndex(e => new { e.ProcessedAt, e.CreatedAt });
        });
    }
}

public class WalletEntity
{
    public Guid Id { get; set; }
    public string OwnerType { get; set; } = string.Empty; // "individual" or "legal_entity"
    public Guid OwnerId { get; set; }
    public decimal Balance { get; set; }
    public decimal Blocked { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class HoldingEntity
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public Guid IssuanceId { get; set; }
    public decimal Quantity { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class OrderEntity
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public Guid IssuanceId { get; set; }
    public decimal Amount { get; set; }
    public string Status { get; set; } = "created"; // created, reserved, paid, failed, cancelled
    public string? IdemKey { get; set; }
    public Guid? WalletId { get; set; }
    public string? DltTxHash { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public DateTime? ConfirmedAt { get; set; }
    public string? FailureReason { get; set; }
}

public class TransactionEntity
{
    public Guid Id { get; set; }
    public string Type { get; set; } = string.Empty; // transfer, redeem, issue
    public Guid? FromWalletId { get; set; }
    public Guid? ToWalletId { get; set; }
    public Guid? IssuanceId { get; set; }
    public decimal Amount { get; set; }
    public string? DltTxHash { get; set; }
    public string Status { get; set; } = "pending"; // pending, confirmed, failed
    public DateTime CreatedAt { get; set; }
    public DateTime? ConfirmedAt { get; set; }
}

public class OutboxMessage
{
    public Guid Id { get; set; }
    public string Topic { get; set; } = string.Empty;
    public string Payload { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
}
</file>

<file path="apps/api-gateway/Properties/launchSettings.json">
{
  "profiles": {
    "api-gateway": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:5003;http://localhost:5002"
    }
  }
}
</file>

<file path="apps/api-gateway/appsettings.Development.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Cors": {
    "AllowedOrigins": [
      "http://localhost:3001",
      "http://localhost:3002",
      "http://localhost:3003",
      "http://localhost:3004",
      "http://localhost:55000"
    ]
  }
}
</file>

<file path="apps/api-gateway/Program.cs">
using Serilog;
using Yarp.ReverseProxy.Configuration;
using System.Threading.RateLimiting;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter())
    .ReadFrom.Configuration(ctx.Configuration));

// Services
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks();
builder.Services.AddCors();

// Rate Limiting (Token Bucket)
builder.Services.AddRateLimiter(options =>
{
    options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(context =>
        RateLimitPartition.GetTokenBucketLimiter(
            partitionKey: context.Connection.RemoteIpAddress?.ToString() ?? "unknown",
            factory: _ => new TokenBucketRateLimiterOptions
            {
                TokenLimit = 100,
                QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
                QueueLimit = 10,
                ReplenishmentPeriod = TimeSpan.FromSeconds(1),
                TokensPerPeriod = 10,
                AutoReplenishment = true
            }));
    
    options.OnRejected = async (context, cancellationToken) =>
    {
        context.HttpContext.Response.StatusCode = 429;
        await context.HttpContext.Response.WriteAsync("Rate limit exceeded. Please retry later.", cancellationToken);
    };
});

// Request Size Limits
builder.Services.Configure<Microsoft.AspNetCore.Http.Features.FormOptions>(options =>
{
    options.MultipartBodyLengthLimit = 10485760; // 10 MB
    options.ValueLengthLimit = 10485760;
});

// YARP Reverse Proxy
builder.Services.AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));

var app = builder.Build();

// Swagger (can be enabled outside Development via config Swagger:Enabled=true)
var swaggerEnabled = app.Configuration.GetValue<bool?>("Swagger:Enabled") ?? app.Environment.IsDevelopment();
if (swaggerEnabled)
{
    app.UseSwagger();
    app.UseSwaggerUI(options =>
    {
        options.SwaggerEndpoint("/swagger/v1/swagger.json", "Gateway v1");
        options.RoutePrefix = "swagger";
    });
}

// Security Headers Middleware
app.Use(async (context, next) =>
{
    context.Response.Headers.Append("X-Content-Type-Options", "nosniff");
    context.Response.Headers.Append("X-Frame-Options", "DENY");
    context.Response.Headers.Append("X-XSS-Protection", "1; mode=block");
    context.Response.Headers.Append("Referrer-Policy", "strict-origin-when-cross-origin");
    context.Response.Headers.Append("Content-Security-Policy", "default-src 'self'");
    await next();
});

// CORS
app.UseCors(policy =>
{
    var allowedOrigins = builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>() 
        ?? new[] { "http://localhost:3001", "http://localhost:3002", "http://localhost:3003" };
    
    policy.WithOrigins(allowedOrigins)
        .AllowAnyMethod()
        .AllowAnyHeader()
        .AllowCredentials();
});

// Request Size Limit
app.Use(async (context, next) =>
{
    context.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature>()!
        .MaxRequestBodySize = 10485760; // 10 MB
    await next();
});

app.UseHttpsRedirection();
app.UseRouting();

// Rate Limiting
app.UseRateLimiter();

// Health checks
app.MapHealthChecks("/health");
app.MapGet("/", () => Results.Redirect("/swagger"));

// API endpoints (proxied)
app.MapReverseProxy();

app.Run();
</file>

<file path="apps/backoffice/src/app/auth/signin/page.tsx">
'use client';

import { signIn } from 'next-auth/react';
import { useSearchParams } from 'next/navigation';
import { Suspense } from 'react';
import { Button, Card, CardContent, Spinner } from '@ois/shared-ui';

function SignInButton() {
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get('callbackUrl') || '/kyc';

  return (
    <Button
      onClick={() => signIn('keycloak', { callbackUrl })}
      variant="primary"
      size="lg"
      className="w-full"
    >
      Войти через Keycloak
    </Button>
  );
}

export default function SignInPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <Card className="max-w-md w-full">
        <CardContent className="space-y-8 p-8">
          <div>
            <h2 className="text-3xl font-bold text-center text-text-primary">
              Бэк-офис OIS
            </h2>
            <p className="mt-2 text-center text-text-secondary">
              Войдите для продолжения
            </p>
          </div>
          <Suspense fallback={<Spinner size="md" className="mx-auto" />}>
            <SignInButton />
          </Suspense>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/complaints/components/ComplaintDetailsPanel.tsx">
'use client';

import { useState } from 'react';
import { Card, CardContent, Badge, Button, Input } from '@ois/shared-ui';
import { Complaint } from '@/mocks/complaints';
import { Send, CheckCircle } from 'lucide-react';

type Props = {
  complaint: Complaint;
  onReply: (params: { id: string; text: string }) => void;
  onResolve: (id: string) => void;
  isSubmitting: boolean;
};

const STATUS_LABELS: Record<string, string> = {
  open: 'НОВАЯ',
  in_progress: 'В РАБОТЕ',
  resolved: 'РЕШЕНА',
  rejected: 'ОТКЛОНЕНА',
};

const STATUS_INTENTS: Record<string, 'danger' | 'warning' | 'success' | 'neutral'> = {
  open: 'danger',
  in_progress: 'warning',
  resolved: 'success',
  rejected: 'neutral',
};

export function ComplaintDetailsPanel({ complaint, onReply, onResolve, isSubmitting }: Props) {
  const [replyText, setReplyText] = useState('');

  const handleReply = () => {
    onReply({ id: complaint.id, text: replyText });
    setReplyText('');
  };

  return (
    <Card className="flex flex-col h-[600px]">
      <CardContent className="flex flex-col h-full p-0">
        {/* Header */}
        <div className="p-6 border-b border-border bg-surface-alt">
          <div className="flex items-center justify-between mb-2">
            <h3 className="text-lg font-semibold text-text-primary">{complaint.subject}</h3>
            <Badge intent={STATUS_INTENTS[complaint.status] ?? 'neutral'}>
              {STATUS_LABELS[complaint.status] ?? complaint.status}
            </Badge>
          </div>
          <div className="text-sm text-text-secondary">От: {complaint.userEmail}</div>
        </div>

        {/* Messages */}
        <div className="flex-1 overflow-y-auto p-6 space-y-4">
          {complaint.messages.map(msg => (
            <div
              key={msg.id}
              className={`flex ${msg.sender === 'support' ? 'justify-end' : 'justify-start'}`}
            >
              <div
                className={`max-w-[80%] rounded-lg p-3 ${
                  msg.sender === 'support'
                    ? 'bg-primary-500 text-white'
                    : 'bg-surface-alt text-text-primary'
                }`}
              >
                <div className="text-sm">{msg.text}</div>
                <div
                  className={`text-xs mt-1 ${msg.sender === 'support' ? 'text-white/70' : 'text-text-tertiary'}`}
                >
                  {new Date(msg.timestamp).toLocaleTimeString('ru-RU', {
                    hour: '2-digit',
                    minute: '2-digit',
                  })}
                </div>
              </div>
            </div>
          ))}
        </div>

        {/* Reply Form */}
        <div className="p-4 border-t border-border bg-surface">
          {complaint.status !== 'resolved' ? (
            <div className="space-y-3">
              <Input
                multiline
                label="Ответ"
                placeholder="Напишите ответ..."
                value={replyText}
                onChange={e => setReplyText(e.target.value)}
                className="min-h-[96px] resize-none"
              />
              <div className="flex justify-between items-center">
                <Button
                  variant="ghost"
                  size="sm"
                  className="text-success-primary hover:text-success-dark"
                  onClick={() => onResolve(complaint.id)}
                  disabled={isSubmitting}
                >
                  <CheckCircle className="mr-2 h-4 w-4" />
                  Отметить как решено
                </Button>
                <Button
                  variant="primary"
                  size="sm"
                  onClick={handleReply}
                  disabled={!replyText.trim() || isSubmitting}
                >
                  <Send className="mr-2 h-4 w-4" />
                  Отправить
                </Button>
              </div>
            </div>
          ) : (
            <div className="flex items-center justify-center gap-2 text-success-primary py-4">
              <CheckCircle className="h-5 w-5" />
              <span className="font-medium">Жалоба решена</span>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/backoffice/src/app/complaints/components/ComplaintItem.tsx">
'use client';

import { Badge } from '@ois/shared-ui';
import { Complaint } from '@/mocks/complaints';

type Props = {
  complaint: Complaint;
  isSelected: boolean;
  onClick: () => void;
};

const STATUS_LABELS: Record<string, string> = {
  open: 'НОВАЯ',
  in_progress: 'В РАБОТЕ',
  resolved: 'РЕШЕНА',
  rejected: 'ОТКЛОНЕНА',
};

const STATUS_INTENTS: Record<string, 'danger' | 'warning' | 'success' | 'neutral'> = {
  open: 'danger',
  in_progress: 'warning',
  resolved: 'success',
  rejected: 'neutral',
};

export function ComplaintItem({ complaint, isSelected, onClick }: Props) {
  return (
    <div
      className={`flex flex-col gap-2 p-4 cursor-pointer transition-all border-l-4 ${
        isSelected
          ? 'bg-primary-50 border-primary-500 shadow-sm'
          : 'border-transparent hover:bg-surface-hover'
      }`}
      onClick={onClick}
    >
      <div className="flex items-center justify-between">
        <span className="font-medium text-text-primary">{complaint.subject}</span>
        <Badge intent={STATUS_INTENTS[complaint.status] ?? 'neutral'}>
          {STATUS_LABELS[complaint.status] ?? complaint.status}
        </Badge>
      </div>
      <div className="flex items-center justify-between text-xs text-text-secondary">
        <span>{complaint.userEmail}</span>
        <span>{new Date(complaint.updatedAt).toLocaleString('ru-RU')}</span>
      </div>
      <div className="text-sm text-text-secondary line-clamp-2">{complaint.description}</div>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/complaints/hooks/useComplaintMutations.ts">
'use client';

import { useMutation, useQueryClient } from '@tanstack/react-query';
import { complaintsService } from '@/lib/services/complaints';
import { toast } from 'sonner';

export function useComplaintMutations(onReplySuccess?: () => void) {
  const queryClient = useQueryClient();

  const replyMutation = useMutation({
    mutationFn: ({ id, text }: { id: string; text: string }) =>
      complaintsService.replyToComplaint(id, text),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['complaints'] });
      toast.success('Ответ отправлен');
      onReplySuccess?.();
    },
  });

  const resolveMutation = useMutation({
    mutationFn: (id: string) => complaintsService.resolveComplaint(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['complaints'] });
      toast.success('Жалоба решена');
    },
  });

  return {
    replyMutation,
    resolveMutation,
    isSubmitting: replyMutation.isPending || resolveMutation.isPending,
  };
}
</file>

<file path="apps/backoffice/src/app/kyc/components/DocumentItem.tsx">
'use client';

import { Badge, Button } from '@ois/shared-ui';
import { FileText, Eye, Download, Image as ImageIcon, FileCheck, AlertCircle } from 'lucide-react';
import { KycDocument, getKycDocumentDownloadUrl } from '@/lib/api/compliance';
import { DOCUMENT_TYPE_LABELS } from '@/lib/constants';
import { formatFileSize, isImageFile } from '@/lib/utils/file';

type Props = {
  document: KycDocument;
  onPreview: (doc: KycDocument) => void;
};

function getDocStatusBadge(status: string) {
  switch (status) {
    case 'verified':
      return (
        <Badge intent="success">
          <FileCheck className="h-3 w-3 mr-1" />
          Проверен
        </Badge>
      );
    case 'rejected':
      return (
        <Badge intent="danger">
          <AlertCircle className="h-3 w-3 mr-1" />
          Отклонен
        </Badge>
      );
    default:
      return <Badge intent="warning">Ожидает</Badge>;
  }
}

export function DocumentItem({ document: doc, onPreview }: Props) {
  const handleDownload = () => {
    window.open(getKycDocumentDownloadUrl(doc.id), '_blank');
  };

  return (
    <div className="group flex items-center justify-between rounded-lg border border-border p-4 hover:bg-surface-hover transition-colors">
      <div className="flex items-center gap-4 overflow-hidden flex-1">
        {isImageFile(doc.mimeType) ? (
          <ImageIcon className="h-6 w-6 text-blue-500 flex-shrink-0" />
        ) : (
          <FileText className="h-6 w-6 text-primary-500 flex-shrink-0" />
        )}
        <div className="flex flex-col overflow-hidden flex-1">
          <div className="flex items-center gap-2">
            <span className="text-sm font-medium text-text-primary truncate" title={doc.fileName}>
              {doc.fileName}
            </span>
            {getDocStatusBadge(doc.status)}
          </div>
          <div className="flex items-center gap-2 text-xs text-text-tertiary">
            <span>{DOCUMENT_TYPE_LABELS[doc.documentType] || doc.documentType}</span>
            <span>•</span>
            <span>{formatFileSize(doc.fileSize)}</span>
            <span>•</span>
            <span>{new Date(doc.uploadedAt).toLocaleDateString('ru-RU')}</span>
          </div>
          {doc.rejectionReason && (
            <p className="text-xs text-red-500 mt-1">{doc.rejectionReason}</p>
          )}
        </div>
      </div>
      <div className="flex gap-2 ml-4">
        {isImageFile(doc.mimeType) && (
          <Button
            variant="ghost"
            size="sm"
            className="h-8 w-8 p-0"
            title="Просмотр"
            onClick={() => onPreview(doc)}
          >
            <Eye className="h-4 w-4" />
          </Button>
        )}
        <Button
          variant="ghost"
          size="sm"
          className="h-8 w-8 p-0"
          title="Скачать"
          onClick={handleDownload}
        >
          <Download className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/kyc/components/QualificationDecisionForm.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Button, Input, Select } from '@ois/shared-ui';
import { CheckCircle, XCircle } from 'lucide-react';

type Props = {
  taskId: string;
  onApprove: (params: { id: string; tier: 'qualified' | 'professional'; limit?: number }) => void;
  onReject: (params: { id: string; reason: string }) => void;
  isSubmitting: boolean;
};

export function QualificationDecisionForm({ taskId, onApprove, onReject, isSubmitting }: Props) {
  const [comment, setComment] = useState('');
  const [selectedTier, setSelectedTier] = useState<'qualified' | 'professional'>('qualified');
  const [limit, setLimit] = useState<string>('');

  // Reset form when task changes
  useEffect(() => {
    setComment('');
    setSelectedTier('qualified');
    setLimit('');
  }, [taskId]);

  const handleApprove = () => {
    onApprove({
      id: taskId,
      tier: selectedTier,
      limit: limit ? Number(limit) : undefined,
    });
  };

  const handleReject = () => {
    onReject({
      id: taskId,
      reason: comment,
    });
  };

  return (
    <div className="space-y-3 pt-4 border-t border-border">
      <div className="grid grid-cols-2 gap-3">
        <Select
          label="Уровень квалификации"
          value={selectedTier}
          onChange={e => setSelectedTier(e.target.value as 'qualified' | 'professional')}
          options={[
            { value: 'qualified', label: 'Квалифицированный' },
            { value: 'professional', label: 'Профессиональный' },
          ]}
        />
        <Input
          label="Лимит (₽)"
          type="number"
          placeholder="Без лимита"
          value={limit}
          onChange={e => setLimit(e.target.value)}
        />
      </div>
      <textarea
        className="w-full rounded-md border border-border bg-surface px-3 py-2 text-sm text-text-primary placeholder:text-text-tertiary focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
        placeholder="Комментарий..."
        rows={3}
        value={comment}
        onChange={e => setComment(e.target.value)}
      />
      <div className="flex gap-2">
        <Button
          variant="primary"
          disabled={isSubmitting}
          onClick={handleApprove}
          className="bg-success-600 hover:bg-success-700 w-full"
        >
          <CheckCircle className="mr-2 h-4 w-4" />
          Подтвердить
        </Button>
        <Button
          variant="danger"
          disabled={isSubmitting || !comment.trim()}
          onClick={handleReject}
          className="w-full"
        >
          <XCircle className="mr-2 h-4 w-4" />
          Отказать
        </Button>
      </div>
      {!comment.trim() && (
        <p className="text-xs text-text-tertiary">* Для отказа необходимо указать причину</p>
      )}
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/kyc/components/QualificationDetailsPanel.tsx">
'use client';

import { Card, CardContent, Badge } from '@ois/shared-ui';
import { FileText } from 'lucide-react';
import { QualificationTask, KycDocument, getKycDocumentDownloadUrl } from '@/lib/api/compliance';
import {
  QUALIFICATION_BASIS_LABELS,
  TIER_LABELS,
  getStatusBadgeIntent,
  getStatusLabel,
} from '@/lib/constants';
import { QualificationDecisionForm } from './QualificationDecisionForm';

type Props = {
  task: QualificationTask;
  documents: KycDocument[];
  onApprove: (params: { id: string; tier: 'qualified' | 'professional'; limit?: number }) => void;
  onReject: (params: { id: string; reason: string }) => void;
  isSubmitting: boolean;
};

export function QualificationDetailsPanel({
  task,
  documents,
  onApprove,
  onReject,
  isSubmitting,
}: Props) {
  return (
    <Card>
      <CardContent className="p-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-text-primary">Заявка на квалификацию</h3>
          <Badge intent={getStatusBadgeIntent(task.status)}>{getStatusLabel(task.status)}</Badge>
        </div>

        {/* Task Info */}
        <div className="space-y-3">
          <div>
            <span className="text-sm text-text-secondary">Инвестор:</span>
            <span className="ml-2 text-sm font-medium text-text-primary font-mono">
              {task.investorId}
            </span>
          </div>
          <div>
            <span className="text-sm text-text-secondary">Основание:</span>
            <span className="ml-2 text-sm font-medium text-text-primary">
              {QUALIFICATION_BASIS_LABELS[task.qualificationBasis]}
            </span>
          </div>
          {task.assignedTier && (
            <div>
              <span className="text-sm text-text-secondary">Уровень:</span>
              <span className="ml-2 text-sm font-medium text-text-primary">
                {TIER_LABELS[task.assignedTier]}
              </span>
            </div>
          )}
          {task.assignedLimit && (
            <div>
              <span className="text-sm text-text-secondary">Лимит:</span>
              <span className="ml-2 text-sm font-medium text-text-primary">
                ₽{task.assignedLimit.toLocaleString('ru-RU')}
              </span>
            </div>
          )}
          {task.reason && (
            <div>
              <span className="text-sm text-text-secondary">Комментарий:</span>
              <p className="mt-1 text-sm text-text-primary">{task.reason}</p>
            </div>
          )}
        </div>

        {/* Documents */}
        <div className="space-y-2">
          <h4 className="text-sm font-medium text-text-secondary">Документы</h4>
          {documents.length > 0 ? (
            documents.map(doc => (
              <div key={doc.id} className="flex items-center gap-2 text-sm text-text-primary">
                <FileText className="h-4 w-4 text-brand-primary" />
                <a
                  href={getKycDocumentDownloadUrl(doc.id)}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="hover:underline"
                >
                  {doc.fileName}
                </a>
                <span className="text-xs text-text-tertiary">
                  ({doc.documentType.replace(/_/g, ' ')})
                </span>
              </div>
            ))
          ) : (
            <p className="text-sm text-text-tertiary">Нет документов</p>
          )}
        </div>

        {/* Decision Form (only for open tasks) */}
        {task.status === 'open' && (
          <QualificationDecisionForm
            taskId={task.id}
            onApprove={onApprove}
            onReject={onReject}
            isSubmitting={isSubmitting}
          />
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/backoffice/src/app/kyc/components/QualificationTaskItem.tsx">
'use client';

import { Badge } from '@ois/shared-ui';
import { QualificationTask } from '@/lib/api/compliance';
import {
  QUALIFICATION_BASIS_LABELS,
  TIER_LABELS,
  getStatusBadgeIntent,
  getStatusLabel,
} from '@/lib/constants';

type Props = {
  task: QualificationTask;
  isSelected: boolean;
  onClick: () => void;
};

export function QualificationTaskItem({ task, isSelected, onClick }: Props) {
  return (
    <div
      className={`flex items-center justify-between p-4 cursor-pointer transition-colors ${
        isSelected ? 'bg-brand-primary/5' : 'hover:bg-surface-hover'
      }`}
      onClick={onClick}
    >
      <div>
        <div className="font-medium text-text-primary">{task.investorId}</div>
        <div className="text-xs text-text-secondary">
          {QUALIFICATION_BASIS_LABELS[task.qualificationBasis] || task.qualificationBasis}
        </div>
        <div className="text-xs text-text-tertiary">
          {new Date(task.createdAt).toLocaleDateString('ru-RU')}
        </div>
      </div>
      <div className="flex flex-col items-end gap-1">
        <Badge intent={getStatusBadgeIntent(task.status)}>{getStatusLabel(task.status)}</Badge>
        {task.assignedTier && (
          <span className="text-xs text-text-secondary">{TIER_LABELS[task.assignedTier]}</span>
        )}
      </div>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/kyc/hooks/useQualificationMutations.ts">
'use client';

import { useMutation, useQueryClient } from '@tanstack/react-query';
import { approveQualificationTask, rejectQualificationTask } from '@/lib/api/compliance';
import { toast } from 'sonner';

type ApproveParams = {
  id: string;
  tier: 'qualified' | 'professional';
  limit?: number;
  reason?: string;
};

type RejectParams = {
  id: string;
  reason: string;
};

export function useQualificationMutations(onSuccess?: () => void) {
  const queryClient = useQueryClient();

  const handleSuccess = () => {
    queryClient.invalidateQueries({ queryKey: ['qualification-tasks'] });
    onSuccess?.();
  };

  const approveMutation = useMutation({
    mutationFn: ({ id, tier, limit, reason }: ApproveParams) =>
      approveQualificationTask(id, tier, limit, reason),
    onSuccess: () => {
      handleSuccess();
      toast.success('Квалификация подтверждена');
    },
    onError: () => toast.error('Ошибка подтверждения квалификации'),
  });

  const rejectMutation = useMutation({
    mutationFn: ({ id, reason }: RejectParams) => rejectQualificationTask(id, reason),
    onSuccess: () => {
      handleSuccess();
      toast.success('Заявка отклонена');
    },
    onError: () => toast.error('Ошибка отклонения заявки'),
  });

  return {
    approveMutation,
    rejectMutation,
    isSubmitting: approveMutation.isPending || rejectMutation.isPending,
  };
}
</file>

<file path="apps/backoffice/src/app/login/page.tsx">
'use client';

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { Button, Card, Input, Badge } from '@ois/shared-ui';
import { toast } from 'sonner';
import { Shield, Lock, User } from 'lucide-react';

export default function LoginPage() {
  const router = useRouter();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isKeycloakLoading, setIsKeycloakLoading] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [remember, setRemember] = useState(true);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      const result = await signIn('credentials', {
        username,
        password,
        redirect: false,
      });

      if (result?.error) {
        toast.error('Неверные учетные данные');
      } else {
        router.push('/');
        toast.success('Вход выполнен успешно');
      }
    } catch (error) {
      toast.error('Что-то пошло не так');
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeycloakSignIn = async () => {
    setIsKeycloakLoading(true);
    try {
      await signIn('keycloak', { callbackUrl: '/' });
    } catch (error) {
      toast.error('Ошибка входа через Keycloak');
      setIsKeycloakLoading(false);
    }
  };

  return (
    <div className="relative min-h-screen bg-gradient-to-br from-primary-50 via-background to-surface px-4 py-8 flex items-center justify-center">
      <div className="mx-auto max-w-md w-full">
        <Card className="p-6 lg:p-8 shadow-lg border-border/70">
          <div className="mb-6 text-center">
            <h1 className="text-2xl font-bold text-text-primary">Вход в Бэкофис</h1>
          </div>

          {/* Keycloak Sign In */}
          <Button
            type="button"
            variant="secondary"
            className="w-full mb-4"
            onClick={handleKeycloakSignIn}
            loading={isKeycloakLoading}
          >
            <svg className="mr-2 h-5 w-5" viewBox="0 0 24 24" fill="currentColor">
              <path d="M11.5 0L0 6v12l11.5 6L23 18V6L11.5 0zm7.8 17.2l-7.8 4.1-7.8-4.1V6.8l7.8-4.1 7.8 4.1v10.4z" />
            </svg>
            Войти через Keycloak
          </Button>

          <div className="relative my-6">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-border"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-surface text-text-tertiary">или mock-аккаунт</span>
            </div>
          </div>

          {/* Credentials Form */}
          <form onSubmit={handleSubmit} className="space-y-4">
            <Input
              label="Имя пользователя"
              value={username}
              onChange={e => setUsername(e.target.value)}
              placeholder="admin или operator"
              required
            />
            <div className="space-y-2">
              <Input
                label="Пароль"
                type={showPassword ? 'text' : 'password'}
                value={password}
                onChange={e => setPassword(e.target.value)}
                placeholder="••••••"
                required
              />
              <button
                type="button"
                className="text-xs font-medium text-primary-600 hover:text-primary-700"
                onClick={() => setShowPassword(prev => !prev)}
              >
                {showPassword ? 'Скрыть' : 'Показать'}
              </button>
            </div>

            <div className="flex items-center text-sm text-text-secondary">
              <label className="flex items-center gap-2 cursor-pointer select-none">
                <input
                  type="checkbox"
                  className="accent-primary-600"
                  checked={remember}
                  onChange={e => setRemember(e.target.checked)}
                />
                Запомнить сессию
              </label>
            </div>

            <Button type="submit" className="w-full" loading={isLoading}>
              Войти в систему
            </Button>
          </form>

          <div className="mt-4 rounded border border-border bg-surface-alt p-3">
            <div className="flex items-center justify-between mb-2">
              <p className="text-xs font-medium text-text-primary">Демо доступ</p>
              <Badge intent="neutral">
                <span className="text-xs">Mock</span>
              </Badge>
            </div>
            <div className="grid grid-cols-2 gap-2 text-xs">
              <div className="rounded bg-background p-2 border border-border">
                <p className="text-text-tertiary">Admin</p>
                <p className="text-text-primary font-medium">admin / admin</p>
              </div>
              <div className="rounded bg-background p-2 border border-border">
                <p className="text-text-tertiary">Operator</p>
                <p className="text-text-primary font-medium">operator / operator</p>
              </div>
            </div>
          </div>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/qualification/page.tsx">
'use client';

import { PageHeader, EmptyState } from '@ois/shared-ui';

export default function QualificationPage() {
  return (
    <div className="container mx-auto p-8">
      <PageHeader
        title="Управление квалификацией"
        description="Управление квалификацией инвесторов"
      />
      <EmptyState
        title="Скоро"
        description="Функции управления квалификацией находятся в разработке"
      />
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/users/components/UserModal.tsx">
'use client';

import { useEffect, useState } from 'react';
import { Modal, Button, Input, Select, SelectOption } from '@ois/shared-ui';
import { User, UserRole, UserStatus } from '@/mocks/users';
import { toast } from 'sonner';

interface UserModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (data: Partial<User>) => Promise<void>;
  user?: User;
}

const roleOptions: SelectOption[] = [
  { value: 'admin', label: 'Администратор' },
  { value: 'operator', label: 'Оператор' },
  { value: 'issuer', label: 'Эмитент' },
  { value: 'investor', label: 'Инвестор' },
];

const statusOptions: SelectOption[] = [
  { value: 'active', label: 'Активен' },
  { value: 'inactive', label: 'Неактивен' },
  { value: 'suspended', label: 'Приостановлен' },
  { value: 'blocked', label: 'Заблокирован' },
];

export function UserModal({ isOpen, onClose, onSave, user }: UserModalProps) {
  const [role, setRole] = useState<UserRole>('investor');
  const [status, setStatus] = useState<UserStatus>('active');
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [companyName, setCompanyName] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (user) {
      setRole(user.role);
      setStatus(user.status);
      setFirstName(user.firstName || '');
      setLastName(user.lastName || '');
      setCompanyName(user.companyName || '');
    } else {
      // Reset for create mode (if implemented later)
      setRole('investor');
      setStatus('active');
      setFirstName('');
      setLastName('');
      setCompanyName('');
    }
  }, [user]);

  const handleSave = async () => {
    setIsLoading(true);
    try {
      await onSave({
        role,
        status,
        firstName:
          role === 'investor' || role === 'admin' || role === 'operator' ? firstName : undefined,
        lastName:
          role === 'investor' || role === 'admin' || role === 'operator' ? lastName : undefined,
        companyName: role === 'issuer' ? companyName : undefined,
      });
      onClose();
    } catch (error) {
      toast.error('Ошибка при сохранении');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={user ? 'Редактирование пользователя' : 'Новый пользователь'}
      size="md"
    >
      <div className="space-y-4 py-4">
        <div className="grid grid-cols-2 gap-4">
          <Select
            label="Роль"
            options={roleOptions}
            value={role}
            onChange={e => setRole(e.target.value as UserRole)}
          />
          <Select
            label="Статус"
            options={statusOptions}
            value={status}
            onChange={e => setStatus(e.target.value as UserStatus)}
          />
        </div>

        {role === 'issuer' ? (
          <Input
            label="Название компании"
            value={companyName}
            onChange={e => setCompanyName(e.target.value)}
          />
        ) : (
          <div className="grid grid-cols-2 gap-4">
            <Input label="Имя" value={firstName} onChange={e => setFirstName(e.target.value)} />
            <Input label="Фамилия" value={lastName} onChange={e => setLastName(e.target.value)} />
          </div>
        )}
      </div>

      <div className="flex justify-end gap-3 pt-4">
        <Button variant="ghost" onClick={onClose} disabled={isLoading}>
          Отмена
        </Button>
        <Button onClick={handleSave} loading={isLoading}>
          Сохранить
        </Button>
      </div>
    </Modal>
  );
}
</file>

<file path="apps/backoffice/src/app/users/components/UsersTable.tsx">
'use client';

import { useState } from 'react';
import { DataTable, Badge, Button, BadgeIntent } from '@ois/shared-ui';
import { User, UserRole, UserStatus } from '@/mocks/users';
import { Edit2, Ban, CheckCircle } from 'lucide-react';
import { ColumnDef } from '@tanstack/react-table';

interface UsersTableProps {
  data: User[];
  isLoading: boolean;
  onEdit: (user: User) => void;
  onBlock: (user: User) => void;
  onUnblock: (user: User) => void;
}

const roleMap: Record<UserRole, string> = {
  admin: 'Администратор',
  operator: 'Оператор',
  issuer: 'Эмитент',
  investor: 'Инвестор',
};

const statusMap: Record<UserStatus, { label: string; intent: BadgeIntent }> = {
  active: { label: 'Активен', intent: 'success' },
  inactive: { label: 'Неактивен', intent: 'neutral' },
  suspended: { label: 'Приостановлен', intent: 'warning' },
  blocked: { label: 'Заблокирован', intent: 'danger' },
};

export function UsersTable({ data, isLoading, onEdit, onBlock, onUnblock }: UsersTableProps) {
  const columns: ColumnDef<User>[] = [
    {
      accessorKey: 'email',
      header: 'Пользователь',
      cell: ({ row }) => {
        const user = row.original;
        const name =
          user.companyName ||
          `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
          'Без имени';
        return (
          <div>
            <div className="font-medium text-text-primary">{name}</div>
            <div className="text-sm text-text-secondary">{user.email}</div>
          </div>
        );
      },
    },
    {
      accessorKey: 'role',
      header: 'Роль',
      cell: ({ row }) => <Badge intent="neutral">{roleMap[row.original.role]}</Badge>,
    },
    {
      accessorKey: 'status',
      header: 'Статус',
      cell: ({ row }) => {
        const status = statusMap[row.original.status] || {
          label: row.original.status,
          intent: 'neutral' as BadgeIntent,
        };
        return <Badge intent={status.intent}>{status.label}</Badge>;
      },
    },
    {
      accessorKey: 'createdAt',
      header: 'Дата регистрации',
      cell: ({ row }) => new Date(row.original.createdAt).toLocaleDateString('ru-RU'),
    },
    {
      id: 'actions',
      header: 'Действия',
      cell: ({ row }) => {
        const user = row.original;
        return (
          <div className="flex gap-2">
            <Button
              variant="ghost"
              size="sm"
              className="p-2"
              onClick={() => onEdit(user)}
              title="Редактировать"
            >
              <Edit2 className="h-4 w-4" />
            </Button>
            {user.status === 'blocked' ? (
              <Button
                variant="ghost"
                size="sm"
                className="p-2 text-success-primary hover:text-success-dark"
                onClick={() => onUnblock(user)}
                title="Разблокировать"
              >
                <CheckCircle className="h-4 w-4" />
              </Button>
            ) : (
              <Button
                variant="ghost"
                size="sm"
                className="p-2 text-error-primary hover:text-error-dark"
                onClick={() => onBlock(user)}
                title="Заблокировать"
              >
                <Ban className="h-4 w-4" />
              </Button>
            )}
          </div>
        );
      },
    },
  ];

  if (isLoading) {
    return <div className="p-4 text-center">Загрузка...</div>;
  }

  return <DataTable columns={columns} data={data} />;
}
</file>

<file path="apps/backoffice/src/app/users/hooks/useUserMutations.ts">
'use client';

import { useMutation, useQueryClient } from '@tanstack/react-query';
import { userService } from '@/lib/services/users';
import { User } from '@/mocks/users';
import { toast } from 'sonner';

export function useUserMutations() {
  const queryClient = useQueryClient();

  const invalidateUsers = () => queryClient.invalidateQueries({ queryKey: ['users'] });

  const updateMutation = useMutation({
    mutationFn: (data: { id: string; data: Partial<User> }) =>
      userService.updateUser(data.id, data.data),
    onSuccess: () => {
      invalidateUsers();
      toast.success('Пользователь обновлен');
    },
    onError: () => toast.error('Ошибка обновления'),
  });

  const blockMutation = useMutation({
    mutationFn: (id: string) => userService.blockUser(id),
    onSuccess: () => {
      invalidateUsers();
      toast.success('Пользователь заблокирован');
    },
    onError: () => toast.error('Ошибка блокировки'),
  });

  const unblockMutation = useMutation({
    mutationFn: (id: string) => userService.unblockUser(id),
    onSuccess: () => {
      invalidateUsers();
      toast.success('Пользователь разблокирован');
    },
    onError: () => toast.error('Ошибка разблокировки'),
  });

  return {
    updateMutation,
    blockMutation,
    unblockMutation,
    isLoading: blockMutation.isPending || unblockMutation.isPending,
  };
}
</file>

<file path="apps/backoffice/src/app/layout.tsx">
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { Providers } from '@/components/providers/Providers';
import { AppShell } from '@/components/layout/AppShell';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'OIS Backoffice',
  description: 'Backoffice for OIS CFA Platform',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Providers>
          <AppShell>{children}</AppShell>
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="apps/backoffice/src/app/not-found.tsx">
import Link from 'next/link';
import { Button } from '@ois/shared-ui';

export default function NotFound() {
  return (
    <div className="flex h-screen flex-col items-center justify-center bg-background text-text-primary">
      <h2 className="text-2xl font-bold mb-4">Страница не найдена</h2>
      <p className="text-text-secondary mb-6">Запрашиваемая страница не существует</p>
      <Link href="/">
        <Button variant="primary">На главную</Button>
      </Link>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/lib/api/compliance/complaints-api.ts">
/**
 * Complaints API (/v1/complaints)
 */

import type { Complaint } from './types';
import { apiCall } from './http-client';

/**
 * Get complaint by ID
 * GET /v1/complaints/{id}
 */
export async function getComplaint(id: string): Promise<Complaint> {
  return apiCall<Complaint>(`/v1/complaints/${id}`);
}

/**
 * Reply to complaint
 * POST /v1/complaints/{id}/reply
 */
export async function replyToComplaint(
  id: string,
  text: string,
  isInternal: boolean = false
): Promise<Complaint> {
  return apiCall<Complaint>(`/v1/complaints/${id}/reply`, {
    method: 'POST',
    body: JSON.stringify({ text, isInternal }),
  });
}

/**
 * Resolve complaint
 * POST /v1/complaints/{id}/resolve
 */
export async function resolveComplaint(
  id: string,
  resolution: 'resolved' | 'closed' | 'rejected' = 'resolved',
  resolutionText?: string
): Promise<Complaint> {
  return apiCall<Complaint>(`/v1/complaints/${id}/resolve`, {
    method: 'POST',
    body: JSON.stringify({ resolution, resolutionText }),
  });
}
</file>

<file path="apps/backoffice/src/lib/api/compliance/http-client.ts">
/**
 * Compliance HTTP Client
 * Routes all API calls through /api/proxy to handle authentication
 */

export const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';
export const COMPLIANCE_MOCK_MODE = process.env.NEXT_PUBLIC_COMPLIANCE_MOCK_MODE === 'true';

export class ComplianceApiError extends Error {
  constructor(
    public status: number,
    message: string
  ) {
    super(message);
    this.name = 'ComplianceApiError';
  }
}

/**
 * Make an API call through the proxy endpoint
 * The proxy handles authentication by adding the Bearer token from the session
 */
export async function apiCall<T>(path: string, init?: RequestInit): Promise<T> {
  const method = init?.method ?? 'GET';
  const proxyUrl = `/api/proxy?path=${encodeURIComponent(path)}`;

  const fetchOptions: RequestInit = {
    method,
    headers: {
      'Content-Type': 'application/json',
    },
    cache: 'no-store',
  };

  // Include body for POST/PUT/PATCH requests
  if (init?.body) {
    fetchOptions.body = init.body;
  }

  const response = await fetch(proxyUrl, fetchOptions);

  if (!response.ok) {
    throw new ComplianceApiError(response.status, `Compliance API error: ${response.status}`);
  }

  return (await response.json()) as T;
}

/**
 * Wrapper for API calls with mock fallback
 */
export async function apiCallWithMock<T>(
  path: string,
  mockData: T,
  errorMessage: string,
  init?: RequestInit
): Promise<T> {
  try {
    return await apiCall<T>(path, init);
  } catch {
    if (!COMPLIANCE_MOCK_MODE) {
      throw new Error(errorMessage);
    }
    return mockData;
  }
}
</file>

<file path="apps/backoffice/src/lib/api/compliance/index.ts">
/**
 * Compliance API Client
 * Re-exports all compliance API modules
 */

// Types
export type {
  KycTask,
  KycDocument,
  QualificationTask,
  Complaint,
  UserRecord,
  // Legacy types
  KycRequest,
  QualificationRequest,
} from './types';

// KYC Tasks API
export {
  listKycTasks,
  approveKycTask,
  rejectKycTask,
  submitKycDecision,
  // Legacy
  listKycRequests,
} from './kyc-api';

// KYC Documents API
export { listKycDocuments, getKycDocument, getKycDocumentDownloadUrl } from './kyc-documents-api';

// Qualification API
export {
  listQualificationTasks,
  getQualificationTask,
  approveQualificationTask,
  rejectQualificationTask,
  submitQualificationDecision,
  // Legacy
  listQualificationRequests,
} from './qualification-api';

// Complaints API
export { getComplaint, replyToComplaint, resolveComplaint } from './complaints-api';

// Users API
export { listUsers } from './users-api';
</file>

<file path="apps/backoffice/src/lib/api/compliance/kyc-api.ts">
/**
 * KYC Tasks API (/v1/kyc/tasks)
 */

import type { KycTask } from './types';
import { apiCall, apiCallWithMock } from './http-client';
import { getMockKycTasks } from './mocks';

/**
 * List KYC tasks
 * GET /v1/kyc/tasks?status={status}
 */
export async function listKycTasks(status?: 'open' | 'approved' | 'rejected'): Promise<KycTask[]> {
  const query = status ? `?status=${status}` : '';
  const mockTasks = getMockKycTasks();
  const filteredMock = status ? mockTasks.filter(t => t.status === status) : mockTasks;

  return apiCallWithMock<KycTask[]>(`/v1/kyc/tasks${query}`, filteredMock, 'KYC tasks unavailable');
}

/**
 * Approve KYC task
 * POST /v1/kyc/tasks/{id}/approve
 */
export async function approveKycTask(id: string): Promise<KycTask> {
  return apiCall<KycTask>(`/v1/kyc/tasks/${id}/approve`, {
    method: 'POST',
  });
}

/**
 * Reject KYC task
 * POST /v1/kyc/tasks/{id}/reject
 */
export async function rejectKycTask(id: string, reason?: string): Promise<KycTask> {
  return apiCall<KycTask>(`/v1/kyc/tasks/${id}/reject`, {
    method: 'POST',
    body: reason ? JSON.stringify({ reason }) : undefined,
  });
}

/**
 * Submit KYC decision (approve or reject)
 * Wrapper for approveKycTask/rejectKycTask
 */
export async function submitKycDecision(
  id: string,
  decision: 'approved' | 'rejected',
  comment?: string
): Promise<void> {
  if (decision === 'approved') {
    await approveKycTask(id);
  } else {
    await rejectKycTask(id, comment);
  }
}

// Legacy function alias
/** @deprecated Use listKycTasks instead */
export const listKycRequests = listKycTasks;
</file>

<file path="apps/backoffice/src/lib/api/compliance/mocks.ts">
/**
 * Mock data for Compliance API
 */

import type { KycTask, KycDocument, QualificationTask, UserRecord } from './types';

export function getMockKycTasks(): KycTask[] {
  return [
    {
      id: 'mock-kyc-1',
      investorId: 'investor-001',
      status: 'open',
      createdAt: new Date().toISOString(),
      reason: null,
    },
    {
      id: 'mock-kyc-2',
      investorId: 'investor-002',
      status: 'approved',
      createdAt: new Date(Date.now() - 86400000).toISOString(),
      resolvedAt: new Date().toISOString(),
    },
  ];
}

export function getMockKycDocuments(investorId: string): KycDocument[] {
  return [
    {
      id: 'doc-1',
      investorId,
      documentType: 'passport_main',
      fileName: 'Passport.pdf',
      fileSize: 1024000,
      mimeType: 'application/pdf',
      status: 'uploaded',
      uploadedAt: new Date().toISOString(),
    },
  ];
}

export function getMockQualificationTasks(): QualificationTask[] {
  return [
    {
      id: 'qual-1',
      investorId: 'investor-003',
      qualificationBasis: 'total_assets',
      status: 'open',
      createdAt: new Date().toISOString(),
    },
    {
      id: 'qual-2',
      investorId: 'investor-004',
      qualificationBasis: 'annual_income',
      status: 'approved',
      assignedTier: 'qualified',
      assignedLimit: 12000000,
      createdAt: new Date(Date.now() - 172800000).toISOString(),
      resolvedAt: new Date().toISOString(),
    },
  ];
}

export function getMockUsers(): UserRecord[] {
  return [
    {
      id: 'user-mock-1',
      email: 'demo@example.com',
      roles: ['issuer'],
      status: 'active',
      createdAt: new Date().toISOString(),
    },
  ];
}
</file>

<file path="apps/backoffice/src/lib/api/compliance/qualification-api.ts">
/**
 * Qualification Tasks API (/v1/qualification/tasks)
 */

import type { QualificationTask } from './types';
import { apiCall, apiCallWithMock } from './http-client';
import { getMockQualificationTasks } from './mocks';

/**
 * List qualification tasks
 * GET /v1/qualification/tasks?status={status}
 */
export async function listQualificationTasks(
  status?: 'open' | 'approved' | 'rejected'
): Promise<QualificationTask[]> {
  const query = status ? `?status=${status}` : '';
  const mockTasks = getMockQualificationTasks();
  const filteredMock = status ? mockTasks.filter(t => t.status === status) : mockTasks;

  return apiCallWithMock<QualificationTask[]>(
    `/v1/qualification/tasks${query}`,
    filteredMock,
    'Qualification tasks unavailable'
  );
}

/**
 * Get qualification task by ID
 * GET /v1/qualification/tasks/{id}
 */
export async function getQualificationTask(id: string): Promise<QualificationTask> {
  return apiCall<QualificationTask>(`/v1/qualification/tasks/${id}`);
}

/**
 * Approve qualification task
 * POST /v1/qualification/tasks/{id}/approve
 */
export async function approveQualificationTask(
  id: string,
  tier: 'qualified' | 'professional',
  limit?: number,
  reason?: string
): Promise<QualificationTask> {
  return apiCall<QualificationTask>(`/v1/qualification/tasks/${id}/approve`, {
    method: 'POST',
    body: JSON.stringify({ tier, limit, reason }),
  });
}

/**
 * Reject qualification task
 * POST /v1/qualification/tasks/{id}/reject
 */
export async function rejectQualificationTask(
  id: string,
  reason: string
): Promise<QualificationTask> {
  return apiCall<QualificationTask>(`/v1/qualification/tasks/${id}/reject`, {
    method: 'POST',
    body: JSON.stringify({ reason }),
  });
}

/**
 * Submit qualification decision (approve or reject)
 * Wrapper for approveQualificationTask/rejectQualificationTask
 */
export async function submitQualificationDecision(
  id: string,
  decision: 'qualified' | 'unqualified',
  comment?: string
): Promise<void> {
  if (decision === 'qualified') {
    await approveQualificationTask(id, 'qualified', undefined, comment);
  } else {
    await rejectQualificationTask(id, comment ?? 'Не соответствует критериям квалификации');
  }
}

// Legacy function alias
/** @deprecated Use listQualificationTasks instead */
export const listQualificationRequests = listQualificationTasks;
</file>

<file path="apps/backoffice/src/lib/api/compliance/types.ts">
/**
 * Compliance API Types
 * Согласовано с openapi-compliance.yaml v1.1.0
 */

/** KYC Task - задача на проверку KYC (из /v1/kyc/tasks) */
export type KycTask = {
  id: string;
  investorId: string;
  status: 'open' | 'approved' | 'rejected';
  reason?: string | null;
  createdAt: string;
  resolvedAt?: string | null;
};

/** Qualification Task - задача на проверку квалификации */
export type QualificationTask = {
  id: string;
  investorId: string;
  qualificationBasis:
    | 'trading_turnover'
    | 'total_assets'
    | 'annual_income'
    | 'work_experience'
    | 'education'
    | 'certificate';
  status: 'open' | 'approved' | 'rejected';
  assignedTier?: 'unqualified' | 'qualified' | 'professional' | null;
  assignedLimit?: number | null;
  reason?: string | null;
  documentIds?: string[];
  createdAt: string;
  resolvedAt?: string | null;
  resolvedBy?: string | null;
  expiresAt?: string | null;
};

/** KYC Document */
export type KycDocument = {
  id: string;
  investorId: string;
  documentType:
    | 'passport_main'
    | 'passport_registration'
    | 'selfie'
    | 'proof_of_address'
    | 'inn_certificate'
    | 'other';
  fileName: string;
  fileSize: number;
  mimeType: string;
  status: 'uploaded' | 'verified' | 'rejected';
  rejectionReason?: string | null;
  uploadedAt: string;
  verifiedAt?: string | null;
};

/** Complaint */
export type Complaint = {
  id: string;
  investorId?: string | null;
  category: 'fraud' | 'service' | 'technical' | 'other';
  text: string;
  status: 'open' | 'in_progress' | 'resolved' | 'closed';
  slaDue?: string | null;
  createdAt: string;
  resolvedAt?: string | null;
};

/** User Record (identity service) */
export type UserRecord = {
  id: string;
  email: string;
  roles: string[];
  status: 'active' | 'blocked' | 'invited';
  createdAt: string;
  firstName?: string;
  lastName?: string;
};

// Legacy type aliases for backward compatibility
/** @deprecated Use KycTask instead */
export type KycRequest = KycTask;

/** @deprecated Use QualificationTask instead */
export type QualificationRequest = QualificationTask;
</file>

<file path="apps/backoffice/src/lib/api/compliance/users-api.ts">
/**
 * Users API (/v1/identity/users)
 */

import type { UserRecord } from './types';
import { apiCallWithMock } from './http-client';
import { getMockUsers } from './mocks';

/**
 * List users
 * GET /v1/identity/users?query={query}
 */
export async function listUsers(query?: string): Promise<UserRecord[]> {
  const search = query ? `?query=${encodeURIComponent(query)}` : '';

  return apiCallWithMock<UserRecord[]>(
    `/v1/identity/users${search}`,
    getMockUsers(),
    'Users listing unavailable'
  );
}
</file>

<file path="apps/backoffice/src/lib/api/audit.ts">
const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';
const AUDIT_MOCK_MODE = process.env.NEXT_PUBLIC_AUDIT_MOCK_MODE === 'true';

export type AuditEvent = {
  id: string;
  actor: string;
  actorName?: string;
  action: string;
  entity: string;
  entityId?: string;
  payload?: Record<string, unknown>;
  ip?: string;
  userAgent?: string;
  timestamp: string;
  result?: 'success' | 'failure' | 'pending';
};

export type AuditFilters = {
  from?: string;
  to?: string;
  action?: string;
  actor?: string;
};

const fallbackEvents: AuditEvent[] = [
  {
    id: 'audit-mock-1',
    actor: 'issuer.portal',
    actorName: 'Issuer Portal',
    action: 'kyc.approve',
    entity: 'investor#001',
    timestamp: new Date().toISOString(),
    result: 'success',
    payload: { note: 'Auto-approved for pilot' },
  },
  {
    id: 'audit-mock-2',
    actor: 'backoffice.admin',
    action: 'login.failure',
    entity: 'session',
    timestamp: new Date(Date.now() - 3600 * 1000).toISOString(),
    result: 'failure',
    payload: { reason: 'MFA timeout' },
  },
];

async function callAudit<T>(path: string, init?: RequestInit): Promise<T> {
  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    throw new Error(`Audit API error ${response.status}`);
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return (await response.json()) as T;
}

function filterFallback(events: AuditEvent[], filters?: AuditFilters): AuditEvent[] {
  if (!filters) {
    return events;
  }

  return events.filter((event) => {
    if (filters.action && !event.action.includes(filters.action)) {
      return false;
    }
    if (filters.actor && !event.actor.includes(filters.actor)) {
      return false;
    }
    if (filters.from && new Date(event.timestamp) < new Date(filters.from)) {
      return false;
    }
    if (filters.to && new Date(event.timestamp) > new Date(filters.to)) {
      return false;
    }
    return true;
  });
}

export async function getAuditLogs(filters?: AuditFilters): Promise<AuditEvent[]> {
  const params = new URLSearchParams();
  if (filters?.from) params.set('from', filters.from);
  if (filters?.to) params.set('to', filters.to);
  if (filters?.action) params.set('action', filters.action);
  if (filters?.actor) params.set('actor', filters.actor);
  const search = params.toString() ? `?${params.toString()}` : '';

  const data = await callAudit<AuditEvent[]>(`/v1/audit${search}`).catch((err) => {
    if (AUDIT_MOCK_MODE) {
      return filterFallback(fallbackEvents, filters);
    }
    throw err;
  });
  return data;
}

export async function getAuditEvent(id: string): Promise<AuditEvent | null> {
  const event = await callAudit<AuditEvent>(`/v1/audit/${id}`).catch(async (err) => {
    if (AUDIT_MOCK_MODE) {
      const logs = await getAuditLogs();
      return logs.find((e) => e.id === id) ?? null;
    }
    throw err;
  });
  return event;
}
</file>

<file path="apps/backoffice/src/lib/constants/index.ts">
/**
 * Shared constants
 */

export * from './status';
export * from './navigation';
</file>

<file path="apps/backoffice/src/lib/constants/navigation.ts">
/**
 * Navigation configuration for backoffice
 */

export type SidebarItem = {
  label: string;
  href: string;
};

export const SIDEBAR_ITEMS: SidebarItem[] = [
  { label: 'Главная', href: '/' },
  { label: 'KYC', href: '/kyc' },
  { label: 'Жалобы', href: '/complaints' },
  { label: 'Пользователи', href: '/users' },
  { label: 'Аудит', href: '/audit' },
  { label: 'Выплаты', href: '/payouts' },
];

export const SIDEBAR_CONFIG = {
  items: SIDEBAR_ITEMS,
};
</file>

<file path="apps/backoffice/src/lib/constants/status.ts">
/**
 * Shared status labels and badge intents
 */

export const STATUS_LABELS: Record<string, string> = {
  open: 'ОЖИДАЮТ',
  approved: 'ОДОБРЕНО',
  rejected: 'ОТКЛОНЕНО',
  pending: 'ОЖИДАЕТ',
  in_progress: 'В РАБОТЕ',
  resolved: 'РЕШЕНО',
  closed: 'ЗАКРЫТО',
  active: 'Активен',
  blocked: 'Заблокирован',
  invited: 'Приглашён',
};

export const QUALIFICATION_BASIS_LABELS: Record<string, string> = {
  trading_turnover: 'Оборот сделок',
  total_assets: 'Активы',
  annual_income: 'Годовой доход',
  work_experience: 'Опыт работы',
  education: 'Образование',
  certificate: 'Аттестат',
};

export const TIER_LABELS: Record<string, string> = {
  unqualified: 'Неквалифицированный',
  qualified: 'Квалифицированный',
  professional: 'Профессиональный',
};

export const COMPLAINT_CATEGORY_LABELS: Record<string, string> = {
  fraud: 'Мошенничество',
  service: 'Сервис',
  technical: 'Техническая',
  other: 'Другое',
};

export const DOCUMENT_TYPE_LABELS: Record<string, string> = {
  passport_main: 'Паспорт (основной разворот)',
  passport_registration: 'Паспорт (регистрация)',
  selfie: 'Селфи с документом',
  proof_of_address: 'Подтверждение адреса',
  inn_certificate: 'Свидетельство ИНН',
  other: 'Другой документ',
};

export type BadgeIntent = 'success' | 'danger' | 'warning' | 'neutral' | 'info';

export function getStatusBadgeIntent(status: string): BadgeIntent {
  switch (status) {
    case 'approved':
    case 'resolved':
    case 'active':
      return 'success';
    case 'rejected':
    case 'blocked':
      return 'danger';
    case 'open':
    case 'pending':
    case 'in_progress':
    case 'invited':
      return 'warning';
    case 'closed':
      return 'neutral';
    default:
      return 'neutral';
  }
}

export function getStatusLabel(status: string): string {
  return STATUS_LABELS[status] ?? status.toUpperCase();
}
</file>

<file path="apps/backoffice/src/lib/hooks/useConfirmDialog.ts">
'use client';

import { useState, useCallback } from 'react';

type DialogVariant = 'danger' | 'warning';

type ConfirmDialogState = {
  isOpen: boolean;
  title: string;
  description: string;
  confirmText: string;
  variant: DialogVariant;
  onConfirm: () => Promise<unknown> | unknown;
};

const INITIAL_STATE: ConfirmDialogState = {
  isOpen: false,
  title: '',
  description: '',
  confirmText: 'Подтвердить',
  variant: 'warning',
  onConfirm: () => {},
};

type OpenDialogParams = {
  title: string;
  description: string;
  confirmText?: string;
  variant?: DialogVariant;
  onConfirm: () => Promise<unknown> | unknown;
};

export function useConfirmDialog() {
  const [state, setState] = useState<ConfirmDialogState>(INITIAL_STATE);
  const [isLoading, setIsLoading] = useState(false);

  const open = useCallback((params: OpenDialogParams) => {
    setState({
      isOpen: true,
      title: params.title,
      description: params.description,
      confirmText: params.confirmText ?? 'Подтвердить',
      variant: params.variant ?? 'warning',
      onConfirm: params.onConfirm,
    });
  }, []);

  const close = useCallback(() => {
    setState(prev => ({ ...prev, isOpen: false }));
  }, []);

  const confirm = useCallback(async () => {
    setIsLoading(true);
    try {
      await state.onConfirm();
      close();
    } finally {
      setIsLoading(false);
    }
  }, [state.onConfirm, close]);

  return {
    dialogProps: {
      isOpen: state.isOpen,
      title: state.title,
      description: state.description,
      confirmText: state.confirmText,
      variant: state.variant,
      isLoading,
      onClose: close,
      onConfirm: confirm,
    },
    open,
    close,
  };
}
</file>

<file path="apps/backoffice/src/lib/services/audit.ts">
import { AuditLogEntry, MOCK_AUDIT_LOGS, AuditEventType } from '@/mocks/audit';

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export const auditService = {
  async getLogs(filters?: {
    eventType?: AuditEventType;
    search?: string;
    startDate?: Date;
    endDate?: Date;
  }): Promise<AuditLogEntry[]> {
    await delay(500);
    let logs = [...MOCK_AUDIT_LOGS];

    if (filters?.eventType) {
      logs = logs.filter(log => log.eventType === filters.eventType);
    }

    if (filters?.search) {
      const searchLower = filters.search.toLowerCase();
      logs = logs.filter(
        log =>
          log.actorEmail.toLowerCase().includes(searchLower) ||
          log.action.toLowerCase().includes(searchLower) ||
          log.details.toLowerCase().includes(searchLower)
      );
    }

    if (filters?.startDate) {
      logs = logs.filter(log => new Date(log.timestamp) >= filters.startDate!);
    }

    if (filters?.endDate) {
      logs = logs.filter(log => new Date(log.timestamp) <= filters.endDate!);
    }

    return logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  },
};
</file>

<file path="apps/backoffice/src/lib/services/complaints.ts">
import { Complaint, MOCK_COMPLAINTS, ComplaintStatus } from '@/mocks/complaints';

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

const complaints = [...MOCK_COMPLAINTS];

export const complaintsService = {
  async getComplaints(status?: ComplaintStatus): Promise<Complaint[]> {
    await delay(500);
    if (status) {
      return complaints.filter(c => c.status === status);
    }
    return complaints.sort(
      (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    );
  },

  async getComplaintById(id: string): Promise<Complaint | undefined> {
    await delay(300);
    return complaints.find(c => c.id === id);
  },

  async replyToComplaint(id: string, text: string): Promise<Complaint> {
    await delay(600);
    const index = complaints.findIndex(c => c.id === id);
    if (index === -1) throw new Error('Complaint not found');

    const complaint = complaints[index];
    const updatedComplaint = {
      ...complaint,
      status: 'in_progress' as ComplaintStatus,
      updatedAt: new Date().toISOString(),
      messages: [
        ...complaint.messages,
        {
          id: `msg-${Date.now()}`,
          sender: 'support' as const,
          text,
          timestamp: new Date().toISOString(),
        },
      ],
    };

    complaints[index] = updatedComplaint;
    return updatedComplaint;
  },

  async resolveComplaint(id: string): Promise<Complaint> {
    await delay(400);
    const index = complaints.findIndex(c => c.id === id);
    if (index === -1) throw new Error('Complaint not found');

    complaints[index] = {
      ...complaints[index],
      status: 'resolved',
      updatedAt: new Date().toISOString(),
    };
    return complaints[index];
  },
};
</file>

<file path="apps/backoffice/src/lib/services/users.ts">
import { MOCK_USERS, User, UserRole, UserStatus } from '@/mocks/users';

// Simulate network delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// In-memory store for development
const users = [...MOCK_USERS];

export const userService = {
  async getUsers(filters?: {
    role?: UserRole;
    status?: UserStatus;
    search?: string;
  }): Promise<User[]> {
    await delay(500);
    let filtered = [...users];

    if (filters?.role) {
      filtered = filtered.filter(u => u.role === filters.role);
    }
    if (filters?.status) {
      filtered = filtered.filter(u => u.status === filters.status);
    }
    if (filters?.search) {
      const searchLower = filters.search.toLowerCase();
      filtered = filtered.filter(
        u =>
          u.email.toLowerCase().includes(searchLower) ||
          u.firstName?.toLowerCase().includes(searchLower) ||
          u.lastName?.toLowerCase().includes(searchLower) ||
          u.companyName?.toLowerCase().includes(searchLower)
      );
    }

    return filtered;
  },

  async getUserById(id: string): Promise<User | undefined> {
    await delay(300);
    return users.find(u => u.id === id);
  },

  async updateUser(id: string, data: Partial<User>): Promise<User> {
    await delay(500);
    const index = users.findIndex(u => u.id === id);
    if (index === -1) throw new Error('User not found');

    users[index] = { ...users[index], ...data };
    return users[index];
  },

  async blockUser(id: string): Promise<User> {
    return this.updateUser(id, { status: 'blocked' });
  },

  async unblockUser(id: string): Promise<User> {
    return this.updateUser(id, { status: 'active' });
  },
};
</file>

<file path="apps/backoffice/src/lib/utils/file.ts">
/**
 * File utilities
 */

export function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

export function isImageFile(mimeType: string): boolean {
  return mimeType?.startsWith('image/') ?? false;
}
</file>

<file path="apps/backoffice/src/lib/api-client.ts">
'use server';

import type { AuditEvent, AuditFilters } from './api/audit';
import { getAuditEvent as fetchAuditEvent, getAuditLogs } from './api/audit';
import type { PayoutReport, SettlementJob } from './api/reports';
import {
  getPayoutsReport as fetchPayoutsReport,
  runSettlement as triggerSettlement,
} from './api/reports';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

async function request<T>(path: string, init?: RequestInit): Promise<T> {
  const res = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!res.ok) {
    throw new Error(`API error ${res.status}`);
  }

  if (res.status === 204) {
    return undefined as T;
  }

  return (await res.json()) as T;
}

type KycDocument = {
  id: string;
  name: string;
  status: string;
};

type KycDecisionPayload = {
  decision: 'approved' | 'rejected';
  comment?: string;
};

type InvestorStatus = {
  kyc: 'not_started' | 'pending' | 'review' | 'pass' | 'fail';
};

export const apiClient = {
  async getAuditEvents(filters?: AuditFilters): Promise<{ data: AuditEvent[] }> {
    const data = await getAuditLogs(filters);
    return { data };
  },
  async getAuditEvent(id: string): Promise<{ data: AuditEvent | null }> {
    const data = await fetchAuditEvent(id);
    return { data };
  },
  async getKycDocuments(investorId: string): Promise<{ data: KycDocument[] }> {
    return {
      data: [
        {
          id: 'doc-demo',
          name: `Document for ${investorId}`,
          status: 'uploaded',
        },
      ],
    };
  },
  async makeKycDecision(
    investorId: string,
    payload: KycDecisionPayload
  ): Promise<{ data: { ok: boolean } }> {
    await request(`/v1/kyc/${investorId}/decision`, {
      method: 'POST',
      body: JSON.stringify(payload),
    });
    return { data: { ok: true } };
  },
  async uploadKycDocuments(): Promise<{ data: { ok: boolean } }> {
    return { data: { ok: true } };
  },
  async getInvestorStatus(): Promise<{ data: InvestorStatus }> {
    return { data: { kyc: 'pending' } };
  },
  async getPayoutsReport(params: { from: string; to: string }): Promise<{ data: PayoutReport }> {
    const data = await fetchPayoutsReport(params);
    return { data };
  },
  async runSettlement(params?: { date?: string }): Promise<{ data: SettlementJob }> {
    const data = await triggerSettlement(params);
    return { data };
  },
};

export const legacyApiClient = apiClient;

export type { AuditEvent } from './api/audit';
export type { PayoutReport, PayoutReportItem, SettlementJob } from './api/reports';
export { getAuditLogs, getAuditEvent } from './api/audit';
export { getPayoutsReport, runSettlement } from './api/reports';
</file>

<file path="apps/backoffice/src/mocks/audit.ts">
export type AuditEventType = 'auth' | 'user_mgmt' | 'kyc' | 'system';
export type AuditEventStatus = 'success' | 'failure';

export interface AuditLogEntry {
  id: string;
  timestamp: string;
  actorId: string;
  actorEmail: string;
  eventType: AuditEventType;
  action: string;
  details: string;
  status: AuditEventStatus;
  ipAddress: string;
}

export const MOCK_AUDIT_LOGS: AuditLogEntry[] = [
  {
    id: 'log-1',
    timestamp: new Date(Date.now() - 1000 * 60 * 5).toISOString(), // 5 mins ago
    actorId: '1',
    actorEmail: 'admin@ois.com',
    eventType: 'auth',
    action: 'LOGIN',
    details: 'User logged in successfully',
    status: 'success',
    ipAddress: '192.168.1.1',
  },
  {
    id: 'log-2',
    timestamp: new Date(Date.now() - 1000 * 60 * 60).toISOString(), // 1 hour ago
    actorId: '2',
    actorEmail: 'operator@ois.com',
    eventType: 'kyc',
    action: 'APPROVE_KYC',
    details: 'Approved KYC for investor-001',
    status: 'success',
    ipAddress: '10.0.0.5',
  },
  {
    id: 'log-3',
    timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(), // 2 hours ago
    actorId: '1',
    actorEmail: 'admin@ois.com',
    eventType: 'user_mgmt',
    action: 'BLOCK_USER',
    details: 'Blocked user blocked@scam.com',
    status: 'success',
    ipAddress: '192.168.1.1',
  },
  {
    id: 'log-4',
    timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(), // 1 day ago
    actorId: 'unknown',
    actorEmail: 'unknown',
    eventType: 'auth',
    action: 'LOGIN_FAILED',
    details: 'Invalid password for user admin',
    status: 'failure',
    ipAddress: '203.0.113.42',
  },
];
</file>

<file path="apps/backoffice/src/mocks/complaints.ts">
export type ComplaintStatus = 'open' | 'in_progress' | 'resolved' | 'rejected';

export interface Complaint {
  id: string;
  userId: string;
  userEmail: string;
  subject: string;
  description: string;
  status: ComplaintStatus;
  createdAt: string;
  updatedAt: string;
  messages: Array<{
    id: string;
    sender: 'user' | 'support';
    text: string;
    timestamp: string;
  }>;
}

export const MOCK_COMPLAINTS: Complaint[] = [
  {
    id: 'comp-1',
    userId: '4',
    userEmail: 'investor@mail.ru',
    subject: 'Не могу пройти KYC',
    description: 'Загружаю паспорт, а система выдает ошибку. Помогите!',
    status: 'open',
    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 3).toISOString(), // 3 hours ago
    updatedAt: new Date(Date.now() - 1000 * 60 * 60 * 3).toISOString(),
    messages: [
      {
        id: 'msg-1',
        sender: 'user',
        text: 'Загружаю паспорт, а система выдает ошибку. Помогите!',
        timestamp: new Date(Date.now() - 1000 * 60 * 60 * 3).toISOString(),
      },
    ],
  },
  {
    id: 'comp-2',
    userId: '3',
    userEmail: 'issuer@gazprom.ru',
    subject: 'Ошибка при выпуске ЦФА',
    description: 'Не отображается кнопка "Подписать".',
    status: 'in_progress',
    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(), // 1 day ago
    updatedAt: new Date(Date.now() - 1000 * 60 * 60 * 20).toISOString(),
    messages: [
      {
        id: 'msg-2',
        sender: 'user',
        text: 'Не отображается кнопка "Подписать".',
        timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(),
      },
      {
        id: 'msg-3',
        sender: 'support',
        text: 'Добрый день. Проверьте, установлен ли плагин КриптоПро.',
        timestamp: new Date(Date.now() - 1000 * 60 * 60 * 20).toISOString(),
      },
    ],
  },
];
</file>

<file path="apps/backoffice/src/mocks/users.ts">
export type UserRole = 'admin' | 'operator' | 'issuer' | 'investor';
export type UserStatus = 'active' | 'inactive' | 'suspended' | 'blocked';

export interface User {
  id: string;
  email: string;
  firstName?: string;
  lastName?: string;
  role: UserRole;
  status: UserStatus;
  createdAt: string;
  lastLogin?: string;
  // Issuer specific
  companyName?: string;
  inn?: string;
}

export const MOCK_USERS: User[] = [
  {
    id: '1',
    email: 'admin@ois.com',
    firstName: 'Admin',
    lastName: 'User',
    role: 'admin',
    status: 'active',
    createdAt: '2023-01-01T00:00:00Z',
    lastLogin: '2023-11-22T10:00:00Z',
  },
  {
    id: '2',
    email: 'operator@ois.com',
    firstName: 'Operator',
    lastName: 'User',
    role: 'operator',
    status: 'active',
    createdAt: '2023-01-02T00:00:00Z',
    lastLogin: '2023-11-22T09:30:00Z',
  },
  {
    id: '3',
    email: 'issuer@gazprom.ru',
    role: 'issuer',
    status: 'active',
    companyName: 'ПАО Газпром',
    inn: '7736050003',
    createdAt: '2023-05-15T10:00:00Z',
    lastLogin: '2023-11-20T14:20:00Z',
  },
  {
    id: '4',
    email: 'investor@mail.ru',
    firstName: 'Иван',
    lastName: 'Иванов',
    role: 'investor',
    status: 'active',
    createdAt: '2023-06-01T12:00:00Z',
    lastLogin: '2023-11-21T18:45:00Z',
  },
  {
    id: '5',
    email: 'blocked@scam.com',
    role: 'investor',
    status: 'blocked',
    createdAt: '2023-08-10T09:00:00Z',
    lastLogin: '2023-08-11T10:00:00Z',
  },
];
</file>

<file path="apps/backoffice/src/types/next-auth.d.ts">
import 'next-auth';

declare module 'next-auth' {
  interface Session {
    accessToken?: string;
    user: {
      name?: string | null;
      email?: string | null;
      image?: string | null;
      roles?: string[];
    };
  }

  interface User {
    roles?: string[];
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    roles?: string[];
    accessToken?: string;
    idToken?: string;
    refreshToken?: string;
  }
}
</file>

<file path="apps/backoffice/src/middleware.ts">
import { withAuth } from 'next-auth/middleware';

export default withAuth({
  callbacks: {
    authorized: ({ token }) => {
      const roles = (token?.roles as string[]) || [];
      // Allow access if user has admin or backoffice role
      // Note: Keycloak roles might be different, adjust as needed based on actual Keycloak config
      if (roles.includes('admin') || roles.includes('backoffice') || roles.includes('operator')) {
        return true;
      }
      // If no specific roles required for general access, just check if token exists
      return !!token;
    },
  },
});

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico|login).*)'],
};
</file>

<file path="apps/backoffice/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  transpilePackages: ['@ois/shared-ui'],
  webpack: (config) => {
    config.resolve.alias['@'] = require('path').join(__dirname, 'src');
    config.resolve.modules = [
      require('path').join(__dirname, 'node_modules'),
      require('path').join(__dirname, '../shared-ui/node_modules'),
      'node_modules'
    ];
    return config;
  },
  env: {
    NEXT_PUBLIC_API_BASE_URL: process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000',
    NEXT_PUBLIC_KEYCLOAK_URL: process.env.NEXT_PUBLIC_KEYCLOAK_URL || 'http://localhost:8080',
    NEXT_PUBLIC_KEYCLOAK_REALM: process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'ois-dev',
    NEXT_PUBLIC_KEYCLOAK_CLIENT_ID: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'backoffice'
  }
};

module.exports = nextConfig;
</file>

<file path="apps/backoffice/package.json">
{
  "name": "@ois/backoffice",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3003",
    "build": "next build",
    "start": "next start -p 3003",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "format:check": "prettier --check \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    "test:unit": "vitest run",
    "test:watch": "vitest watch",
    "test:coverage": "vitest run --coverage",
    "prepare": "cd ../.. && husky apps/.husky || true"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "prettier --write",
      "eslint --fix --max-warnings=100"
    ],
    "*.{json,css,md}": [
      "prettier --write"
    ]
  },
  "dependencies": {
    "@ois/api-client": "file:../../packages/sdks/ts",
    "@ois/shared-ui": "file:../shared-ui",
    "@tanstack/react-query": "^5.17.0",
    "@tanstack/react-table": "^8.21.3",
    "axios": "^1.6.0",
    "lucide-react": "^0.303.0",
    "next": "15.0.0",
    "next-auth": "^4.24.5",
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "recharts": "^3.4.1",
    "sonner": "^1.3.1",
    "tailwind-merge": "^3.4.0",
    "web-vitals": "^4.2.4",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^5.1.1",
    "@vitest/coverage-v8": "^4.0.13",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.56.0",
    "eslint-config-next": "15.0.0",
    "eslint-config-prettier": "^9.1.0",
    "husky": "^9.1.0",
    "jsdom": "^27.0.1",
    "lint-staged": "^15.2.0",
    "msw": "^2.12.2",
    "postcss": "^8.4.32",
    "prettier": "^3.2.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="apps/backoffice/tailwind.config.ts">
import type { Config } from 'tailwindcss';
import preset from '../_theme/tailwind-preset.js';

const config: Config = {
  presets: [preset],
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
    '../shared-ui/src/**/*.{js,ts,jsx,tsx,mdx}',
    '../../node_modules/@ois/shared-ui/dist/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;
</file>

<file path="apps/backoffice/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./vitest.setup.ts'],
    include: ['src/**/*.{test,spec}.{ts,tsx}'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/lib/**', 'src/hooks/**'],
      exclude: ['src/**/*.d.ts', 'src/**/*.test.ts', 'src/**/*.spec.ts'],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
</file>

<file path="apps/backoffice/vitest.setup.ts">
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach, vi } from 'vitest';

afterEach(() => {
  cleanup();
});

vi.mock('next/navigation', () => ({
  useRouter: () => ({
    push: vi.fn(),
    replace: vi.fn(),
    back: vi.fn(),
    forward: vi.fn(),
    refresh: vi.fn(),
    prefetch: vi.fn(),
  }),
  usePathname: () => '/',
  useSearchParams: () => new URLSearchParams(),
  useParams: () => ({}),
  redirect: vi.fn(),
}));

vi.mock('next-auth/react', () => ({
  useSession: () => ({
    data: {
      user: {
        id: 'test-admin-id',
        name: 'Test Admin',
        email: 'admin@test.com',
        role: 'admin',
      },
      expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
    },
    status: 'authenticated',
  }),
  signIn: vi.fn(),
  signOut: vi.fn(),
}));

global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});
</file>

<file path="apps/portal-investor/src/app/history/components/DateRangeFilter.tsx">
import { Input } from '@ois/shared-ui';

type Props = {
  from: string;
  to: string;
  onChange: (range: { from: string; to: string }) => void;
};

export function DateRangeFilter({ from, to, onChange }: Props) {
  return (
    <div className="mb-6 flex flex-col gap-2 md:flex-row md:items-end md:gap-2">
      <Input
        label="С"
        type="date"
        value={from}
        onChange={e => onChange({ from: e.target.value, to })}
        className="md:w-44"
      />
      <Input
        label="По"
        type="date"
        value={to}
        onChange={e => onChange({ from, to: e.target.value })}
        className="md:w-44"
      />
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/history/components/HistoryTabs.tsx">
import { Button } from '@ois/shared-ui';

type Props = {
  active: 'orders' | 'payouts' | 'redemptions';
  counts: { orders?: number; payouts?: number; redemptions?: number };
  onChange: (tab: 'orders' | 'payouts' | 'redemptions') => void;
};

export function HistoryTabs({ active, counts, onChange }: Props) {
  return (
    <div className="mb-6 border-b border-border">
      <div className="flex flex-wrap gap-2">
        <Button
          variant={active === 'orders' ? 'primary' : 'secondary'}
          onClick={() => onChange('orders')}
        >
          Заявки ({counts.orders || 0})
        </Button>
        <Button
          variant={active === 'payouts' ? 'primary' : 'secondary'}
          onClick={() => onChange('payouts')}
        >
          Выплаты ({counts.payouts || 0})
        </Button>
        <Button
          variant={active === 'redemptions' ? 'primary' : 'secondary'}
          onClick={() => onChange('redemptions')}
        >
          Погашения ({counts.redemptions || 0})
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/issuances/[id]/components/DocumentsSection.tsx">
import { FileText } from 'lucide-react';
import { formatDateTime } from '@/lib/format';

type Props = {
  documents: Array<{ id: string; title: string; type?: string; url: string; publishedAt?: string }>;
};

export function DocumentsSection({ documents }: Props) {
  return (
    <div className="bg-surface border border-border rounded-lg p-6">
      <h2 className="text-xl font-semibold text-text-primary mb-4">Документы</h2>
      {documents.length === 0 ? (
        <p className="text-text-secondary">Документы недоступны.</p>
      ) : (
        <div className="space-y-3">
          {documents.map(doc => (
            <a
              key={doc.id}
              href={doc.url}
              className="flex items-center justify-between rounded-md border border-border px-4 py-3 hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              <div className="flex items-center gap-3">
                <FileText className="h-4 w-4 text-text-tertiary" />
                <div>
                  <p className="font-medium text-text-primary">{doc.title}</p>
                  <p className="text-xs text-text-secondary">
                    {doc.type || 'Документ'} ·{' '}
                    {doc.publishedAt ? formatDateTime(doc.publishedAt) : '—'}
                  </p>
                </div>
              </div>
              <span className="text-sm text-primary-600">Скачать</span>
            </a>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/issuances/[id]/components/OrderPanel.tsx">
import { Button, Input } from '@ois/shared-ui';
import { formatCurrency } from '@/lib/format';

type Props = {
  availableAmount: number;
  yieldPercent: number;
  amount: string;
  onAmountChange: (val: string) => void;
  onBuy: () => void;
  isSubmitting: boolean;
};

export function OrderPanel({
  availableAmount,
  yieldPercent,
  amount,
  onAmountChange,
  onBuy,
  isSubmitting,
}: Props) {
  const numericAmount = parseFloat(amount || '0');
  const isDisabled =
    !amount || numericAmount <= 0 || numericAmount > availableAmount || Number.isNaN(numericAmount);

  const expectedIncome = (numericAmount * yieldPercent) / 100;

  return (
    <div className="bg-surface border border-border rounded-lg p-6 sticky top-24">
      <h2 className="text-xl font-semibold text-text-primary mb-4">Создать заявку</h2>

      <div className="space-y-4">
        <Input
          label="Сумма (₽)"
          type="number"
          inputSize="lg"
          step="0.01"
          min={0}
          max={availableAmount}
          value={amount}
          onChange={e => onAmountChange(e.target.value)}
          placeholder="0.00"
        />
        <p className="text-xs text-text-tertiary">Доступно: {formatCurrency(availableAmount)}</p>

        {numericAmount > 0 && (
          <div className="bg-surface-alt rounded-md p-4 space-y-2">
            <div className="flex justify-between text-sm">
              <span className="text-text-secondary">Сумма:</span>
              <span className="text-text-primary font-medium">{formatCurrency(numericAmount)}</span>
            </div>
            <div className="flex justify-between text-sm">
              <span className="text-text-secondary">Ожидаемый доход:</span>
              <span className="text-success-600 font-medium">{formatCurrency(expectedIncome)}</span>
            </div>
          </div>
        )}

        <Button onClick={onBuy} loading={isSubmitting} disabled={isDisabled} className="w-full">
          Купить
        </Button>

        <p className="text-xs text-text-tertiary text-center">
          Отправляя заявку, вы соглашаетесь с условиями выпуска.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/issuances/[id]/components/YieldChartSection.tsx">
import { ChartContainer, LineChart } from '@ois/shared-ui';

type Props = {
  data: Array<{ name: string; yield: number }>;
};

export function YieldChartSection({ data }: Props) {
  return (
    <ChartContainer title="Динамика доходности" description="История изменения доходности">
      <LineChart
        data={data}
        lines={[
          {
            dataKey: 'yield',
            name: 'Доходность, %',
            color: '#22c55e',
          },
        ]}
        height={200}
      />
    </ChartContainer>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/components/steps/DocumentsStep.tsx">
import { useMemo, useRef } from 'react';
import { Badge, Button, Select, EmptyState } from '@ois/shared-ui';
import { Upload, Trash2, CheckCircle, Circle, FileText } from 'lucide-react';
import { UPLOAD_DOCUMENT_TYPES, REQUIRED_DOCUMENTS } from '../../constants';
import { LocalDocument } from '../../types';
import { toast } from 'sonner';

type Props = {
  selectedDocType: string;
  onDocTypeChange: (value: string) => void;
  localDocuments: LocalDocument[];
  onAddDocument: (doc: LocalDocument) => void;
  onRemoveDocument: (id: string) => void;
  disableActions?: boolean;
};

export function DocumentsStep({
  selectedDocType,
  onDocTypeChange,
  localDocuments,
  onAddDocument,
  onRemoveDocument,
  disableActions,
}: Props) {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const docLabelByType = useMemo(
    () =>
      UPLOAD_DOCUMENT_TYPES.reduce<Record<string, string>>(
        (acc, item) => ({ ...acc, [item.value]: item.label }),
        {}
      ),
    []
  );

  const uploadedTypes = useMemo(
    () => new Set(localDocuments.map(d => d.documentType)),
    [localDocuments]
  );

  const requiredUploaded = REQUIRED_DOCUMENTS.filter(d => uploadedTypes.has(d.value)).length;

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (file.size > 10 * 1024 * 1024) {
      toast.error('Файл слишком большой. Максимум 10MB');
      return;
    }

    if (uploadedTypes.has(selectedDocType)) {
      toast.error('Документ этого типа уже добавлен. Удалите его, чтобы загрузить новый.');
      event.target.value = '';
      return;
    }

    const newDoc: LocalDocument = {
      id: `local-${Date.now()}-${Math.random().toString(36).slice(2)}`,
      documentType: selectedDocType,
      file,
      fileName: file.name,
      fileSize: file.size,
      preview: file.type.startsWith('image/') ? URL.createObjectURL(file) : undefined,
    };

    onAddDocument(newDoc);
    event.target.value = '';
  };

  const handleUploadClick = () => {
    fileInputRef.current?.click();
  };

  const formatFileSize = (bytes: number) => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-semibold text-text-primary mb-2">Загрузка документов</h3>
        <p className="text-sm text-text-secondary">
          Загрузите скан-копии или фотографии документов для подтверждения личности. Максимальный
          размер файла: 10MB. Форматы: JPG, PNG, PDF.
        </p>
      </div>

      {/* Чеклист обязательных документов */}
      <div className="bg-surface-alt border border-border rounded-lg p-4">
        <div className="flex items-center justify-between mb-3">
          <h4 className="text-sm font-semibold text-text-primary">Обязательные документы</h4>
          <Badge intent={requiredUploaded === REQUIRED_DOCUMENTS.length ? 'success' : 'warning'}>
            {requiredUploaded} из {REQUIRED_DOCUMENTS.length}
          </Badge>
        </div>
        <div className="space-y-2">
          {REQUIRED_DOCUMENTS.map(doc => {
            const isUploaded = uploadedTypes.has(doc.value);
            return (
              <div
                key={doc.value}
                className={`flex items-center gap-3 p-2 rounded-md transition-colors ${
                  isUploaded ? 'bg-success-50' : 'bg-surface'
                }`}
              >
                {isUploaded ? (
                  <CheckCircle className="h-5 w-5 text-success-500 flex-shrink-0" />
                ) : (
                  <Circle className="h-5 w-5 text-text-tertiary flex-shrink-0" />
                )}
                <span
                  className={`text-sm ${isUploaded ? 'text-success-700' : 'text-text-secondary'}`}
                >
                  {doc.label}
                </span>
                {!isUploaded && (
                  <span className="text-xs text-danger-500 ml-auto">Обязательно</span>
                )}
              </div>
            );
          })}
        </div>
      </div>

      {/* Загрузка документа */}
      <div className="flex gap-4 items-end flex-wrap">
        <div className="flex-1 min-w-[240px]">
          <Select
            label="Тип документа"
            options={UPLOAD_DOCUMENT_TYPES.map(d => ({
              value: d.value,
              label: `${d.label}${d.required ? ' *' : ''}`,
            }))}
            value={selectedDocType}
            onChange={e => onDocTypeChange(e.target.value)}
            disabled={disableActions}
          />
        </div>
        <div>
          <input
            ref={fileInputRef}
            type="file"
            className="hidden"
            accept="image/*,.pdf"
            onChange={handleFileChange}
            disabled={disableActions}
          />
          <Button
            variant="primary"
            leftIcon={<Upload className="h-4 w-4" />}
            onClick={handleUploadClick}
            disabled={disableActions}
          >
            Выбрать файл
          </Button>
        </div>
      </div>

      {/* Загруженные документы */}
      <div>
        <h4 className="text-sm font-semibold text-text-primary mb-3">
          Добавленные документы ({localDocuments.length})
        </h4>
        {localDocuments.length > 0 ? (
          <div className="space-y-2">
            {localDocuments.map(doc => (
              <div
                key={doc.id}
                className="flex items-center justify-between p-3 bg-surface-alt border border-border rounded-lg"
              >
                <div className="flex items-center gap-3">
                  {doc.preview ? (
                    <img
                      src={doc.preview}
                      alt={doc.fileName}
                      className="w-10 h-10 object-cover rounded"
                    />
                  ) : (
                    <div className="w-10 h-10 flex items-center justify-center bg-primary-50 rounded">
                      <FileText className="h-5 w-5 text-primary-500" />
                    </div>
                  )}
                  <div>
                    <p className="text-sm font-medium text-text-primary">
                      {docLabelByType[doc.documentType] || doc.documentType}
                    </p>
                    <p className="text-xs text-text-tertiary">
                      {doc.fileName} ({formatFileSize(doc.fileSize)})
                    </p>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <Badge intent="neutral">Готов к отправке</Badge>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => {
                      if (doc.preview) URL.revokeObjectURL(doc.preview);
                      onRemoveDocument(doc.id);
                    }}
                    disabled={disableActions}
                  >
                    <Trash2 className="h-4 w-4 text-danger-500" />
                  </Button>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <EmptyState
            icon={FileText}
            title="Нет добавленных документов"
            description={`Загрузите минимум ${REQUIRED_DOCUMENTS.length} обязательных документа для прохождения KYC`}
            className="border-2 border-dashed border-border rounded-lg"
          />
        )}
      </div>

      {/* Информация */}
      <p className="text-xs text-text-tertiary">
        * Документы будут отправлены на проверку вместе с заявкой KYC при нажатии кнопки
        &ldquo;Отправить на проверку&rdquo;
      </p>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/components/KycStepper.tsx">
import { STEPS } from '../constants';

type Props = {
  currentStep: number;
  onStepChange: (index: number) => void;
};

export function KycStepper({ currentStep, onStepChange }: Props) {
  return (
    <div className="mb-8">
      <div className="flex items-center justify-between gap-2 overflow-x-auto pb-4 px-1">
        {STEPS.map((step, index) => {
          const isCurrent = currentStep === index;
          const isCompleted = index < currentStep;
          const _isPending = index > currentStep;

          return (
            <div key={step} className="flex items-center flex-1 min-w-0">
              <button
                type="button"
                onClick={() => onStepChange(index)}
                className={`
                  flex items-center gap-2 px-4 py-2.5 rounded-lg text-sm font-medium
                  whitespace-nowrap transition-all w-full border-2
                  ${
                    isCurrent
                      ? 'bg-primary-500 text-white border-primary-500 shadow-md'
                      : isCompleted
                        ? 'bg-success-100 text-success-700 border-success-300 hover:bg-success-200'
                        : 'bg-surface-alt text-text-secondary border-border hover:bg-surface-hover hover:border-primary-300'
                  }
                `}
              >
                <span
                  className={`
                    flex items-center justify-center w-6 h-6 rounded-full text-xs font-bold flex-shrink-0
                    ${
                      isCurrent
                        ? 'bg-white text-primary-600'
                        : isCompleted
                          ? 'bg-success-500 text-white'
                          : 'bg-surface text-text-tertiary border border-border'
                    }
                  `}
                >
                  {isCompleted ? '✓' : index + 1}
                </span>
                <span className="hidden sm:inline truncate">{step}</span>
              </button>
              {index < STEPS.length - 1 && (
                <div
                  className={`hidden md:block w-8 h-0.5 mx-1 flex-shrink-0 ${
                    isCompleted ? 'bg-success-400' : 'bg-border'
                  }`}
                />
              )}
            </div>
          );
        })}
      </div>
      <p className="mt-3 text-sm text-text-secondary text-center sm:hidden">
        Шаг {currentStep + 1} из {STEPS.length}: {STEPS[currentStep]}
      </p>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/constants.ts">
export const DOCUMENT_TYPES = [
  { value: 'passport_rf', label: 'Паспорт РФ' },
  { value: 'passport_foreign', label: 'Иностранный паспорт' },
  { value: 'residence_permit', label: 'Вид на жительство' },
  { value: 'refugee_certificate', label: 'Удостоверение беженца' },
  { value: 'temporary_asylum', label: 'Временное убежище' },
];

export const UPLOAD_DOCUMENT_TYPES = [
  { value: 'passport_main', label: 'Паспорт (главная страница)', required: true },
  { value: 'passport_registration', label: 'Паспорт (прописка)', required: true },
  { value: 'selfie', label: 'Селфи с паспортом', required: true },
  { value: 'inn', label: 'Свидетельство ИНН', required: false },
  { value: 'snils', label: 'СНИЛС', required: false },
  { value: 'address_proof', label: 'Подтверждение адреса', required: false },
  { value: 'other', label: 'Другой документ', required: false },
];

export const REQUIRED_DOCUMENTS = UPLOAD_DOCUMENT_TYPES.filter(d => d.required);

export const STEPS = ['Персональные данные', 'Документ', 'Адрес', 'Контакты', 'Документы'] as const;
</file>

<file path="apps/portal-investor/src/app/kyc/countries.ts">
// ISO 3166 country names (Russian) for citizenship dropdown.
export const COUNTRIES = [
  'Россия',
  'Австралия',
  'Австрия',
  'Азербайджан',
  'Албания',
  'Алжир',
  'Ангола',
  'Андорра',
  'Антигуа и Барбуда',
  'Аргентина',
  'Армения',
  'Афганистан',
  'Багамы',
  'Бангладеш',
  'Барбадос',
  'Бахрейн',
  'Беларусь',
  'Белиз',
  'Бельгия',
  'Бенин',
  'Болгария',
  'Боливия',
  'Босния и Герцеговина',
  'Ботсвана',
  'Бразилия',
  'Бруней',
  'Буркина-Фасо',
  'Бурунди',
  'Бутан',
  'Вануату',
  'Ватикан',
  'Великобритания',
  'Венгрия',
  'Венесуэла',
  'Восточный Тимор',
  'Вьетнам',
  'Габон',
  'Гаити',
  'Гайана',
  'Гамбия',
  'Гана',
  'Гватемала',
  'Гвинея',
  'Гвинея-Бисау',
  'Германия',
  'Гондурас',
  'Гренада',
  'Греция',
  'Грузия',
  'Дания',
  'Джибути',
  'Доминика',
  'Доминиканская Республика',
  'Египет',
  'Замбия',
  'Зимбабве',
  'Израиль',
  'Индия',
  'Индонезия',
  'Иордания',
  'Ирак',
  'Иран',
  'Ирландия',
  'Исландия',
  'Испания',
  'Италия',
  'Йемен',
  'Кабо-Верде',
  'Казахстан',
  'Камбоджа',
  'Камерун',
  'Канада',
  'Катар',
  'Кения',
  'Кипр',
  'Киргизия',
  'Кирибати',
  'Китай',
  'Колумбия',
  'Коморы',
  'Конго',
  'Коста-Рика',
  'Кот-д’Ивуар',
  'Куба',
  'Кувейт',
  'Лаос',
  'Латвия',
  'Лесото',
  'Либерия',
  'Ливан',
  'Ливия',
  'Литва',
  'Лихтенштейн',
  'Люксембург',
  'Маврикий',
  'Мавритания',
  'Мадагаскар',
  'Македония',
  'Малави',
  'Малайзия',
  'Мали',
  'Мальдивы',
  'Мальта',
  'Марокко',
  'Маршалловы Острова',
  'Мексика',
  'Мозамбик',
  'Молдавия',
  'Монако',
  'Монголия',
  'Мьянма',
  'Намибия',
  'Науру',
  'Непал',
  'Нигер',
  'Нигерия',
  'Нидерланды',
  'Никарагуа',
  'Новая Зеландия',
  'Норвегия',
  'Объединенные Арабские Эмираты',
  'Оман',
  'Пакистан',
  'Палау',
  'Панама',
  'Папуа — Новая Гвинея',
  'Парагвай',
  'Перу',
  'Польша',
  'Португалия',
  'Республика Корея',
  'Республика Конго',
  'Руанда',
  'Румыния',
  'Сальвадор',
  'Самоа',
  'Сан-Марино',
  'Сан-Томе и Принсипи',
  'Саудовская Аравия',
  'Северная Корея',
  'Северная Македония',
  'Сейшелы',
  'Сенегал',
  'Сент-Винсент и Гренадины',
  'Сент-Китс и Невис',
  'Сент-Люсия',
  'Сербия',
  'Сингапур',
  'Сирия',
  'Словакия',
  'Словения',
  'Соломоновы Острова',
  'Сомали',
  'Судан',
  'Суринам',
  'США',
  'Сьерра-Леоне',
  'Таджикистан',
  'Таиланд',
  'Танзания',
  'Того',
  'Тонга',
  'Тринидад и Тобаго',
  'Тувалу',
  'Тунис',
  'Туркменистан',
  'Турция',
  'Уганда',
  'Узбекистан',
  'Украина',
  'Уругвай',
  'Фиджи',
  'Филиппины',
  'Финляндия',
  'Франция',
  'Хорватия',
  'Центральноафриканская Республика',
  'Чад',
  'Черногория',
  'Чехия',
  'Чили',
  'Швейцария',
  'Швеция',
  'Шри-Ланка',
  'Эквадор',
  'Экваториальная Гвинея',
  'Эритрея',
  'Эсватини',
  'Эстония',
  'Эфиопия',
  'ЮАР',
  'Южный Судан',
  'Ямайка',
  'Япония',
];
</file>

<file path="apps/portal-investor/src/app/kyc/validation.ts">
import { FormData, FormErrors } from './types';
import { STEPS } from './constants';

const EMAIL_REGEX = /^[\w.\-]+@([\w\-]+\.)+[\w\-]{2,4}$/;
const CODE_REGEX = /^[0-9]{3}-[0-9]{3}$/;
const PASSPORT_SERIES_REGEX = /^[0-9]{4}$/;
const PASSPORT_NUMBER_REGEX = /^[0-9]{6}$/;

export const validateStep = (data: FormData, stepIndex: number): FormErrors => {
  const stepKey = STEPS[stepIndex];
  const errors: FormErrors = {};
  const stepErrors: Record<string, string> = {};

  if (stepIndex === 0) {
    const { lastName, firstName, birthDate } = data.personalData;
    if (!lastName.trim()) stepErrors.lastName = 'Укажите фамилию';
    if (!firstName.trim()) stepErrors.firstName = 'Укажите имя';
    if (!birthDate) stepErrors.birthDate = 'Укажите дату рождения';
    if (birthDate) {
      const birth = new Date(birthDate);
      const now = new Date();
      const adultDate = new Date(now.getFullYear() - 18, now.getMonth(), now.getDate());
      if (birth > adultDate) stepErrors.birthDate = 'Возраст должен быть 18+ лет';
    }
  }

  if (stepIndex === 1) {
    const { series, number, issuedAt, departmentCode } = data.identityDocument;
    if (!PASSPORT_SERIES_REGEX.test(series)) stepErrors.series = 'Серия: 4 цифры';
    if (!PASSPORT_NUMBER_REGEX.test(number)) stepErrors.number = 'Номер: 6 цифр';
    if (!issuedAt) stepErrors.issuedAt = 'Укажите дату выдачи';
    if (issuedAt) {
      const issued = new Date(issuedAt);
      if (issued > new Date()) stepErrors.issuedAt = 'Дата выдачи не может быть в будущем';
    }
    if (departmentCode && !CODE_REGEX.test(departmentCode)) {
      stepErrors.departmentCode = 'Формат кода: XXX-XXX';
    }
  }

  if (stepIndex === 2) {
    const { country, region, city, street, house } = data.address;
    if (!country.trim()) stepErrors.country = 'Укажите страну';
    if (!region.trim()) stepErrors.region = 'Укажите регион';
    if (!city.trim()) stepErrors.city = 'Укажите город';
    if (!street.trim()) stepErrors.street = 'Улица обязательна';
    if (!house.trim()) stepErrors.house = 'Укажите дом';
  }

  if (stepIndex === 3) {
    const { phone, email } = data.contacts;
    const phoneDigits = phone.replace(/\D/g, '');
    if (!phoneDigits.startsWith('7') || phoneDigits.length !== 11) {
      stepErrors.phone = 'Формат: +7XXXXXXXXXX';
    }
    if (!email || !EMAIL_REGEX.test(email)) {
      stepErrors.email = 'Некорректный email';
    }
    if (!data.consentToProcessing) {
      stepErrors.consent = 'Необходимо согласие на обработку';
    }
  }

  errors[stepKey] = stepErrors;
  return errors;
};
</file>

<file path="apps/portal-investor/src/lib/api/compliance.ts">
import { getSession } from 'next-auth/react';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

type FetchError = Error & { status?: number };

async function authFetch<T>(path: string, init?: RequestInit): Promise<T> {
  const session = await getSession();
  const token = (session?.accessToken as string) || undefined;

  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    const err: FetchError = new Error(`Compliance API error: ${response.status}`);
    err.status = response.status;
    throw err;
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return (await response.json()) as T;
}

export type KycStatusResponse = {
  investorId: string;
  kyc: string;
  qualificationTier: string;
  qualificationLimit?: number;
  qualificationUsed?: number;
  updatedAt: string;
};

export type KycApplicationPayload = {
  investorId?: string;
  fullName?: string;
  documentType?: string;
  documentNumber?: string;
  comment?: string;
};

export async function fetchKycStatus(investorId: string): Promise<KycStatusResponse | null> {
  try {
    return await authFetch<KycStatusResponse>(`/v1/compliance/investors/${investorId}/status`);
  } catch (err) {
    const status = (err as FetchError).status;
    if (status === 404) return null;
    throw err;
  }
}

export async function submitKycApplication(payload: KycApplicationPayload) {
  return authFetch(`/v1/compliance/kyc`, {
    method: 'POST',
    body: JSON.stringify(payload),
  });
}
</file>

<file path="apps/portal-investor/src/lib/format.ts">
export const formatDateTime = (value?: string | Date) => {
  if (!value) return '-';
  const date = value instanceof Date ? value : new Date(value);
  return `${date.toLocaleDateString('ru-RU')} ${date.toLocaleTimeString('ru-RU', {
    hour: '2-digit',
    minute: '2-digit',
  })}`;
};

export const formatCurrency = (value?: number, currency: string = 'RUB') => {
  if (typeof value !== 'number') return '-';
  return new Intl.NumberFormat('ru-RU', {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(value);
};

export const shortHash = (hash?: string, length = 8) =>
  hash ? `${hash.substring(0, length)}...` : '-';
</file>

<file path="apps/portal-investor/src/lib/nav.ts">
export const investorNav = [
  { label: 'Portfolio', href: '/portfolio' },
  { label: 'Catalog', href: '/catalog' },
  { label: 'Orders', href: '/orders/new' },
  { label: 'History', href: '/history' },
  { label: 'KYC', href: '/kyc' },
];
</file>

<file path="apps/portal-investor/src/types/api-client.d.ts">
declare module '@ois/api-client' {
  interface InvestorStatusResponse {
    kyc: 'pass' | 'fail' | 'pending' | 'review';
    qualificationTier?: 'unqualified' | 'qualified' | 'professional' | string;
    qualificationLimit?: number | null;
    qualificationUsed?: number | null;
    updatedAt?: string;
    rejectionReason?: string | null;
    canUploadDocuments?: boolean;
  }

  // Minimal class typing to satisfy TS where SDK declarations are stale
  export class OisApiClient {
    constructor(config?: unknown);
    getInvestorStatus(investorId: string, config?: unknown): Promise<InvestorStatusResponse>;
    getInvestorTransactions(
      investorId: string,
      params?: unknown
    ): Promise<{
      items: Array<{
        id?: string;
        createdAt: string;
        type: 'transfer' | 'redeem' | 'issue';
        issuanceCode: string;
        amount: number;
        status: 'pending' | 'confirmed' | 'failed';
        dltTxHash?: string;
      }>;
      total: number;
    }>;
    getInvestorPayouts(
      investorId: string,
      params?: unknown
    ): Promise<{
      items: Array<{
        id?: string;
        executedAt?: string;
        issuanceId: string;
        amount: number;
        status: 'pending' | 'executed' | 'failed';
      }>;
      total: number;
      totalAmount?: number;
    }>;
    getMarketIssuances(params?: unknown): Promise<unknown>;
    getMarketIssuance(id: string, config?: unknown): Promise<unknown>;
    createOrder(data: unknown, config?: unknown): Promise<unknown>;
    uploadKycDocument(
      investorId: string,
      documentType: string,
      file: File,
      onUploadProgress?: (progressEvent: unknown) => void
    ): Promise<unknown>;
    deleteKycDocument(documentId: string, config?: unknown): Promise<unknown>;
    getKycDocuments(investorId: string, config?: unknown): Promise<unknown>;
    getWallet(
      investorId: string,
      config?: unknown
    ): Promise<{ id: string; balance: number; blocked?: number }>;
  }
}
</file>

<file path="apps/portal-investor/src/middleware.ts">
import { withAuth } from 'next-auth/middleware';

export default withAuth({
  callbacks: {
    authorized: ({ token }) => {
      const roles = (token?.roles as string[]) || [];
      if (!roles.includes('investor')) {
        return false;
      }
      return !!token;
    },
  },
});

export const config = {
  matcher: ['/portfolio/:path*', '/orders/:path*', '/history/:path*', '/profile/:path*'],
};
</file>

<file path="apps/portal-investor/.eslintrc.json">
{
  "extends": [
    "next/core-web-vitals",
    "next/typescript",
    "prettier"
  ],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": [
      "warn",
      {
        "argsIgnorePattern": "^_",
        "varsIgnorePattern": "^_",
        "caughtErrorsIgnorePattern": "^_"
      }
    ],
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "react-hooks/exhaustive-deps": "warn",
    "prefer-const": "warn"
  },
  "ignorePatterns": [
    "node_modules/",
    ".next/",
    "out/",
    "dist/"
  ]
}
</file>

<file path="apps/portal-investor/package.json">
{
  "name": "@ois/portal-investor",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3002",
    "build": "next build",
    "start": "next start -p 3002",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "format:check": "prettier --check \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    "test:unit": "vitest run",
    "test:watch": "vitest watch",
    "test:coverage": "vitest run --coverage",
    "prepare": "cd ../.. && husky apps/.husky || true"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "prettier --write",
      "eslint --fix --max-warnings=100"
    ],
    "*.{json,css,md}": [
      "prettier --write"
    ]
  },
  "dependencies": {
    "@ois/api-client": "file:../../packages/sdks/ts",
    "@ois/shared-ui": "file:../shared-ui",
    "@tanstack/react-query": "^5.17.0",
    "@tanstack/react-table": "^8.21.3",
    "axios": "^1.6.0",
    "clsx": "^2.1.0",
    "lucide-react": "^0.303.0",
    "next": "15.0.0",
    "next-auth": "^4.24.5",
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "recharts": "^2.10.3",
    "sonner": "^1.3.1",
    "tailwind-merge": "^2.2.0",
    "web-vitals": "^4.2.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@stoplight/spectral-cli": "^6.15.0",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^5.1.1",
    "@vitest/coverage-v8": "^4.0.13",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.56.0",
    "eslint-config-next": "15.0.0",
    "eslint-config-prettier": "^9.1.0",
    "husky": "^9.1.0",
    "jsdom": "^27.0.1",
    "lint-staged": "^15.2.0",
    "msw": "^2.12.2",
    "postcss": "^8.4.32",
    "prettier": "^3.2.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="apps/portal-investor/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./vitest.setup.ts'],
    include: ['src/**/*.{test,spec}.{ts,tsx}'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/lib/**', 'src/hooks/**'],
      exclude: ['src/**/*.d.ts', 'src/**/*.test.ts', 'src/**/*.spec.ts'],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
</file>

<file path="apps/portal-investor/vitest.setup.ts">
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach, vi } from 'vitest';

afterEach(() => {
  cleanup();
});

vi.mock('next/navigation', () => ({
  useRouter: () => ({
    push: vi.fn(),
    replace: vi.fn(),
    back: vi.fn(),
    forward: vi.fn(),
    refresh: vi.fn(),
    prefetch: vi.fn(),
  }),
  usePathname: () => '/',
  useSearchParams: () => new URLSearchParams(),
  useParams: () => ({}),
  redirect: vi.fn(),
}));

vi.mock('next-auth/react', () => ({
  useSession: () => ({
    data: {
      user: {
        id: 'test-investor-id',
        name: 'Test Investor',
        email: 'investor@test.com',
        role: 'investor',
      },
      expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
    },
    status: 'authenticated',
  }),
  signIn: vi.fn(),
  signOut: vi.fn(),
}));

global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});
</file>

<file path="apps/portal-issuer/src/app/issuances/[id]/components/DocumentsCard.tsx">
import { Card, CardContent, CardHeader, CardTitle, Button } from '@ois/shared-ui';
import { ExternalLink } from 'lucide-react';

type DocumentItem = { name: string; url: string };

type DocumentsCardProps = {
  documents?: DocumentItem[];
};

export function DocumentsCard({ documents }: DocumentsCardProps) {
  if (!documents || documents.length === 0) {
    return null;
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Документы выпуска</CardTitle>
      </CardHeader>
      <CardContent className="space-y-3">
        {documents.map((doc) => (
          <div key={doc.url} className="flex items-center justify-between gap-3">
            <div className="text-sm">{doc.name}</div>
            <Button asChild size="sm" variant="ghost">
              <a href={doc.url} target="_blank" rel="noreferrer">
                Открыть
                <ExternalLink className="ml-2 h-4 w-4" />
              </a>
            </Button>
          </div>
        ))}
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/portal-issuer/src/app/issuances/[id]/components/PayoutScheduleTable.tsx">
import { DataTable } from '@ois/shared-ui';
import { ColumnDef } from '@tanstack/react-table';
import { format } from 'date-fns';
import type { PayoutScheduleItem } from '@/lib/mocks/issuances';

type PayoutScheduleTableProps = {
  items: PayoutScheduleItem[];
};

const columns: ColumnDef<PayoutScheduleItem>[] = [
  {
    header: 'Дата',
    accessorKey: 'date',
    cell: ({ getValue }) => {
      const value = getValue<string>();
      const parsed = value ? new Date(value) : null;
      return parsed ? format(parsed, 'dd.MM.yyyy') : '—';
    },
  },
  {
    header: 'Сумма',
    accessorKey: 'amount',
    cell: ({ getValue }) => {
      const val = getValue<number>();
      return val?.toLocaleString('ru-RU', { style: 'currency', currency: 'RUB' });
    },
  },
  {
    header: 'Тип',
    accessorKey: 'type',
    cell: ({ getValue }) => {
      const value = getValue<string>();
      return value === 'coupon' ? 'Купон' : 'Погашение';
    },
  },
  {
    header: 'Статус',
    accessorKey: 'status',
    cell: ({ getValue }) => {
      const value = getValue<string>();
      const map: Record<string, string> = {
        planned: 'Запланировано',
        processing: 'В обработке',
        paid: 'Выплачено',
        cancelled: 'Отменено',
      };
      return map[value ?? ''] ?? value ?? '—';
    },
  },
];

export function PayoutScheduleTable({ items }: PayoutScheduleTableProps) {
  return <DataTable columns={columns} data={items} />;
}
</file>

<file path="apps/portal-issuer/src/app/issuances/[id]/components/StatusBadges.tsx">
import { Badge } from '@ois/shared-ui';
import type { IssuanceStatus } from '@/lib/mocks/issuances';

const statusLabels: Record<IssuanceStatus, string> = {
  draft: 'Черновик',
  published: 'Опубликован',
  closed: 'Закрыт',
  redeemed: 'Погашен',
};

const statusIntent: Record<IssuanceStatus, Parameters<typeof Badge>[0]['intent']> = {
  draft: 'neutral',
  published: 'success',
  closed: 'warning',
  redeemed: 'info',
};

type StatusBadgesProps = {
  status: IssuanceStatus;
  apy?: number;
  maturityDate?: string;
};

export function StatusBadges({ status, apy, maturityDate }: StatusBadgesProps) {
  return (
    <div className="flex flex-wrap items-center gap-2">
      <Badge intent={statusIntent[status]}>{statusLabels[status]}</Badge>
      {typeof apy === 'number' && <Badge intent="info">{`Ставка: ${apy}%`}</Badge>}
      {maturityDate && <Badge intent="neutral">{`Погашение: ${maturityDate}`}</Badge>}
    </div>
  );
}
</file>

<file path="apps/portal-issuer/src/app/kyc/page.tsx">
'use client';

import { useEffect, useState } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useQuery, useMutation } from '@tanstack/react-query';
import { AppShell, PageHeader, Skeleton, EmptyState } from '@ois/shared-ui';
import { issuerNav } from '@/lib/nav';
import { fetchKycStatus, submitKycApplication } from '@/lib/api/compliance';
import { toast } from 'sonner';

export default function IssuerKycPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [form, setForm] = useState({
    fullName: '',
    documentType: 'passport',
    documentNumber: '',
    comment: '',
  });

  const issuerId = (session?.user as any)?.issuerId || (session?.user as any)?.id || '';

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const {
    data: kycStatus,
    isLoading: statusLoading,
    refetch,
  } = useQuery({
    queryKey: ['issuer-kyc-status', issuerId],
    queryFn: () => fetchKycStatus(issuerId),
    enabled: status === 'authenticated' && !!issuerId,
  });

  const submitMutation = useMutation({
    mutationFn: async () =>
      submitKycApplication({
        investorId: issuerId,
        ...form,
      }),
    onSuccess: () => {
      toast.success('KYC application submitted');
      refetch();
    },
    onError: (error: any) => {
      toast.error(error?.message ?? 'Failed to submit KYC');
    },
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) return null;

  const statusLabel = kycStatus?.kyc ?? 'not-submitted';
  const isSubmitted = statusLabel !== 'not-submitted';

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: issuerNav }}
    >
      <PageHeader
        title="Issuer KYC"
        description="Provide issuer verification details for compliance review"
      />

      <section className="grid gap-6 lg:grid-cols-2">
        <div className="rounded-lg border border-border bg-surface p-6 space-y-4">
          <h2 className="text-lg font-semibold text-text-primary">Current status</h2>
          {statusLoading ? (
            <Skeleton className="h-20 w-full" variant="rectangular" />
          ) : isSubmitted ? (
            <div className="space-y-2">
              <div className="text-sm text-text-secondary">Status</div>
              <div className="text-2xl font-bold text-text-primary capitalize">
                {statusLabel}
              </div>
              <div className="text-sm text-text-secondary">
                Updated at:{' '}
                {kycStatus?.updatedAt
                  ? new Date(kycStatus.updatedAt).toLocaleString()
                  : '—'}
              </div>
            </div>
          ) : (
            <EmptyState
              title="No KYC on file"
              description="Submit issuer details to start verification."
            />
          )}
        </div>

        <div className="rounded-lg border border-border bg-surface p-6 space-y-4">
          <h2 className="text-lg font-semibold text-text-primary">Submit application</h2>
          <form
            className="space-y-4"
            onSubmit={(e) => {
              e.preventDefault();
              submitMutation.mutate();
            }}
          >
            <div className="space-y-2">
              <label className="text-sm text-text-secondary">Full name / Company name</label>
              <input
                type="text"
                value={form.fullName}
                onChange={(e) => setForm({ ...form, fullName: e.target.value })}
                className="w-full rounded-md border border-border px-3 py-2"
                placeholder="Issuer representative"
              />
            </div>

            <div className="grid gap-4 sm:grid-cols-2">
              <div className="space-y-2">
                <label className="text-sm text-text-secondary">Document type</label>
                <select
                  value={form.documentType}
                  onChange={(e) => setForm({ ...form, documentType: e.target.value })}
                  className="w-full rounded-md border border-border px-3 py-2"
                >
                  <option value="passport">Passport</option>
                  <option value="inn">INN</option>
                  <option value="ogrn">OGRN</option>
                  <option value="other">Other</option>
                </select>
              </div>
              <div className="space-y-2">
                <label className="text-sm text-text-secondary">Document number</label>
                <input
                  type="text"
                  value={form.documentNumber}
                  onChange={(e) => setForm({ ...form, documentNumber: e.target.value })}
                  className="w-full rounded-md border border-border px-3 py-2"
                  placeholder="00 00 000000"
                />
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-sm text-text-secondary">Comment</label>
              <textarea
                value={form.comment}
                onChange={(e) => setForm({ ...form, comment: e.target.value })}
                className="w-full rounded-md border border-border px-3 py-2"
                rows={3}
                placeholder="Additional issuer info"
              />
            </div>

            <button
              type="submit"
              className="rounded-md bg-primary-600 px-4 py-2 text-sm font-medium text-white hover:bg-primary-700 disabled:opacity-50"
              disabled={submitMutation.isPending || !issuerId}
            >
              {submitMutation.isPending ? 'Submitting…' : 'Submit KYC'}
            </button>
            {!issuerId && (
              <p className="text-xs text-danger-600">
                Missing issuer id in session; cannot submit.
              </p>
            )}
          </form>
        </div>
      </section>
    </AppShell>
  );
}
</file>

<file path="apps/portal-issuer/src/app/reports/components/IssuancesReportTable.tsx">
import { DataTable, StatCard } from '@ois/shared-ui';
import { ColumnDef } from '@tanstack/react-table';
import type { IssuerReportRow } from '@ois/api-client';

type IssuancesReportTableProps = {
  data?: IssuerReportRow[];
  summary?: {
    totalIssuances?: number;
    totalAmount?: number;
    totalSold?: number;
    totalInvestors?: number;
  };
};

const columns: ColumnDef<IssuerReportRow>[] = [
  { header: 'ID выпуска', accessorKey: 'issuanceId' },
  { header: 'Название', accessorKey: 'assetName' },
  { header: 'Статус', accessorKey: 'status' },
  {
    header: 'Объём',
    accessorKey: 'totalAmount',
    cell: ({ getValue }) =>
      (getValue<number>() ?? 0).toLocaleString('ru-RU', { style: 'currency', currency: 'RUB' }),
  },
  { header: 'Дата выпуска', accessorKey: 'issueDate' },
  { header: 'Дата закрытия', accessorKey: 'closeDate' },
];

export function IssuancesReportTable({ data, summary }: IssuancesReportTableProps) {
  return (
    <div className="space-y-4">
      {summary && (
        <div className="grid grid-cols-1 gap-3 md:grid-cols-4">
          <StatCard title="Выпусков" value={summary.totalIssuances ?? 0} />
          <StatCard
            title="Объём"
            value={(summary.totalAmount ?? 0).toLocaleString('ru-RU', {
              style: 'currency',
              currency: 'RUB',
            })}
          />
          <StatCard title="Продано" value={(summary.totalSold ?? 0).toLocaleString('ru-RU')} />
          <StatCard title="Инвесторов" value={summary.totalInvestors ?? 0} />
        </div>
      )}
      <DataTable columns={columns} data={data ?? []} />
    </div>
  );
}
</file>

<file path="apps/portal-issuer/src/lib/api/compliance.ts">
import { getSession } from 'next-auth/react';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:5000';

type FetchError = Error & { status?: number };

async function authFetch<T>(path: string, init?: RequestInit): Promise<T> {
  const session = await getSession();
  const token = (session?.accessToken as string) || undefined;

  const response = await fetch(`${API_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
      ...(init?.headers ?? {}),
    },
    cache: 'no-store',
  });

  if (!response.ok) {
    const err: FetchError = new Error(`Compliance API error: ${response.status}`);
    err.status = response.status;
    throw err;
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return (await response.json()) as T;
}

export type KycStatusResponse = {
  investorId: string;
  kyc: string;
  qualificationTier: string;
  qualificationLimit?: number;
  qualificationUsed?: number;
  updatedAt: string;
};

export type KycApplicationPayload = {
  investorId?: string;
  fullName?: string;
  documentType?: string;
  documentNumber?: string;
  comment?: string;
};

export async function fetchKycStatus(investorId: string): Promise<KycStatusResponse | null> {
  try {
    return await authFetch<KycStatusResponse>(`/v1/compliance/investors/${investorId}/status`);
  } catch (err) {
    const status = (err as FetchError).status;
    if (status === 404) return null;
    throw err;
  }
}

export async function submitKycApplication(payload: KycApplicationPayload) {
  return authFetch(`/v1/compliance/kyc`, {
    method: 'POST',
    body: JSON.stringify(payload),
  });
}
</file>

<file path="apps/portal-issuer/src/lib/mocks/issuances.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import {
  getIssuances,
  getIssuanceById,
  publishIssuance,
  closeIssuance,
  createIssuance,
  updateIssuanceSchedule,
  resetIssuancesStore,
  MOCK_ISSUER_ID,
} from './issuances';

describe('Issuances Service', () => {
  beforeEach(() => {
    resetIssuancesStore();
  });

  describe('getIssuances', () => {
    it('возвращает все выпуски', () => {
      const issuances = getIssuances();
      expect(issuances).toHaveLength(4);
    });

    it('фильтрует по issuerId', () => {
      const issuances = getIssuances(MOCK_ISSUER_ID);
      expect(issuances.length).toBeGreaterThan(0);
      expect(issuances.every(i => i.issuerId === MOCK_ISSUER_ID)).toBe(true);
    });

    it('возвращает пустой массив для несуществующего issuerId', () => {
      const issuances = getIssuances('non-existent-id');
      expect(issuances).toHaveLength(0);
    });
  });

  describe('getIssuanceById', () => {
    it('возвращает выпуск по ID', () => {
      const issuance = getIssuanceById('iss-001');
      expect(issuance).toBeDefined();
      expect(issuance?.assetCode).toBe('CFA-ALPHA-001');
    });

    it('возвращает undefined для несуществующего ID', () => {
      const issuance = getIssuanceById('non-existent');
      expect(issuance).toBeUndefined();
    });
  });

  describe('publishIssuance', () => {
    it('публикует черновик', () => {
      const result = publishIssuance('iss-003'); // draft
      expect(result).not.toBeNull();
      expect(result?.status).toBe('published');
      expect(result?.publishedAt).toBeDefined();
      expect(result?.dltTxHash).toBeDefined();
    });

    it('не публикует уже опубликованный выпуск', () => {
      const result = publishIssuance('iss-001'); // published
      expect(result).toBeNull();
    });

    it('возвращает null для несуществующего ID', () => {
      const result = publishIssuance('non-existent');
      expect(result).toBeNull();
    });
  });

  describe('closeIssuance', () => {
    it('закрывает опубликованный выпуск', () => {
      const result = closeIssuance('iss-001'); // published
      expect(result).not.toBeNull();
      expect(result?.status).toBe('closed');
    });

    it('не закрывает черновик', () => {
      const result = closeIssuance('iss-003'); // draft
      expect(result).toBeNull();
    });

    it('возвращает null для несуществующего ID', () => {
      const result = closeIssuance('non-existent');
      expect(result).toBeNull();
    });
  });

  describe('createIssuance', () => {
    it('создает новый выпуск', () => {
      const newIssuance = createIssuance({
        assetId: 'new-asset',
        issuerId: MOCK_ISSUER_ID,
        totalAmount: 1_000_000,
        nominal: 1000,
        issueDate: '2025-01-01',
        maturityDate: '2026-01-01',
      });

      expect(newIssuance.id).toBeDefined();
      expect(newIssuance.status).toBe('draft');
      expect(newIssuance.totalAmount).toBe(1_000_000);
      expect(newIssuance.availableAmount).toBe(1_000_000);

      // Проверяем, что добавлен в store
      const all = getIssuances();
      expect(all).toContainEqual(newIssuance);
    });

    it('создает выпуск со значениями по умолчанию', () => {
      const newIssuance = createIssuance({
        assetId: 'asset-123',
        issuerId: 'issuer-123',
        totalAmount: 5_000_000,
        nominal: 5000,
        issueDate: '2025-06-01',
        maturityDate: '2027-06-01',
      });

      expect(newIssuance.currency).toBe('RUB');
      expect(newIssuance.apy).toBe(12.0);
      expect(newIssuance.dltTxHash).toBeNull();
      expect(newIssuance.publishedAt).toBeNull();
      expect(newIssuance.documents).toEqual([]);
      expect(newIssuance.scheduleJson).toEqual([]);
    });
  });

  describe('updateIssuanceSchedule', () => {
    it('обновляет график выплат', () => {
      const newSchedule = [
        {
          id: 'new-pay-1',
          issuanceId: 'iss-001',
          date: '2025-06-01',
          amount: 100,
          type: 'coupon' as const,
          status: 'planned' as const,
        },
      ];

      const result = updateIssuanceSchedule('iss-001', newSchedule);
      expect(result).not.toBeNull();
      expect(result?.scheduleJson).toEqual(newSchedule);
    });

    it('возвращает null для несуществующего ID', () => {
      const result = updateIssuanceSchedule('non-existent', []);
      expect(result).toBeNull();
    });
  });

  describe('resetIssuancesStore', () => {
    it('сбрасывает store к начальному состоянию', () => {
      // Модифицируем данные
      publishIssuance('iss-003');
      const modified = getIssuanceById('iss-003');
      expect(modified?.status).toBe('published');

      // Сбрасываем
      resetIssuancesStore();

      // Проверяем, что данные восстановлены
      const restored = getIssuanceById('iss-003');
      expect(restored?.status).toBe('draft');
    });
  });
});
</file>

<file path="apps/portal-issuer/src/lib/mocks/issuances.ts">
/**
 * Mock data for issuances based on portal-issuer-mock-schemas.md
 */

export type IssuanceStatus = 'draft' | 'published' | 'closed' | 'redeemed';
export type PayoutType = 'coupon' | 'redemption';
export type PayoutStatus = 'planned' | 'processing' | 'paid' | 'cancelled';

export interface PayoutScheduleItem {
  id: string;
  issuanceId: string;
  date: string;
  amount: number;
  type: PayoutType;
  status: PayoutStatus;
}

export interface Issuance {
  id: string;
  assetId: string;
  assetCode: string;
  assetName: string;
  issuerId: string;
  totalAmount: number;
  nominal: number;
  availableAmount: number;
  currency: string;
  issueDate: string;
  maturityDate: string;
  apy: number;
  status: IssuanceStatus;
  scheduleJson: PayoutScheduleItem[];
  dltTxHash: string | null;
  createdAt: string;
  publishedAt: string | null;
  documents: { name: string; url: string }[];
}

// Mock issuer ID (used for filtering)
export const MOCK_ISSUER_ID = 'issuer-001-uuid';

// Mock issuances data
export const mockIssuances: Issuance[] = [
  {
    id: 'iss-001',
    assetId: 'asset-001',
    assetCode: 'CFA-ALPHA-001',
    assetName: 'Альфа Облигация 2025',
    issuerId: MOCK_ISSUER_ID,
    totalAmount: 100_000_000,
    nominal: 1000,
    availableAmount: 45_000_000,
    currency: 'RUB',
    issueDate: '2024-01-15',
    maturityDate: '2026-01-15',
    apy: 12.5,
    status: 'published',
    scheduleJson: [
      {
        id: 'pay-001-1',
        issuanceId: 'iss-001',
        date: '2024-07-15',
        amount: 62.5,
        type: 'coupon',
        status: 'paid',
      },
      {
        id: 'pay-001-2',
        issuanceId: 'iss-001',
        date: '2025-01-15',
        amount: 62.5,
        type: 'coupon',
        status: 'paid',
      },
      {
        id: 'pay-001-3',
        issuanceId: 'iss-001',
        date: '2025-07-15',
        amount: 62.5,
        type: 'coupon',
        status: 'planned',
      },
      {
        id: 'pay-001-4',
        issuanceId: 'iss-001',
        date: '2026-01-15',
        amount: 1062.5,
        type: 'redemption',
        status: 'planned',
      },
    ],
    dltTxHash: '0xabc123def456',
    createdAt: '2024-01-10T10:00:00Z',
    publishedAt: '2024-01-15T09:00:00Z',
    documents: [
      { name: 'Проспект эмиссии', url: '/docs/prospectus-001.pdf' },
      { name: 'Условия выпуска', url: '/docs/terms-001.pdf' },
    ],
  },
  {
    id: 'iss-002',
    assetId: 'asset-002',
    assetCode: 'CFA-BETA-002',
    assetName: 'Бета Инвест 2024',
    issuerId: MOCK_ISSUER_ID,
    totalAmount: 50_000_000,
    nominal: 5000,
    availableAmount: 20_000_000,
    currency: 'RUB',
    issueDate: '2024-03-01',
    maturityDate: '2025-03-01',
    apy: 15.0,
    status: 'published',
    scheduleJson: [
      {
        id: 'pay-002-1',
        issuanceId: 'iss-002',
        date: '2024-09-01',
        amount: 375,
        type: 'coupon',
        status: 'paid',
      },
      {
        id: 'pay-002-2',
        issuanceId: 'iss-002',
        date: '2025-03-01',
        amount: 5375,
        type: 'redemption',
        status: 'planned',
      },
    ],
    dltTxHash: '0xdef789abc012',
    createdAt: '2024-02-20T14:00:00Z',
    publishedAt: '2024-03-01T08:00:00Z',
    documents: [{ name: 'Проспект эмиссии', url: '/docs/prospectus-002.pdf' }],
  },
  {
    id: 'iss-003',
    assetId: 'asset-003',
    assetCode: 'CFA-GAMMA-003',
    assetName: 'Гамма Капитал 2026',
    issuerId: MOCK_ISSUER_ID,
    totalAmount: 200_000_000,
    nominal: 10000,
    availableAmount: 200_000_000,
    currency: 'RUB',
    issueDate: '2025-01-01',
    maturityDate: '2027-01-01',
    apy: 18.0,
    status: 'draft',
    scheduleJson: [
      {
        id: 'pay-003-1',
        issuanceId: 'iss-003',
        date: '2025-07-01',
        amount: 900,
        type: 'coupon',
        status: 'planned',
      },
      {
        id: 'pay-003-2',
        issuanceId: 'iss-003',
        date: '2026-01-01',
        amount: 900,
        type: 'coupon',
        status: 'planned',
      },
      {
        id: 'pay-003-3',
        issuanceId: 'iss-003',
        date: '2026-07-01',
        amount: 900,
        type: 'coupon',
        status: 'planned',
      },
      {
        id: 'pay-003-4',
        issuanceId: 'iss-003',
        date: '2027-01-01',
        amount: 10900,
        type: 'redemption',
        status: 'planned',
      },
    ],
    dltTxHash: null,
    createdAt: '2024-11-15T16:00:00Z',
    publishedAt: null,
    documents: [],
  },
  {
    id: 'iss-004',
    assetId: 'asset-004',
    assetCode: 'CFA-DELTA-004',
    assetName: 'Дельта Финанс 2023',
    issuerId: MOCK_ISSUER_ID,
    totalAmount: 30_000_000,
    nominal: 1000,
    availableAmount: 0,
    currency: 'RUB',
    issueDate: '2023-06-01',
    maturityDate: '2024-06-01',
    apy: 10.0,
    status: 'redeemed',
    scheduleJson: [
      {
        id: 'pay-004-1',
        issuanceId: 'iss-004',
        date: '2023-12-01',
        amount: 50,
        type: 'coupon',
        status: 'paid',
      },
      {
        id: 'pay-004-2',
        issuanceId: 'iss-004',
        date: '2024-06-01',
        amount: 1050,
        type: 'redemption',
        status: 'paid',
      },
    ],
    dltTxHash: '0x111222333444',
    createdAt: '2023-05-20T10:00:00Z',
    publishedAt: '2023-06-01T09:00:00Z',
    documents: [
      { name: 'Проспект эмиссии', url: '/docs/prospectus-004.pdf' },
      { name: 'Отчет о погашении', url: '/docs/redemption-004.pdf' },
    ],
  },
];

// In-memory store for mutations (simulates state changes)
let issuancesStore = [...mockIssuances];

export function getIssuances(issuerId?: string): Issuance[] {
  if (issuerId) {
    return issuancesStore.filter(i => i.issuerId === issuerId);
  }
  return issuancesStore;
}

export function getIssuanceById(id: string): Issuance | undefined {
  return issuancesStore.find(i => i.id === id);
}

export function publishIssuance(id: string): Issuance | null {
  const idx = issuancesStore.findIndex(i => i.id === id);
  if (idx === -1) return null;

  const issuance = issuancesStore[idx];
  if (issuance.status !== 'draft') return null;

  issuancesStore[idx] = {
    ...issuance,
    status: 'published',
    publishedAt: new Date().toISOString(),
    dltTxHash: `0x${Math.random().toString(16).slice(2, 14)}`,
  };

  return issuancesStore[idx];
}

export function closeIssuance(id: string): Issuance | null {
  const idx = issuancesStore.findIndex(i => i.id === id);
  if (idx === -1) return null;

  const issuance = issuancesStore[idx];
  if (issuance.status !== 'published') return null;

  issuancesStore[idx] = {
    ...issuance,
    status: 'closed',
  };

  return issuancesStore[idx];
}

export function createIssuance(data: {
  assetId: string;
  issuerId: string;
  totalAmount: number;
  nominal: number;
  issueDate: string;
  maturityDate: string;
}): Issuance {
  const newIssuance: Issuance = {
    id: `iss-${Date.now()}`,
    assetId: data.assetId,
    assetCode: `CFA-NEW-${Date.now().toString().slice(-4)}`,
    assetName: `Новый выпуск ${new Date().toLocaleDateString('ru-RU')}`,
    issuerId: data.issuerId,
    totalAmount: data.totalAmount,
    nominal: data.nominal,
    availableAmount: data.totalAmount,
    currency: 'RUB',
    issueDate: data.issueDate,
    maturityDate: data.maturityDate,
    apy: 12.0,
    status: 'draft',
    scheduleJson: [],
    dltTxHash: null,
    createdAt: new Date().toISOString(),
    publishedAt: null,
    documents: [],
  };

  issuancesStore.push(newIssuance);
  return newIssuance;
}

export function updateIssuanceSchedule(
  issuanceId: string,
  schedule: PayoutScheduleItem[]
): Issuance | null {
  const idx = issuancesStore.findIndex(i => i.id === issuanceId);
  if (idx === -1) return null;

  issuancesStore[idx] = {
    ...issuancesStore[idx],
    scheduleJson: schedule,
  };

  return issuancesStore[idx];
}

// Reset store (useful for testing)
export function resetIssuancesStore() {
  issuancesStore = [...mockIssuances];
}
</file>

<file path="apps/portal-issuer/src/lib/mocks/profile.test.ts">
import { describe, it, expect } from 'vitest';
import { getIssuerProfile, mockIssuerProfile } from './profile';

describe('Profile Service', () => {
  describe('getIssuerProfile', () => {
    it('возвращает профиль эмитента', () => {
      const profile = getIssuerProfile();
      expect(profile).toBeDefined();
      expect(profile.id).toBe(mockIssuerProfile.id);
    });

    it('содержит корректные данные компании', () => {
      const profile = getIssuerProfile();
      expect(profile.companyName).toBe('ООО "Альфа Финанс"');
      expect(profile.inn).toBe('7707083893');
      expect(profile.ogrn).toBe('1027700132195');
      expect(profile.kpp).toBe('770701001');
    });

    it('содержит банковские реквизиты', () => {
      const profile = getIssuerProfile();
      expect(profile.bankDetails).toBeDefined();
      expect(profile.bankDetails.bankName).toBeDefined();
      expect(profile.bankDetails.bik).toBeDefined();
      expect(profile.bankDetails.account).toBeDefined();
    });

    it('содержит контактную информацию', () => {
      const profile = getIssuerProfile();
      expect(profile.email).toBeDefined();
      expect(profile.ceoName).toBeDefined();
      expect(profile.address).toBeDefined();
    });

    it('имеет корректный статус и роль', () => {
      const profile = getIssuerProfile();
      expect(profile.status).toBe('active');
      expect(profile.role).toBe('issuer');
    });

    it('содержит временные метки', () => {
      const profile = getIssuerProfile();
      expect(profile.createdAt).toBeDefined();
      expect(profile.lastLogin).toBeDefined();
      expect(new Date(profile.createdAt)).toBeInstanceOf(Date);
      expect(new Date(profile.lastLogin)).toBeInstanceOf(Date);
    });
  });
});
</file>

<file path="apps/portal-issuer/src/lib/mocks/profile.ts">
/**
 * Mock data for issuer profile based on portal-issuer-mock-schemas.md
 */

export interface BankDetails {
  bik: string;
  account: string;
  bankName: string;
}

export interface IssuerProfile {
  id: string;
  email: string;
  role: 'issuer';
  status: 'active' | 'inactive' | 'suspended' | 'blocked';
  createdAt: string;
  lastLogin: string;
  companyName: string;
  inn: string;
  ogrn: string;
  kpp: string;
  address: string;
  ceoName: string;
  bankDetails: BankDetails;
}

export const mockIssuerProfile: IssuerProfile = {
  id: 'issuer-001-uuid',
  email: 'info@alpha-finance.ru',
  role: 'issuer',
  status: 'active',
  createdAt: '2023-01-15T10:00:00Z',
  lastLogin: new Date().toISOString(),
  companyName: 'ООО "Альфа Финанс"',
  inn: '7707083893',
  ogrn: '1027700132195',
  kpp: '770701001',
  address: '123456, г. Москва, ул. Финансовая, д. 10, офис 501',
  ceoName: 'Иванов Иван Иванович',
  bankDetails: {
    bik: '044525225',
    account: '40702810500000012345',
    bankName: 'ПАО Сбербанк',
  },
};

export function getIssuerProfile(): IssuerProfile {
  return mockIssuerProfile;
}
</file>

<file path="apps/portal-issuer/src/lib/nav.ts">
export const issuerNav = [
  { label: 'Dashboard', href: '/dashboard' },
  { label: 'Issuances', href: '/issuances' },
  { label: 'Reports', href: '/reports' },
  { label: 'Payouts Schedule', href: '/payouts/schedule' },
  { label: 'KYC', href: '/kyc' },
];
</file>

<file path="apps/portal-issuer/src/lib/navigation.tsx">
import { BarChart3, CalendarClock, FileText, LayoutDashboard, UserCircle2 } from 'lucide-react';

export const issuerNavItems = [
  { label: 'Главная', href: '/dashboard', icon: <LayoutDashboard className="h-4 w-4" /> },
  { label: 'Выпуски', href: '/issuances', icon: <FileText className="h-4 w-4" /> },
  { label: 'Отчёты', href: '/reports', icon: <BarChart3 className="h-4 w-4" /> },
  { label: 'Профиль', href: '/profile', icon: <UserCircle2 className="h-4 w-4" /> },
];

export const issuerNavWithSchedule = [
  ...issuerNavItems,
  {
    label: 'График выплат',
    href: '/payouts/schedule',
    icon: <CalendarClock className="h-4 w-4" />,
  },
];
</file>

<file path="apps/portal-issuer/src/types/next-auth.d.ts">
import 'next-auth';
import 'next-auth/jwt';

declare module 'next-auth' {
  interface Session {
    user: {
      roles?: string[];
      issuerId?: string;
    } & DefaultSession['user'];
    accessToken?: string;
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    roles?: string[];
    accessToken?: string;
    issuerId?: string;
  }
}
</file>

<file path="apps/portal-issuer/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./vitest.setup.ts'],
    include: ['src/**/*.{test,spec}.{ts,tsx}'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/lib/**', 'src/hooks/**'],
      exclude: ['src/**/*.d.ts', 'src/**/*.test.ts', 'src/**/*.spec.ts'],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
</file>

<file path="apps/portal-issuer/vitest.setup.ts">
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach, vi } from 'vitest';

// Cleanup после каждого теста
afterEach(() => {
  cleanup();
});

// Mock next/navigation
vi.mock('next/navigation', () => ({
  useRouter: () => ({
    push: vi.fn(),
    replace: vi.fn(),
    back: vi.fn(),
    forward: vi.fn(),
    refresh: vi.fn(),
    prefetch: vi.fn(),
  }),
  usePathname: () => '/',
  useSearchParams: () => new URLSearchParams(),
  useParams: () => ({}),
  redirect: vi.fn(),
}));

// Mock next-auth/react
vi.mock('next-auth/react', () => ({
  useSession: () => ({
    data: {
      user: {
        id: 'test-user-id',
        name: 'Test Issuer',
        email: 'issuer@test.com',
        role: 'issuer',
      },
      expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
    },
    status: 'authenticated',
  }),
  signIn: vi.fn(),
  signOut: vi.fn(),
}));

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});
</file>

<file path="packages/contracts/asyncapi.yaml">
asyncapi: 2.6.0
id: urn:ois:events
info:
  title: OIS Events API
  version: 1.1.0
  description: События системы ОИС (Kafka)
  contact:
    name: OIS Platform
    email: devops@llmneighbors.com
    url: https://llmneighbors.com
  license:
    name: Apache-2.0
    url: https://www.apache.org/licenses/LICENSE-2.0
tags:
  - name: exchange
    description: Core exchange domain events (issuance, orders, payouts, audit)
servers:
  kafka:
    url: localhost:9092
    protocol: kafka
    description: Development Kafka broker
  cfa1:
    url: kafka:9092
    protocol: kafka
    description: CFA1 docker-compose / internal broker (behind SSH/VPN)

defaultContentType: application/json

channels:
  ois.issuance.published:
    description: Событие публикации выпуска ЦФА
    publish:
      operationId: onIssuancePublished
      summary: Issuance published event
      message:
        $ref: '#/components/messages/IssuancePublished'
  
  ois.issuance.closed:
    description: Событие закрытия выпуска
    publish:
      operationId: onIssuanceClosed
      summary: Issuance closed event
      message:
        $ref: '#/components/messages/IssuanceClosed'
  
  ois.order.placed:
    description: Событие размещения заказа на покупку
    publish:
      operationId: onOrderPlaced
      summary: Order placed event
      message:
        $ref: '#/components/messages/OrderPlaced'
  
  ois.order.confirmed:
    description: Событие подтверждения заказа
    publish:
      operationId: onOrderConfirmed
      summary: Order confirmed event
      message:
        $ref: '#/components/messages/OrderConfirmed'

  ois.order.created:
    description: Событие создания заказа
    publish:
      operationId: onOrderCreated
      summary: Order created event
      message:
        $ref: '#/components/messages/OrderCreated'

  ois.order.reserved:
    description: Событие резерва средств по заказу
    publish:
      operationId: onOrderReserved
      summary: Order reserved event
      message:
        $ref: '#/components/messages/OrderReserved'

  ois.order.paid:
    description: Событие оплаты заказа
    publish:
      operationId: onOrderPaid
      summary: Order paid event
      message:
        $ref: '#/components/messages/OrderPaid'
  
  ois.payout.executed:
    description: Событие выполнения выплаты
    publish:
      operationId: onPayoutExecuted
      summary: Payout executed event
      message:
        $ref: '#/components/messages/PayoutExecuted'
  
  ois.payout.scheduled:
    description: Событие запланированной выплаты
    publish:
      operationId: onPayoutScheduled
      summary: Payout scheduled event
      message:
        $ref: '#/components/messages/PayoutScheduled'
  
  ois.audit.logged:
    description: Событие аудита (журналирование действий)
    publish:
      operationId: onAuditLogged
      summary: Audit log event
      message:
        $ref: '#/components/messages/AuditLogged'
  
  ois.transfer.completed:
    description: Событие завершения перевода на DLT
    publish:
      operationId: onTransferCompleted
      summary: Transfer completed event
      message:
        $ref: '#/components/messages/TransferCompleted'
  
  ois.registry.transferred:
    description: Событие перевода ЦФА через реестр
    publish:
      operationId: onRegistryTransferred
      summary: Registry transfer event
      message:
        $ref: '#/components/messages/RegistryTransferred'
  
  ois.compliance.flagged:
    description: Событие флага compliance для инвестора
    publish:
      operationId: onComplianceFlagged
      summary: Compliance flagged event
      message:
        $ref: '#/components/messages/ComplianceFlagged'

  ois.kyc.updated:
    description: Обновление статуса KYC инвестора
    publish:
      operationId: onKycUpdated
      summary: KYC updated event
      message:
        $ref: '#/components/messages/KycUpdated'

components:
  messages:
    OrderCreated:
      name: OrderCreated
      title: Order Created Event
      messageId: order.created
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderCreatedPayload'

    OrderReserved:
      name: OrderReserved
      title: Order Reserved Event
      messageId: order.reserved
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderReservedPayload'

    OrderPaid:
      name: OrderPaid
      title: Order Paid Event
      messageId: order.paid
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderPaidPayload'
    IssuancePublished:
      name: IssuancePublished
      title: Issuance Published Event
      messageId: issuance.published
      contentType: application/json
      payload:
        $ref: '#/components/schemas/IssuancePublishedPayload'
    
    IssuanceClosed:
      name: IssuanceClosed
      title: Issuance Closed Event
      messageId: issuance.closed
      contentType: application/json
      payload:
        $ref: '#/components/schemas/IssuanceClosedPayload'
    
    OrderPlaced:
      name: OrderPlaced
      title: Order Placed Event
      messageId: order.placed
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderPlacedPayload'
    
    OrderConfirmed:
      name: OrderConfirmed
      title: Order Confirmed Event
      messageId: order.confirmed
      contentType: application/json
      payload:
        $ref: '#/components/schemas/OrderConfirmedPayload'
    
    PayoutExecuted:
      name: PayoutExecuted
      title: Payout Executed Event
      messageId: payout.executed
      contentType: application/json
      payload:
        $ref: '#/components/schemas/PayoutExecutedPayload'
    
    PayoutScheduled:
      name: PayoutScheduled
      title: Payout Scheduled Event
      messageId: payout.scheduled
      contentType: application/json
      payload:
        $ref: '#/components/schemas/PayoutScheduledPayload'
    
    AuditLogged:
      name: AuditLogged
      title: Audit Log Event
      messageId: audit.logged
      contentType: application/json
      payload:
        $ref: '#/components/schemas/AuditLoggedPayload'
    
    TransferCompleted:
      name: TransferCompleted
      title: Transfer Completed Event
      messageId: transfer.completed
      contentType: application/json
      payload:
        $ref: '#/components/schemas/TransferCompletedPayload'
    
    RegistryTransferred:
      name: RegistryTransferred
      title: Registry Transferred Event
      messageId: registry.transferred
      contentType: application/json
      payload:
        $ref: '#/components/schemas/RegistryTransferredPayload'
    
    ComplianceFlagged:
      name: ComplianceFlagged
      title: Compliance Flagged Event
      messageId: compliance.flagged
      contentType: application/json
      payload:
        $ref: '#/components/schemas/ComplianceFlaggedPayload'

    KycUpdated:
      name: KycUpdated
      title: KYC Updated Event
      messageId: kyc.updated
      contentType: application/json
      payload:
        $ref: '#/components/schemas/KycUpdatedPayload'
  
  schemas:
    OrderCreatedPayload:
      type: object
      required: [orderId, investorId, issuanceId, amount, createdAt]
      properties:
        orderId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        createdAt:
          type: string
          format: date-time

    OrderReservedPayload:
      type: object
      required: [orderId, investorId, issuanceId, amount, reservedAt]
      properties:
        orderId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        reservedAt:
          type: string
          format: date-time
        bankTransferId:
          type: string

    OrderPaidPayload:
      type: object
      required: [orderId, investorId, issuanceId, amount, paidAt, txHash]
      properties:
        orderId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        paidAt:
          type: string
          format: date-time
        txHash:
          type: string
    IssuancePublishedPayload:
      type: object
      required:
        - issuanceId
        - assetId
        - issuerId
        - publishedAt
      properties:
        issuanceId:
          type: string
          format: uuid
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
        schedule:
          type: object
          description: Payout schedule JSON
        publishedAt:
          type: string
          format: date-time
        metadata:
          type: object
        dltTxHash:
          type: string
          description: Transaction hash on ledger (if available)
    
    IssuanceClosedPayload:
      type: object
      required:
        - issuanceId
        - closedAt
      properties:
        issuanceId:
          type: string
          format: uuid
        closedAt:
          type: string
          format: date-time
        reason:
          type: string
        dltTxHash:
          type: string
          description: Closing transaction hash on ledger (if available)
    
    OrderPlacedPayload:
      type: object
      required:
        - orderId
        - investorId
        - issuanceId
        - amount
        - placedAt
      properties:
        orderId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        placedAt:
          type: string
          format: date-time
    
    OrderConfirmedPayload:
      type: object
      required:
        - orderId
        - confirmedAt
        - dltTxHash
      properties:
        orderId:
          type: string
          format: uuid
        confirmedAt:
          type: string
          format: date-time
        dltTxHash:
          type: string
        walletId:
          type: string
          format: uuid
    
    PayoutExecutedPayload:
      type: object
      required:
        - batchId
        - executedAt
        - items
      properties:
        batchId:
          type: string
          format: uuid
        executedAt:
          type: string
          format: date-time
        items:
          type: array
          items:
            type: object
            properties:
              payoutId:
                type: string
                format: uuid
              investorId:
                type: string
                format: uuid
              issuanceId:
                type: string
                format: uuid
              amount:
                type: number
                format: decimal
              status:
                type: string
                enum: [executed, failed]
        totalAmount:
          type: number
          format: decimal
    
    PayoutScheduledPayload:
      type: object
      required:
        - batchId
        - scheduledFor
        - issuanceId
      properties:
        batchId:
          type: string
          format: uuid
        scheduledFor:
          type: string
          format: date-time
        issuanceId:
          type: string
          format: uuid
        expectedAmount:
          type: number
          format: decimal
    
    AuditLoggedPayload:
      type: object
      required:
        - id
        - actor
        - action
        - entity
        - timestamp
      properties:
        id:
          type: string
          format: uuid
          description: Audit event ID
        actor:
          type: string
          format: uuid
          description: User/system that performed the action
        actorName:
          type: string
          description: Actor name or identifier
        action:
          type: string
          description: Action type (e.g., 'create', 'update', 'delete', 'approve', 'reject')
        entity:
          type: string
          description: Entity type (e.g., 'issuance', 'order', 'kyc', 'investor', 'audit')
        entityId:
          type: string
          format: uuid
          nullable: true
          description: Entity ID
        payload:
          type: object
          description: Additional event data
          additionalProperties: true
        ip:
          type: string
          format: ipv4
          nullable: true
          description: IP address
        userAgent:
          type: string
          nullable: true
          description: User agent string
        timestamp:
          type: string
          format: date-time
        result:
          type: string
          enum: [success, failure, pending]
          nullable: true
          description: Action result
        correlationId:
          type: string
          format: uuid
          nullable: true
          description: Request correlation ID
    
    TransferCompletedPayload:
      type: object
      required:
        - transferId
        - dltTxHash
        - completedAt
      properties:
        transferId:
          type: string
          format: uuid
        dltTxHash:
          type: string
        blockNumber:
          type: integer
        fromWalletId:
          type: string
          format: uuid
        toWalletId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        completedAt:
          type: string
      format: date-time
    
    RegistryTransferredPayload:
      type: object
      required:
        - orderId
        - issuanceId
        - investorId
        - amount
        - txHash
        - transferredAt
      properties:
        orderId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        walletId:
          type: string
          format: uuid
          nullable: true
        amount:
          type: number
          format: decimal
        txHash:
          type: string
        transferredAt:
          type: string
          format: date-time
    
    ComplianceFlaggedPayload:
      type: object
      required:
        - id
        - investorId
        - reason
        - severity
        - flaggedAt
      properties:
        id:
          type: string
          format: uuid
          description: Compliance flag ID
        investorId:
          type: string
          format: uuid
        investorName:
          type: string
          nullable: true
          description: Investor name or identifier
        reason:
          type: string
          enum: [kyc_fail, qualification_exceeded, watchlist_match, manual_review, document_issue]
          description: Reason for flagging
        severity:
          type: string
          enum: [low, medium, high, critical]
        flaggedAt:
          type: string
          format: date-time
        flaggedBy:
          type: string
          format: uuid
          nullable: true
          description: User/system that flagged the investor
        details:
          type: object
          description: Additional compliance flag details
          additionalProperties: true
        resolvedAt:
          type: string
          format: date-time
          nullable: true
          description: Resolution timestamp
        resolvedBy:
          type: string
          format: uuid
          nullable: true
          description: User who resolved the flag

    KycUpdatedPayload:
      type: object
      required:
        - investorId
        - status
        - updatedAt
      properties:
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [pass, fail, pending, review]
        reason:
          type: string
          nullable: true
        updatedAt:
          type: string
          format: date-time
</file>

<file path="services/compliance/Background/OutboxPublisher.cs">
using MassTransit;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using OIS.Contracts.Events;
using Polly;

namespace OIS.Compliance.Background;

public class OutboxPublisher : BackgroundService
{
    private readonly IServiceProvider _services;
    private readonly ILogger<OutboxPublisher> _logger;

    public OutboxPublisher(IServiceProvider services, ILogger<OutboxPublisher> logger)
    {
        _services = services;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _services.CreateScope();
                var db = scope.ServiceProvider.GetRequiredService<ComplianceDbContext>();
                var publisher = scope.ServiceProvider.GetRequiredService<IPublishEndpoint>();

                var messages = await db.OutboxMessages
                    .Where(x => x.ProcessedAt == null)
                    .OrderBy(x => x.CreatedAt)
                    .Take(50)
                    .ToListAsync(stoppingToken);

                foreach (var msg in messages)
                {
                    var retry = Polly.Policy
                        .Handle<Exception>()
                        .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)));

                    var published = await retry.ExecuteAsync(async () =>
                        await PublishTypedAsync(publisher, msg, stoppingToken));

                    if (published)
                    {
                        msg.ProcessedAt = DateTime.UtcNow;
                    }
                    else
                    {
                        _logger.LogWarning("Outbox message skipped in compliance: unsupported topic {Topic}", msg.Topic);
                    }
                }

                await db.SaveChangesAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken);
            }
            catch (OperationCanceledException) { break; }
            catch (Exception ex)
            {
                _logger.LogError(ex, "OutboxPublisher (Compliance) failed");
                await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
            }
        }
    }

    private static async Task<bool> PublishTypedAsync(IPublishEndpoint publisher, OutboxMessage msg, CancellationToken ct)
    {
        switch (msg.Topic)
        {
            case "ois.compliance.flagged":
                if (System.Text.Json.JsonSerializer.Deserialize<ComplianceFlagged>(msg.Payload) is { } cf)
                { await publisher.Publish(cf, x => x.MessageId = msg.Id, ct); return true; }
                break;
            case "ois.kyc.updated":
                if (System.Text.Json.JsonSerializer.Deserialize<KycUpdated>(msg.Payload) is { } ku)
                { await publisher.Publish(ku, x => x.MessageId = msg.Id, ct); return true; }
                break;
            case "ois.audit.logged":
                if (System.Text.Json.JsonSerializer.Deserialize<AuditLogged>(msg.Payload) is { } al)
                { await publisher.Publish(al, x => x.MessageId = msg.Id, ct); return true; }
                break;
        }
        return false;
    }
}
</file>

<file path="services/compliance/compliance.Tests/AuditApiTests.cs">
using System.Net;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Security.Claims;
using System.Text.Json;
using FluentAssertions;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.AspNetCore.TestHost;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using OIS.Compliance;
using Xunit;

namespace OIS.Compliance.Tests;

public class AuditApiTests : IClassFixture<ComplianceFactory>
{
    private readonly ComplianceFactory _factory;
    public AuditApiTests(ComplianceFactory factory) { _factory = factory; }

    [Fact]
    public async Task GetAudit_Returns_Items_In_Order()
    {
        var client = _factory.CreateClient();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "test");

        // seed one audit outbox message
        using (var scope = _factory.Services.CreateScope())
        {
            var db = scope.ServiceProvider.GetRequiredService<ComplianceDbContext>();
            db.OutboxMessages.Add(new OutboxMessage
            {
                Id = Guid.NewGuid(),
                Topic = "ois.audit.logged",
                Payload = JsonSerializer.Serialize(new
                {
                    id = Guid.NewGuid(),
                    actor = Guid.NewGuid(),
                    action = "kyc.update",
                    entity = "investor",
                    timestamp = DateTime.UtcNow,
                }),
                CreatedAt = DateTime.UtcNow
            });
            await db.SaveChangesAsync();
        }

        var res = await client.GetAsync("/v1/audit");
        res.StatusCode.Should().Be(HttpStatusCode.OK);
        var body = await res.Content.ReadFromJsonAsync<JsonElement>();
        body.TryGetProperty("items", out var items).Should().BeTrue();
        items.GetArrayLength().Should().BeGreaterThan(0);
    }

    [Fact]
    public async Task ExportCsv_Returns_Csv_Content()
    {
        var client = _factory.CreateClient();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "test");
        var res = await client.GetAsync("/v1/audit/export.csv");
        res.StatusCode.Should().Be(HttpStatusCode.OK);
        res.Content.Headers.ContentType!.MediaType.Should().Be("text/csv");
        var text = await res.Content.ReadAsStringAsync();
        text.Should().Contain("id,actor,actorName,action,entity,entityId,result,timestamp,ip,userAgent");
    }
}

public class ComplianceFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.UseEnvironment("Testing");
        builder.ConfigureServices(services =>
        {
            // Remove all EF Core registrations to avoid provider conflicts
            services.RemoveAll<DbContextOptions<ComplianceDbContext>>();
            services.RemoveAll<ComplianceDbContext>();
            var efDescriptors = services.Where(d =>
                d.ServiceType == typeof(DbContextOptions) ||
                (d.ServiceType.IsGenericType && d.ServiceType.GetGenericTypeDefinition() == typeof(DbContextOptions<>)) ||
                d.ImplementationType?.FullName?.Contains("Npgsql") == true ||
                d.ServiceType.FullName?.Contains("Npgsql") == true ||
                d.ServiceType.FullName?.Contains("EntityFrameworkCore") == true).ToList();
            foreach (var d in efDescriptors) services.Remove(d);
            services.AddDbContext<ComplianceDbContext>(o => o.UseInMemoryDatabase("compliance-audit-tests"));
        });
        builder.ConfigureTestServices(services =>
        {

            // Remove existing authentication configuration and replace with test handler
            var authDescriptors = services.Where(d =>
                d.ServiceType.FullName?.Contains("Authentication") == true ||
                d.ServiceType == typeof(IAuthenticationSchemeProvider)).ToList();
            foreach (var d in authDescriptors) services.Remove(d);

            // Bypass auth; always authenticate with backoffice role
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddScheme<AuthenticationSchemeOptions, TestAuthHandler>(JwtBearerDefaults.AuthenticationScheme, options => { });
        });
    }
}

public class TestAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    public TestAuthHandler(IOptionsMonitor<AuthenticationSchemeOptions> options, ILoggerFactory logger, System.Text.Encodings.Web.UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock) { }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, Guid.NewGuid().ToString()),
            new Claim(ClaimTypes.Role, "backoffice")
        };
        var identity = new ClaimsIdentity(claims, Scheme.Name);
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, Scheme.Name);
        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}
</file>

<file path="services/compliance/compliance.Tests/QualificationLimitTests.cs">
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using OIS.Compliance.Services;
using Xunit;

namespace OIS.Compliance.Tests;

public class QualificationLimitTests
{
    private readonly ComplianceDbContext _db;
    private readonly ComplianceService _service;
    private readonly Mock<IQualificationPolicyService> _policy;

    public QualificationLimitTests()
    {
        var options = new DbContextOptionsBuilder<ComplianceDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        _db = new ComplianceDbContext(options);

        var logger = new Mock<ILogger<ComplianceService>>();
        var watchlists = new Mock<IWatchlistsService>();
        watchlists.Setup(w => w.CheckAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new WatchlistCheckResult { Matched = false });

        _policy = new Mock<IQualificationPolicyService>();
        _policy.Setup(p => p.EvaluateTierAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(QualificationTier.Qualified);
        _policy.Setup(p => p.GetLimitForTier("qualified")).Returns(100m);

        var outbox = new OutboxService(_db);
        _service = new ComplianceService(_db, logger.Object, watchlists.Object, _policy.Object, outbox);
    }

    [Fact]
    public async Task EvaluateQualification_Increments_Used_Within_Limit()
    {
        var investor = Guid.NewGuid();

        var first = await _service.EvaluateQualificationAsync(new QualificationEvaluateRequest
        {
            InvestorId = investor,
            Amount = 40m
        }, CancellationToken.None);

        first.Allowed.Should().BeTrue();
        first.Used.Should().Be(40m);
        first.Limit.Should().Be(100m);

        var entity = await _db.InvestorsCompliance.FirstAsync(x => x.InvestorId == investor);
        entity.QualUsed.Should().Be(40m);
    }

    [Fact]
    public async Task EvaluateQualification_Blocks_When_Exceeding_Limit()
    {
        var investor = Guid.NewGuid();

        await _service.EvaluateQualificationAsync(new QualificationEvaluateRequest
        {
            InvestorId = investor,
            Amount = 80m
        }, CancellationToken.None);

        var second = await _service.EvaluateQualificationAsync(new QualificationEvaluateRequest
        {
            InvestorId = investor,
            Amount = 30m
        }, CancellationToken.None);

        second.Allowed.Should().BeFalse();
        second.Reason.Should().NotBeNullOrWhiteSpace();

        var entity = await _db.InvestorsCompliance.FirstAsync(x => x.InvestorId == investor);
        entity.QualUsed.Should().Be(80m);
    }
}
</file>

<file path="services/compliance/DTOs/ComplaintActionDtos.cs">
namespace OIS.Compliance.DTOs;

public class ComplaintReplyRequest
{
    public string Text { get; set; } = string.Empty;
    public bool IsInternal { get; set; } = false;
}

public class ComplaintResolveRequest
{
    public string Resolution { get; set; } = "resolved"; // resolved, closed, rejected
    public string? ResolutionText { get; set; }
}
</file>

<file path="services/compliance/DTOs/InvestorStatusResponse.cs">
namespace OIS.Compliance.DTOs;

public record InvestorStatusResponse
{
    public Guid InvestorId { get; init; }
    /// <summary>
    /// KYC status: not_started (нет заявки), pending (в очереди), review (в работе), pass, fail
    /// </summary>
    public string Kyc { get; init; } = string.Empty;
    public string QualificationTier { get; init; } = string.Empty;
    public decimal? QualificationLimit { get; init; }
    public decimal? QualificationUsed { get; init; }
    /// <summary>
    /// Number of KYC rejections (max 5 attempts allowed)
    /// </summary>
    public int RejectionCount { get; init; }
    /// <summary>
    /// Reason for last rejection (if any)
    /// </summary>
    public string? RejectionReason { get; init; }
    /// <summary>
    /// True if investor can upload/re-upload KYC documents
    /// </summary>
    public bool CanUploadDocuments { get; init; }
    public DateTime UpdatedAt { get; init; }
}
</file>

<file path="services/compliance/DTOs/KycApplicationRequest.cs">
using System;

namespace OIS.Compliance.DTOs;

public record KycApplicationRequest
{
    public Guid? InvestorId { get; init; }
    public string? FullName { get; init; }
    public string? DocumentType { get; init; }
    public string? DocumentNumber { get; init; }
    public string? Comment { get; init; }
}
</file>

<file path="services/compliance/DTOs/KycDocumentDto.cs">
namespace OIS.Compliance.DTOs;

public class KycDocumentDto
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public string DocumentType { get; set; } = string.Empty;
    public string FileName { get; set; } = string.Empty;
    public long FileSize { get; set; }
    public string MimeType { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public string? RejectionReason { get; set; }
    public DateTime UploadedAt { get; set; }
    public DateTime? VerifiedAt { get; set; }
}

public class UploadKycDocumentRequest
{
    public Guid InvestorId { get; set; }
    public string DocumentType { get; set; } = "other";
    public string? Description { get; set; }
}
</file>

<file path="services/compliance/DTOs/QualificationTaskDto.cs">
namespace OIS.Compliance.DTOs;

public class QualificationTaskDto
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public string QualificationBasis { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public string? AssignedTier { get; set; }
    public decimal? AssignedLimit { get; set; }
    public string? Reason { get; set; }
    public List<Guid>? DocumentIds { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ResolvedAt { get; set; }
    public Guid? ResolvedBy { get; set; }
    public DateTime? ExpiresAt { get; set; }
}

public class CreateQualificationTaskRequest
{
    public Guid InvestorId { get; set; }
    public string QualificationBasis { get; set; } = string.Empty;
    public decimal? TradingTurnover { get; set; }
    public int? TradingFrequency { get; set; }
    public decimal? TotalAssets { get; set; }
    public decimal? AnnualIncome { get; set; }
    public FinancialWorkExperienceDto? WorkExperience { get; set; }
    public FinancialEducationDto? Education { get; set; }
    public QualificationCertificateDto? QualificationCertificate { get; set; }
    public List<Guid>? DocumentIds { get; set; }
}

public class QualificationDecisionRequest
{
    public string? Tier { get; set; }
    public decimal? Limit { get; set; }
    public string? Reason { get; set; }
}

public class FinancialWorkExperienceDto
{
    public bool HasExperience { get; set; }
    public string? OrganizationType { get; set; }
    public string? OrganizationName { get; set; }
    public string? Position { get; set; }
    public decimal? YearsOfExperience { get; set; }
    public string? PeriodFrom { get; set; }
    public string? PeriodTo { get; set; }
}

public class FinancialEducationDto
{
    public bool HasEducation { get; set; }
    public string? EducationType { get; set; }
    public string? InstitutionName { get; set; }
    public string? Specialization { get; set; }
    public int? GraduationYear { get; set; }
    public string? DiplomaNumber { get; set; }
}

public class QualificationCertificateDto
{
    public bool HasCertificate { get; set; }
    public string? CertificateType { get; set; }
    public string? CertificateNumber { get; set; }
    public string? IssuedAt { get; set; }
    public string? IssuedBy { get; set; }
}
</file>

<file path="services/compliance/Migrations/20250104120000_AddKycDocsAndQualification.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace OIS.Compliance.Migrations
{
    public partial class AddKycDocsAndQualification : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "kyc_documents",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false),
                    document_type = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    file_name = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    file_size = table.Column<long>(type: "bigint", nullable: false),
                    mime_type = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    rejection_reason = table.Column<string>(type: "text", nullable: true),
                    file_data = table.Column<byte[]>(type: "bytea", nullable: false),
                    uploaded_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    verified_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_kyc_documents", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_kyc_documents_document_type",
                table: "kyc_documents",
                column: "document_type");

            migrationBuilder.CreateIndex(
                name: "ix_kyc_documents_investor_id",
                table: "kyc_documents",
                column: "investor_id");

            migrationBuilder.CreateIndex(
                name: "ix_kyc_documents_status",
                table: "kyc_documents",
                column: "status");

            migrationBuilder.CreateTable(
                name: "qualification_tasks",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None),
                    investor_id = table.Column<Guid>(type: "uuid", nullable: false),
                    qualification_basis = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    assigned_tier = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: true),
                    assigned_limit = table.Column<decimal>(type: "numeric(20,8)", precision: 20, scale: 8, nullable: true),
                    reason = table.Column<string>(type: "text", nullable: true),
                    document_ids = table.Column<string>(type: "jsonb", nullable: true),
                    created_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    resolved_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    resolved_by = table.Column<Guid>(type: "uuid", nullable: true),
                    expires_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("pk_qualification_tasks", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "ix_qualification_tasks_investor_id",
                table: "qualification_tasks",
                column: "investor_id");

            migrationBuilder.CreateIndex(
                name: "ix_qualification_tasks_qualification_basis",
                table: "qualification_tasks",
                column: "qualification_basis");

            migrationBuilder.CreateIndex(
                name: "ix_qualification_tasks_status",
                table: "qualification_tasks",
                column: "status");
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "kyc_documents");

            migrationBuilder.DropTable(
                name: "qualification_tasks");
        }
    }
}
</file>

<file path="services/compliance/compliance.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <DefaultItemExcludes>$(DefaultItemExcludes);compliance.Tests/**</DefaultItemExcludes>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="compliance.Tests/**/*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="1.9.0-beta.1" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.9.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.9.0" />
    <PackageReference Include="Polly" Version="8.4.1" />
    <PackageReference Include="System.Text.Json" Version="9.0.0" />
    <PackageReference Include="MassTransit" Version="8.2.0" />
    <PackageReference Include="MassTransit.Kafka" Version="8.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\packages\domain\domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Compile Remove="compliance.Tests/**/*.cs" />
  </ItemGroup>

</Project>
</file>

<file path="services/identity/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  },
  "Swagger": {
    "Enabled": true
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=ois;Username=ois;Password=ois_dev_password"
  },
  "Keycloak": {
    "Authority": "http://localhost:8080/realms/ois"
  }
}
</file>

<file path="services/identity/Program.cs">
using Microsoft.EntityFrameworkCore;
using Serilog;
using System.Collections.Generic;
using System.Linq;

var builder = WebApplication.CreateBuilder(args);

builder.Host.UseSerilog((ctx, lc) => lc
    .WriteTo.Console()
    .ReadFrom.Configuration(ctx.Configuration));

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks();
builder.Services.AddDbContext<IdentityDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();

var swaggerEnabled = app.Configuration.GetValue<bool?>("Swagger:Enabled") ?? app.Environment.IsDevelopment();
if (swaggerEnabled)
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.MapHealthChecks("/health");

app.MapGet("/.well-known/openid-configuration", () => Results.Ok(new
{
    issuer = builder.Configuration["Keycloak:Authority"],
    authorization_endpoint = $"{builder.Configuration["Keycloak:Authority"]}/protocol/openid-connect/auth",
    token_endpoint = $"{builder.Configuration["Keycloak:Authority"]}/protocol/openid-connect/token",
    userinfo_endpoint = "/userinfo",
    response_types_supported = new[] { "code" },
    scopes_supported = new[] { "openid", "profile", "email" }
}));

app.MapGet("/userinfo", () => Results.Ok(new
{
    sub = Guid.NewGuid().ToString(),
    email = "test@example.com",
    email_verified = true,
    name = "Test User"
}));

// Simple in-memory registry for backoffice UI until real Keycloak/registry integration is ready
var seededUsers = new List<User>
{
    new() { Id = Guid.Parse("11111111-1111-1111-1111-111111111111"), Email = "issuer@example.com", Role = "issuer", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-5) },
    new() { Id = Guid.Parse("22222222-2222-2222-2222-222222222222"), Email = "backoffice@example.com", Role = "backoffice", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-10) },
    new() { Id = Guid.Parse("33333333-3333-3333-3333-333333333333"), Email = "investor@example.com", Role = "investor", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-15) }
};

app.MapGet("/users", () => Results.Ok(seededUsers.Select(MapUser)));
app.MapGet("/users/{id:guid}", (Guid id) =>
{
    var user = seededUsers.FirstOrDefault(u => u.Id == id);
    return user is null ? Results.NotFound() : Results.Ok(MapUser(user));
});

app.MapGet("/v1/identity/users", (string? query) =>
{
    var filtered = string.IsNullOrWhiteSpace(query)
        ? seededUsers
        : seededUsers.Where(u => u.Email.Contains(query, StringComparison.OrdinalIgnoreCase) || u.Role.Contains(query, StringComparison.OrdinalIgnoreCase)).ToList();
    return Results.Ok(filtered.Select(MapUser));
});

app.Run();

static object MapUser(User u) => new
{
    id = u.Id,
    email = u.Email,
    roles = new[] { u.Role },
    status = u.Status,
    createdAt = u.CreatedAt
};

// Minimal DbContext for now
public class IdentityDbContext : DbContext
{
    public IdentityDbContext(DbContextOptions<IdentityDbContext> options) : base(options) { }
    public DbSet<User> Users => Set<User>();
}

public class User
{
    public Guid Id { get; set; }
    public string Email { get; set; } = string.Empty;
    public string Role { get; set; } = string.Empty;
    public string Status { get; set; } = "active";
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
</file>

<file path="services/issuance/Services/IssuanceService.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using OIS.Domain;
using OIS.Issuance.DTOs;
using System.Text.Json;

namespace OIS.Issuance.Services;

public interface IIssuanceService
{
    Task<IssuanceResponse> CreateAsync(CreateIssuanceRequest request, CancellationToken ct);
    Task<IssuanceResponse?> GetByIdAsync(Guid id, CancellationToken ct);
    Task<IssuanceResponse?> PublishAsync(Guid id, CancellationToken ct);
    Task<IssuanceResponse?> CloseAsync(Guid id, CancellationToken ct);
    Task<IssuerIssuancesReportResponse> GetIssuerIssuancesReportAsync(Guid issuerId, DateOnly? from, DateOnly? to, CancellationToken ct);
}

public class IssuanceService : IIssuanceService
{
    private readonly IssuanceDbContext _db;
    private readonly ILogger<IssuanceService> _logger;
    private readonly IOutboxService _outbox;
    private readonly ILedgerIssuance _ledger;

    public IssuanceService(
        IssuanceDbContext db,
        ILogger<IssuanceService> logger,
        IOutboxService outbox,
        ILedgerIssuance ledger)
    {
        _db = db;
        _logger = logger;
        _outbox = outbox;
        _ledger = ledger;
    }

    public async Task<IssuanceResponse> CreateAsync(CreateIssuanceRequest request, CancellationToken ct)
    {
        var issuance = new IssuanceEntity
        {
            Id = Guid.NewGuid(),
            AssetId = request.AssetId,
            IssuerId = request.IssuerId,
            TotalAmount = request.TotalAmount,
            Nominal = request.Nominal,
            IssueDate = request.IssueDate,
            MaturityDate = request.MaturityDate,
            Status = IssuanceStatus.Draft,
            ScheduleJson = request.ScheduleJson != null 
                ? JsonSerializer.Serialize(request.ScheduleJson) 
                : null,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _db.Issuances.Add(issuance);
        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Created issuance {IssuanceId} for asset {AssetId}", issuance.Id, issuance.AssetId);

        return MapToResponse(issuance);
    }

    public async Task<IssuerIssuancesReportResponse> GetIssuerIssuancesReportAsync(
        Guid issuerId,
        DateOnly? from,
        DateOnly? to,
        CancellationToken ct)
    {
        var query = _db.Issuances
            .AsNoTracking()
            .Where(i => i.IssuerId == issuerId);

        if (from.HasValue)
        {
            query = query.Where(i => i.IssueDate >= from.Value);
        }

        if (to.HasValue)
        {
            query = query.Where(i => i.IssueDate <= to.Value);
        }

        var issuances = await query.ToListAsync(ct);

        var items = issuances.Select(i => new IssuerReportRow
        {
            IssuanceId = i.Id,
            AssetCode = i.AssetId.ToString(), // TODO: replace with real asset code when available
            AssetName = i.AssetId.ToString(), // TODO: replace with real asset name from domain/catalog
            TotalAmount = i.TotalAmount,
            SoldAmount = 0m, // TODO: pull real sold amount from registry once available
            InvestorsCount = 0, // TODO: pull investors count from registry once available
            Status = i.Status.ToStringValue(),
            IssueDate = i.IssueDate,
            MaturityDate = i.MaturityDate,
            PublishedAt = i.PublishedAt
        }).ToList();

        var summary = new IssuerIssuancesReportSummary
        {
            TotalIssuances = items.Count,
            TotalAmount = items.Sum(x => x.TotalAmount),
            TotalSold = items.Sum(x => x.SoldAmount),
            TotalInvestors = items.Sum(x => x.InvestorsCount)
        };

        return new IssuerIssuancesReportResponse
        {
            IssuerId = issuerId,
            Period = new IssuerIssuancesReportPeriod
            {
                From = from,
                To = to
            },
            Items = items,
            Summary = summary
        };
    }

    public async Task<IssuanceResponse?> GetByIdAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        return issuance != null ? MapToResponse(issuance) : null;
    }

    public async Task<IssuanceResponse?> PublishAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        if (issuance == null)
        {
            _logger.LogWarning("Publish requested for missing issuance {IssuanceId}", id);
            return null;
        }

        if (issuance.Status != IssuanceStatus.Draft)
            throw new InvalidOperationException($"Cannot publish issuance in status {issuance.Status}");

        // Issue on ledger
        var scheduleJson = issuance.ScheduleJson;
        string txHash;
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        try
        {
            txHash = await _ledger.IssueAsync(
                issuance.Id,
                issuance.AssetId,
                issuance.IssuerId,
                issuance.TotalAmount,
                issuance.Nominal,
                issuance.IssueDate,
                issuance.MaturityDate,
                scheduleJson,
                ct);

            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Issue successful for {IssuanceId}: txHash={TxHash}, duration={Duration}ms",
                issuance.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Issue failed for {IssuanceId} after {Duration}ms",
                issuance.Id, stopwatch.ElapsedMilliseconds);
            throw new InvalidOperationException($"Failed to issue on ledger: {ex.Message}", ex);
        }

        // Update database
        issuance.Status = IssuanceStatus.Published;
        issuance.PublishedAt = DateTime.UtcNow;
        issuance.UpdatedAt = DateTime.UtcNow;
        issuance.DltTxHash = txHash;

        await _db.SaveChangesAsync(ct);

        // Publish event via outbox
        var schedule = scheduleJson != null
            ? JsonSerializer.Deserialize<Dictionary<string, object>>(scheduleJson)
            : null;

        await _outbox.AddAsync("ois.issuance.published", new
        {
            issuanceId = issuance.Id,
            assetId = issuance.AssetId,
            issuerId = issuance.IssuerId,
            totalAmount = issuance.TotalAmount,
            schedule = schedule,
            publishedAt = issuance.PublishedAt,
            metadata = new
            {
                dltTxHash = txHash
            }
        }, ct);

        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Published issuance {IssuanceId} with txHash {TxHash}", issuance.Id, txHash);

        return MapToResponse(issuance);
    }

    public async Task<IssuanceResponse?> CloseAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        if (issuance == null)
        {
            _logger.LogWarning("Close requested for missing issuance {IssuanceId}", id);
            return null;
        }

        if (issuance.Status != IssuanceStatus.Published)
            throw new InvalidOperationException($"Cannot close issuance in status {issuance.Status}");

        // Close on ledger
        string txHash;
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        try
        {
            txHash = await _ledger.CloseAsync(issuance.Id, ct);

            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Close successful for {IssuanceId}: txHash={TxHash}, duration={Duration}ms",
                issuance.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Close failed for {IssuanceId} after {Duration}ms",
                issuance.Id, stopwatch.ElapsedMilliseconds);
            throw new InvalidOperationException($"Failed to close on ledger: {ex.Message}", ex);
        }

        // Update database
        issuance.Status = IssuanceStatus.Closed;
        issuance.ClosedAt = DateTime.UtcNow;
        issuance.UpdatedAt = DateTime.UtcNow;
        issuance.DltTxHash = txHash; // Update with latest transaction hash

        await _db.SaveChangesAsync(ct);

        await _outbox.AddAsync("ois.issuance.closed", new
        {
            issuanceId = issuance.Id,
            closedAt = issuance.ClosedAt,
            metadata = new
            {
                dltTxHash = txHash
            }
        }, ct);

        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Closed issuance {IssuanceId} with txHash {TxHash}", issuance.Id, txHash);

        return MapToResponse(issuance);
    }

    private static IssuanceResponse MapToResponse(IssuanceEntity entity)
    {
        Dictionary<string, object>? scheduleJson = null;
        if (!string.IsNullOrEmpty(entity.ScheduleJson))
        {
            scheduleJson = JsonSerializer.Deserialize<Dictionary<string, object>>(entity.ScheduleJson);
        }

        return new IssuanceResponse
        {
            Id = entity.Id,
            AssetId = entity.AssetId,
            IssuerId = entity.IssuerId,
            TotalAmount = entity.TotalAmount,
            Nominal = entity.Nominal,
            IssueDate = entity.IssueDate,
            MaturityDate = entity.MaturityDate,
            Status = entity.Status.ToStringValue(),
            ScheduleJson = scheduleJson,
            DltTxHash = entity.DltTxHash,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            PublishedAt = entity.PublishedAt,
            ClosedAt = entity.ClosedAt
        };
    }
}
</file>

<file path="apps/backoffice/src/app/audit/page.tsx">
'use client';

import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { PageHeader, Card, DataTable, Badge, Input, Select } from '@ois/shared-ui';
import { auditService } from '@/lib/services/audit';
import { AuditLogEntry, AuditEventType } from '@/mocks/audit';
import { ColumnDef } from '@tanstack/react-table';

export default function AuditPage() {
  const [eventType, setEventType] = useState<AuditEventType | 'all'>('all');
  const [search, setSearch] = useState('');

  const { data: logs = [], isLoading } = useQuery({
    queryKey: ['audit-logs', eventType, search],
    queryFn: () =>
      auditService.getLogs({
        eventType: eventType === 'all' ? undefined : eventType,
        search: search || undefined,
      }),
  });

  const columns: ColumnDef<AuditLogEntry>[] = [
    {
      accessorKey: 'timestamp',
      header: 'Время',
      cell: ({ row }) => new Date(row.original.timestamp).toLocaleString('ru-RU'),
    },
    {
      accessorKey: 'eventType',
      header: 'Тип события',
      cell: ({ row }) => {
        const typeMap: Record<string, string> = {
          auth: 'Аутентификация',
          user_mgmt: 'Управление пользователями',
          kyc: 'KYC/Комплаенс',
          system: 'Система',
        };
        return (
          <Badge intent="neutral">
            {typeMap[row.original.eventType] || row.original.eventType}
          </Badge>
        );
      },
    },
    {
      accessorKey: 'actorEmail',
      header: 'Пользователь',
    },
    {
      accessorKey: 'action',
      header: 'Действие',
      cell: ({ row }) => <span className="font-medium">{row.original.action}</span>,
    },
    {
      accessorKey: 'details',
      header: 'Детали',
    },
    {
      accessorKey: 'status',
      header: 'Статус',
      cell: ({ row }) => (
        <Badge intent={row.original.status === 'success' ? 'success' : 'danger'}>
          {row.original.status === 'success' ? 'Успех' : 'Ошибка'}
        </Badge>
      ),
    },
    {
      accessorKey: 'ipAddress',
      header: 'IP Адрес',
      cell: ({ row }) => (
        <span className="text-xs text-text-secondary">{row.original.ipAddress}</span>
      ),
    },
  ];

  return (
    <div className="space-y-6">
      <PageHeader
        title="Журнал аудита"
        description="История действий пользователей и системных событий"
      />

      <Card className="p-4">
        <div className="grid grid-cols-1 gap-4 md:grid-cols-3">
          <Input
            placeholder="Поиск по пользователю, действию..."
            value={search}
            onChange={e => setSearch(e.target.value)}
          />
          <Select
            options={[
              { value: 'all', label: 'Все типы событий' },
              { value: 'auth', label: 'Аутентификация' },
              { value: 'user_mgmt', label: 'Управление пользователями' },
              { value: 'kyc', label: 'KYC/Комплаенс' },
              { value: 'system', label: 'Система' },
            ]}
            value={eventType}
            onChange={e => setEventType(e.target.value as any)}
          />
        </div>
      </Card>

      <Card>
        {isLoading ? (
          <div className="p-8 text-center text-text-secondary">Загрузка логов...</div>
        ) : (
          <DataTable columns={columns} data={logs} />
        )}
      </Card>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/kyc/components/DocumentPreviewModal.tsx">
'use client';

import { Modal, Button } from '@ois/shared-ui';
import { Download } from 'lucide-react';
import { KycDocument, getKycDocumentDownloadUrl } from '@/lib/api/compliance';
import { DOCUMENT_TYPE_LABELS } from '@/lib/constants';

type Props = {
  document: KycDocument | null;
  onClose: () => void;
};

export function DocumentPreviewModal({ document, onClose }: Props) {
  if (!document) return null;

  const downloadUrl = getKycDocumentDownloadUrl(document.id);

  const handleDownload = () => {
    window.open(downloadUrl, '_blank');
  };

  return (
    <Modal isOpen={!!document} onClose={onClose} title={`Просмотр: ${document.fileName}`}>
      <div className="p-4">
        <img
          src={downloadUrl}
          alt={document.fileName}
          className="max-w-full max-h-[70vh] mx-auto rounded-lg shadow-lg"
        />
        <div className="flex justify-between items-center mt-4 pt-4 border-t">
          <div className="text-sm text-text-tertiary">
            {DOCUMENT_TYPE_LABELS[document.documentType] || document.documentType}
          </div>
          <Button variant="secondary" size="sm" onClick={handleDownload}>
            <Download className="h-4 w-4 mr-2" />
            Скачать
          </Button>
        </div>
      </div>
    </Modal>
  );
}
</file>

<file path="apps/backoffice/src/components/providers/Providers.tsx">
'use client';

import { SessionProvider } from 'next-auth/react';
import { Toaster } from 'sonner';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useState } from 'react';

import { ThemeProvider } from '@ois/shared-ui';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <SessionProvider>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider>
          {children}
          <Toaster position="top-right" richColors />
        </ThemeProvider>
      </QueryClientProvider>
    </SessionProvider>
  );
}
</file>

<file path="apps/backoffice/src/lib/api/compliance/kyc-documents-api.ts">
/**
 * KYC Documents API (/v1/kyc/documents)
 */

import type { KycDocument } from './types';
import { apiCall, apiCallWithMock, API_BASE } from './http-client';
import { getMockKycDocuments } from './mocks';

/**
 * List KYC documents for investor
 * GET /v1/kyc/investors/{investorId}/documents
 */
export async function listKycDocuments(investorId: string): Promise<KycDocument[]> {
  return apiCallWithMock<KycDocument[]>(
    `/v1/kyc/investors/${investorId}/documents`,
    getMockKycDocuments(investorId),
    'KYC documents unavailable'
  );
}

/**
 * Get KYC document metadata
 * GET /v1/kyc/documents/{id}
 */
export async function getKycDocument(id: string): Promise<KycDocument> {
  return apiCall<KycDocument>(`/v1/kyc/documents/${id}`);
}

/**
 * Get KYC document download URL
 * GET /v1/kyc/documents/{id}/download
 */
export function getKycDocumentDownloadUrl(id: string): string {
  // Прокси добавит токен авторизации
  const path = `/v1/kyc/documents/${id}/download`;
  return `/api/proxy?path=${encodeURIComponent(path)}`;
}
</file>

<file path="apps/backoffice/src/lib/services/dashboard.ts">
import { listUsers, listKycTasks, UserRecord, KycTask } from '../api/compliance';
import { complaintsService } from './complaints';
import { auditService } from './audit';
import { Complaint } from '@/mocks/complaints';
import { AuditLogEntry } from '@/mocks/audit';

export interface DashboardStats {
  users: {
    total: number;
    active: number;
    blocked: number;
  };
  kyc: {
    open: number;
    approved: number;
    rejected: number;
  };
  complaints: {
    open: number;
    inProgress: number;
    resolved: number;
  };
  recentActivity: Array<{
    id: string;
    type: 'audit' | 'complaint' | 'kyc';
    message: string;
    timestamp: string;
  }>;
}

export const dashboardService = {
  async getStats(): Promise<DashboardStats> {
    const [users, kycTasks, complaints, auditLogs] = await Promise.all([
      listUsers(),
      listKycTasks(),
      complaintsService.getComplaints(),
      auditService.getLogs(),
    ]);

    const stats: DashboardStats = {
      users: {
        total: users.length,
        active: users.filter((u: UserRecord) => u.status === 'active').length,
        blocked: users.filter((u: UserRecord) => u.status === 'blocked').length,
      },
      kyc: {
        open: kycTasks.filter((k: KycTask) => k.status === 'open').length,
        approved: kycTasks.filter((k: KycTask) => k.status === 'approved').length,
        rejected: kycTasks.filter((k: KycTask) => k.status === 'rejected').length,
      },
      complaints: {
        open: complaints.filter((c: Complaint) => c.status === 'open').length,
        inProgress: complaints.filter((c: Complaint) => c.status === 'in_progress').length,
        resolved: complaints.filter((c: Complaint) => c.status === 'resolved').length,
      },
      recentActivity: [],
    };

    // Aggregate recent activity
    const activity = [
      ...auditLogs.slice(0, 3).map((log: AuditLogEntry) => ({
        id: log.id,
        type: 'audit' as const,
        message: `${log.action}: ${log.details}`,
        timestamp: log.timestamp,
      })),
      ...complaints.slice(0, 2).map((c: Complaint) => ({
        id: c.id,
        type: 'complaint' as const,
        message: `Новая жалоба: ${c.subject}`,
        timestamp: c.createdAt,
      })),
    ];

    stats.recentActivity = activity
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, 5);

    return stats;
  },
};
</file>

<file path="apps/backoffice/src/lib/auth.ts">
import type { NextAuthOptions, User, Account } from 'next-auth';
import type { JWT } from 'next-auth/jwt';
import CredentialsProvider from 'next-auth/providers/credentials';
import KeycloakProvider from 'next-auth/providers/keycloak';

// Extended user type with roles
interface UserWithRoles extends User {
  roles?: string[];
}

// Extended account type for Keycloak
interface KeycloakAccount extends Account {
  realm_access?: {
    roles?: string[];
  };
}

// Extended JWT type
interface ExtendedJWT extends JWT {
  roles?: string[];
  accessToken?: string;
  idToken?: string;
  refreshToken?: string;
}

// Extended session type
declare module 'next-auth' {
  interface Session {
    user: {
      name?: string | null;
      email?: string | null;
      image?: string | null;
      roles?: string[];
    };
    accessToken?: string;
  }
}

export const authOptions: NextAuthOptions = {
  secret: process.env.NEXTAUTH_SECRET || 'dev-secret-cfa1',
  providers: [
    KeycloakProvider({
      clientId: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || '',
      clientSecret: process.env.KEYCLOAK_CLIENT_SECRET || '',
      issuer: process.env.NEXT_PUBLIC_KEYCLOAK_URL
        ? `${process.env.NEXT_PUBLIC_KEYCLOAK_URL}/realms/${process.env.NEXT_PUBLIC_KEYCLOAK_REALM}`
        : undefined,
    }),
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        username: { label: 'Username', type: 'text', placeholder: 'admin' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials): Promise<UserWithRoles | null> {
        // Mock authentication for testing
        if (credentials?.username === 'admin' && credentials?.password === 'admin') {
          return {
            id: '1',
            name: 'Admin User',
            email: 'admin@ois.com',
            roles: ['admin', 'backoffice'],
          };
        }
        if (credentials?.username === 'operator' && credentials?.password === 'operator') {
          return {
            id: '2',
            name: 'Operator User',
            email: 'operator@ois.com',
            roles: ['operator', 'backoffice'],
          };
        }
        return null;
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user, account }): Promise<ExtendedJWT> {
      const extendedToken = token as ExtendedJWT;

      if (user) {
        const userWithRoles = user as UserWithRoles;
        extendedToken.roles = userWithRoles.roles || [];
      }

      // Handle Keycloak tokens and roles
      if (account?.provider === 'keycloak') {
        const keycloakAccount = account as KeycloakAccount;
        extendedToken.accessToken = account.access_token;
        extendedToken.idToken = account.id_token;
        extendedToken.refreshToken = account.refresh_token;
        // Extract roles from Keycloak token
        extendedToken.roles = keycloakAccount.realm_access?.roles || [];
      }

      return extendedToken;
    },
    async session({ session, token }) {
      const extendedToken = token as ExtendedJWT;

      if (session.user) {
        session.user.roles = extendedToken.roles;
      }
      // Include access token in session for server-side API calls
      session.accessToken = extendedToken.accessToken;

      return session;
    },
  },
  pages: {
    signIn: '/login',
  },
};
</file>

<file path="apps/portal-investor/src/app/history/columns.tsx">
import { ColumnDef } from '@tanstack/react-table';
import { formatCurrency, formatDateTime, shortHash } from '@/lib/format';

type TxHistoryItem = {
  id?: string;
  createdAt: string;
  type: 'transfer' | 'redeem' | 'issue';
  issuanceCode: string;
  amount: number;
  status: 'pending' | 'confirmed' | 'failed';
  dltTxHash?: string;
};

type PayoutItem = {
  id?: string;
  executedAt?: string;
  issuanceId: string;
  amount: number;
  status: 'pending' | 'executed' | 'failed';
};

export const txColumns: ColumnDef<TxHistoryItem>[] = [
  {
    accessorKey: 'createdAt',
    header: 'Дата',
    cell: ({ row }) => (
      <span className="text-sm text-text-primary">{formatDateTime(row.original.createdAt)}</span>
    ),
  },
  {
    accessorKey: 'type',
    header: 'Тип',
    cell: ({ row }) => {
      const type = row.original.type;
      const colors: Record<string, string> = {
        issue: 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300',
        transfer: 'bg-info-100 text-info-700 dark:bg-info-900 dark:text-info-300',
        redeem: 'bg-warning-100 text-warning-700 dark:bg-warning-900 dark:text-warning-300',
      };
      return (
        <span className={`px-2 py-1 text-xs font-medium rounded ${colors[type] || ''}`}>
          {type}
        </span>
      );
    },
  },
  {
    accessorKey: 'issuanceCode',
    header: 'Выпуск',
    cell: ({ row }) => (
      <span className="text-sm text-text-primary">{row.original.issuanceCode}</span>
    ),
  },
  {
    accessorKey: 'amount',
    header: 'Сумма',
    cell: ({ row }) => (
      <span className="text-sm font-medium text-text-primary">
        {formatCurrency(row.original.amount)}
      </span>
    ),
  },
  {
    accessorKey: 'status',
    header: 'Статус',
    cell: ({ row }) => {
      const status = row.original.status;
      const colors: Record<string, string> = {
        confirmed: 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300',
        pending: 'bg-warning-100 text-warning-700 dark:bg-warning-900 dark:text-warning-300',
        failed: 'bg-danger-100 text-danger-700 dark:bg-danger-900 dark:text-danger-300',
      };
      return (
        <span className={`px-2 py-1 text-xs font-medium rounded ${colors[status] || ''}`}>
          {status}
        </span>
      );
    },
  },
  {
    accessorKey: 'dltTxHash',
    header: 'DLT хэш',
    cell: ({ row }) => (
      <span className="text-xs text-text-tertiary font-mono">
        {shortHash(row.original.dltTxHash)}
      </span>
    ),
  },
];

export const payoutColumns: ColumnDef<PayoutItem>[] = [
  {
    accessorKey: 'executedAt',
    header: 'Дата',
    cell: ({ row }) => (
      <span className="text-sm text-text-primary">{formatDateTime(row.original.executedAt)}</span>
    ),
  },
  {
    accessorKey: 'issuanceId',
    header: 'ID выпуска',
    cell: ({ row }) => (
      <span className="text-xs text-text-tertiary font-mono">
        {shortHash(row.original.issuanceId, 10)}
      </span>
    ),
  },
  {
    accessorKey: 'amount',
    header: 'Сумма',
    cell: ({ row }) => (
      <span className="text-sm font-medium text-text-primary">
        {formatCurrency(row.original.amount)}
      </span>
    ),
  },
  {
    accessorKey: 'status',
    header: 'Статус',
    cell: ({ row }) => {
      const status = row.original.status;
      const colors: Record<string, string> = {
        executed: 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300',
        pending: 'bg-warning-100 text-warning-700 dark:bg-warning-900 dark:text-warning-300',
        failed: 'bg-danger-100 text-danger-700 dark:bg-danger-900 dark:text-danger-300',
      };
      return (
        <span className={`px-2 py-1 text-xs font-medium rounded ${colors[status] || ''}`}>
          {status}
        </span>
      );
    },
  },
];
</file>

<file path="apps/portal-investor/src/app/issuances/[id]/components/MetricsCard.tsx">
import { formatCurrency, formatDateTime } from '@/lib/format';

type Props = {
  issuance: {
    totalAmount: number;
    availableAmount: number;
    nominal: number;
    yield: number;
    issueDate: string;
    maturityDate: string;
  };
};

export function MetricsCard({ issuance }: Props) {
  return (
    <div className="bg-surface border border-border rounded-lg p-6">
      <h2 className="text-xl font-semibold text-text-primary mb-4">Основные параметры</h2>
      <div className="grid grid-cols-2 gap-4">
        <Metric label="Общий объём" value={formatCurrency(issuance.totalAmount)} />
        <Metric label="Доступно" value={formatCurrency(issuance.availableAmount)} />
        <Metric label="Номинал" value={formatCurrency(issuance.nominal)} />
        <Metric
          label="Годовая доходность"
          value={`${issuance.yield}%`}
          valueClass="text-success-600"
        />
        <Metric label="Дата выпуска" value={formatDateTime(issuance.issueDate)} />
        <Metric label="Дата погашения" value={formatDateTime(issuance.maturityDate)} />
      </div>
    </div>
  );
}

function Metric({
  label,
  value,
  valueClass,
}: {
  label: string;
  value: string;
  valueClass?: string;
}) {
  return (
    <div>
      <p className="text-sm text-text-secondary mb-1">{label}</p>
      <p className={`text-lg font-semibold text-text-primary ${valueClass || ''}`}>{value}</p>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/issuances/[id]/components/ScheduleSection.tsx">
import { formatCurrency, formatDateTime } from '@/lib/format';

type Props = {
  scheduleJson?: Record<string, number | string>;
};

export function ScheduleSection({ scheduleJson }: Props) {
  if (!scheduleJson) return null;
  return (
    <div className="bg-surface border border-border rounded-lg p-6">
      <h2 className="text-xl font-semibold text-text-primary mb-4">График выплат</h2>
      <div className="space-y-2">
        {Object.entries(scheduleJson).map(([date, amount]) => (
          <div
            key={date}
            className="flex items-center justify-between py-2 border-b border-border last:border-0"
          >
            <span className="text-text-primary">{formatDateTime(date)}</span>
            <span className="font-semibold text-text-primary">
              {formatCurrency(parseFloat(String(amount)))}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/components/steps/AddressStep.tsx">
import { Input } from '@ois/shared-ui';
import { FormData, FormErrors } from '../../types';
import { STEPS } from '../../constants';

type Props = {
  data: FormData;
  errors: FormErrors;
  onChange: (section: keyof FormData, field: any, value: any) => void;
};

export function AddressStep({ data, errors, onChange }: Props) {
  const stepErrors = errors[STEPS[2]] || {};

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-semibold text-text-primary mb-4">Адрес регистрации</h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <Input
          label="Страна *"
          value={data.address.country}
          onChange={e => onChange('address', 'country', e.target.value)}
          required
          error={stepErrors.country}
        />
        <Input
          label="Почтовый индекс"
          value={data.address.postalCode}
          onChange={e => onChange('address', 'postalCode', e.target.value)}
        />
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <Input
          label="Регион *"
          value={data.address.region}
          onChange={e => onChange('address', 'region', e.target.value)}
          required
          error={stepErrors.region}
        />
        <Input
          label="Город *"
          value={data.address.city}
          onChange={e => onChange('address', 'city', e.target.value)}
          required
          error={stepErrors.city}
        />
      </div>
      <Input
        label="Улица *"
        value={data.address.street}
        onChange={e => onChange('address', 'street', e.target.value)}
        required
        error={stepErrors.street}
      />
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Input
          label="Дом *"
          value={data.address.house}
          onChange={e => onChange('address', 'house', e.target.value)}
          required
          error={stepErrors.house}
        />
        <Input
          label="Корпус/строение"
          value={data.address.building}
          onChange={e => onChange('address', 'building', e.target.value)}
        />
        <Input
          label="Квартира"
          value={data.address.apartment}
          onChange={e => onChange('address', 'apartment', e.target.value)}
        />
      </div>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/components/steps/ContactsStep.tsx">
import { Input } from '@ois/shared-ui';
import { FormData, FormErrors } from '../../types';
import { STEPS } from '../../constants';

type Props = {
  data: FormData;
  errors: FormErrors;
  onChange: (section: keyof FormData, field: any, value: any) => void;
  setData: React.Dispatch<React.SetStateAction<FormData>>;
};

export function ContactsStep({ data, errors, onChange, setData }: Props) {
  const stepErrors = errors[STEPS[3]] || {};

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-semibold text-text-primary mb-4">Контактная информация</h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <Input
          label="Телефон *"
          type="tel"
          value={data.contacts.phone}
          onChange={e => onChange('contacts', 'phone', e.target.value)}
          placeholder="+7 (XXX) XXX-XX-XX"
          required
          helpText="Указывайте номер в формате +7"
          error={stepErrors.phone}
        />
        <Input
          label="Дополнительный телефон"
          type="tel"
          value={data.contacts.additionalPhone}
          onChange={e => onChange('contacts', 'additionalPhone', e.target.value)}
        />
      </div>
      <Input
        label="Email *"
        type="email"
        value={data.contacts.email}
        onChange={e => onChange('contacts', 'email', e.target.value)}
        required
        placeholder="ivanov@example.ru"
        error={stepErrors.email}
      />

      <div className="border-t pt-4 mt-6">
        <h4 className="text-md font-semibold text-text-primary mb-4">Дополнительная информация</h4>
        <div className="space-y-3">
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={data.isPep}
              onChange={e => setData(prev => ({ ...prev, isPep: e.target.checked }))}
              className="w-4 h-4"
            />
            <span className="text-sm text-text-primary">
              Являюсь публичным должностным лицом (ПДЛ)
            </span>
          </label>
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={data.isBeneficialOwner}
              onChange={e => setData(prev => ({ ...prev, isBeneficialOwner: e.target.checked }))}
              className="w-4 h-4"
            />
            <span className="text-sm text-text-primary">
              Действую в своих интересах (бенефициарный владелец)
            </span>
          </label>
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={data.consentToProcessing}
              onChange={e => setData(prev => ({ ...prev, consentToProcessing: e.target.checked }))}
              className="w-4 h-4"
            />
            <span className="text-sm text-text-primary">
              Даю согласие на обработку персональных данных *
            </span>
          </label>
          {stepErrors.consent && <p className="text-xs text-danger">{stepErrors.consent}</p>}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/components/steps/IdentityStep.tsx">
import { Input, Select } from '@ois/shared-ui';
import { DOCUMENT_TYPES, STEPS } from '../../constants';
import { FormData, FormErrors } from '../../types';

type Props = {
  data: FormData;
  errors: FormErrors;
  onChange: (section: keyof FormData, field: any, value: any) => void;
};

export function IdentityStep({ data, errors, onChange }: Props) {
  const stepErrors = errors[STEPS[1]] || {};

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-semibold text-text-primary mb-4">
        Документ, удостоверяющий личность
      </h3>
      <Select
        label="Тип документа *"
        options={DOCUMENT_TYPES}
        value={data.identityDocument.type}
        onChange={e => onChange('identityDocument', 'type', e.target.value as any)}
      />
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <Input
          label="Серия *"
          value={data.identityDocument.series}
          placeholder="1234"
          onChange={e => onChange('identityDocument', 'series', e.target.value)}
          required
          error={stepErrors.series}
        />
        <Input
          label="Номер *"
          value={data.identityDocument.number}
          placeholder="123456"
          onChange={e => onChange('identityDocument', 'number', e.target.value)}
          required
          error={stepErrors.number}
        />
      </div>
      <Input
        label="Кем выдан *"
        value={data.identityDocument.issuedBy}
        onChange={e => onChange('identityDocument', 'issuedBy', e.target.value)}
        required
      />
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Input
          label="Дата выдачи *"
          type="date"
          value={data.identityDocument.issuedAt}
          onChange={e => onChange('identityDocument', 'issuedAt', e.target.value)}
          required
          error={stepErrors.issuedAt}
        />
        <Input
          label="Код подразделения"
          value={data.identityDocument.departmentCode}
          placeholder="770-000"
          onChange={e => onChange('identityDocument', 'departmentCode', e.target.value)}
          error={stepErrors.departmentCode}
        />
        <Input
          label="Срок действия"
          type="date"
          value={data.identityDocument.expiresAt}
          onChange={e => onChange('identityDocument', 'expiresAt', e.target.value)}
        />
      </div>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/components/steps/PersonalStep.tsx">
import { useMemo, useState } from 'react';
import { Input, Select } from '@ois/shared-ui';
import { FormData, FormErrors } from '../../types';
import { STEPS } from '../../constants';
import { COUNTRIES } from '../../countries';

type Props = {
  data: FormData;
  errors: FormErrors;
  onChange: (section: keyof FormData, field: any, value: any) => void;
  setData: React.Dispatch<React.SetStateAction<FormData>>;
};

export function PersonalStep({ data, errors, onChange, setData }: Props) {
  const stepErrors = errors[STEPS[0]] || {};
  const [countrySearch, setCountrySearch] = useState('');

  const filteredCountries = useMemo(() => {
    const query = countrySearch.trim().toLowerCase();
    if (!query) return COUNTRIES;
    return COUNTRIES.filter(c => c.toLowerCase().includes(query));
  }, [countrySearch]);

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-semibold text-text-primary mb-4">Персональные данные</h3>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Input
          label="Фамилия *"
          value={data.personalData.lastName}
          placeholder="Иванов"
          onChange={e => onChange('personalData', 'lastName', e.target.value)}
          required
          error={stepErrors.lastName}
        />
        <Input
          label="Имя *"
          value={data.personalData.firstName}
          placeholder="Иван"
          onChange={e => onChange('personalData', 'firstName', e.target.value)}
          required
          error={stepErrors.firstName}
        />
        <Input
          label="Отчество"
          value={data.personalData.middleName}
          onChange={e => onChange('personalData', 'middleName', e.target.value)}
        />
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <Input
          label="Дата рождения *"
          type="date"
          value={data.personalData.birthDate}
          onChange={e => onChange('personalData', 'birthDate', e.target.value)}
          required
          error={stepErrors.birthDate}
        />
        <Input
          label="Место рождения"
          value={data.personalData.birthPlace}
          onChange={e => onChange('personalData', 'birthPlace', e.target.value)}
        />
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <Input
          label="ИНН"
          value={data.inn}
          onChange={e => setData(prev => ({ ...prev, inn: e.target.value }))}
          maxLength={12}
          placeholder="123456789012"
          helpText="12 цифр для физ. лица"
        />
        <Input
          label="СНИЛС"
          value={data.snils}
          onChange={e => setData(prev => ({ ...prev, snils: e.target.value }))}
          placeholder="123-456-789 00"
        />
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="grid grid-cols-1 md:grid-cols-[2fr,auto] gap-4 items-end">
          <div className="space-y-2">
            <Input
              label="Поиск страны"
              placeholder="Введите страну"
              value={countrySearch}
              onChange={e => setCountrySearch(e.target.value)}
            />
            <Select
              label="Гражданство"
              value={data.citizenship}
              onChange={e => setData(prev => ({ ...prev, citizenship: e.target.value }))}
              options={filteredCountries.map(c => ({ value: c, label: c }))}
              placeholder="Выберите страну"
            />
          </div>
          <label className="flex items-center gap-2 cursor-pointer pb-1">
            <input
              type="checkbox"
              checked={data.isResident}
              onChange={e => setData(prev => ({ ...prev, isResident: e.target.checked }))}
              className="w-4 h-4"
            />
            <span className="text-sm text-text-primary">Резидент РФ</span>
          </label>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/components/KycStatusCard.tsx">
import { Badge, Card, CardContent } from '@ois/shared-ui';
import { AlertCircle, CheckCircle, Clock } from 'lucide-react';

type Props = {
  kycStatus?: string;
  rejectionReason?: string;
  updatedAt?: string;
};

const statusBadge = (status?: string) => {
  switch (status) {
    case 'pass':
    case 'approved':
      return {
        intent: 'success' as const,
        text: 'Подтвержден',
        icon: <CheckCircle className="h-5 w-5 text-green-500" />,
      };
    case 'rejected':
    case 'fail':
      return {
        intent: 'danger' as const,
        text: 'Отказано',
        icon: <AlertCircle className="h-5 w-5 text-red-500" />,
      };
    case 'pending':
    case 'review':
      return {
        intent: 'warning' as const,
        text: 'На проверке',
        icon: <Clock className="h-5 w-5 text-yellow-500" />,
      };
    case 'not_started':
      return {
        intent: 'neutral' as const,
        text: 'Не начато',
        icon: <AlertCircle className="h-5 w-5 text-text-tertiary" />,
      };
    default:
      return {
        intent: 'danger' as const,
        text: 'Не подтвержден',
        icon: <AlertCircle className="h-5 w-5 text-red-500" />,
      };
  }
};

export function KycStatusCard({ kycStatus, rejectionReason, updatedAt }: Props) {
  const { intent, text, icon } = statusBadge(kycStatus);

  return (
    <Card className="mb-6">
      <CardContent className="p-6">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            {icon}
            <div>
              <p className="text-sm text-text-secondary">Статус KYC</p>
              <Badge intent={intent}>{text}</Badge>
              {kycStatus &&
                (kycStatus === 'rejected' || kycStatus === 'fail') &&
                rejectionReason && (
                  <p className="text-sm text-text-secondary mt-2">Причина: {rejectionReason}</p>
                )}
            </div>
          </div>
          {(kycStatus === 'pass' || kycStatus === 'approved') && (
            <p className="text-sm text-text-tertiary">
              Последнее обновление:{' '}
              {updatedAt
                ? new Date(updatedAt).toLocaleDateString('ru-RU')
                : new Date().toLocaleDateString('ru-RU')}
            </p>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/portal-investor/src/app/layout.tsx">
import type { Metadata } from 'next';
import './globals.css';
import { Providers } from './providers';
import { ErrorBoundary } from '@ois/shared-ui';
import { Toaster } from 'sonner';

export const metadata: Metadata = {
  title: 'OIS Portal - Investor',
  description: 'Portal for CFA investors',
};

// Используем any из-за конфликтов типов React между рабочими пространствами
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export default function RootLayout({ children }: { children: any }) {
  return (
    <html lang="ru">
      <body className="font-sans">
        <Providers>
          <ErrorBoundary>
            {children}
            <Toaster />
          </ErrorBoundary>
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="apps/portal-investor/src/lib/mocks.ts">
const now = new Date();
const daysAgo = (d: number) => {
  const date = new Date(now);
  date.setDate(date.getDate() - d);
  return date.toISOString();
};

export const mockCatalog = {
  total: 3,
  items: [
    {
      id: 'mock-issuance-1',
      assetName: 'Газпром 2026',
      issuerName: 'Газпром',
      status: 'open',
      yield: 12.5,
      availableAmount: 5_000_000,
      totalAmount: 10_000_000,
      nominal: 1_000,
      maturityDate: daysAgo(-365),
      issueDate: daysAgo(90),
      scheduleJson: {
        [daysAgo(-30)]: '150000',
        [daysAgo(60)]: '150000',
      },
    },
    {
      id: 'mock-issuance-2',
      assetName: 'Лукойл 2027',
      issuerName: 'Лукойл',
      status: 'open',
      yield: 11.2,
      availableAmount: 2_500_000,
      totalAmount: 7_000_000,
      nominal: 1_000,
      maturityDate: daysAgo(-730),
      issueDate: daysAgo(120),
    },
    {
      id: 'mock-issuance-3',
      assetName: 'Сбер 2025',
      issuerName: 'Сбербанк',
      status: 'closed',
      yield: 9.8,
      availableAmount: 0,
      totalAmount: 5_000_000,
      nominal: 1_000,
      maturityDate: daysAgo(-180),
      issueDate: daysAgo(400),
    },
  ],
};

export const mockIssuanceDetail = (id: string) => {
  const base = mockCatalog.items.find(i => i.id === id) || mockCatalog.items[0];
  return {
    ...base,
    documents: [
      {
        id: 'doc-1',
        title: 'Инвестиционный меморандум',
        type: 'terms',
        url: '#',
        publishedAt: daysAgo(15),
      },
      {
        id: 'doc-2',
        title: 'Отчёт эмитента Q1',
        type: 'report',
        url: '#',
        publishedAt: daysAgo(45),
      },
    ],
  };
};

export const mockWallet = {
  balance: 1_250_000,
  blocked: 150_000,
  holdings: [
    { assetId: 'mock-issuance-1', assetName: 'Газпром 2026', amount: 1200 },
    { assetId: 'mock-issuance-2', assetName: 'Лукойл 2027', amount: 800 },
  ],
};

const baseTransactions = [
  {
    id: 'tx-1',
    createdAt: daysAgo(3),
    type: 'transfer' as const,
    issuanceCode: 'ГАЗП26',
    issuanceId: 'mock-issuance-1',
    amount: 200_000,
    status: 'confirmed' as const,
    dltTxHash: '0xmock123',
  },
  {
    id: 'tx-2',
    createdAt: daysAgo(10),
    type: 'redeem' as const,
    issuanceCode: 'СБЕР25',
    issuanceId: 'mock-issuance-3',
    amount: 50_000,
    status: 'pending' as const,
    dltTxHash: '0xmock456',
  },
  {
    id: 'tx-3',
    createdAt: daysAgo(15),
    type: 'issue' as const,
    issuanceCode: 'ЛУК27',
    issuanceId: 'mock-issuance-2',
    amount: 120_000,
    status: 'confirmed' as const,
    dltTxHash: '0xmock789',
  },
  {
    id: 'tx-4',
    createdAt: daysAgo(25),
    type: 'transfer' as const,
    issuanceCode: 'СБЕР25',
    issuanceId: 'mock-issuance-3',
    amount: 75_000,
    status: 'failed' as const,
    dltTxHash: '0xmockabc',
  },
  {
    id: 'tx-5',
    createdAt: daysAgo(40),
    type: 'redeem' as const,
    issuanceCode: 'ГАЗП26',
    issuanceId: 'mock-issuance-1',
    amount: 30_000,
    status: 'confirmed' as const,
    dltTxHash: '0xmockdef',
  },
];

export const mockTransactions = (type?: string, limit = 10, offset = 0) => {
  const filtered = type ? baseTransactions.filter(t => t.type === type) : baseTransactions;
  const items = filtered.slice(offset, offset + limit);
  return { items, total: filtered.length };
};

const basePayouts = [
  {
    id: 'payout-1',
    executedAt: daysAgo(7),
    issuanceId: 'mock-issuance-1',
    investorId: 'mock-investor',
    batchId: 'batch-1',
    amount: 12_000,
    status: 'executed' as const,
  },
  {
    id: 'payout-2',
    executedAt: daysAgo(40),
    issuanceId: 'mock-issuance-2',
    investorId: 'mock-investor',
    batchId: 'batch-2',
    amount: 8_500,
    status: 'pending' as const,
  },
  {
    id: 'payout-3',
    executedAt: daysAgo(65),
    issuanceId: 'mock-issuance-3',
    investorId: 'mock-investor',
    batchId: 'batch-3',
    amount: 5_750,
    status: 'failed' as const,
  },
  {
    id: 'payout-4',
    executedAt: daysAgo(90),
    issuanceId: 'mock-issuance-2',
    investorId: 'mock-investor',
    batchId: 'batch-4',
    amount: 14_200,
    status: 'executed' as const,
  },
];

export const mockPayouts = (limit = 10, offset = 0) => {
  const items = basePayouts.slice(offset, offset + limit);
  return {
    items,
    total: basePayouts.length,
    totalAmount: basePayouts.reduce((sum, p) => sum + p.amount, 0),
  };
};

export const mockCompliance = {
  kyc: 'pass',
  qualificationTier: 'qualified',
  qualificationLimit: 2_000_000,
  qualificationUsed: 500_000,
  updatedAt: now.toISOString(),
};

export const mockOrder = (params: { investorId: string; issuanceId: string; amount: number }) => ({
  id: `mock-order-${Date.now()}`,
  ...params,
  status: 'created',
  createdAt: now.toISOString(),
  idempotencyKey: crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}`,
});
</file>

<file path="apps/portal-investor/src/lib/navigation.tsx">
import { LayoutDashboard, ShoppingCart, Clock, User, Wallet, FileCheck } from 'lucide-react';

export const investorNavItems = [
  { label: 'Портфель', href: '/portfolio', icon: <Wallet className="h-4 w-4" /> },
  { label: 'Каталог', href: '/catalog', icon: <LayoutDashboard className="h-4 w-4" /> },
  { label: 'Заявки', href: '/orders/new', icon: <ShoppingCart className="h-4 w-4" /> },
  { label: 'История', href: '/history', icon: <Clock className="h-4 w-4" /> },
  { label: 'KYC', href: '/kyc', icon: <FileCheck className="h-4 w-4" /> },
  { label: 'Профиль', href: '/profile', icon: <User className="h-4 w-4" /> },
];
</file>

<file path="apps/portal-issuer/src/app/issuances/[id]/hooks/useIssuanceDetail.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { useRouter } from 'next/navigation';
import { signOut, useSession } from 'next-auth/react';
import { useEffect } from 'react';
import { toast } from 'sonner';
import {
  getIssuanceById,
  publishIssuance as mockPublishIssuance,
  closeIssuance as mockCloseIssuance,
  updateIssuanceSchedule,
  type Issuance,
  type PayoutScheduleItem,
} from '@/lib/mocks/issuances';

export function useIssuanceDetail(id: string) {
  const { data: session, status } = useSession();
  const router = useRouter();
  const qc = useQueryClient();

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data, isLoading, isError } = useQuery({
    queryKey: ['issuance', id],
    queryFn: () => getIssuanceById(id),
    enabled: !!id && status === 'authenticated',
    retry: 0,
  });

  const publishMutation = useMutation({
    mutationFn: async () => mockPublishIssuance(id),
    onSuccess: (updated) => {
      if (updated) {
        qc.setQueryData<Issuance | undefined>(['issuance', id], updated);
      }
      toast.success('Выпуск опубликован');
    },
    onError: () => toast.error('Не удалось опубликовать выпуск'),
  });

  const closeMutation = useMutation({
    mutationFn: async () => mockCloseIssuance(id),
    onSuccess: (updated) => {
      if (updated) {
        qc.setQueryData<Issuance | undefined>(['issuance', id], updated);
      }
      toast.success('Выпуск закрыт');
    },
    onError: () => toast.error('Не удалось закрыть выпуск'),
  });

  const updateScheduleMutation = useMutation({
    mutationFn: async (payload: { issuanceId: string; scheduleJson: PayoutScheduleItem[] }) =>
      updateIssuanceSchedule(payload.issuanceId, payload.scheduleJson),
    onSuccess: (updated) => {
      if (updated) {
        qc.setQueryData<Issuance | undefined>(['issuance', id], updated);
      }
      toast.success('Расписание обновлено');
    },
    onError: () => toast.error('Не удалось обновить расписание'),
  });

  const handleSignOut = () => signOut({ callbackUrl: '/auth/signin' });

  return {
    session,
    status,
    data,
    isLoading,
    isError,
    publish: publishMutation.mutate,
    close: closeMutation.mutate,
    updateSchedule: updateScheduleMutation.mutate,
    isPublishing: publishMutation.isPending,
    isClosing: closeMutation.isPending,
    isUpdatingSchedule: updateScheduleMutation.isPending,
    handleSignOut,
  };
}
</file>

<file path="apps/portal-issuer/src/app/reports/hooks/useReportsData.ts">
import { useQuery } from '@tanstack/react-query';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { signOut, useSession } from 'next-auth/react';
import { getIssuerReports, getIssuerPayoutsReport } from '@/lib/api/issuances';
import { getMockIssuerIssuancesReport, getMockIssuerPayoutsReport, MOCK_ISSUER_ID } from '@/lib/mocks/reports';

type DateRange = { from: string; to: string };

export function useReportsData(activeTab: 'issuances' | 'payouts', granularity: 'day' | 'week' | 'month' | 'year') {
  const router = useRouter();
  const { data: session, status } = useSession();
  const [dateRange, setDateRange] = useState<DateRange>(() => ({
    from: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    to: new Date().toISOString().split('T')[0],
  }));

  useEffect(() => {
    if (status === 'unauthenticated') router.push('/auth/signin');
  }, [status, router]);

  type IssuerUser = { issuerId?: string; id?: string | null };
  const issuerUser = session?.user as IssuerUser | undefined;
  const issuerId = issuerUser?.issuerId || issuerUser?.id || MOCK_ISSUER_ID;

 const issuancesQuery = useQuery({
    queryKey: ['issuer-issuances-report', issuerId, dateRange.from, dateRange.to],
    queryFn: async () => getIssuerReports(issuerId, { from: dateRange.from, to: dateRange.to }),
    enabled: status === 'authenticated' && activeTab === 'issuances' && !!issuerId,
    retry: 0,
  });

  const payoutsQuery = useQuery({
    queryKey: ['issuer-payouts-report', issuerId, dateRange.from, dateRange.to, granularity],
    queryFn: async () => getIssuerPayoutsReport({ issuerId, from: dateRange.from, to: dateRange.to, granularity }),
    enabled: status === 'authenticated' && activeTab === 'payouts' && !!issuerId,
    retry: 0,
  });

  const mockIssuances = getMockIssuerIssuancesReport(issuerId, dateRange);
  const mockPayouts = getMockIssuerPayoutsReport(issuerId, { from: dateRange.from, to: dateRange.to, granularity });

  const handleLogout = () => signOut({ callbackUrl: '/auth/signin' });

  return {
    status,
    issuerId,
    dateRange,
    setDateRange,
    issuancesQuery,
    payoutsQuery,
    mockIssuances,
    mockPayouts,
    handleLogout,
  };
}
</file>

<file path="apps/portal-issuer/src/lib/api/issuances.ts">
import { apiClient } from '@/lib/api-client';
import type { IssuerIssuancesReportResponse, IssuerPayoutsReportResponse } from '@ois/api-client';
import {
  getMockIssuerIssuancesReport,
  getMockIssuerPayoutsReport,
  MOCK_ISSUER_ID,
} from '../mocks/reports';

export type IssuerReportsParams = {
  from?: string;
  to?: string;
};

export async function getIssuerReports(
  issuerId: string,
  params?: IssuerReportsParams
): Promise<IssuerIssuancesReportResponse> {
  const fallbackIssuerId = issuerId || MOCK_ISSUER_ID;
  try {
    const { data } = await apiClient.getIssuerIssuancesReport({
      issuerId: fallbackIssuerId,
      ...(params?.from ? { from: params.from } : {}),
      ...(params?.to ? { to: params.to } : {}),
    });

    if (!data?.items?.length) {
      return getMockIssuerIssuancesReport(fallbackIssuerId, params);
    }

    return data;
  } catch (_error) {
    return getMockIssuerIssuancesReport(fallbackIssuerId, params);
  }
}

export type PayoutScheduleItem = {
  id: string;
  date: string;
  amount: number;
  status: 'planned' | 'paid' | 'cancelled' | string;
  note?: string;
};

export function extractScheduleItems(raw: unknown): PayoutScheduleItem[] {
  if (!raw) return [];

  const getList = (): unknown[] => {
    if (Array.isArray(raw)) {
      return raw;
    }

    if (typeof raw === 'object') {
      const obj = raw as Record<string, unknown>;
      if (Array.isArray(obj.items)) {
        return obj.items;
      }
      return Object.values(obj);
    }

    return [];
  };

  const normalized = getList()
    .filter(item => typeof item === 'object' && item !== null)
    .map((item, idx) => {
      const entry = item as Record<string, unknown>;
      return {
        id: String(entry.id ?? entry.slug ?? idx),
        date: typeof entry.date === 'string' ? entry.date : '',
        amount: typeof entry.amount === 'number' ? entry.amount : Number(entry.amount ?? 0),
        status: typeof entry.status === 'string' ? entry.status : 'planned',
        note: typeof entry.note === 'string' ? entry.note : undefined,
      };
    })
    .filter(item => Boolean(item.date));

  return normalized;
}

export async function getIssuerPayoutsReport(params: {
  issuerId: string;
  from: string;
  to: string;
  granularity: IssuerPayoutsReportResponse['granularity'];
}): Promise<IssuerPayoutsReportResponse> {
  const fallbackIssuerId = params.issuerId || MOCK_ISSUER_ID;
  try {
    const { data } = await apiClient.getIssuerPayoutsReport({
      ...params,
      issuerId: fallbackIssuerId,
    });
    if (!data?.items?.length) {
      return getMockIssuerPayoutsReport(fallbackIssuerId, params);
    }
    return data;
  } catch (_error) {
    return getMockIssuerPayoutsReport(fallbackIssuerId, params);
  }
}
</file>

<file path="apps/portal-issuer/src/lib/mocks/reports.ts">
import type { IssuerIssuancesReportResponse, IssuerPayoutsReportResponse } from '@ois/api-client';
import { mockIssuances, MOCK_ISSUER_ID } from './issuances';

// Re-export для использования в других модулях
export { MOCK_ISSUER_ID };

function clamp(value: number, min: number, max: number) {
  return Math.min(Math.max(value, min), max);
}

function deterministicNumber(seed: string, min: number, max: number) {
  const hash = Array.from(seed).reduce((acc, char) => acc + char.charCodeAt(0), 0);
  const normalized = (hash % 1000) / 1000;
  const value = min + normalized * (max - min);
  return Math.round(value);
}

function withinRange(date: string, from?: string, to?: string) {
  const ts = new Date(date).getTime();
  if (Number.isNaN(ts)) return false;
  if (from && ts < new Date(from).getTime()) return false;
  if (to && ts > new Date(to).getTime()) return false;
  return true;
}

export function getMockIssuerIssuancesReport(
  issuerId: string,
  params?: { from?: string; to?: string }
): IssuerIssuancesReportResponse {
  const list = mockIssuances.filter(i => i.issuerId === issuerId || issuerId === MOCK_ISSUER_ID);

  const items = list
    .filter(item => {
      if (!params?.from && !params?.to) return true;
      return withinRange(item.issueDate, params?.from, params?.to);
    })
    .map(item => {
      const soldAmount = Math.max(0, item.totalAmount - item.availableAmount);
      const investorsCount = clamp(deterministicNumber(item.id, 18, 120), 5, 200);

      return {
        issuanceId: item.id,
        assetCode: item.assetCode,
        assetName: item.assetName,
        totalAmount: item.totalAmount,
        soldAmount,
        investorsCount,
        status: item.status,
        issueDate: item.issueDate,
        maturityDate: item.maturityDate,
        publishedAt: item.publishedAt ?? undefined,
      };
    });

  const summary = items.reduce(
    (acc, item) => {
      acc.totalIssuances += 1;
      acc.totalAmount += item.totalAmount;
      acc.totalSold += item.soldAmount;
      acc.totalInvestors += item.investorsCount;
      return acc;
    },
    { totalIssuances: 0, totalAmount: 0, totalSold: 0, totalInvestors: 0 }
  );

  return {
    issuerId,
    period: params,
    items,
    summary,
  };
}

function formatPeriodKey(date: Date, granularity: IssuerPayoutsReportResponse['granularity']) {
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth() + 1;
  const day = date.getUTCDate();

  if (granularity === 'year') return `${year}`;
  if (granularity === 'month') return `${year}-${String(month).padStart(2, '0')}`;
  if (granularity === 'week') {
    const firstDayOfYear = new Date(Date.UTC(year, 0, 1));
    const pastDaysOfYear = (date.getTime() - firstDayOfYear.getTime()) / 86400000;
    const week = Math.ceil((pastDaysOfYear + firstDayOfYear.getUTCDay() + 1) / 7);
    return `${year}-W${String(week).padStart(2, '0')}`;
  }
  return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
}

export function getMockIssuerPayoutsReport(
  issuerId: string,
  params: {
    from: string;
    to: string;
    granularity: IssuerPayoutsReportResponse['granularity'];
  }
): IssuerPayoutsReportResponse {
  const { from, to, granularity } = params;
  const list = mockIssuances.filter(i => i.issuerId === issuerId || issuerId === MOCK_ISSUER_ID);

  const buckets = new Map<
    string,
    { totalAmount: number; payoutCount: number; investorsCount: number }
  >();

  list.forEach(issuance => {
    const units = issuance.nominal > 0 ? issuance.totalAmount / issuance.nominal : 0;
    issuance.scheduleJson.forEach(item => {
      if (!withinRange(item.date, from, to)) return;
      const date = new Date(item.date);
      const key = formatPeriodKey(date, granularity);
      const existing = buckets.get(key) || { totalAmount: 0, payoutCount: 0, investorsCount: 0 };
      existing.totalAmount += item.amount * units;
      existing.payoutCount += 1;
      existing.investorsCount = Math.max(
        existing.investorsCount,
        clamp(deterministicNumber(`${issuance.id}-${key}`, 8, 64), 5, 200)
      );
      buckets.set(key, existing);
    });
  });

  const items = Array.from(buckets.entries())
    .map(([period, value]) => ({
      period,
      totalAmount: Math.round(value.totalAmount),
      payoutCount: value.payoutCount,
      investorsCount: value.investorsCount,
    }))
    .sort((a, b) => a.period.localeCompare(b.period));

  const summary = items.reduce(
    (acc, item) => {
      acc.totalAmount += item.totalAmount;
      acc.totalPayouts += item.payoutCount;
      acc.totalInvestors += item.investorsCount;
      return acc;
    },
    { totalAmount: 0, totalPayouts: 0, totalInvestors: 0 }
  );

  return {
    issuerId,
    period: { from, to },
    granularity,
    items,
    summary,
  };
}
</file>

<file path="apps/portal-issuer/src/lib/auth.ts">
import { NextAuthOptions, DefaultSession } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import KeycloakProvider from 'next-auth/providers/keycloak';
import { mockIssuerProfile } from './mocks/profile';

const issuerBase =
  process.env.KEYCLOAK_INTERNAL_URL ||
  process.env.NEXT_PUBLIC_KEYCLOAK_URL ||
  'http://localhost:8080';

// Secret должен быть задан через переменную окружения
const getSecret = (): string => {
  const secret = process.env.NEXTAUTH_SECRET;
  if (!secret && process.env.NODE_ENV === 'production') {
    throw new Error('NEXTAUTH_SECRET is required in production');
  }
  return secret || 'dev-nextauth-secret-please-change';
};

export const authOptions: NextAuthOptions = {
  secret: getSecret(),
  session: { strategy: 'jwt' },
  providers: [
    CredentialsProvider({
      name: 'Demo Issuer',
      credentials: {
        email: { label: 'Email', type: 'email', value: 'issuer@demo.local' },
        password: { label: 'Password', type: 'password', value: 'demo123' },
      },
      async authorize(credentials) {
        if (credentials?.email === 'issuer@demo.local' && credentials?.password === 'demo123') {
          return {
            id: mockIssuerProfile.id,
            name: mockIssuerProfile.companyName,
            email: credentials.email,
            roles: ['issuer'],
            issuerId: mockIssuerProfile.id,
            accessToken: 'mock-access-token',
          } as DefaultSession['user'];
        }
        return null;
      },
    }),
    KeycloakProvider({
      clientId: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'portal-issuer',
      clientSecret: process.env.KEYCLOAK_CLIENT_SECRET || '',
      issuer: `${issuerBase}/realms/${process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'ois'}`,
      authorization: {
        params: {
          scope: 'openid profile email roles',
        },
      },
    }),
  ],
  debug: process.env.NODE_ENV === 'development',
  logger: {
    error: (code, metadata) => {
      if (process.env.NODE_ENV === 'development') {
        // eslint-disable-next-line no-console
        console.error('NextAuth error', code, metadata);
      }
    },
    warn: code => {
      if (process.env.NODE_ENV === 'development') {
        // eslint-disable-next-line no-console
        console.warn('NextAuth warn', code);
      }
    },
    debug: (code, metadata) => {
      if (process.env.NODE_ENV === 'development') {
        // eslint-disable-next-line no-console
        console.debug('NextAuth debug', code, metadata);
      }
    },
  },
  callbacks: {
    async jwt({ token, account, user }) {
      type IssuerUser = DefaultSession['user'] & {
        roles?: string[];
        issuerId?: string;
        accessToken?: string;
      };

      if (account?.provider === 'credentials' && user) {
        const issuerUser = user as IssuerUser;
        token.accessToken = issuerUser.accessToken || 'mock-access-token';
        token.roles = issuerUser.roles?.length ? issuerUser.roles : ['issuer'];
        token.issuerId = issuerUser.issuerId || mockIssuerProfile.id;
        return token;
      }

      if (account?.access_token && typeof account.access_token === 'string') {
        token.accessToken = account.access_token;
        try {
          const decoded = JSON.parse(
            Buffer.from(account.access_token.split('.')[1], 'base64').toString()
          );
          const parsedRoles = decoded?.realm_access?.roles;
          token.roles =
            Array.isArray(parsedRoles) && parsedRoles.length > 0 ? parsedRoles : ['issuer'];
          token.issuerId = decoded?.sub || mockIssuerProfile.id;
        } catch (_e) {
          token.roles = token.roles && token.roles.length > 0 ? token.roles : ['issuer'];
          token.issuerId = token.issuerId || mockIssuerProfile.id;
        }
      } else {
        token.roles = token.roles && token.roles.length > 0 ? token.roles : ['issuer'];
        token.issuerId = token.issuerId || mockIssuerProfile.id;
      }
      if (!token.roles || (Array.isArray(token.roles) && token.roles.length === 0)) {
        token.roles = ['issuer'];
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        const typedToken = token as { roles?: string[]; issuerId?: string; accessToken?: string };
        session.user.roles = (
          typedToken.roles && typedToken.roles.length > 0 ? typedToken.roles : ['issuer']
        ) as string[];
        (session.user as { issuerId?: string }).issuerId =
          typedToken.issuerId || mockIssuerProfile.id;
        session.accessToken = token.accessToken as string;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
};
</file>

<file path="apps/portal-issuer/src/middleware.ts">
import { withAuth } from 'next-auth/middleware';
import { NextResponse } from 'next/server';

export default withAuth({
  callbacks: {
    authorized: ({ token }) => {
      // Проверяем наличие токена
      if (!token) return false;

      // Проверяем наличие роли issuer
      const roles = (token.roles as string[]) || [];
      return roles.includes('issuer');
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
});

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/issuances/:path*',
    '/reports/:path*',
    '/payouts/:path*',
    '/profile/:path*',
  ],
};
</file>

<file path="apps/portal-issuer/package.json">
{
  "name": "@ois/portal-issuer",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3001",
    "build": "next build",
    "start": "next start -p 3001",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "format:check": "prettier --check \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    "test:unit": "vitest run",
    "test:watch": "vitest watch",
    "test:coverage": "vitest run --coverage",
    "prepare": "cd ../.. && husky apps/.husky || true"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "prettier --write",
      "eslint --fix --max-warnings=100"
    ],
    "*.{json,css,md}": [
      "prettier --write"
    ]
  },
  "dependencies": {
    "@ois/api-client": "file:../../packages/sdks/ts",
    "@ois/shared-ui": "file:../shared-ui",
    "@tanstack/react-query": "^5.17.0",
    "@tanstack/react-table": "^8.21.3",
    "axios": "^1.6.0",
    "clsx": "^2.1.0",
    "date-fns": "^3.0.0",
    "lucide-react": "^0.303.0",
    "next": "15.0.0",
    "next-auth": "^4.24.5",
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "recharts": "^2.10.3",
    "sonner": "^1.3.1",
    "tailwind-merge": "^2.2.0",
    "web-vitals": "^4.2.0",
    "xlsx": "^0.18.5",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@types/xlsx": "^0.0.35",
    "@vitejs/plugin-react": "^5.1.1",
    "@vitest/coverage-v8": "^4.0.13",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.56.0",
    "eslint-config-next": "15.0.0",
    "eslint-config-prettier": "^9.1.0",
    "husky": "^9.1.0",
    "jsdom": "^27.0.1",
    "lint-staged": "^15.2.0",
    "msw": "^2.12.2",
    "postcss": "^8.4.32",
    "prettier": "^3.2.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="packages/contracts/openapi-compliance.yaml">
openapi: 3.1.0
info:
  title: Compliance Service API
  version: 1.1.0
  description: |
    Compliance service для KYC, qualification и complaints.

    ## Нормативная база
    - **115-ФЗ** — Противодействие легализации доходов (KYC/AML)
    - **39-ФЗ** — О рынке ценных бумаг (квалифицированные инвесторы)
    - **Указание ЦБ 3629-У** — Признание квалифицированных инвесторов
    - **259-ФЗ** — О цифровых финансовых активах
servers:
  - url: http://localhost:5008
    description: Development

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
  
  /v1/compliance/kyc/check:
    post:
      summary: Check KYC status for investor
      operationId: checkKyc
      tags:
        - Compliance
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycCheckRequest'
      responses:
        '200':
          description: KYC check result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/qualification/evaluate:
    post:
      summary: Evaluate investor qualification tier
      operationId: evaluateQualification
      tags:
        - Compliance
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QualificationEvaluateRequest'
      responses:
        '200':
          description: Qualification evaluation result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/investors/{id}/status:
    get:
      summary: Get compliance status for investor
      operationId: getInvestorStatus
      tags:
        - Compliance
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Investor compliance status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InvestorStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/compliance/kyc/investors/{id}/approve:
    post:
      summary: Approve KYC for investor
      operationId: approveKyc
      tags:
        - KYC
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: KYC updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'

  /v1/compliance/kyc/investors/{id}/reject:
    post:
      summary: Reject KYC for investor
      operationId: rejectKyc
      tags:
        - KYC
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: KYC updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'

  /v1/kyc/tasks:
    post:
      summary: Create KYC manual review task
      operationId: createKycTask
      tags:
        - KYC Tasks
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [investorId]
              properties:
                investorId:
                  type: string
                  format: uuid
                reason:
                  type: string
                  nullable: true
      responses:
        '201':
          description: Task created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
    get:
      summary: List KYC tasks
      operationId: listKycTasks
      tags:
        - KYC Tasks
      parameters:
        - name: status
          in: query
          schema:
            type: string
            enum: [open, approved, rejected]
      responses:
        '200':
          description: List of tasks
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycTask'

  /v1/kyc/tasks/{id}/approve:
    post:
      summary: Approve KYC task and investor
      operationId: approveKycTask
      tags:
        - KYC Tasks
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Task approved
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/kyc/tasks/{id}/reject:
    post:
      summary: Reject KYC task and investor
      operationId: rejectKycTask
      tags:
        - KYC Tasks
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Task rejected
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/complaints:
    post:
      summary: Create complaint
      operationId: createComplaint
      tags:
        - Complaints
      parameters:
        - name: Idempotency-Key
          in: header
          required: false
          schema:
            type: string
            format: uuid
          description: Idempotency key for duplicate prevention
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateComplaintRequest'
      responses:
        '201':
          description: Complaint created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/complaints/{id}:
    get:
      summary: Get complaint by ID
      operationId: getComplaint
      tags:
        - Complaints
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Complaint details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/complaints/{id}/reply:
    post:
      summary: Reply to complaint
      operationId: replyToComplaint
      tags:
        - Complaints
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ComplaintReplyRequest'
      responses:
        '200':
          description: Reply added
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/complaints/{id}/resolve:
    post:
      summary: Resolve complaint
      operationId: resolveComplaint
      tags:
        - Complaints
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: false
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ComplaintResolveRequest'
      responses:
        '200':
          description: Complaint resolved
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  # ============================================
  # KYC Documents
  # ============================================
  /v1/kyc/documents:
    post:
      summary: Upload KYC document
      operationId: uploadKycDocument
      tags:
        - KYC Documents
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              $ref: '#/components/schemas/KycDocumentUploadRequest'
      responses:
        '201':
          description: Document uploaded
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycDocument'
        '400':
          $ref: '#/components/responses/BadRequest'

  /v1/kyc/documents/{id}:
    get:
      summary: Get KYC document metadata
      operationId: getKycDocument
      tags:
        - KYC Documents
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Document metadata
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycDocument'
        '404':
          $ref: '#/components/responses/NotFound'
    delete:
      summary: Delete KYC document
      operationId: deleteKycDocument
      tags:
        - KYC Documents
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '204':
          description: Document deleted
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/kyc/documents/{id}/download:
    get:
      summary: Download KYC document file
      operationId: downloadKycDocument
      tags:
        - KYC Documents
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Document file
          content:
            application/octet-stream:
              schema:
                type: string
                format: binary
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/kyc/investors/{investorId}/documents:
    get:
      summary: List KYC documents for investor
      operationId: listKycDocuments
      tags:
        - KYC Documents
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: List of documents
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycDocument'

  # ============================================
  # Qualification Tasks
  # ============================================
  /v1/qualification/tasks:
    get:
      summary: List qualification tasks
      operationId: listQualificationTasks
      tags:
        - Qualification Tasks
      parameters:
        - name: status
          in: query
          schema:
            type: string
            enum: [open, approved, rejected]
      responses:
        '200':
          description: List of qualification tasks
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/QualificationTask'
    post:
      summary: Create qualification task (submit application)
      operationId: createQualificationTask
      tags:
        - Qualification Tasks
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateQualificationTaskRequest'
      responses:
        '201':
          description: Task created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationTask'
        '400':
          $ref: '#/components/responses/BadRequest'

  /v1/qualification/tasks/{id}:
    get:
      summary: Get qualification task by ID
      operationId: getQualificationTask
      tags:
        - Qualification Tasks
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Task details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationTask'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/qualification/tasks/{id}/approve:
    post:
      summary: Approve qualification task
      operationId: approveQualificationTask
      tags:
        - Qualification Tasks
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: false
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QualificationDecisionRequest'
      responses:
        '200':
          description: Task approved
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationTask'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/qualification/tasks/{id}/reject:
    post:
      summary: Reject qualification task
      operationId: rejectQualificationTask
      tags:
        - Qualification Tasks
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QualificationDecisionRequest'
      responses:
        '200':
          description: Task rejected
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationTask'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    # ============================================
    # KYC Schemas (согласно 115-ФЗ)
    # ============================================
    KycCheckRequest:
      type: object
      description: |
        Заявка на прохождение KYC согласно требованиям 115-ФЗ.
        Для физических лиц — резидентов РФ.
      required:
        - investorId
        - personalData
        - identityDocument
        - address
        - contacts
      properties:
        investorId:
          type: string
          format: uuid
          description: ID инвестора в системе
        personalData:
          $ref: '#/components/schemas/PersonalData'
        identityDocument:
          $ref: '#/components/schemas/IdentityDocument'
        address:
          $ref: '#/components/schemas/Address'
        contacts:
          $ref: '#/components/schemas/Contacts'
        inn:
          type: string
          pattern: '^\d{12}$'
          description: ИНН физического лица (12 цифр)
          nullable: true
        snils:
          type: string
          pattern: '^\d{11}$'
          description: СНИЛС (11 цифр без разделителей)
          nullable: true
        citizenship:
          type: string
          description: Гражданство (код страны ISO 3166-1 alpha-2)
          default: RU
          example: RU
        isResident:
          type: boolean
          description: Резидент РФ
          default: true
        isPep:
          type: boolean
          description: Публичное должностное лицо (ПДЛ/PEP)
          default: false
        isBeneficialOwner:
          type: boolean
          description: Действует в собственных интересах (не бенефициар третьего лица)
          default: true
        consentToProcessing:
          type: boolean
          description: Согласие на обработку персональных данных
          default: false

    PersonalData:
      type: object
      description: Личные данные согласно 115-ФЗ
      required:
        - lastName
        - firstName
        - birthDate
      properties:
        lastName:
          type: string
          minLength: 1
          maxLength: 100
          description: Фамилия
          example: Иванов
        firstName:
          type: string
          minLength: 1
          maxLength: 100
          description: Имя
          example: Иван
        middleName:
          type: string
          maxLength: 100
          description: Отчество (при наличии)
          nullable: true
          example: Иванович
        birthDate:
          type: string
          format: date
          description: Дата рождения
          example: '1985-03-15'
        birthPlace:
          type: string
          maxLength: 200
          description: Место рождения
          nullable: true
          example: г. Москва

    IdentityDocument:
      type: object
      description: Документ, удостоверяющий личность
      required:
        - type
        - series
        - number
        - issuedBy
        - issuedAt
      properties:
        type:
          type: string
          enum: [passport_rf, passport_foreign, residence_permit, refugee_certificate, temporary_asylum]
          description: |
            Тип документа:
            - passport_rf — Паспорт гражданина РФ
            - passport_foreign — Паспорт иностранного гражданина
            - residence_permit — Вид на жительство
            - refugee_certificate — Удостоверение беженца
            - temporary_asylum — Свидетельство о временном убежище
          example: passport_rf
        series:
          type: string
          minLength: 2
          maxLength: 10
          description: Серия документа
          example: '4510'
        number:
          type: string
          minLength: 4
          maxLength: 20
          description: Номер документа
          example: '123456'
        issuedBy:
          type: string
          minLength: 5
          maxLength: 300
          description: Кем выдан
          example: ГУ МВД России по г. Москве
        issuedAt:
          type: string
          format: date
          description: Дата выдачи
          example: '2015-05-20'
        departmentCode:
          type: string
          pattern: '^\d{3}-\d{3}$'
          description: Код подразделения (для паспорта РФ)
          nullable: true
          example: '770-001'
        expiresAt:
          type: string
          format: date
          description: Срок действия (для иностранных документов)
          nullable: true

    Address:
      type: object
      description: Адрес регистрации
      required:
        - country
        - region
        - city
        - street
        - house
      properties:
        country:
          type: string
          description: Страна (код ISO 3166-1 alpha-2)
          default: RU
          example: RU
        postalCode:
          type: string
          pattern: '^\d{6}$'
          description: Почтовый индекс
          nullable: true
          example: '101000'
        region:
          type: string
          maxLength: 100
          description: Регион/область
          example: г. Москва
        city:
          type: string
          maxLength: 100
          description: Город/населённый пункт
          example: Москва
        street:
          type: string
          maxLength: 200
          description: Улица
          example: ул. Тверская
        house:
          type: string
          maxLength: 20
          description: Дом
          example: '1'
        building:
          type: string
          maxLength: 20
          description: Корпус/строение
          nullable: true
        apartment:
          type: string
          maxLength: 20
          description: Квартира/офис
          nullable: true
          example: '10'

    Contacts:
      type: object
      description: Контактные данные
      required:
        - phone
        - email
      properties:
        phone:
          type: string
          pattern: '^\+7\d{10}$'
          description: Телефон в формате +7XXXXXXXXXX
          example: '+79991234567'
        email:
          type: string
          format: email
          description: Email
          example: investor@example.com
        additionalPhone:
          type: string
          pattern: '^\+7\d{10}$'
          description: Дополнительный телефон
          nullable: true

    # KYC Documents
    KycDocumentUploadRequest:
      type: object
      required:
        - investorId
        - documentType
        - file
      properties:
        investorId:
          type: string
          format: uuid
          description: ID инвестора
        documentType:
          type: string
          enum: [passport_main, passport_registration, selfie, proof_of_address, inn_certificate, other]
          description: |
            Тип документа:
            - passport_main — Основной разворот паспорта
            - passport_registration — Страница регистрации
            - selfie — Селфи с документом
            - proof_of_address — Подтверждение адреса (квитанция ЖКХ, выписка)
            - inn_certificate — Свидетельство ИНН
            - other — Прочий документ
        file:
          type: string
          format: binary
          description: Файл документа (PDF, JPG, PNG; max 10MB)
        description:
          type: string
          maxLength: 500
          description: Описание документа
          nullable: true

    KycDocument:
      type: object
      description: Загруженный KYC документ
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        documentType:
          type: string
          enum: [passport_main, passport_registration, selfie, proof_of_address, inn_certificate, other]
        fileName:
          type: string
          description: Имя файла
        fileSize:
          type: integer
          description: Размер файла в байтах
        mimeType:
          type: string
          description: MIME-тип файла
        status:
          type: string
          enum: [uploaded, verified, rejected]
          description: Статус проверки документа
        rejectionReason:
          type: string
          nullable: true
          description: Причина отклонения
        uploadedAt:
          type: string
          format: date-time
        verifiedAt:
          type: string
          format: date-time
          nullable: true
    
    KycResult:
      type: object
      required:
        - investorId
        - status
      properties:
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [pass, fail, pending, review]
        checkedAt:
          type: string
          format: date-time
        reason:
          type: string
          nullable: true
    
    # ============================================
    # Qualification Schemas (согласно 39-ФЗ, Указание ЦБ 3629-У)
    # ============================================
    QualificationEvaluateRequest:
      type: object
      description: |
        Запрос на оценку квалификации инвестора согласно 39-ФЗ и Указанию ЦБ 3629-У.
        Инвестор признаётся квалифицированным при соответствии ОДНОМУ из критериев.
      required:
        - investorId
        - amount
      properties:
        investorId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
          description: Сумма планируемой операции (для проверки лимита)
        # Критерий 1: Оборот сделок (минимум 6 млн руб за 4 квартала)
        tradingTurnover:
          type: number
          format: decimal
          nullable: true
          description: |
            Оборот сделок с ценными бумагами, производными финансовыми инструментами
            за последние 4 квартала (в рублях). Минимум 6 000 000 руб.
        tradingFrequency:
          type: integer
          nullable: true
          description: |
            Количество сделок за последние 4 квартала.
            Минимум 10 сделок в квартал, не менее 1 в месяц.
        # Критерий 2: Активы (минимум 12 млн руб)
        totalAssets:
          type: number
          format: decimal
          nullable: true
          description: |
            Общий размер активов (денежные средства, ценные бумаги,
            производные финансовые инструменты) в рублях. Минимум 12 000 000 руб.
        # Критерий 3: Доход (минимум 12 млн руб/год за 2 года)
        annualIncome:
          type: number
          format: decimal
          nullable: true
          description: |
            Среднегодовой доход за последние 2 года (в рублях).
            Минимум 12 000 000 руб/год (или 6 000 000 руб при наличии образования).
        # Критерий 4: Опыт работы в финансовом секторе
        workExperience:
          $ref: '#/components/schemas/FinancialWorkExperience'
        # Критерий 5: Профильное образование
        education:
          $ref: '#/components/schemas/FinancialEducation'
        # Критерий 6: Квалификационный аттестат
        qualificationCertificate:
          $ref: '#/components/schemas/QualificationCertificate'

    FinancialWorkExperience:
      type: object
      description: Опыт работы в финансовом секторе
      nullable: true
      properties:
        hasExperience:
          type: boolean
          description: Есть опыт работы в финансовой организации
          default: false
        organizationType:
          type: string
          enum: [broker, dealer, management_company, bank, insurance, other_financial]
          description: |
            Тип организации:
            - broker — Брокер
            - dealer — Дилер
            - management_company — Управляющая компания
            - bank — Банк (инвестиционное подразделение)
            - insurance — Страховая компания (инвестиции)
            - other_financial — Иная финансовая организация
          nullable: true
        organizationName:
          type: string
          maxLength: 200
          description: Наименование организации
          nullable: true
        position:
          type: string
          maxLength: 100
          description: Должность
          nullable: true
        yearsOfExperience:
          type: number
          format: decimal
          description: Стаж работы (лет). Минимум 2 года для квалификации.
          nullable: true
        periodFrom:
          type: string
          format: date
          description: Дата начала работы
          nullable: true
        periodTo:
          type: string
          format: date
          description: Дата окончания работы (null если работает)
          nullable: true

    FinancialEducation:
      type: object
      description: Профильное образование для квалифицированного инвестора
      nullable: true
      properties:
        hasEducation:
          type: boolean
          description: Есть профильное образование
          default: false
        educationType:
          type: string
          enum: [higher_economics, higher_finance, mba_finance, cfa, frm, other_financial]
          description: |
            Тип образования:
            - higher_economics — Высшее экономическое
            - higher_finance — Высшее финансовое
            - mba_finance — MBA (финансы)
            - cfa — CFA (Chartered Financial Analyst)
            - frm — FRM (Financial Risk Manager)
            - other_financial — Иное финансовое образование
          nullable: true
        institutionName:
          type: string
          maxLength: 300
          description: Наименование учебного заведения
          nullable: true
        specialization:
          type: string
          maxLength: 200
          description: Специальность
          nullable: true
        graduationYear:
          type: integer
          minimum: 1950
          maximum: 2030
          description: Год окончания
          nullable: true
        diplomaNumber:
          type: string
          maxLength: 50
          description: Номер диплома
          nullable: true

    QualificationCertificate:
      type: object
      description: Квалификационный аттестат специалиста финансового рынка
      nullable: true
      properties:
        hasCertificate:
          type: boolean
          description: Есть квалификационный аттестат
          default: false
        certificateType:
          type: string
          enum: [series_1, series_2, series_3, series_4, series_5, series_6, series_7]
          description: |
            Серия аттестата:
            - series_1 — Брокерская, дилерская деятельность
            - series_2 — Управление ценными бумагами
            - series_3 — Клиринговая, депозитарная деятельность
            - series_4 — Деятельность по ведению реестра
            - series_5 — Деятельность по организации торговли
            - series_6 — Специалист рынка коллективных инвестиций
            - series_7 — Корпоративные финансы
          nullable: true
        certificateNumber:
          type: string
          maxLength: 50
          description: Номер аттестата
          nullable: true
        issuedAt:
          type: string
          format: date
          description: Дата выдачи
          nullable: true
        issuedBy:
          type: string
          maxLength: 200
          description: Кем выдан
          nullable: true

    # Qualification Tasks
    CreateQualificationTaskRequest:
      type: object
      description: Заявка на признание квалифицированным инвестором
      required:
        - investorId
        - qualificationBasis
      properties:
        investorId:
          type: string
          format: uuid
        qualificationBasis:
          type: string
          enum: [trading_turnover, total_assets, annual_income, work_experience, education, certificate]
          description: |
            Основание для признания квалифицированным инвестором:
            - trading_turnover — Оборот сделок ≥ 6 млн руб
            - total_assets — Активы ≥ 12 млн руб
            - annual_income — Доход ≥ 12 млн руб/год
            - work_experience — Опыт работы в финансовом секторе
            - education — Профильное образование
            - certificate — Квалификационный аттестат
        # Данные в зависимости от основания
        tradingTurnover:
          type: number
          format: decimal
          nullable: true
        tradingFrequency:
          type: integer
          nullable: true
        totalAssets:
          type: number
          format: decimal
          nullable: true
        annualIncome:
          type: number
          format: decimal
          nullable: true
        workExperience:
          $ref: '#/components/schemas/FinancialWorkExperience'
        education:
          $ref: '#/components/schemas/FinancialEducation'
        qualificationCertificate:
          $ref: '#/components/schemas/QualificationCertificate'
        # Подтверждающие документы
        documentIds:
          type: array
          items:
            type: string
            format: uuid
          description: ID загруженных документов, подтверждающих основание

    QualificationTask:
      type: object
      description: Задача на проверку квалификации инвестора
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        qualificationBasis:
          type: string
          enum: [trading_turnover, total_assets, annual_income, work_experience, education, certificate]
        status:
          type: string
          enum: [open, approved, rejected]
        assignedTier:
          type: string
          enum: [unqualified, qualified, professional]
          nullable: true
          description: Присвоенный уровень квалификации (после одобрения)
        assignedLimit:
          type: number
          format: decimal
          nullable: true
          description: Присвоенный лимит операций
        reason:
          type: string
          nullable: true
          description: Комментарий/причина решения
        documentIds:
          type: array
          items:
            type: string
            format: uuid
          description: ID приложенных документов
        createdAt:
          type: string
          format: date-time
        resolvedAt:
          type: string
          format: date-time
          nullable: true
        resolvedBy:
          type: string
          format: uuid
          nullable: true
          description: ID сотрудника, принявшего решение
        expiresAt:
          type: string
          format: date-time
          nullable: true
          description: Срок действия статуса (проверяется ежегодно)

    QualificationDecisionRequest:
      type: object
      description: Решение по заявке на квалификацию
      properties:
        tier:
          type: string
          enum: [qualified, professional]
          description: Присваиваемый уровень (при одобрении)
          nullable: true
        limit:
          type: number
          format: decimal
          description: Лимит операций (при одобрении)
          nullable: true
        reason:
          type: string
          maxLength: 1000
          description: Комментарий/причина решения
          nullable: true

    # ============================================
    # Complaints Schemas (дополнения)
    # ============================================
    ComplaintReplyRequest:
      type: object
      description: Ответ на жалобу
      required:
        - text
      properties:
        text:
          type: string
          minLength: 1
          maxLength: 5000
          description: Текст ответа
        isInternal:
          type: boolean
          description: Внутренний комментарий (не виден клиенту)
          default: false

    ComplaintResolveRequest:
      type: object
      description: Закрытие жалобы
      properties:
        resolution:
          type: string
          enum: [resolved, closed, rejected]
          description: |
            Тип закрытия:
            - resolved — Решена (в пользу клиента)
            - closed — Закрыта (нейтрально)
            - rejected — Отклонена (необоснованная)
          default: resolved
        resolutionText:
          type: string
          maxLength: 2000
          description: Текст резолюции
          nullable: true
    
    QualificationResult:
      type: object
      required:
        - investorId
        - tier
        - allowed
      properties:
        investorId:
          type: string
          format: uuid
        tier:
          type: string
          enum: [unqualified, qualified, professional]
        limit:
          type: number
          format: decimal
          nullable: true
        used:
          type: number
          format: decimal
          nullable: true
        allowed:
          type: boolean
        reason:
          type: string
          nullable: true
        evaluatedAt:
          type: string
          format: date-time
    
    InvestorStatusResponse:
      type: object
      required:
        - investorId
        - kyc
        - qualificationTier
      properties:
        investorId:
          type: string
          format: uuid
        kyc:
          type: string
          enum: [not_started, pending, review, pass, fail]
        qualificationTier:
          type: string
          enum: [unqualified, qualified, professional]
        qualificationLimit:
          type: number
          format: decimal
          nullable: true
        qualificationUsed:
          type: number
          format: decimal
          nullable: true
        updatedAt:
          type: string
          format: date-time

    KycTask:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [open, approved, rejected]
        reason:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        resolvedAt:
          type: string
          format: date-time
          nullable: true
    
    CreateComplaintRequest:
      type: object
      required:
        - category
        - text
      properties:
        investorId:
          type: string
          format: uuid
          nullable: true
        category:
          type: string
          enum: [fraud, service, technical, other]
        text:
          type: string
          minLength: 10
          maxLength: 5000
    
    ComplaintResponse:
      type: object
      required:
        - id
        - status
        - createdAt
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
          nullable: true
        category:
          type: string
          enum: [fraud, service, technical, other]
        text:
          type: string
        status:
          type: string
          enum: [open, in_progress, resolved, closed]
        slaDue:
          type: string
          format: date-time
          nullable: true
        createdAt:
          type: string
          format: date-time
        resolvedAt:
          type: string
          format: date-time
          nullable: true
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
</file>

<file path="services/compliance/compliance.Tests/AuthorizationTests.cs">
using System.Net;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Security.Claims;
using FluentAssertions;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.AspNetCore.TestHost;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using Xunit;

namespace OIS.Compliance.Tests;

public class AuthorizationTests : IClassFixture<AuthFactory>
{
    private readonly AuthFactory _factory;
    public AuthorizationTests(AuthFactory factory) { _factory = factory; }

    [Fact]
    public async Task Investor_Cannot_Read_Other_Investor_KycDoc()
    {
        var investorA = Guid.NewGuid();
        var investorB = Guid.NewGuid();
        Guid docId;

        using (var scope = _factory.Services.CreateScope())
        {
            var db = scope.ServiceProvider.GetRequiredService<ComplianceDbContext>();
            var doc = new KycDocumentEntity
            {
                Id = Guid.NewGuid(),
                InvestorId = investorA,
                DocumentType = "passport",
                FileName = "doc.pdf",
                FileSize = 10,
                MimeType = "application/pdf",
                Status = "uploaded",
                FileData = new byte[] { 1, 2, 3 },
                UploadedAt = DateTime.UtcNow
            };
            db.KycDocuments.Add(doc);
            await db.SaveChangesAsync();
            docId = doc.Id;
        }

        var clientB = _factory.CreateClientForUser(investorB, roles: new[] { "investor" });
        var resB = await clientB.GetAsync($"/v1/kyc/documents/{docId}");
        resB.StatusCode.Should().Be(HttpStatusCode.Forbidden);

        var clientBackoffice = _factory.CreateClientForUser(Guid.NewGuid(), roles: new[] { "backoffice" });
        var resBackoffice = await clientBackoffice.GetAsync($"/v1/kyc/documents/{docId}");
        resBackoffice.EnsureSuccessStatusCode();
    }

    [Fact]
    public async Task Complaint_Create_Forces_Ownership_For_Investor()
    {
        var investor = Guid.NewGuid();
        var other = Guid.NewGuid();

        var client = _factory.CreateClientForUser(investor, roles: new[] { "investor" });

        // mismatched investorId -> forbid
        var badReq = new CreateComplaintRequest
        {
            InvestorId = other,
            Category = "service",
            Text = "issue"
        };
        var badRes = await client.PostAsJsonAsync("/v1/complaints", badReq);
        badRes.StatusCode.Should().Be(HttpStatusCode.Forbidden);

        // missing investorId -> auto-filled with current user's ID (Created)
        var missingRes = await client.PostAsJsonAsync("/v1/complaints", new CreateComplaintRequest
        {
            Category = "service",
            Text = "issue"
        });
        missingRes.StatusCode.Should().Be(HttpStatusCode.Created);

        // valid self complaint
        var okRes = await client.PostAsJsonAsync("/v1/complaints", new CreateComplaintRequest
        {
            InvestorId = investor,
            Category = "service",
            Text = "issue"
        });
        okRes.EnsureSuccessStatusCode();
    }
}

public class AuthFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.UseEnvironment("Testing");
        builder.ConfigureServices(services =>
        {
            // Remove all EF Core registrations to avoid provider conflicts
            services.RemoveAll<DbContextOptions<ComplianceDbContext>>();
            services.RemoveAll<ComplianceDbContext>();
            var efDescriptors = services.Where(d =>
                d.ServiceType == typeof(DbContextOptions) ||
                (d.ServiceType.IsGenericType && d.ServiceType.GetGenericTypeDefinition() == typeof(DbContextOptions<>)) ||
                d.ImplementationType?.FullName?.Contains("Npgsql") == true ||
                d.ServiceType.FullName?.Contains("Npgsql") == true ||
                d.ServiceType.FullName?.Contains("EntityFrameworkCore") == true).ToList();
            foreach (var d in efDescriptors) services.Remove(d);
            services.AddDbContext<ComplianceDbContext>(o => o.UseInMemoryDatabase("compliance-auth-tests"));
        });
        builder.ConfigureTestServices(services =>
        {

            // Remove existing authentication configuration and replace with test handler
            var authDescriptors = services.Where(d =>
                d.ServiceType.FullName?.Contains("Authentication") == true ||
                d.ServiceType == typeof(IAuthenticationSchemeProvider)).ToList();
            foreach (var d in authDescriptors) services.Remove(d);

            // Header-driven auth for deterministic tests
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddScheme<AuthenticationSchemeOptions, HeaderAuthHandler>(JwtBearerDefaults.AuthenticationScheme, options => { });
        });
    }

    public HttpClient CreateClientForUser(Guid userId, string[]? roles = null)
    {
        var client = CreateClient();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "test");
        client.DefaultRequestHeaders.Add("X-Test-UserId", userId.ToString());
        if (roles is { Length: > 0 })
        {
            client.DefaultRequestHeaders.Add("X-Test-Roles", string.Join(",", roles));
        }
        return client;
    }
}

public class HeaderAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    public HeaderAuthHandler(IOptionsMonitor<AuthenticationSchemeOptions> options, ILoggerFactory logger, System.Text.Encodings.Web.UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock) { }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var headers = Request.Headers;
        var userId = headers.TryGetValue("X-Test-UserId", out var idVals) ? idVals.FirstOrDefault() : null;
        var rolesRaw = headers.TryGetValue("X-Test-Roles", out var rolesVals) ? rolesVals.FirstOrDefault() : null;

        if (string.IsNullOrWhiteSpace(userId) || !Guid.TryParse(userId, out var guid))
            return Task.FromResult(AuthenticateResult.Fail("No test user"));

        var claims = new List<Claim>
        {
            new Claim(ClaimTypes.NameIdentifier, guid.ToString()),
            new Claim("sub", guid.ToString())
        };
        if (!string.IsNullOrWhiteSpace(rolesRaw))
        {
            foreach (var role in rolesRaw.Split(',', StringSplitOptions.RemoveEmptyEntries))
            {
                claims.Add(new Claim(ClaimTypes.Role, role.Trim()));
            }
        }

        var identity = new ClaimsIdentity(claims, Scheme.Name);
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, Scheme.Name);
        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}
</file>

<file path="services/compliance/compliance.Tests/QualificationPolicyTests.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Compliance.Services;
using Xunit;
using FluentAssertions;

namespace OIS.Compliance.Tests;

public class QualificationPolicyTests
{
    private readonly Mock<ILogger<QualificationPolicyService>> _logger;
    private readonly IConfiguration _config;
    private readonly QualificationPolicyService _service;

    public QualificationPolicyTests()
    {
        _logger = new Mock<ILogger<QualificationPolicyService>>();
        // Only set qualified limit - professional should fall back to default (null = unlimited)
        _config = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Qualification:Limits:qualified"] = "5000"
            })
            .Build();
        _service = new QualificationPolicyService(_logger.Object, _config);
    }

    [Theory]
    [InlineData(250, QualificationTier.Professional)]
    [InlineData(150, QualificationTier.Qualified)]
    [InlineData(10, QualificationTier.Unqualified)]
    public async Task EvaluateTier_Is_Deterministic_By_Guid_Byte(int lastByte, QualificationTier expected)
    {
        var guid = MakeGuidWithLastByte((byte)lastByte);
        var tier = await _service.EvaluateTierAsync(guid, CancellationToken.None);
        tier.Should().Be(expected);
    }

    [Fact]
    public void GetLimitForTier_Qualified_Returns_Config_Value()
    {
        _service.GetLimitForTier("qualified").Should().Be(5000m);
    }

    [Fact]
    public void GetLimitForTier_Professional_Returns_Null()
    {
        // When config value is null or not set, should return null (unlimited)
        _service.GetLimitForTier("professional").Should().BeNull();
    }

    private static Guid MakeGuidWithLastByte(byte last)
    {
        var bytes = Guid.NewGuid().ToByteArray();
        bytes[^1] = last;
        return new Guid(bytes);
    }
}
</file>

<file path="services/compliance/Services/ComplianceService.cs">
using Microsoft.EntityFrameworkCore;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using System.Text.Json;

namespace OIS.Compliance.Services;

public interface IComplianceService
{
    Task<KycResult> CheckKycAsync(KycCheckRequest request, CancellationToken ct);
    Task<QualificationResult> EvaluateQualificationAsync(QualificationEvaluateRequest request, CancellationToken ct);
    Task<InvestorStatusResponse?> GetInvestorStatusAsync(Guid investorId, CancellationToken ct);
    Task<ComplaintResponse> CreateComplaintAsync(CreateComplaintRequest request, string? idempotencyKey, CancellationToken ct);
    Task<ComplaintResponse?> GetComplaintAsync(Guid id, CancellationToken ct);
    Task<KycResult> UpdateKycStatusAsync(Guid investorId, string status, Guid? actorId, string? reason, CancellationToken ct);
    Task<KycTaskDto> CreateKycTaskAsync(Guid investorId, string? reason, CancellationToken ct);
    Task<IReadOnlyList<KycTaskDto>> ListKycTasksAsync(string? status, CancellationToken ct);
    Task<KycTaskDto?> ResolveKycTaskAsync(Guid taskId, string action, Guid? actorId, string? reason, CancellationToken ct);
}

public class ComplianceService : IComplianceService
{
    private readonly ComplianceDbContext _db;
    private readonly ILogger<ComplianceService> _logger;
    private readonly IWatchlistsService _watchlists;
    private readonly IQualificationPolicyService _qualificationPolicy;
    private readonly IOutboxService _outbox;

    public ComplianceService(
        ComplianceDbContext db,
        ILogger<ComplianceService> logger,
        IWatchlistsService watchlists,
        IQualificationPolicyService qualificationPolicy,
        IOutboxService outbox)
    {
        _db = db;
        _logger = logger;
        _watchlists = watchlists;
        _qualificationPolicy = qualificationPolicy;
        _outbox = outbox;
    }

    public async Task<KycResult> UpdateKycStatusAsync(Guid investorId, string status, Guid? actorId, string? reason, CancellationToken ct)
    {
        var compliance = await GetOrCreateComplianceAsync(investorId, ct);

        if (status is not ("pass" or "fail" or "pending" or "review"))
            throw new InvalidOperationException($"Unsupported KYC status '{status}'");

        compliance.Kyc = status;
        compliance.UpdatedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        // Events: kyc.updated
        await _outbox.AddAsync("ois.kyc.updated", new
        {
            investorId,
            status,
            reason,
            updatedAt = compliance.UpdatedAt
        }, ct);

        // Audit
        await _outbox.AddAsync("ois.audit.logged", new
        {
            id = Guid.NewGuid(),
            actor = actorId,
            action = "kyc.update",
            entity = "investor",
            entityId = investorId,
            payload = new { status, reason },
            timestamp = DateTime.UtcNow,
            result = "success"
        }, ct);

        await _db.SaveChangesAsync(ct);

        return new KycResult
        {
            InvestorId = investorId,
            Status = compliance.Kyc,
            CheckedAt = compliance.UpdatedAt,
            Reason = reason
        };
    }

    public async Task<KycTaskDto> CreateKycTaskAsync(Guid investorId, string? reason, CancellationToken ct)
    {
        var task = new KycTaskEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = investorId,
            Status = "open",
            Reason = reason,
            CreatedAt = DateTime.UtcNow
        };
        _db.KycTasks.Add(task);
        await _db.SaveChangesAsync(ct);
        return MapToDto(task);
    }

    public async Task<IReadOnlyList<KycTaskDto>> ListKycTasksAsync(string? status, CancellationToken ct)
    {
        var query = _db.KycTasks.AsQueryable();
        if (!string.IsNullOrEmpty(status))
            query = query.Where(t => t.Status == status);
        var items = await query.OrderBy(t => t.CreatedAt).ToListAsync(ct);
        return items.Select(MapToDto).ToList();
    }

    public async Task<KycTaskDto?> ResolveKycTaskAsync(Guid taskId, string action, Guid? actorId, string? reason, CancellationToken ct)
    {
        var task = await _db.KycTasks.FindAsync(new object[] { taskId }, ct);
        if (task == null) return null;
        if (task.Status != "open") return MapToDto(task);

        string status = action == "approve" ? "pass" : action == "reject" ? "fail" : throw new InvalidOperationException("Unknown action");
        task.Status = action == "approve" ? "approved" : "rejected";
        task.ResolvedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        // Update KYC
        await UpdateKycStatusAsync(task.InvestorId, status, actorId, reason, ct);
        return MapToDto(task);
    }

    private static KycTaskDto MapToDto(KycTaskEntity e) => new()
    {
        Id = e.Id,
        InvestorId = e.InvestorId,
        Status = e.Status,
        Reason = e.Reason,
        CreatedAt = e.CreatedAt,
        ResolvedAt = e.ResolvedAt
    };

    public async Task<KycResult> CheckKycAsync(KycCheckRequest request, CancellationToken ct)
    {
        var compliance = await GetOrCreateComplianceAsync(request.InvestorId, ct);

        // Check watchlists
        var watchlistResult = await _watchlists.CheckAsync(request.InvestorId, ct);
        if (watchlistResult.Matched)
        {
            compliance.Kyc = "fail";
            compliance.UpdatedAt = DateTime.UtcNow;
            await _db.SaveChangesAsync(ct);

            // Emit flagged event
            await _outbox.AddAsync("ois.compliance.flagged", new
            {
                investorId = request.InvestorId,
                reason = "watchlist_match",
                severity = watchlistResult.Severity,
                flaggedAt = DateTime.UtcNow,
                details = new { watchlistReason = watchlistResult.Reason }
            }, ct);

            await _db.SaveChangesAsync(ct);

            return new KycResult
            {
                InvestorId = request.InvestorId,
                Status = "fail",
                CheckedAt = DateTime.UtcNow,
                Reason = watchlistResult.Reason ?? "Watchlist match"
            };
        }

        // If already passed — return current status
        if (compliance.Kyc == "pass")
        {
            return new KycResult
            {
                InvestorId = request.InvestorId,
                Status = "pass",
                CheckedAt = compliance.UpdatedAt,
                Reason = null
            };
        }

        // Move to pending for manual review; keep existing pending/review as-is
        if (compliance.Kyc != "pending" && compliance.Kyc != "review")
        {
            compliance.Kyc = "pending";
            compliance.UpdatedAt = DateTime.UtcNow;
            await _db.SaveChangesAsync(ct);
        }

        // Ensure there is an open task for backoffice review when KYC is pending
        if (compliance.Kyc == "pending")
        {
            var hasOpenTask = await _db.KycTasks
                .AnyAsync(t => t.InvestorId == request.InvestorId && t.Status == "open", ct);

            if (!hasOpenTask)
            {
                await CreateKycTaskAsync(request.InvestorId, "KYC submission received", ct);
            }
        }

        return new KycResult
        {
            InvestorId = request.InvestorId,
            Status = compliance.Kyc,
            CheckedAt = compliance.UpdatedAt,
            Reason = null
        };
    }

    public async Task<QualificationResult> EvaluateQualificationAsync(QualificationEvaluateRequest request, CancellationToken ct)
    {
        if (request.Amount <= 0)
            throw new ArgumentOutOfRangeException(nameof(request.Amount), "Amount must be greater than zero");

        var compliance = await GetOrCreateComplianceAsync(request.InvestorId, ct);

        // Evaluate tier if not set
        if (compliance.QualificationTier == "unqualified")
        {
            var tier = await _qualificationPolicy.EvaluateTierAsync(request.InvestorId, ct);
            compliance.QualificationTier = tier.ToString().ToLowerInvariant();
            compliance.QualLimit = _qualificationPolicy.GetLimitForTier(compliance.QualificationTier);
            compliance.QualUsed = 0;
            compliance.UpdatedAt = DateTime.UtcNow;
            await _db.SaveChangesAsync(ct);
        }

        // Check if amount is allowed
        var limit = compliance.QualLimit;
        var used = compliance.QualUsed ?? 0;
        var allowed = true;
        string? reason = null;

        var projectedUsed = used + request.Amount;

        if (limit.HasValue && projectedUsed > limit.Value)
        {
            allowed = false;
            reason = $"Qualification limit exceeded: used {used}, limit {limit}, requested {request.Amount}";

            // Emit flagged event
            await _outbox.AddAsync("ois.compliance.flagged", new
            {
                investorId = request.InvestorId,
                reason = "qualification_exceeded",
                severity = "high",
                flaggedAt = DateTime.UtcNow,
                details = new { used = used, limit = limit, requested = request.Amount }
            }, ct);

            await _db.SaveChangesAsync(ct);
        }

        if (allowed)
        {
            compliance.QualUsed = projectedUsed;
            compliance.UpdatedAt = DateTime.UtcNow;
            await _db.SaveChangesAsync(ct);
        }

        return new QualificationResult
        {
            InvestorId = request.InvestorId,
            Tier = compliance.QualificationTier,
            Limit = compliance.QualLimit,
            Used = compliance.QualUsed,
            Allowed = allowed,
            Reason = reason,
            EvaluatedAt = DateTime.UtcNow
        };
    }

    public async Task<InvestorStatusResponse?> GetInvestorStatusAsync(Guid investorId, CancellationToken ct)
    {
        // Auto-create compliance record for new investors with default not_started status
        var compliance = await GetOrCreateComplianceAsync(investorId, ct);

        // Can upload documents if:
        // 1. KYC not started yet, OR
        // 2. KYC was rejected and rejection count < 5
        var canUpload = compliance.Kyc == "not_started" ||
                        (compliance.Kyc == "rejected" && compliance.RejectionCount < 5);

        return new InvestorStatusResponse
        {
            InvestorId = compliance.InvestorId,
            Kyc = compliance.Kyc,
            QualificationTier = compliance.QualificationTier,
            QualificationLimit = compliance.QualLimit,
            QualificationUsed = compliance.QualUsed,
            RejectionCount = compliance.RejectionCount,
            RejectionReason = compliance.RejectionReason,
            CanUploadDocuments = canUpload,
            UpdatedAt = compliance.UpdatedAt
        };
    }

    public async Task<ComplaintResponse> CreateComplaintAsync(CreateComplaintRequest request, string? idempotencyKey, CancellationToken ct)
    {
        // Check idempotency if key provided
        if (!string.IsNullOrEmpty(idempotencyKey))
        {
            var existing = await _db.Complaints
                .FirstOrDefaultAsync(c => c.IdemKey == idempotencyKey, ct);

            if (existing != null)
            {
                _logger.LogInformation("Complaint with idempotency key {IdemKey} already exists: {ComplaintId}",
                    idempotencyKey, existing.Id);
                return MapToComplaintResponse(existing);
            }
        }

        var complaint = new ComplaintEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = request.InvestorId,
            Category = request.Category,
            Text = request.Text,
            Status = "open",
            SlaDue = DateTime.UtcNow.AddDays(7), // 7-day SLA
            CreatedAt = DateTime.UtcNow,
            IdemKey = idempotencyKey
        };

        _db.Complaints.Add(complaint);
        await _db.SaveChangesAsync(ct);

        var investorMasked = request.InvestorId.HasValue ? OIS.Domain.Security.MaskGuid(request.InvestorId.Value) : "(null)";
        _logger.LogInformation("Created complaint {ComplaintId} for investor {Investor}, category {Category}",
            complaint.Id, investorMasked, request.Category);

        return MapToComplaintResponse(complaint);
    }

    public async Task<ComplaintResponse?> GetComplaintAsync(Guid id, CancellationToken ct)
    {
        var complaint = await _db.Complaints.FindAsync(new object[] { id }, ct);
        return complaint != null ? MapToComplaintResponse(complaint) : null;
    }

    private async Task<InvestorComplianceEntity> GetOrCreateComplianceAsync(Guid investorId, CancellationToken ct)
    {
        var compliance = await _db.InvestorsCompliance
            .FirstOrDefaultAsync(c => c.InvestorId == investorId, ct);

        if (compliance == null)
        {
            compliance = new InvestorComplianceEntity
            {
                InvestorId = investorId,
                Kyc = "not_started",
                QualificationTier = "unqualified",
                UpdatedAt = DateTime.UtcNow
            };
            _db.InvestorsCompliance.Add(compliance);
            await _db.SaveChangesAsync(ct);
        }

        return compliance;
    }

    private static ComplaintResponse MapToComplaintResponse(ComplaintEntity entity)
    {
        return new ComplaintResponse
        {
            Id = entity.Id,
            InvestorId = entity.InvestorId,
            Category = entity.Category,
            Text = entity.Text,
            Status = entity.Status,
            SlaDue = entity.SlaDue,
            CreatedAt = entity.CreatedAt,
            ResolvedAt = entity.ResolvedAt
        };
    }
}

public record KycTaskDto
{
    public Guid Id { get; init; }
    public Guid InvestorId { get; init; }
    public string Status { get; init; } = string.Empty;
    public string? Reason { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime? ResolvedAt { get; init; }
}

public record CreateKycTaskRequest
{
    public Guid InvestorId { get; init; }
    public string? Reason { get; init; }
}

public interface IOutboxService
{
    Task AddAsync(string topic, object payload, CancellationToken ct);
}

public class OutboxService : IOutboxService
{
    private readonly ComplianceDbContext _db;

    public OutboxService(ComplianceDbContext db)
    {
        _db = db;
    }

    public async Task AddAsync(string topic, object payload, CancellationToken ct)
    {
        var message = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            Topic = topic,
            Payload = JsonSerializer.Serialize(payload),
            CreatedAt = DateTime.UtcNow
        };

        _db.OutboxMessages.Add(message);
    }
}
</file>

<file path="services/compliance/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "Swagger": {
    "Enabled": true
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=ois;Username=ois;Password=ois_dev_password"
  },
  "Kafka": {
    "Enabled": false,
    "BootstrapServers": "localhost:9092"
  },
  "Qualification": {
    "Limits": {
      "unqualified": null,
      "qualified": 60000,
      "professional": null
    }
  },
  "Serilog": {
    "Using": ["Serilog.Sinks.Console"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  }
}
</file>

<file path="services/compliance/ComplianceDbContext.cs">
using Microsoft.EntityFrameworkCore;

namespace OIS.Compliance;

public class ComplianceDbContext : DbContext
{
    public ComplianceDbContext(DbContextOptions<ComplianceDbContext> options) : base(options) { }

    public DbSet<InvestorComplianceEntity> InvestorsCompliance => Set<InvestorComplianceEntity>();
    public DbSet<ComplaintEntity> Complaints => Set<ComplaintEntity>();
    public DbSet<OutboxMessage> OutboxMessages => Set<OutboxMessage>();
    public DbSet<KycTaskEntity> KycTasks => Set<KycTaskEntity>();
    public DbSet<KycDocumentEntity> KycDocuments => Set<KycDocumentEntity>();
    public DbSet<QualificationTaskEntity> QualificationTasks => Set<QualificationTaskEntity>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity<InvestorComplianceEntity>(entity =>
        {
            entity.ToTable("investors_compliance");
            entity.HasKey(e => e.InvestorId);

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .ValueGeneratedNever();

            entity.Property(e => e.Kyc)
                .HasColumnName("kyc")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.QualificationTier)
                .HasColumnName("qualification_tier")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.QualLimit)
                .HasColumnName("qual_limit")
                .HasPrecision(20, 8);

            entity.Property(e => e.QualUsed)
                .HasColumnName("qual_used")
                .HasPrecision(20, 8);

            entity.Property(e => e.RejectionCount)
                .HasColumnName("rejection_count")
                .HasDefaultValue(0);

            entity.Property(e => e.RejectionReason)
                .HasColumnName("rejection_reason");

            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .IsRequired();
        });

        modelBuilder.Entity<ComplaintEntity>(entity =>
        {
            entity.ToTable("complaints");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id");

            entity.Property(e => e.Category)
                .HasColumnName("category")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.Text)
                .HasColumnName("text")
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.SlaDue)
                .HasColumnName("sla_due");

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ResolvedAt)
                .HasColumnName("resolved_at");

            entity.Property(e => e.IdemKey)
                .HasColumnName("idem_key")
                .HasMaxLength(255);

            entity.HasIndex(e => e.IdemKey).IsUnique()
                .HasFilter("\"idem_key\" IS NOT NULL");
            entity.HasIndex(e => e.InvestorId);
            entity.HasIndex(e => e.Status);
            entity.HasIndex(e => e.Category);
        });

        modelBuilder.Entity<OutboxMessage>(entity =>
        {
            entity.ToTable("outbox_messages");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.Topic)
                .HasColumnName("topic")
                .HasMaxLength(255)
                .IsRequired();

            entity.Property(e => e.Payload)
                .HasColumnName("payload")
                .HasColumnType("jsonb")
                .IsRequired();

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ProcessedAt)
                .HasColumnName("processed_at");

            entity.HasIndex(e => new { e.ProcessedAt, e.CreatedAt });
        });

        modelBuilder.Entity<KycTaskEntity>(entity =>
        {
            entity.ToTable("kyc_tasks");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.Reason)
                .HasColumnName("reason");

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ResolvedAt)
                .HasColumnName("resolved_at");

            entity.HasIndex(e => e.InvestorId);
            entity.HasIndex(e => e.Status);
        });

        modelBuilder.Entity<KycDocumentEntity>(entity =>
        {
            entity.ToTable("kyc_documents");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .IsRequired();

            entity.Property(e => e.DocumentType)
                .HasColumnName("document_type")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.FileName)
                .HasColumnName("file_name")
                .HasMaxLength(255)
                .IsRequired();

            entity.Property(e => e.FileSize)
                .HasColumnName("file_size")
                .IsRequired();

            entity.Property(e => e.MimeType)
                .HasColumnName("mime_type")
                .HasMaxLength(100)
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.RejectionReason)
                .HasColumnName("rejection_reason");

            entity.Property(e => e.FileData)
                .HasColumnName("file_data")
                .IsRequired();

            entity.Property(e => e.UploadedAt)
                .HasColumnName("uploaded_at")
                .IsRequired();

            entity.Property(e => e.VerifiedAt)
                .HasColumnName("verified_at");

            entity.HasIndex(e => e.InvestorId);
            entity.HasIndex(e => e.DocumentType);
            entity.HasIndex(e => e.Status);
        });

        modelBuilder.Entity<QualificationTaskEntity>(entity =>
        {
            entity.ToTable("qualification_tasks");
            entity.HasKey(e => e.Id);

            entity.Property(e => e.Id)
                .HasColumnName("id")
                .ValueGeneratedNever();

            entity.Property(e => e.InvestorId)
                .HasColumnName("investor_id")
                .IsRequired();

            entity.Property(e => e.QualificationBasis)
                .HasColumnName("qualification_basis")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.AssignedTier)
                .HasColumnName("assigned_tier")
                .HasMaxLength(50);

            entity.Property(e => e.AssignedLimit)
                .HasColumnName("assigned_limit")
                .HasPrecision(20, 8);

            entity.Property(e => e.Reason)
                .HasColumnName("reason");

            entity.Property(e => e.DocumentIds)
                .HasColumnName("document_ids")
                .HasColumnType("jsonb");

            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .IsRequired();

            entity.Property(e => e.ResolvedAt)
                .HasColumnName("resolved_at");

            entity.Property(e => e.ResolvedBy)
                .HasColumnName("resolved_by");

            entity.Property(e => e.ExpiresAt)
                .HasColumnName("expires_at");

            entity.HasIndex(e => e.InvestorId);
            entity.HasIndex(e => e.Status);
            entity.HasIndex(e => e.QualificationBasis);
        });
    }
}

public class InvestorComplianceEntity
{
    public Guid InvestorId { get; set; }
    public string Kyc { get; set; } = "not_started"; // not_started, pending, review, pass, fail
    public string QualificationTier { get; set; } = "unqualified"; // unqualified, qualified, professional
    public decimal? QualLimit { get; set; }
    public decimal? QualUsed { get; set; }
    public int RejectionCount { get; set; } = 0;
    public string? RejectionReason { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class ComplaintEntity
{
    public Guid Id { get; set; }
    public Guid? InvestorId { get; set; }
    public string Category { get; set; } = string.Empty; // fraud, service, technical, other
    public string Text { get; set; } = string.Empty;
    public string Status { get; set; } = "open"; // open, in_progress, resolved, closed
    public DateTime? SlaDue { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ResolvedAt { get; set; }
    public string? IdemKey { get; set; }
}

public class OutboxMessage
{
    public Guid Id { get; set; }
    public string Topic { get; set; } = string.Empty;
    public string Payload { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
}

public class KycTaskEntity
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public string Status { get; set; } = "open"; // open, approved, rejected
    public string? Reason { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ResolvedAt { get; set; }
}

public class KycDocumentEntity
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public string DocumentType { get; set; } = "other"; // passport_main, passport_registration, selfie, proof_of_address, inn_certificate, other
    public string FileName { get; set; } = string.Empty;
    public long FileSize { get; set; }
    public string MimeType { get; set; } = string.Empty;
    public string Status { get; set; } = "uploaded"; // uploaded, verified, rejected
    public string? RejectionReason { get; set; }
    public byte[] FileData { get; set; } = Array.Empty<byte>(); // Store file in DB for simplicity
    public DateTime UploadedAt { get; set; }
    public DateTime? VerifiedAt { get; set; }
}

public class QualificationTaskEntity
{
    public Guid Id { get; set; }
    public Guid InvestorId { get; set; }
    public string QualificationBasis { get; set; } = string.Empty; // trading_turnover, total_assets, annual_income, work_experience, education, certificate
    public string Status { get; set; } = "open"; // open, approved, rejected
    public string? AssignedTier { get; set; } // unqualified, qualified, professional
    public decimal? AssignedLimit { get; set; }
    public string? Reason { get; set; }
    public string? DocumentIds { get; set; } // JSON array of document IDs
    public DateTime CreatedAt { get; set; }
    public DateTime? ResolvedAt { get; set; }
    public Guid? ResolvedBy { get; set; }
    public DateTime? ExpiresAt { get; set; }
}
</file>

<file path="services/issuance/issuance.Tests/Services/IssuanceServiceTests.cs">
using System.Text.Json;
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using OIS.Domain;
using OIS.Issuance;
using OIS.Issuance.Services;
using Xunit;

namespace issuance.Tests.Services;

public class IssuanceServiceTests
{
    [Fact]
    public async Task PublishAsync_WritesOutboxPayloadAlignedWithAsyncApi()
    {
        var issuanceId = Guid.NewGuid();
        var (service, db, ledgerMock) = BuildService();

        db.Issuances.Add(new IssuanceEntity
        {
            Id = issuanceId,
            AssetId = Guid.Parse("aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"),
            IssuerId = Guid.Parse("bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb"),
            TotalAmount = 1_000_000m,
            Nominal = 1_000m,
            IssueDate = DateOnly.FromDateTime(DateTime.UtcNow.Date),
            MaturityDate = DateOnly.FromDateTime(DateTime.UtcNow.Date.AddYears(1)),
            Status = IssuanceStatus.Draft,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        });
        await db.SaveChangesAsync();

        ledgerMock.Setup(l => l.IssueAsync(
                issuanceId,
                It.IsAny<Guid>(),
                It.IsAny<Guid>(),
                It.IsAny<decimal>(),
                It.IsAny<decimal>(),
                It.IsAny<DateOnly>(),
                It.IsAny<DateOnly>(),
                It.IsAny<string?>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync("tx-hash-123");

        var result = await service.PublishAsync(issuanceId, CancellationToken.None);

        result.Should().NotBeNull();

        var message = db.OutboxMessages.Single(m => m.Topic == "ois.issuance.published");
        using var doc = JsonDocument.Parse(message.Payload);
        var root = doc.RootElement;

        root.GetProperty("issuanceId").GetGuid().Should().Be(issuanceId);
        root.GetProperty("assetId").GetGuid().Should().Be(Guid.Parse("aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"));
        root.GetProperty("issuerId").GetGuid().Should().Be(Guid.Parse("bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb"));
        root.GetProperty("totalAmount").GetDecimal().Should().Be(1_000_000m);
        root.GetProperty("publishedAt").GetDateTime().Should().BeCloseTo(DateTime.UtcNow, TimeSpan.FromSeconds(5));
        root.TryGetProperty("dltTxHash", out _).Should().BeFalse("dltTxHash должен быть вложен в metadata согласно AsyncAPI");

        var metadata = root.GetProperty("metadata");
        metadata.GetProperty("dltTxHash").GetString().Should().Be("tx-hash-123");
    }

    [Fact]
    public async Task CloseAsync_WritesOutboxPayloadAlignedWithAsyncApi()
    {
        var issuanceId = Guid.NewGuid();
        var (service, db, ledgerMock) = BuildService();

        db.Issuances.Add(new IssuanceEntity
        {
            Id = issuanceId,
            AssetId = Guid.NewGuid(),
            IssuerId = Guid.NewGuid(),
            TotalAmount = 500_000m,
            Nominal = 1_000m,
            IssueDate = DateOnly.FromDateTime(DateTime.UtcNow.Date),
            MaturityDate = DateOnly.FromDateTime(DateTime.UtcNow.Date.AddYears(1)),
            Status = IssuanceStatus.Published,
            DltTxHash = "tx-hash-published",
            CreatedAt = DateTime.UtcNow.AddDays(-1),
            UpdatedAt = DateTime.UtcNow.AddDays(-1),
            PublishedAt = DateTime.UtcNow.AddHours(-1)
        });
        await db.SaveChangesAsync();

        ledgerMock.Setup(l => l.CloseAsync(issuanceId, It.IsAny<CancellationToken>()))
            .ReturnsAsync("tx-hash-close");

        var result = await service.CloseAsync(issuanceId, CancellationToken.None);

        result.Should().NotBeNull();

        var message = db.OutboxMessages.Single(m => m.Topic == "ois.issuance.closed");
        using var doc = JsonDocument.Parse(message.Payload);
        var root = doc.RootElement;

        root.GetProperty("issuanceId").GetGuid().Should().Be(issuanceId);
        root.GetProperty("closedAt").GetDateTime().Should().BeCloseTo(DateTime.UtcNow, TimeSpan.FromSeconds(5));
        root.TryGetProperty("dltTxHash", out _).Should().BeFalse();

        var metadata = root.GetProperty("metadata");
        metadata.GetProperty("dltTxHash").GetString().Should().Be("tx-hash-close");
    }

    private static (IssuanceService service, IssuanceDbContext db, Mock<ILedgerIssuance> ledgerMock) BuildService()
    {
        var options = new DbContextOptionsBuilder<IssuanceDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        var db = new IssuanceDbContext(options);
        var outbox = new OutboxService(db);
        var ledgerMock = new Mock<ILedgerIssuance>();
        var loggerFactory = LoggerFactory.Create(cfg => cfg.AddDebug().SetMinimumLevel(LogLevel.Debug));
        var logger = loggerFactory.CreateLogger<IssuanceService>();

        var service = new IssuanceService(db, logger, outbox, ledgerMock.Object);
        return (service, db, ledgerMock);
    }
}
</file>

<file path="services/issuance/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "Swagger": {
    "Enabled": true
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=ois;Username=ois;Password=ois_dev_password"
  },
  "Kafka": {
    "Enabled": false,
    "BootstrapServers": "localhost:9092"
  },
  "Ledger": {
    "UseMock": false,
    "ChaincodeEndpoint": "http://localhost:8080"
  },
  "Fabric": {
    "PeerEndpoint": "http://localhost:7051",
    "ChannelName": "cfa-main",
    "MspId": "OisDevMSP",
    "TlsCertPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/server.crt",
    "TlsKeyPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/server.key",
    "TlsRootCertPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/ca.crt"
  },
  "Serilog": {
    "Using": ["Serilog.Sinks.Console"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  }
}
</file>

<file path="services/issuance/Program.cs">
using FluentValidation;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Issuance;
using OIS.Issuance.DTOs;
using OIS.Issuance.Services;
using OIS.Issuance.Validators;
using Serilog;
using MassTransit;
using OIS.Contracts.Events;
using OIS.Issuance.Infrastructure;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using System.Diagnostics;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
var otlpEndpoint = builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"] ?? "http://otel-collector:4317";
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("issuance-service")
        .AddAttributes(new Dictionary<string, object> { ["environment"] = builder.Environment.EnvironmentName }))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddOtlpExporter(options => options.Endpoint = new Uri(otlpEndpoint)))
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Prometheus metrics endpoint is added via OpenTelemetry above

// Database
var useInMemoryDb = builder.Configuration.GetValue<bool>("UseInMemoryDatabase", false);
var issuanceMigrationsAssembly = typeof(IssuanceDbContext).Assembly.GetName().Name;

builder.Services.AddDbContext<IssuanceDbContext>(options =>
{
    if (useInMemoryDb)
    {
        var dbName = builder.Configuration.GetValue<string>("InMemoryDatabaseName") ?? "IssuanceTestsDb";
        options.UseInMemoryDatabase(dbName);
    }
    else
    {
        options.UseNpgsql(
            builder.Configuration.GetConnectionString("DefaultConnection"),
            npgsqlOptions => npgsqlOptions.MigrationsAssembly(issuanceMigrationsAssembly));
    }
});

// HTTP Client for Ledger Adapter
builder.Services.AddHttpClient<LedgerIssuanceAdapter>()
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

// Services
builder.Services.AddScoped<ILedgerIssuance, LedgerIssuanceAdapter>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IIssuanceService, IssuanceService>();

// MassTransit + Kafka publish
var kafkaEnabled = builder.Configuration.GetValue<bool>("Kafka:Enabled", false);
var kafkaBootstrap = builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092";
if (kafkaEnabled)
{
    builder.Services.AddMassTransit(x =>
    {
        // In-memory transport ensures IBus/IPublishEndpoint are available for outbox publishing
        x.UsingInMemory((context, cfg) =>
        {
            cfg.ConfigureEndpoints(context);
        });

        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(kafkaBootstrap);
                cfg.Message<IssuancePublished>(m => m.SetEntityName("ois.issuance.published"));
                cfg.Message<IssuanceClosed>(m => m.SetEntityName("ois.issuance.closed"));
                cfg.Message<AuditLogged>(m => m.SetEntityName("ois.audit.logged"));
            });
        });
    });

    builder.Services.AddHostedService<OIS.Issuance.Background.OutboxPublisher>();
}

// Validation
builder.Services.AddValidatorsFromAssemblyContaining<CreateIssuanceRequestValidator>();
builder.Services.AddFluentValidationAutoValidation();

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        if (!string.IsNullOrEmpty(authority)) options.Authority = authority;
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            RoleClaimType = ClaimTypes.Role
        };
        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx => { MapKeycloakRoles(ctx); return Task.CompletedTask; }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:any-auth", p => p.RequireAuthenticatedUser());
    options.AddPolicy("role:issuer-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("issuer") || ctx.User.IsInRole("backoffice")));
});

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<IssuanceDbContext>();

var app = builder.Build();

// Apply migrations (env MIGRATE_ON_STARTUP overrides RunMigrations flag)
var runMigrations = builder.Configuration.GetValue<bool>("RunMigrations", true);
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    runMigrations = true;
}
else if (string.Equals(migrateOnStartup, "false", StringComparison.OrdinalIgnoreCase))
{
    runMigrations = false;
}

if (runMigrations)
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<IssuanceDbContext>();
    try
    {
        db.Database.Migrate();
    }
    catch (Exception ex)
    {
        app.Logger.LogWarning(ex, "Issuance migration failed, falling back to EnsureCreated (dev only)");
        db.Database.EnsureCreated();
    }
}

// Configure pipeline
var swaggerEnabled = app.Configuration.GetValue<bool?>("Swagger:Enabled") ?? app.Environment.IsDevelopment();
if (swaggerEnabled)
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

var disableHttpsRedirect = builder.Configuration.GetValue<bool>("DisableHttpsRedirection", false);
if (!disableHttpsRedirect)
{
    app.UseHttpsRedirection();
}
app.UseAuthentication();
app.UseAuthorization();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    // Correlate X-Request-ID
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();

    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Issuances").RequireAuthorization();

api.MapPost("/issuances", async (
    CreateIssuanceRequest request,
    IIssuanceService service,
    ILoggerFactory loggerFactory,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CreateAsync(request, ct);
        return Results.Created($"/v1/issuances/{result.Id}", result);
    }
    catch (FluentValidation.ValidationException vex)
    {
        var logger = loggerFactory.CreateLogger("CreateIssuance");
        logger.LogWarning(vex, "Validation failed for CreateIssuance");
        var errors = vex.Errors
            .GroupBy(e => e.PropertyName)
            .ToDictionary(g => g.Key, g => g.Select(e => e.ErrorMessage).ToArray());
        return Results.ValidationProblem(errors, statusCode: 400, title: "Validation Failed");
    }
    catch (Exception ex)
    {
        var logger = loggerFactory.CreateLogger("CreateIssuance");
        logger.LogError(ex, "CreateIssuance failed");
        return Results.Problem(detail: ex.Message, statusCode: 500, title: "Internal Server Error");
    }
})
.WithName("CreateIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapGet("/issuances/{id:guid}", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    var result = await service.GetByIdAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetIssuance")
.RequireAuthorization("role:any-auth")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/publish", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.PublishAsync(id, ct);
        return result is not null ? Results.Ok(result) : Results.NotFound();
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("PublishIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/close", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CloseAsync(id, ct);
        return result is not null ? Results.Ok(result) : Results.NotFound();
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("CloseIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapGet("/reports/issuances", async (
    Guid issuerId,
    DateOnly? from,
    DateOnly? to,
    IIssuanceService service,
    CancellationToken ct) =>
{
    var report = await service.GetIssuerIssuancesReportAsync(issuerId, from, to, ct);
    return Results.Ok(report);
})
.WithName("GetIssuerIssuancesReport")
.RequireAuthorization("role:issuer-or-backoffice")
.WithOpenApi();

app.Run();

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { }
}

public partial class Program { }
</file>

<file path="services/registry/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "Swagger": {
    "Enabled": true
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=ois;Username=ois;Password=ois_dev_password"
  },
  "Kafka": {
    "Enabled": false,
    "BootstrapServers": "localhost:9092"
  },
  "BankNominal": {
    "BaseUrl": "http://bank-nominal:8080"
  },
  "Compliance": {
    "BaseUrl": "http://compliance-service:8080"
  },
  "Ledger": {
    "UseMock": false,
    "ChaincodeEndpoint": "http://localhost:8080"
  },
  "Fabric": {
    "PeerEndpoint": "http://localhost:7051",
    "ChannelName": "cfa-main",
    "MspId": "OisDevMSP",
    "TlsCertPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/server.crt",
    "TlsKeyPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/server.key",
    "TlsRootCertPath": "../../ops/fabric/crypto-config/peerOrganizations/ois-dev.example.com/peers/peer0.ois-dev.example.com/tls/ca.crt"
  },
  "Serilog": {
    "Using": ["Serilog.Sinks.Console"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  }
}
</file>

<file path="services/registry/Program.cs">
using Microsoft.EntityFrameworkCore;
using FluentValidation;
using OIS.Registry.Validators;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Registry;
using OIS.Registry.DTOs;
using OIS.Registry.Services;
using Serilog;
using System.Diagnostics;
using MassTransit;
using OIS.Contracts.Events;
using OIS.Registry.Infrastructure;
using Microsoft.AspNetCore.RateLimiting;
using System.Threading.RateLimiting;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("registry-service"))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Database
var registryMigrationsAssembly = typeof(RegistryDbContext).Assembly.GetName().Name;
builder.Services.AddDbContext<RegistryDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions => npgsqlOptions.MigrationsAssembly(registryMigrationsAssembly)));

// HTTP Clients
builder.Services.AddHttpClient<IBankNominalService, BankNominalServiceClient>();
builder.Services.AddHttpClient<IComplianceService, ComplianceServiceClient>();
builder.Services.AddHttpClient<LedgerRegistryAdapter>()
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

// Services
builder.Services.AddScoped<ILedgerRegistry, LedgerRegistryAdapter>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IRegistryService, RegistryService>();

// Validation
builder.Services.AddValidatorsFromAssemblyContaining<CreateOrderRequestValidator>();
builder.Services.AddFluentValidationAutoValidation();

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        if (!string.IsNullOrEmpty(authority))
        {
            options.Authority = authority;
        }
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            RoleClaimType = ClaimTypes.Role
        };

        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx =>
            {
                MapKeycloakRoles(ctx);
                return Task.CompletedTask;
            }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:investor", p => p.RequireRole("investor"));
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:broker", p => p.RequireRole("broker"));
    options.AddPolicy("role:backoffice", p => p.RequireRole("backoffice"));
    options.AddPolicy("role:investor-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
    options.AddPolicy("scope:orders.write", p => p.RequireAssertion(HasScope("orders.write")));
    options.AddPolicy("scope:orders.read", p => p.RequireAssertion(HasScope("orders.read")));
});

// MassTransit + Kafka for publishing
var kafkaEnabled = builder.Configuration.GetValue<bool>("Kafka:Enabled", false);
var kafkaBootstrap = builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092";
if (kafkaEnabled)
{
    builder.Services.AddMassTransit(x =>
    {
        // In-memory transport to provide IBus/IPublishEndpoint for outbox publish
        x.UsingInMemory((context, cfg) =>
        {
            cfg.ConfigureEndpoints(context);
        });

        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(kafkaBootstrap);
                cfg.Message<OrderCreated>(m => m.SetEntityName("ois.order.created"));
                cfg.Message<OrderPlaced>(m => m.SetEntityName("ois.order.placed"));
                cfg.Message<OrderReserved>(m => m.SetEntityName("ois.order.reserved"));
                cfg.Message<OrderPaid>(m => m.SetEntityName("ois.order.paid"));
                cfg.Message<OrderConfirmed>(m => m.SetEntityName("ois.order.confirmed"));
                cfg.Message<RegistryTransferred>(m => m.SetEntityName("ois.registry.transferred"));
                cfg.Message<AuditLogged>(m => m.SetEntityName("ois.audit.logged"));
            });
        });
    });

    builder.Services.AddHostedService<OIS.Registry.Background.OutboxPublisher>();
}

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<RegistryDbContext>();

// Rate limiting
builder.Services.AddRateLimiter(options =>
{
    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
    options.AddPolicy("sensitive", httpContext =>
    {
        var key = GetPartitionKey(httpContext);
        return RateLimitPartition.GetTokenBucketLimiter(key, _ => new TokenBucketRateLimiterOptions
        {
            TokenLimit = 20,
            TokensPerPeriod = 20,
            ReplenishmentPeriod = TimeSpan.FromSeconds(1),
            AutoReplenishment = true,
            QueueLimit = 0,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst
        });
    });
});

var app = builder.Build();

// Apply migrations (optional, via MIGRATE_ON_STARTUP=true)
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<RegistryDbContext>();
    try
    {
        db.Database.Migrate();
    }
    catch (Exception ex)
    {
        app.Logger.LogWarning(ex, "Registry migration failed, falling back to EnsureCreated (dev only)");
        db.Database.EnsureCreated();
    }
}

// Configure pipeline
var swaggerEnabled = app.Configuration.GetValue<bool?>("Swagger:Enabled") ?? app.Environment.IsDevelopment();
if (swaggerEnabled)
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.UseRateLimiter();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();

    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Registry").RequireAuthorization();

api.MapPost("/orders", async (
    CreateOrderRequest request,
    HttpContext httpContext,
    IRegistryService service,
    CancellationToken ct) =>
{
    // Get idempotency key from header
    if (!httpContext.Request.Headers.TryGetValue("Idempotency-Key", out var idemKeyValues) ||
        !Guid.TryParse(idemKeyValues.FirstOrDefault(), out var idemKeyGuid))
    {
        return Results.Problem(
            detail: "Idempotency-Key header is required and must be a valid UUID",
            statusCode: 400,
            title: "Bad Request");
    }

    var idemKey = idemKeyGuid.ToString();
    var result = await service.PlaceOrderAsync(request, idemKey, ct);
    return Results.Accepted($"/v1/orders/{result.Id}", result);
})
.WithName("PlaceOrder")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapGet("/orders/{id:guid}", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    var result = await service.GetOrderAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetOrder")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapGet("/wallets/{investorId:guid}", async (
    Guid investorId,
    IRegistryService service,
    CancellationToken ct) =>
{
    var result = await service.GetWalletAsync(investorId, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetWallet")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/redeem", async (
    Guid id,
    RedeemRequest request,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.RedeemAsync(id, request, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("RedeemIssuance")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapPost("/orders/{id:guid}/cancel", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CancelOrderAsync(id, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? 404 : 400,
            title: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? "Not Found" : "Bad Request");
    }
})
.WithName("CancelOrder")
.RequireAuthorization("role:investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapPost("/orders/{id:guid}/mark-paid", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.MarkPaidAsync(id, null, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? 404 : 400,
            title: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? "Not Found" : "Bad Request");
    }
})
.WithName("MarkOrderPaid")
.RequireAuthorization("role:investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

app.Run();
static Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext, bool> HasScope(string scope) => ctx =>
{
    var scp = ctx.User.FindFirst("scope")?.Value ?? ctx.User.FindFirst("scp")?.Value;
    if (string.IsNullOrWhiteSpace(scp)) return false;
    return scp.Split(' ', StringSplitOptions.RemoveEmptyEntries)
        .Any(s => string.Equals(s, scope, StringComparison.OrdinalIgnoreCase));
};

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { /* ignore parsing errors */ }
}

static string GetPartitionKey(HttpContext ctx)
{
    var sub = ctx.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
    if (!string.IsNullOrEmpty(sub)) return $"user:{sub}";
    return $"ip:{ctx.Connection.RemoteIpAddress}";
}
</file>

<file path="apps/api-gateway/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Swagger": {
    "Enabled": true
  },
  "Cors": {
    "AllowedOrigins": [
      "http://87.249.49.56:3001",
      "http://87.249.49.56:3002",
      "http://87.249.49.56:3003",
      "http://87.249.49.56:53001",
      "http://87.249.49.56:53002",
      "http://87.249.49.56:53003",
      "http://localhost:155101",
      "http://localhost:155102",
      "http://localhost:155103",
      "http://localhost:3001",
      "http://localhost:3002",
      "http://localhost:3003",
      "http://localhost:3004"
    ]
  },
  "ReverseProxy": {
    "Routes": {
      "identity": {
        "ClusterId": "identity",
        "Match": {
          "Path": "/identity/{**catch-all}"
        }
      },
      "identity-v1": {
        "ClusterId": "identity",
        "Match": {
          "Path": "/v1/identity/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/identity/{**catch-all}"
          }
        ]
      },
      "issuances": {
        "ClusterId": "issuance",
        "Match": {
          "Path": "/issuances/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/issuances/{**catch-all}"
          }
        ]
      },
      "orders": {
        "ClusterId": "registry",
        "Match": {
          "Path": "/v1/orders/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/orders/{**catch-all}"
          }
        ]
      },
      "wallets": {
        "ClusterId": "registry",
        "Match": {
          "Path": "/v1/wallets/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/wallets/{**catch-all}"
          }
        ]
      },
      "settlement": {
        "ClusterId": "settlement",
        "Match": {
          "Path": "/v1/settlement/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/settlement/{**catch-all}"
          }
        ]
      },
      "compliance": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/compliance/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/compliance/{**catch-all}"
          }
        ]
      },
      "kyc-tasks": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/kyc/tasks/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/kyc/tasks/{**catch-all}"
          }
        ]
      },
      "kyc-documents-root": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/kyc/documents"
        },
        "Transforms": [
          {
            "PathSet": "/v1/kyc/documents"
          }
        ]
      },
      "kyc-documents": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/kyc/documents/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/kyc/documents/{**catch-all}"
          }
        ]
      },
      "kyc-investors": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/kyc/investors/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/kyc/investors/{**catch-all}"
          }
        ]
      },
      "audit": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/audit/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/audit/{**catch-all}"
          }
        ]
      },
      "complaints": {
        "ClusterId": "compliance",
        "Match": {
          "Path": "/v1/complaints/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/complaints/{**catch-all}"
          }
        ]
      },
      "reports-issuances": {
        "ClusterId": "issuance",
        "Match": {
          "Path": "/v1/reports/issuances"
        },
        "Transforms": [
          {
            "PathSet": "/v1/reports/issuances"
          }
        ]
      },
      "reports": {
        "ClusterId": "settlement",
        "Match": {
          "Path": "/v1/reports/{**catch-all}"
        },
        "Transforms": [
          {
            "PathPattern": "/v1/reports/{**catch-all}"
          }
        ]
      }
    },
    "Clusters": {
      "identity": {
        "Destinations": {
          "default": {
            "Address": "http://identity-service:8080"
          }
        }
      },
      "issuance": {
        "Destinations": {
          "default": {
            "Address": "http://issuance-service:8080"
          }
        }
      },
      "registry": {
        "Destinations": {
          "default": {
            "Address": "http://registry-service:8080"
          }
        }
      },
      "settlement": {
        "Destinations": {
          "default": {
            "Address": "http://settlement-service:8080"
          }
        }
      },
      "compliance": {
        "Destinations": {
          "default": {
            "Address": "http://compliance-service:8080"
          }
        }
      }
    }
  }
}
</file>

<file path="apps/backoffice/src/app/complaints/page.tsx">
'use client';

import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { PageHeader, Card, CardContent, Button, Skeleton } from '@ois/shared-ui';
import { complaintsService } from '@/lib/services/complaints';
import { ComplaintStatus } from '@/mocks/complaints';
import { useComplaintMutations } from './hooks/useComplaintMutations';
import { ComplaintItem } from './components/ComplaintItem';
import { ComplaintDetailsPanel } from './components/ComplaintDetailsPanel';

const STATUS_LABELS: Record<string, string> = {
  all: 'ВСЕ',
  open: 'НОВАЯ',
  in_progress: 'В РАБОТЕ',
  resolved: 'РЕШЕНА',
};

const STATUSES = ['all', 'open', 'in_progress', 'resolved'] as const;
type FilterStatus = (typeof STATUSES)[number];

export default function ComplaintsPage() {
  const [activeStatus, setActiveStatus] = useState<FilterStatus>('all');
  const [selectedId, setSelectedId] = useState<string | null>(null);

  const { data: complaints = [], isLoading } = useQuery({
    queryKey: ['complaints', activeStatus],
    queryFn: () =>
      complaintsService.getComplaints(
        activeStatus === 'all' ? undefined : (activeStatus as ComplaintStatus)
      ),
  });

  const { replyMutation, resolveMutation, isSubmitting } = useComplaintMutations();

  const selected = complaints.find(c => c.id === selectedId);

  const handleStatusChange = (status: FilterStatus) => {
    setActiveStatus(status);
    setSelectedId(null);
  };

  return (
    <div className="space-y-6">
      <PageHeader
        title="Жалобы пользователей"
        description="Обработка обращений и жалоб от пользователей"
      />

      {/* Status Filter */}
      <div className="flex items-center gap-2">
        {STATUSES.map(status => (
          <Button
            key={status}
            onClick={() => handleStatusChange(status)}
            variant={activeStatus === status ? 'primary' : 'secondary'}
            size="sm"
          >
            {STATUS_LABELS[status]}
          </Button>
        ))}
      </div>

      <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
        {/* List */}
        <Card>
          <CardContent className="p-0">
            <div className="divide-y divide-border">
              {isLoading && (
                <div className="p-4 space-y-2">
                  <Skeleton className="h-16 w-full" />
                  <Skeleton className="h-16 w-full" />
                </div>
              )}
              {!isLoading && complaints.length === 0 && (
                <div className="p-8 text-center text-text-tertiary">Нет жалоб в этом статусе</div>
              )}
              {complaints.map(complaint => (
                <ComplaintItem
                  key={complaint.id}
                  complaint={complaint}
                  isSelected={selectedId === complaint.id}
                  onClick={() => setSelectedId(complaint.id)}
                />
              ))}
            </div>
          </CardContent>
        </Card>

        {/* Details */}
        {selected ? (
          <ComplaintDetailsPanel
            complaint={selected}
            onReply={replyMutation.mutate}
            onResolve={resolveMutation.mutate}
            isSubmitting={isSubmitting}
          />
        ) : (
          <div className="hidden lg:flex items-center justify-center rounded-lg border-2 border-dashed border-border p-12 text-text-tertiary">
            Выберите жалобу для просмотра
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/payouts/page.tsx">
'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import { getPayoutsReport, runSettlement } from '@/lib/api/reports';
import type { PayoutReport } from '@/lib/api/reports';
import { PageHeader, Button, Card, CardContent, Skeleton, StatCard } from '@ois/shared-ui';
import { DollarSign, FileText, CheckCircle, XCircle } from 'lucide-react';

export default function PayoutsPage() {
  const queryClient = useQueryClient();

  const { data: report, isLoading } = useQuery<PayoutReport>({
    queryKey: ['payouts-report'],
    queryFn: async () => {
      const to = new Date();
      const from = new Date();
      from.setDate(from.getDate() - 30);
      return getPayoutsReport({
        from: from.toISOString().slice(0, 10),
        to: to.toISOString().slice(0, 10),
      });
    },
  });

  const runSettlementMutation = useMutation({
    mutationFn: (date?: string) => runSettlement(date ? { date } : undefined),
    onSuccess: () => {
      toast.success('Расчёт запущен');
      queryClient.invalidateQueries({ queryKey: ['payouts-report'] });
    },
    onError: (error: unknown) => {
      const message = error instanceof Error ? error.message : 'Ошибка запуска расчёта';
      toast.error(message);
    },
  });

  const summary: PayoutReport = report ?? {
    totalAmount: 0,
    totalItems: 0,
    items: [],
  };

  return (
    <div className="space-y-6">
      <PageHeader
        title="Выплаты"
        description="Расчёты с эмитентами"
        actions={
          <Button
            onClick={() => runSettlementMutation.mutate(undefined)}
            disabled={runSettlementMutation.isPending}
            variant="primary"
          >
            {runSettlementMutation.isPending ? 'Выполняется…' : 'Запустить расчёт'}
          </Button>
        }
      />

      {isLoading && (
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
          {[1, 2, 3, 4].map(i => (
            <Skeleton key={i} className="h-24 w-full" variant="rectangular" />
          ))}
        </div>
      )}

      {!isLoading && (
        <Card>
          <CardContent className="p-6 space-y-4">
            <h2 className="text-xl font-semibold text-text-primary">Последние 30 дней</h2>
            <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
              <StatCard
                title="Общая сумма"
                value={`₽${summary.totalAmount.toLocaleString()}`}
                icon={DollarSign}
              />
              <StatCard
                title="Количество операций"
                value={summary.totalItems.toString()}
                icon={FileText}
              />
              <StatCard
                title="Выполнено"
                value={summary.items.filter(item => item.status === 'executed').length.toString()}
                icon={CheckCircle}
              />
              <StatCard
                title="Ошибки"
                value={summary.items.filter(item => item.status === 'failed').length.toString()}
                icon={XCircle}
              />
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/users/page.tsx">
'use client';

import { useState } from 'react';
import { PageHeader, Card, Select, Input, Button, ConfirmDialog } from '@ois/shared-ui';
import { User, UserRole, UserStatus } from '@/mocks/users';
import { userService } from '@/lib/services/users';
import { UsersTable } from './components/UsersTable';
import { UserModal } from './components/UserModal';
import { useUserMutations } from './hooks/useUserMutations';
import { useConfirmDialog } from '@/lib/hooks/useConfirmDialog';
import { Plus } from 'lucide-react';
import { useQuery } from '@tanstack/react-query';

const ROLE_OPTIONS = [
  { value: 'all', label: 'Все роли' },
  { value: 'admin', label: 'Администратор' },
  { value: 'operator', label: 'Оператор' },
  { value: 'issuer', label: 'Эмитент' },
  { value: 'investor', label: 'Инвестор' },
];

const STATUS_OPTIONS = [
  { value: 'all', label: 'Все статусы' },
  { value: 'active', label: 'Активен' },
  { value: 'inactive', label: 'Неактивен' },
  { value: 'suspended', label: 'Приостановлен' },
  { value: 'blocked', label: 'Заблокирован' },
];

export default function UsersPage() {
  const [roleFilter, setRoleFilter] = useState<UserRole | 'all'>('all');
  const [statusFilter, setStatusFilter] = useState<UserStatus | 'all'>('all');
  const [search, setSearch] = useState('');
  const [selectedUser, setSelectedUser] = useState<User | undefined>(undefined);
  const [isModalOpen, setIsModalOpen] = useState(false);

  const { data: users = [], isLoading } = useQuery({
    queryKey: ['users', roleFilter, statusFilter, search],
    queryFn: () =>
      userService.getUsers({
        role: roleFilter === 'all' ? undefined : roleFilter,
        status: statusFilter === 'all' ? undefined : statusFilter,
        search: search || undefined,
      }),
  });

  const {
    updateMutation,
    blockMutation,
    unblockMutation,
    isLoading: isMutating,
  } = useUserMutations();
  const { dialogProps, open: openConfirm } = useConfirmDialog();

  const handleEdit = (user: User) => {
    setSelectedUser(user);
    setIsModalOpen(true);
  };

  const handleSave = async (data: Partial<User>) => {
    if (!selectedUser) return;
    await updateMutation.mutateAsync({ id: selectedUser.id, data });
  };

  const handleBlock = (user: User) => {
    openConfirm({
      title: 'Заблокировать пользователя?',
      description: `Вы уверены, что хотите заблокировать ${user.email}? Пользователь не сможет войти в систему.`,
      confirmText: 'Заблокировать',
      variant: 'danger',
      onConfirm: () => blockMutation.mutateAsync(user.id),
    });
  };

  const handleUnblock = (user: User) => {
    openConfirm({
      title: 'Разблокировать пользователя?',
      description: `Вы уверены, что хотите разблокировать ${user.email}? Пользователь снова сможет войти в систему.`,
      confirmText: 'Разблокировать',
      variant: 'warning',
      onConfirm: () => unblockMutation.mutateAsync(user.id),
    });
  };

  return (
    <div className="space-y-6">
      <PageHeader
        title="Пользователи"
        description="Управление пользователями и их правами доступа"
        actions={
          <Button
            onClick={() => {
              setSelectedUser(undefined);
              setIsModalOpen(true);
            }}
            disabled
          >
            <Plus className="mr-2 h-4 w-4" />
            Добавить
          </Button>
        }
      />

      <Card className="p-4">
        <div className="grid grid-cols-1 gap-4 md:grid-cols-4">
          <Input
            placeholder="Поиск по email или имени..."
            value={search}
            onChange={e => setSearch(e.target.value)}
          />
          <Select
            options={ROLE_OPTIONS}
            value={roleFilter}
            onChange={e => setRoleFilter(e.target.value as UserRole | 'all')}
          />
          <Select
            options={STATUS_OPTIONS}
            value={statusFilter}
            onChange={e => setStatusFilter(e.target.value as UserStatus | 'all')}
          />
        </div>
      </Card>

      <Card>
        <UsersTable
          data={users}
          isLoading={isLoading}
          onEdit={handleEdit}
          onBlock={handleBlock}
          onUnblock={handleUnblock}
        />
      </Card>

      <UserModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSave={handleSave}
        user={selectedUser}
      />

      <ConfirmDialog {...dialogProps} isLoading={isMutating || dialogProps.isLoading} />
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/page.tsx">
'use client';

import { useQuery } from '@tanstack/react-query';
import { PageHeader, Card, CardContent, Skeleton, Badge, Button } from '@ois/shared-ui';
import { dashboardService } from '@/lib/services/dashboard';
import { Users, FileCheck, MessageSquareWarning, Activity, ArrowRight } from 'lucide-react';
import Link from 'next/link';

export default function DashboardPage() {
  const { data: stats, isLoading } = useQuery({
    queryKey: ['dashboard-stats'],
    queryFn: () => dashboardService.getStats(),
  });

  const StatCard = ({ title, value, subtext, icon: Icon, href, intent }: any) => (
    <Link href={href} className="block group">
      <Card className="h-full transition-all hover:shadow-md hover:border-primary-200">
        <CardContent className="p-6 flex items-start justify-between">
          <div>
            <p className="text-sm font-medium text-text-secondary mb-1">{title}</p>
            <h3 className="text-2xl font-bold text-text-primary mb-1">
              {isLoading ? <Skeleton className="h-8 w-16" /> : value}
            </h3>
            <p className="text-xs text-text-tertiary">{subtext}</p>
          </div>
          <div className="flex flex-col items-end gap-2">
            <Badge intent={intent} className="uppercase text-[11px]">
              {intent === 'info'
                ? 'info'
                : intent === 'warning'
                  ? 'warning'
                  : intent === 'danger'
                    ? 'alerts'
                    : 'primary'}
            </Badge>
            <Icon className="h-6 w-6 text-text-secondary" />
          </div>
        </CardContent>
      </Card>
    </Link>
  );

  return (
    <div className="space-y-8">
      <PageHeader title="Дашборд" description="Обзор ключевых показателей системы" />

      <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
        <StatCard
          title="Пользователи"
          value={stats?.users.total}
          subtext={`${stats?.users.active ?? 0} активных, ${stats?.users.blocked ?? 0} заблокированных`}
          icon={Users}
          href="/users"
          intent="info"
        />
        <StatCard
          title="KYC Заявки"
          value={stats?.kyc.open}
          subtext={`${stats?.kyc.approved ?? 0} одобрено сегодня`}
          icon={FileCheck}
          href="/kyc"
          intent="warning"
        />
        <StatCard
          title="Жалобы"
          value={stats?.complaints.open}
          subtext={`${stats?.complaints.inProgress ?? 0} в работе`}
          icon={MessageSquareWarning}
          href="/complaints"
          intent="danger"
        />
      </div>

      <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between mb-6">
              <h3 className="font-semibold text-text-primary flex items-center gap-2">
                <Activity className="h-5 w-5 text-text-secondary" />
                Последняя активность
              </h3>
              <Link
                href="/audit"
                className="text-sm text-text-secondary hover:text-text-primary transition-colors flex items-center"
              >
                Все события <ArrowRight className="ml-1 h-4 w-4" />
              </Link>
            </div>
            <div className="space-y-4">
              {isLoading ? (
                Array(3)
                  .fill(0)
                  .map((_, i) => <Skeleton key={i} className="h-12 w-full" />)
              ) : stats?.recentActivity.length === 0 ? (
                <p className="text-text-tertiary text-center py-4">Нет недавней активности</p>
              ) : (
                stats?.recentActivity.map(activity => (
                  <div
                    key={activity.id}
                    className="flex items-start gap-3 pb-3 border-b border-border last:border-0 last:pb-0"
                  >
                    <div
                      className={`mt-1 h-2 w-2 rounded-full ${
                        activity.type === 'complaint'
                          ? 'bg-danger-500'
                          : activity.type === 'kyc'
                            ? 'bg-warning-500'
                            : 'bg-text-tertiary'
                      }`}
                    />
                    <div>
                      <p className="text-sm text-text-primary font-medium">{activity.message}</p>
                      <p className="text-xs text-text-tertiary">
                        {new Date(activity.timestamp).toLocaleString('ru-RU')}
                      </p>
                    </div>
                  </div>
                ))
              )}
            </div>
          </CardContent>
        </Card>

        {/* Quick Actions or Info Panel */}
        <Card className="bg-gradient-to-br from-slate-700 to-slate-800 text-white">
          <CardContent className="p-8 flex flex-col justify-between h-full">
            <div>
              <h3 className="text-xl font-bold mb-2">Добро пожаловать в Бэкофис</h3>
              <p className="text-white/80 mb-6">
                Используйте меню слева для навигации по разделам. Проверяйте KYC заявки и
                обрабатывайте жалобы пользователей своевременно.
              </p>
            </div>
            <div className="flex gap-3">
              <Button asChild variant="secondary" size="sm">
                <Link href="/kyc">Перейти к KYC</Link>
              </Button>
              <Button asChild variant="secondary" size="sm">
                <Link href="/users">Управление пользователями</Link>
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/components/layout/AppShell.tsx">
'use client';

import React from 'react';
import { AppShell as SDKAppShell, SidebarItem } from '@ois/shared-ui';
import { signOut, useSession } from 'next-auth/react';
import { usePathname } from 'next/navigation';
import { Users, FileCheck, ShieldAlert, LayoutDashboard, MessageSquareWarning } from 'lucide-react';

const navigation: SidebarItem[] = [
  { label: 'Дашборд', href: '/', icon: <LayoutDashboard className="h-5 w-5" /> },
  { label: 'Пользователи', href: '/users', icon: <Users className="h-5 w-5" /> },
  { label: 'KYC и Комплаенс', href: '/kyc', icon: <FileCheck className="h-5 w-5" /> },
  { label: 'Жалобы', href: '/complaints', icon: <MessageSquareWarning className="h-5 w-5" /> },
  { label: 'Аудит', href: '/audit', icon: <ShieldAlert className="h-5 w-5" /> },
];

export function AppShell({ children }: { children: React.ReactNode }) {
  const { data: session, status } = useSession();
  const pathname = usePathname();

  // Don't show shell on login page or if not authenticated
  if (pathname === '/login' || status === 'unauthenticated') {
    return <>{children}</>;
  }

  return (
    <SDKAppShell
      variant="admin"
      showFooter={false}
      appName="Бэк-офис"
      user={{
        name: session?.user?.name,
        email: session?.user?.email,
      }}
      onSignOut={() => signOut()}
      sidebar={{
        items: navigation,
      }}
    >
      {children}
    </SDKAppShell>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/types.ts">
export type PersonalData = {
  lastName: string;
  firstName: string;
  middleName: string;
  birthDate: string;
  birthPlace: string;
};

export type IdentityDocument = {
  type:
    | 'passport_rf'
    | 'passport_foreign'
    | 'residence_permit'
    | 'refugee_certificate'
    | 'temporary_asylum';
  series: string;
  number: string;
  issuedBy: string;
  issuedAt: string;
  departmentCode: string;
  expiresAt: string;
};

export type AddressData = {
  country: string;
  postalCode: string;
  region: string;
  city: string;
  street: string;
  house: string;
  building: string;
  apartment: string;
};

export type ContactsData = {
  phone: string;
  email: string;
  additionalPhone: string;
};

export type FormData = {
  personalData: PersonalData;
  identityDocument: IdentityDocument;
  address: AddressData;
  contacts: ContactsData;
  inn: string;
  snils: string;
  citizenship: string;
  isResident: boolean;
  isPep: boolean;
  isBeneficialOwner: boolean;
  consentToProcessing: boolean;
};

export type FieldError = Record<string, string>;

export type FormErrors = Record<string, FieldError>;

export interface KycDocument {
  id: string;
  documentType: string;
  fileName: string;
  fileSize: number;
  status: string;
  uploadedAt: string;
}

// Локальный файл, хранящийся в state до отправки формы
export interface LocalDocument {
  id: string;
  documentType: string;
  file: File;
  fileName: string;
  fileSize: number;
  preview?: string; // URL для превью изображений
}

export interface InvestorStatusResponse {
  investorId: string;
  kyc: 'not_started' | 'pending' | 'review' | 'pass' | 'fail';
  qualificationTier: string;
  qualificationLimit?: number | null;
  qualificationUsed?: number | null;
  updatedAt: string;
  rejectionReason?: string | null;
  canUploadDocuments?: boolean;
}
</file>

<file path="apps/portal-investor/src/lib/auth.ts">
import { NextAuthOptions } from 'next-auth';
import { JWT } from 'next-auth/jwt';
import KeycloakProvider from 'next-auth/providers/keycloak';

// Prefer internal URL for server-to-server calls; fall back to public
const issuerBase =
  process.env.KEYCLOAK_INTERNAL_URL ||
  process.env.NEXT_PUBLIC_KEYCLOAK_URL ||
  'http://localhost:8080';

const realm = process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'ois';
const clientId = process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'portal-investor';
const clientSecret = process.env.KEYCLOAK_CLIENT_SECRET || 'secret';

// Type extensions for NextAuth
interface KeycloakProfile {
  sub: string;
  email?: string;
  name?: string;
  realm_access?: {
    roles: string[];
  };
}

interface ExtendedJWT extends JWT {
  accessToken?: string;
  refreshToken?: string;
  accessTokenExpires?: number;
  roles?: string[];
  error?: string;
}

// Extend Session type
declare module 'next-auth' {
  interface Session {
    user: {
      id?: string;
      name?: string | null;
      email?: string | null;
      image?: string | null;
      roles?: string[];
    };
    accessToken?: string;
    error?: string;
  }
}

/**
 * Parse JWT token payload safely
 * JWT format: header.payload.signature
 */
function parseJwtRoles(accessToken: string): string[] {
  try {
    const payload = accessToken.split('.')[1];
    if (!payload) return [];
    const decoded = JSON.parse(Buffer.from(payload, 'base64').toString());
    return decoded.realm_access?.roles || [];
  } catch (error) {
    console.error('[auth] Failed to parse JWT token:', error);
    return [];
  }
}

/**
 * Refresh access token using Keycloak token endpoint
 */
async function refreshAccessToken(token: ExtendedJWT): Promise<ExtendedJWT> {
  try {
    const tokenEndpoint = `${issuerBase}/realms/${realm}/protocol/openid-connect/token`;

    console.log('[auth] Refreshing access token...');

    const response = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        client_id: clientId,
        client_secret: clientSecret,
        grant_type: 'refresh_token',
        refresh_token: token.refreshToken || '',
      }),
    });

    const refreshedTokens = await response.json();

    if (!response.ok) {
      console.error('[auth] Token refresh failed:', refreshedTokens);
      throw new Error(refreshedTokens.error_description || 'Failed to refresh token');
    }

    console.log('[auth] Token refreshed successfully');

    return {
      ...token,
      accessToken: refreshedTokens.access_token,
      refreshToken: refreshedTokens.refresh_token ?? token.refreshToken,
      accessTokenExpires: Date.now() + (refreshedTokens.expires_in - 60) * 1000, // Refresh 60s before expiry
      roles: parseJwtRoles(refreshedTokens.access_token),
      error: undefined,
    };
  } catch (error) {
    console.error('[auth] Error refreshing access token:', error);
    return {
      ...token,
      error: 'RefreshAccessTokenError',
    };
  }
}

if (process.env.NODE_ENV !== 'production') {
  // Helpful runtime log to debug OAuthSignin issues without leaking secrets
  console.info('[auth] portal-investor keycloak config', {
    issuerBase,
    realm,
    clientId,
    nextauthUrl: process.env.NEXTAUTH_URL,
    hasInternalUrl: Boolean(process.env.KEYCLOAK_INTERNAL_URL),
  });
}

export const authOptions: NextAuthOptions = {
  providers: [
    KeycloakProvider({
      clientId,
      clientSecret,
      issuer: `${issuerBase}/realms/${realm}`,
    }),
  ],
  debug: process.env.NODE_ENV !== 'production',
  logger: {
    error: (code, metadata) => console.error('NextAuth error', code, metadata),
    warn: code => console.warn('NextAuth warn', code),
    debug: (code, metadata) => console.debug('NextAuth debug', code, metadata),
  },
  events: {
    signIn: async ({ user, account, profile }) => {
      const keycloakProfile = profile as KeycloakProfile | undefined;
      console.info('[auth] signIn', {
        user: user?.email || user?.name,
        provider: account?.provider,
        kid: account?.token_type,
        profile: keycloakProfile
          ? { sub: keycloakProfile.sub, email: keycloakProfile.email }
          : null,
      });
    },
    signOut: async ({ token }) => {
      const extToken = token as ExtendedJWT;
      console.info('[auth] signOut', {
        user: extToken?.email,
        roles: extToken?.roles,
      });
    },
    session: async ({ session }) => {
      console.info('[auth] session', {
        user: session?.user?.email,
        roles: session?.user?.roles,
      });
    },
  },
  callbacks: {
    async jwt({ token, account }): Promise<ExtendedJWT> {
      const extToken = token as ExtendedJWT;

      // Initial sign in - store tokens and expiry
      if (account) {
        console.log('[auth] Initial sign in, storing tokens');
        return {
          ...extToken,
          accessToken: account.access_token,
          refreshToken: account.refresh_token,
          // expires_in is in seconds, convert to timestamp with 60s buffer
          accessTokenExpires: Date.now() + ((account.expires_in as number) - 60) * 1000,
          roles: account.access_token ? parseJwtRoles(account.access_token) : [],
        };
      }

      // Return previous token if not expired
      if (extToken.accessTokenExpires && Date.now() < extToken.accessTokenExpires) {
        return extToken;
      }

      // Token expired, try to refresh
      console.log('[auth] Access token expired, refreshing...');
      return refreshAccessToken(extToken);
    },
    async session({ session, token }) {
      const extToken = token as ExtendedJWT;

      if (session.user) {
        session.user.roles = extToken.roles;
        // Keycloak subject (UUID) is used as investorId
        session.user.id = extToken.sub;
        session.accessToken = extToken.accessToken;
        session.error = extToken.error;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
};
</file>

<file path="apps/portal-issuer/src/app/profile/page.tsx">
'use client';

import { useQuery } from '@tanstack/react-query';
import { signOut, useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';
import { AppShell, PageHeader, Card, CardContent, Skeleton, Badge } from '@ois/shared-ui';
import { Building2, Mail, User, MapPin, CreditCard, Calendar, CheckCircle } from 'lucide-react';
import { getIssuerProfile, type IssuerProfile } from '@/lib/mocks/profile';
import { issuerNavItems } from '@/lib/navigation';

const statusLabels: Record<IssuerProfile['status'], string> = {
  active: 'Активен',
  inactive: 'Неактивен',
  suspended: 'Приостановлен',
  blocked: 'Заблокирован',
};

const statusIntent: Record<IssuerProfile['status'], Parameters<typeof Badge>[0]['intent']> = {
  active: 'success',
  inactive: 'neutral',
  suspended: 'warning',
  blocked: 'danger',
};

export default function ProfilePage() {
  const { data: session, status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: profile, isLoading } = useQuery({
    queryKey: ['issuer-profile'],
    queryFn: async () => {
      // Use mock data
      return getIssuerProfile();
    },
    enabled: status === 'authenticated',
  });

  if (status === 'loading') {
    return <div className="p-8">Загрузка...</div>;
  }

  if (!session) {
    return null;
  }

  return (
    <AppShell appName="ЛК Эмитента"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: issuerNavItems }}
    >
      <PageHeader title="Профиль компании" description="Информация об эмитенте и реквизиты" />

      {isLoading ? (
        <div className="space-y-6">
          <Skeleton className="h-48 w-full" variant="rectangular" />
          <Skeleton className="h-48 w-full" variant="rectangular" />
          <Skeleton className="h-32 w-full" variant="rectangular" />
        </div>
      ) : profile ? (
        <div className="space-y-6">
          {/* Company Info */}
          <Card>
            <CardContent className="p-6">
              <div className="flex items-start justify-between mb-6">
                <h3 className="text-lg font-semibold text-text-primary flex items-center gap-2">
                  <Building2 className="h-5 w-5 text-primary-600" />
                  Информация о компании
                </h3>
                <Badge intent={statusIntent[profile.status]}>{statusLabels[profile.status]}</Badge>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-4">
                  <div>
                    <label className="text-sm text-text-secondary">Наименование</label>
                    <p className="font-medium text-text-primary mt-1">{profile.companyName}</p>
                  </div>
                  <div>
                    <label className="text-sm text-text-secondary">ИНН</label>
                    <p className="font-mono text-text-primary mt-1">{profile.inn}</p>
                  </div>
                  <div>
                    <label className="text-sm text-text-secondary">ОГРН</label>
                    <p className="font-mono text-text-primary mt-1">{profile.ogrn}</p>
                  </div>
                  <div>
                    <label className="text-sm text-text-secondary">КПП</label>
                    <p className="font-mono text-text-primary mt-1">{profile.kpp}</p>
                  </div>
                </div>

                <div className="space-y-4">
                  <div>
                    <label className="text-sm text-text-secondary flex items-center gap-1">
                      <User className="h-4 w-4" />
                      Руководитель
                    </label>
                    <p className="font-medium text-text-primary mt-1">{profile.ceoName}</p>
                  </div>
                  <div>
                    <label className="text-sm text-text-secondary flex items-center gap-1">
                      <Mail className="h-4 w-4" />
                      Email
                    </label>
                    <p className="text-text-primary mt-1">{profile.email}</p>
                  </div>
                  <div>
                    <label className="text-sm text-text-secondary flex items-center gap-1">
                      <MapPin className="h-4 w-4" />
                      Юридический адрес
                    </label>
                    <p className="text-text-primary mt-1">{profile.address}</p>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Bank Details */}
          <Card>
            <CardContent className="p-6">
              <h3 className="text-lg font-semibold text-text-primary flex items-center gap-2 mb-6">
                <CreditCard className="h-5 w-5 text-primary-600" />
                Банковские реквизиты
              </h3>

              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div>
                  <label className="text-sm text-text-secondary">Банк</label>
                  <p className="font-medium text-text-primary mt-1">
                    {profile.bankDetails.bankName}
                  </p>
                </div>
                <div>
                  <label className="text-sm text-text-secondary">БИК</label>
                  <p className="font-mono text-text-primary mt-1">{profile.bankDetails.bik}</p>
                </div>
                <div>
                  <label className="text-sm text-text-secondary">Расчетный счет</label>
                  <p className="font-mono text-text-primary mt-1">{profile.bankDetails.account}</p>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Account Info */}
          <Card>
            <CardContent className="p-6">
              <h3 className="text-lg font-semibold text-text-primary flex items-center gap-2 mb-6">
                <CheckCircle className="h-5 w-5 text-primary-600" />
                Учетная запись
              </h3>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-4">
                  <div>
                    <label className="text-sm text-text-secondary">ID пользователя</label>
                    <p className="font-mono text-xs text-text-tertiary mt-1">{profile.id}</p>
                  </div>
                  <div>
                    <label className="text-sm text-text-secondary">Роль</label>
                    <p className="text-text-primary mt-1 capitalize">
                      {profile.role === 'issuer' ? 'Эмитент' : profile.role}
                    </p>
                  </div>
                </div>

                <div className="space-y-4">
                  <div>
                    <label className="text-sm text-text-secondary flex items-center gap-1">
                      <Calendar className="h-4 w-4" />
                      Дата регистрации
                    </label>
                    <p className="text-text-primary mt-1">
                      {new Date(profile.createdAt).toLocaleDateString('ru-RU', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                      })}
                    </p>
                  </div>
                  <div>
                    <label className="text-sm text-text-secondary">Последний вход</label>
                    <p className="text-text-primary mt-1">
                      {new Date(profile.lastLogin).toLocaleString('ru-RU', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                      })}
                    </p>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Read-only note */}
          <div className="text-sm text-text-tertiary text-center">
            Для изменения данных обратитесь в службу поддержки
          </div>
        </div>
      ) : null}
    </AppShell>
  );
}
</file>

<file path="apps/portal-issuer/src/lib/api-client.ts">
'use client';

import { getSession } from 'next-auth/react';
import { OisApiClient } from '@ois/api-client';

// Типы для создания выпуска
interface CreateIssuanceData {
  issuerId: string;
  assetId: string;
  assetCode: string;
  assetName: string;
  totalAmount: number;
  nominal: number;
  apy: number;
  issueDate: string;
  maturityDate: string;
}

const baseURL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

// Типизированная сессия
interface TypedSession {
  accessToken?: string;
  user?: {
    id?: string;
    issuerId?: string;
    roles?: string[];
  };
}

// Helper to create client with token
async function getClient(): Promise<OisApiClient> {
  const session = (await getSession()) as TypedSession | null;
  if (!session?.accessToken) {
    console.warn('[api-client] Нет активной сессии или access token');
  }
  return new OisApiClient({
    baseURL,
    accessToken: session?.accessToken || undefined,
  });
}

// SDK wrapper with NextAuth integration
export const apiClient = {
  // Issuances
  async createIssuance(data: CreateIssuanceData) {
    const client = await getClient();
    const issuance = await client.createIssuance(data);
    return { data: issuance };
  },

  async getIssuance(id: string) {
    const client = await getClient();
    const issuance = await client.getIssuance(id);
    return { data: issuance };
  },

  async publishIssuance(id: string) {
    const client = await getClient();
    const issuance = await client.publishIssuance(id);
    return { data: issuance };
  },

  async closeIssuance(id: string) {
    const client = await getClient();
    const issuance = await client.closeIssuance(id);
    return { data: issuance };
  },

  // Reports
  async getIssuerIssuancesReport(params: { issuerId: string; from?: string; to?: string }) {
    const client = await getClient();
    const { issuerId, from, to } = params;
    // SDK requires non-optional dates; fall back to empty strings to satisfy type
    const report = await client.getIssuerIssuancesReport({
      issuerId,
      from: from ?? '',
      to: to ?? '',
    });
    return { data: report };
  },

  async getIssuerPayoutsReport(params: {
    issuerId: string;
    from: string;
    to: string;
    granularity?: 'day' | 'week' | 'month' | 'year';
  }) {
    const client = await getClient();
    const report = await client.getIssuerPayoutsReport(params);
    return { data: report };
  },

  // Settlement
  async runSettlement(params?: { date?: string }) {
    const client = await getClient();
    const result = await client.runSettlement(params);
    return { data: result };
  },

  // Legacy compatibility
  getPayoutsReport: async (params: { from: string; to: string }) => {
    const client = await getClient();
    const report = await client.getPayoutsReport(params);
    return { data: report };
  },
};
</file>

<file path="packages/contracts/openapi-gateway.yaml">
openapi: 3.1.0
info:
  title: OIS Gateway API
  version: 1.0.0
  description: API Gateway для оператора информационной системы ЦФА
  contact:
    name: OIS Support
servers:
  - url: http://localhost:5000
    description: Development
  - url: https://api.ois.example.com
    description: Production

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthStatus'
  
  /issuances:
    post:
      summary: Create draft issuance
      operationId: createIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateIssuanceRequest'
      responses:
        '201':
          description: Issuance created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
  
  /issuances/{id}:
    get:
      summary: Get issuance by ID
      operationId: getIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '404':
          $ref: '#/components/responses/NotFound'
    
  /issuances/{id}/publish:
    post:
      summary: Publish issuance
      operationId: publishIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance published
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /issuances/{id}/close:
    post:
      summary: Close issuance
      operationId: closeIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance closed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/orders:
    post:
      summary: Place buy order
      operationId: placeOrder
      tags:
        - Orders
      security:
        - BearerAuth: []
      parameters:
        - name: Idempotency-Key
          in: header
          required: true
          schema:
            type: string
            format: uuid
          description: Idempotency key to prevent duplicate orders
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        '202':
          description: Order accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '409':
          description: Order with this idempotency key already exists
  
  /orders/{id}:
    get:
      summary: Get order by ID
      operationId: getOrder
      tags:
        - Orders
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/wallets/{investorId}:
    get:
      summary: Get wallet portfolio
      operationId: getWallet
      tags:
        - Wallets
      security:
        - BearerAuth: []
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Wallet portfolio
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WalletResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/redeem:
    post:
      summary: Redeem issuance
      operationId: redeemIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RedeemRequest'
      responses:
        '200':
          description: Issuance redeemed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RedeemResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/settlement/run:
    post:
      summary: Run settlement for a specific date
      operationId: runSettlement
      tags:
        - Settlement
      security:
        - BearerAuth: []
      parameters:
        - name: date
          in: query
          schema:
            type: string
            format: date
          description: Date to run settlement for (YYYY-MM-DD). Defaults to today.
      responses:
        '202':
          description: Settlement accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SettlementResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/kyc/check:
    post:
      summary: Check KYC status
      operationId: checkKyc
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycCheckRequest'
      responses:
        '200':
          description: KYC check result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/qualification/evaluate:
    post:
      summary: Evaluate qualification
      operationId: evaluateQualification
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QualificationEvaluateRequest'
      responses:
        '200':
          description: Qualification result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/investors/{id}/status:
    get:
      summary: Get investor compliance status
      operationId: getInvestorStatus
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Investor status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InvestorStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/compliance/kyc:
    get:
      summary: List KYC requests (tasks)
      operationId: listKycRequests
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: status
          in: query
          required: false
          schema:
            type: string
            enum: [pending, approved, rejected]
          description: Filter by status
      responses:
        '200':
          description: List of KYC requests
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
    post:
      summary: Submit KYC application (investor/issuer)
      operationId: submitKycApplication
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycApplicationRequest'
      responses:
        '201':
          description: KYC application created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycRequest'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/compliance/kyc/{id}/decision:
    post:
      summary: Resolve KYC request (approve/reject)
      operationId: resolveKycRequest
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: KYC task identifier
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycDecisionRequest'
      responses:
        '200':
          description: Updated KYC request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycRequest'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/complaints:
    post:
      summary: Create complaint
      operationId: createComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: Idempotency-Key
          in: header
          required: false
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateComplaintRequest'
      responses:
        '201':
          description: Complaint created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/complaints/{id}:
    get:
      summary: Get complaint
      operationId: getComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Complaint details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/reports/payouts:
    get:
      summary: Get payouts report
      operationId: getPayoutsReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Payouts report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PayoutsReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'

  /v1/market/issuances:
    get:
      summary: List market issuances
      operationId: listMarketIssuances
      tags:
        - Market
      security:
        - BearerAuth: []
      parameters:
        - name: status
          in: query
          schema:
            type: string
            enum: [open, closed, all]
            default: open
          description: Filter by status
        - name: sort
          in: query
          schema:
            type: string
            enum: [-yield, yield, -maturityDate, maturityDate, -totalAmount, totalAmount]
            default: -yield
          description: Sort order (prefix - for descending)
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
          description: Page size
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
          description: Page offset
      responses:
        '200':
          description: Market issuances list
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MarketIssuancesResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/market/issuances/{id}:
    get:
      summary: Get market issuance details
      operationId: getMarketIssuance
      tags:
        - Market
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Issuance ID
      responses:
        '200':
          description: Market issuance details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MarketIssuanceCard'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/investors/{id}/transactions:
    get:
      summary: Get investor transaction history
      operationId: getInvestorTransactions
      tags:
        - Investors
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
        - name: type
          in: query
          schema:
            type: string
            enum: [transfer, redeem, issue, all]
            default: all
          description: Filter by transaction type
      responses:
        '200':
          description: Transaction history
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TransactionHistoryResponse'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/investors/{id}/payouts:
    get:
      summary: Get investor payout history
      operationId: getInvestorPayouts
      tags:
        - Investors
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Payout history
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PayoutHistoryResponse'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/reports/issuances:
    get:
      summary: Get issuer report for issuances
      operationId: getIssuerIssuancesReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: issuerId
          in: query
          required: true
          schema:
            type: string
            format: uuid
          description: Issuer ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Issuer issuances report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuerIssuancesReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/reports/issuer/payouts:
    get:
      summary: Get issuer payouts report
      operationId: getIssuerPayoutsReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: issuerId
          in: query
          required: true
          schema:
            type: string
            format: uuid
          description: Issuer ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
        - name: granularity
          in: query
          schema:
            type: string
            enum: [day, week, month, year]
            default: month
          description: Report granularity
      responses:
        '200':
          description: Issuer payouts report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuerPayoutsReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/audit:
    get:
      summary: Get audit events
      operationId: getAuditEvents
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: actor
          in: query
          schema:
            type: string
            format: uuid
          description: Filter by actor ID
        - name: action
          in: query
          schema:
            type: string
          description: Filter by action type
        - name: entity
          in: query
          schema:
            type: string
          description: Filter by entity type
        - name: from
          in: query
          schema:
            type: string
            format: date-time
          description: Start datetime
        - name: to
          in: query
          schema:
            type: string
            format: date-time
          description: End datetime
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
          description: Page size
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
          description: Page offset
      responses:
        '200':
          description: Audit events list
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuditEventsResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/audit/export.csv:
    get:
      summary: Export audit events as CSV
      operationId: exportAuditCsv
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: actor
          in: query
          schema:
            type: string
            format: uuid
        - name: action
          in: query
          schema:
            type: string
        - name: entity
          in: query
          schema:
            type: string
        - name: from
          in: query
          schema:
            type: string
            format: date-time
        - name: to
          in: query
          schema:
            type: string
            format: date-time
      responses:
        '200':
          description: CSV export
          content:
            text/csv:
              schema:
                type: string
                format: binary
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/audit/{id}:
    get:
      summary: Get audit event by ID
      operationId: getAuditEvent
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Audit event ID
      responses:
        '200':
          description: Audit event details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuditEvent'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/identity/users:
    get:
      summary: List users (Identity registry stub)
      operationId: listIdentityUsers
      tags:
        - Identity
      parameters:
        - name: query
          in: query
          required: false
          schema:
            type: string
          description: Filter by email/role
      responses:
        '200':
          description: List of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/IdentityUser'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'


  /v1/kyc/investors/{investorId}/documents:
    get:
      summary: Get investor KYC documents
      operationId: getInvestorKycDocuments
      tags:
        - KYC Documents
      security:
        - BearerAuth: []
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
      responses:
        '200':
          description: Documents list
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycDocument'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/kyc/tasks:
    post:
      summary: Create KYC task
      operationId: createKycTask
      tags:
        - KYC Tasks
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [investorId]
              properties:
                investorId:
                  type: string
                  format: uuid
                reason:
                  type: string
      responses:
        '201':
          description: Task created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
    get:
      summary: List KYC tasks
      operationId: listKycTasks
      tags:
        - KYC Tasks
      security:
        - BearerAuth: []
      parameters:
        - name: status
          in: query
          required: false
          schema:
            type: string
            enum: [open, approved, rejected]
      responses:
        '200':
          description: Tasks list
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycTask'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/kyc/tasks/{id}/approve:
    post:
      summary: Approve KYC task
      operationId: approveKycTask
      tags:
        - KYC Tasks
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Task approved
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/kyc/tasks/{id}/reject:
    post:
      summary: Reject KYC task
      operationId: rejectKycTask
      tags:
        - KYC Tasks
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Task rejected
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycTask'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/complaints:
    post:
      summary: Create complaint
      operationId: createComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: Idempotency-Key
          in: header
          required: false
          schema:
            type: string
            format: uuid
          description: Idempotency key
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateComplaintRequest'
      responses:
        '201':
          description: Complaint created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/complaints/{id}:
    get:
      summary: Get complaint
      operationId: getComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Complaint
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/complaints/{id}/reply:
    post:
      summary: Reply to complaint
      operationId: replyComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ComplaintReplyRequest'
      responses:
        '200':
          description: Complaint updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/complaints/{id}/resolve:
    post:
      summary: Resolve complaint
      operationId: resolveComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: false
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ComplaintResolveRequest'
      responses:
        '200':
          description: Complaint resolved
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'
  /v1/kyc/documents:
    post:
      summary: Upload KYC document
      operationId: uploadKycDocument
      tags:
        - KYC Documents
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              required:
                - file
              properties:
                file:
                  type: string
                  format: binary
                investorId:
                  type: string
                  format: uuid
                documentType:
                  type: string
                  enum: [passport, inn, snils, address_proof, income_proof, other]
                comment:
                  type: string
                  description: Optional comment
      responses:
        '201':
          description: Document uploaded
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycDocument'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
    get:
      summary: List KYC documents
      operationId: listKycDocuments
      tags:
        - KYC Documents
      security:
        - BearerAuth: []
      parameters:
        - name: ids
          in: query
          required: false
          schema:
            type: array
            items:
              type: string
              format: uuid
          style: form
          explode: true
      responses:
        '200':
          description: Documents
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycDocument'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/kyc/documents/{id}:
    get:
      summary: Get KYC document metadata
      operationId: getKycDocument
      tags:
        - KYC Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Document
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycDocument'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'
    delete:
      summary: Delete KYC document
      operationId: deleteKycDocument
      tags:
        - KYC Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '204':
          description: Deleted
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/compliance/kyc/investors/{id}/approve:
    post:
      summary: Approve KYC for investor
      operationId: approveKycInvestor
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
      responses:
        '200':
          description: KYC updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/compliance/kyc/investors/{id}/reject:
    post:
      summary: Reject KYC for investor
      operationId: rejectKycInvestor
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
      responses:
        '200':
          description: KYC updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/kyc/documents/{id}/download:
    get:
      summary: Download KYC document
      operationId: downloadKycDocument
      tags:
        - KYC Documents
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: File stream
          content:
            application/octet-stream:
              schema:
                type: string
                format: binary
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  parameters:
    IssuanceId:
      name: id
      in: path
      required: true
      schema:
        type: string
        format: uuid
      description: Issuance ID
  
  schemas:
    HealthStatus:
      type: object
      properties:
        status:
          type: string
          enum: [healthy, unhealthy]
        timestamp:
          type: string
          format: date-time
    
    CreateIssuanceRequest:
      type: object
      required:
        - assetId
        - issuerId
        - totalAmount
        - nominal
        - issueDate
        - maturityDate
      properties:
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        nominal:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        scheduleJson:
          type: object
          description: Payout schedule (optional)
    
    IssuanceResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
        nominal:
          type: number
          format: decimal
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        status:
          type: string
          enum: [draft, published, closed, redeemed]
        scheduleJson:
          type: object
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    RedeemRequest:
      type: object
      required:
        - amount
      properties:
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    RedeemResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        status:
          type: string
          enum: [redeemed, partial]
        redeemedAmount:
          type: number
          format: decimal
        remainingAmount:
          type: number
          format: decimal

    # Cross-file references to service schemas
    SettlementResponse:
      $ref: 'openapi-settlement.yaml#/components/schemas/SettlementResponse'
    KycCheckRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/KycCheckRequest'
    KycResult:
      $ref: 'openapi-compliance.yaml#/components/schemas/KycResult'
    QualificationEvaluateRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/QualificationEvaluateRequest'
    QualificationResult:
      $ref: 'openapi-compliance.yaml#/components/schemas/QualificationResult'
    InvestorStatusResponse:
      $ref: 'openapi-compliance.yaml#/components/schemas/InvestorStatusResponse'
    CreateComplaintRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/CreateComplaintRequest'
    ComplaintResponse:
      $ref: 'openapi-compliance.yaml#/components/schemas/ComplaintResponse'
    
    CreateOrderRequest:
      type: object
      required:
        - investorId
        - issuanceId
        - amount
      properties:
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    OrderResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [created, reserved, paid, failed, cancelled]
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    WalletResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        ownerType:
          type: string
          enum: [individual, legal_entity]
        ownerId:
          type: string
          format: uuid
        balance:
          type: number
          format: decimal
        blocked:
          type: number
          format: decimal
        holdings:
          type: array
          items:
            $ref: '#/components/schemas/Holding'
    
    Holding:
      type: object
      properties:
        assetId:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        amount:
          type: number
          format: decimal
    
    PayoutsReportResponse:
      type: object
      properties:
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        items:
          type: array
          items:
            $ref: '#/components/schemas/PayoutItem'
        totalAmount:
          type: number
          format: decimal
    
    PayoutItem:
      type: object
      properties:
        id:
          type: string
          format: uuid
        batchId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, executed, failed]
        executedAt:
          type: string
          format: date-time

    MarketIssuanceCard:
      type: object
      properties:
        id:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        issuerName:
          type: string
        totalAmount:
          type: number
          format: decimal
        nominal:
          type: number
          format: decimal
        availableAmount:
          type: number
          format: decimal
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        yield:
          type: number
          format: decimal
          description: Annual yield percentage
        status:
          type: string
          enum: [open, closed]
        publishedAt:
          type: string
          format: date-time
        scheduleJson:
          type: object
          description: Payout schedule

    MarketIssuancesResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/MarketIssuanceCard'
        total:
          type: integer
          description: Total count
        limit:
          type: integer
        offset:
          type: integer

    TxHistoryItem:
      type: object
      properties:
        id:
          type: string
          format: uuid
        type:
          type: string
          enum: [transfer, redeem, issue]
        issuanceId:
          type: string
          format: uuid
        issuanceCode:
          type: string
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, confirmed, failed]
        dltTxHash:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        confirmedAt:
          type: string
          format: date-time
          nullable: true

    TransactionHistoryResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/TxHistoryItem'
        total:
          type: integer

    PayoutHistoryResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/PayoutItem'
        total:
          type: integer
        totalAmount:
          type: number
          format: decimal

    IssuerReportRow:
      type: object
      properties:
        issuanceId:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        totalAmount:
          type: number
          format: decimal
        soldAmount:
          type: number
          format: decimal
        investorsCount:
          type: integer
        status:
          type: string
          enum: [draft, published, closed, redeemed]
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        publishedAt:
          type: string
          format: date-time
          nullable: true

    IssuerIssuancesReportResponse:
      type: object
      properties:
        issuerId:
          type: string
          format: uuid
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        items:
          type: array
          items:
            $ref: '#/components/schemas/IssuerReportRow'
        summary:
          type: object
          properties:
            totalIssuances:
              type: integer
            totalAmount:
              type: number
              format: decimal
            totalSold:
              type: number
              format: decimal
            totalInvestors:
              type: integer

    IssuerPayoutsReportResponse:
      type: object
      properties:
        issuerId:
          type: string
          format: uuid
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        granularity:
          type: string
          enum: [day, week, month, year]
        items:
          type: array
          items:
            type: object
            properties:
              period:
                type: string
                description: Period label (depends on granularity)
              totalAmount:
                type: number
                format: decimal
              payoutCount:
                type: integer
              investorsCount:
                type: integer
        summary:
          type: object
          properties:
            totalAmount:
              type: number
              format: decimal
            totalPayouts:
              type: integer
            totalInvestors:
              type: integer

    BrokerClient:
      type: object
      required: [id, name, email, kycStatus, qualificationStatus]
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
          description: Client name
        email:
          type: string
          format: email
        inn:
          type: string
          description: Tax ID (for legal entities)
        type:
          type: string
          enum: [individual, legal_entity]
        kycStatus:
          type: string
          enum: [pending, approved, rejected]
        qualificationStatus:
          type: string
          enum: [none, qualified, unqualified]
        createdAt:
          type: string
          format: date-time
        lastActivityAt:
          type: string
          format: date-time
          nullable: true

    BrokerClientsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/BrokerClient'
        total:
          type: integer
        limit:
          type: integer
        offset:
          type: integer

    CreateBrokerOrderRequest:
      type: object
      required: [clientId, issuanceId, amount]
      properties:
        clientId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true

    BrokerOrderResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        clientId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, confirmed, failed, cancelled]
        commission:
          type: number
          format: decimal
          description: Commission amount
        createdAt:
          type: string
          format: date-time

    CommissionRow:
      type: object
      properties:
        period:
          type: string
          description: Period label (YYYY-MM or YYYY-MM-DD)
        totalAmount:
          type: number
          format: decimal
          description: Total order amount
        commissionAmount:
          type: number
          format: decimal
          description: Commission earned
        ordersCount:
          type: integer
          description: Number of orders
        clientsCount:
          type: integer
          description: Number of unique clients

    CommissionsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/CommissionRow'
        total:
          type: integer
        totalAmount:
          type: number
          format: decimal
        totalCommission:
          type: number
          format: decimal

    FeedItem:
      type: object
      required: [id, type, timestamp]
      properties:
        id:
          type: string
          format: uuid
        type:
          type: string
          enum: [order, transfer, payout, kyc, qualification]
        title:
          type: string
          description: Event title
        description:
          type: string
          description: Event description
        clientId:
          type: string
          format: uuid
          nullable: true
        clientName:
          type: string
          nullable: true
        issuanceId:
          type: string
          format: uuid
          nullable: true
        amount:
          type: number
          format: decimal
          nullable: true
        status:
          type: string
          enum: [pending, completed, failed]
          nullable: true
        timestamp:
          type: string
          format: date-time
        metadata:
          type: object
          description: Additional event data
          additionalProperties: true

    FeedResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/FeedItem'
        total:
          type: integer
        hasMore:
          type: boolean

    AuditEvent:
      type: object
      required: [id, actor, action, entity, timestamp]
      properties:
        id:
          type: string
          format: uuid
        actor:
          type: string
          format: uuid
          description: User/system that performed the action
        actorName:
          type: string
          description: Actor name or identifier
        action:
          type: string
          description: Action type (e.g., 'create', 'update', 'delete', 'approve', 'reject')
        entity:
          type: string
          description: Entity type (e.g., 'issuance', 'order', 'kyc', 'investor')
        entityId:
          type: string
          format: uuid
          nullable: true
          description: Entity ID
        payload:
          type: object
          description: Additional event data
          additionalProperties: true
        ip:
          type: string
          format: ipv4
          nullable: true
          description: IP address
        userAgent:
          type: string
          nullable: true
          description: User agent string
        timestamp:
          type: string
          format: date-time
        result:
          type: string
          enum: [success, failure, pending]
          nullable: true
          description: Action result

    AuditEventsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/AuditEvent'
        total:
          type: integer
        limit:
          type: integer
        offset:
          type: integer

    KycDecisionRequest:
      type: object
      required: [decision]
      properties:
        decision:
          type: string
          enum: [approved, rejected]
          description: KYC decision status
        comment:
          type: string
          description: Optional decision comment/reason

    KycDecisionResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [approved, rejected]
        comment:
          type: string
        decisionBy:
          type: string
          format: uuid
          description: User who made the decision
        decisionAt:
          type: string
          format: date-time

    KycApplicationRequest:
      type: object
      properties:
        investorId:
          type: string
          format: uuid
          description: Optional investorId; will default to authenticated user
        fullName:
          type: string
          description: Full name of applicant
        documentType:
          type: string
          description: Document type (passport/inn/other)
        documentNumber:
          type: string
          description: Document number
        comment:
          type: string
          description: Additional comment for backoffice

    KycRequest:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [pending, approved, rejected]
        reason:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        resolvedAt:
          type: string
          format: date-time
          nullable: true
    KycDocument:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        documentType:
          type: string
          enum: [passport, inn, snils, address_proof, income_proof, other]
        fileName:
          type: string
        fileSize:
          type: integer
          description: File size in bytes
        mimeType:
          type: string
        storageUrl:
          type: string
          format: uri
          description: S3/MinIO storage URL
        uploadedAt:
          type: string
          format: date-time
        uploadedBy:
          type: string
          format: uuid
        comment:
          type: string
          nullable: true

    KycDocumentsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/KycDocument'
        total:
          type: integer

    IdentityUser:
      type: object
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        roles:
          type: array
          items:
            type: string
        status:
          type: string
          description: User status (active/blocked/invited)
        createdAt:
          type: string
          format: date-time
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
          example:
            type: "https://tools.ietf.org/html/rfc7807"
            title: "Bad Request"
            status: 400
            detail: "Invalid request parameters"
    
    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    Forbidden:
      description: Forbidden
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
</file>

<file path="apps/backoffice/src/app/api/proxy/route.ts">
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { NextResponse } from 'next/server';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

// Whitelist of allowed API paths to prevent SSRF
const ALLOWED_PATH_PREFIXES = [
  '/v1/kyc/',
  '/v1/qualification/',
  '/v1/audit/',
  '/v1/complaints/',
  '/v1/identity/',
  '/v1/payouts/',
  '/v1/issuances/',
  '/v1/investors/',
];

function isPathAllowed(path: string): boolean {
  return ALLOWED_PATH_PREFIXES.some(prefix => path.startsWith(prefix));
}

// Extended session type to include accessToken
interface SessionWithToken {
  user?: {
    name?: string | null;
    email?: string | null;
    image?: string | null;
    roles?: string[];
  };
  accessToken?: string;
}

function buildHeaders(session: SessionWithToken): Record<string, string> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  if (session.accessToken) {
    headers['Authorization'] = `Bearer ${session.accessToken}`;
  }

  return headers;
}

async function handleResponse(response: Response): Promise<NextResponse> {
  const contentType = response.headers.get('content-type');

  if (contentType?.includes('application/json')) {
    try {
      const data = await response.json();
      return NextResponse.json(data, { status: response.status });
    } catch {
      return NextResponse.json({ error: 'Некорректный JSON ответ от сервера' }, { status: 502 });
    }
  }

  // Для бинарных/файловых ответов проксируем поток тела как есть
  return new NextResponse(response.body, {
    status: response.status,
    headers: {
      'Content-Type': contentType || 'application/octet-stream',
      ...(response.headers.get('content-disposition')
        ? { 'Content-Disposition': response.headers.get('content-disposition') as string }
        : {}),
    },
  });
}

async function handleProxyRequest(request: Request, method: 'GET' | 'POST'): Promise<NextResponse> {
  const session = (await getServerSession(authOptions)) as SessionWithToken | null;

  if (!session) {
    return NextResponse.json({ error: 'Не авторизован' }, { status: 401 });
  }

  const url = new URL(request.url);
  const path = url.searchParams.get('path') || '';

  if (!path || !isPathAllowed(path)) {
    return NextResponse.json({ error: 'Недопустимый путь API' }, { status: 400 });
  }

  // Parse body for POST requests
  let body: string | undefined;
  if (method === 'POST') {
    try {
      const jsonBody = await request.json();
      body = JSON.stringify(jsonBody);
    } catch {
      return NextResponse.json({ error: 'Некорректное тело запроса' }, { status: 400 });
    }
  }

  try {
    const response = await fetch(`${API_BASE}${path}`, {
      method,
      headers: buildHeaders(session),
      body,
    });

    return handleResponse(response);
  } catch (error) {
    console.error('Ошибка проксирования запроса:', error);
    return NextResponse.json({ error: 'Ошибка выполнения API запроса' }, { status: 500 });
  }
}

export async function GET(request: Request) {
  return handleProxyRequest(request, 'GET');
}

export async function POST(request: Request) {
  return handleProxyRequest(request, 'POST');
}
</file>

<file path="apps/backoffice/src/app/audit/[id]/page.tsx">
'use client';

import { useQuery } from '@tanstack/react-query';
import { getAuditEvent } from '@/lib/api/audit';
import type { AuditEvent } from '@/lib/api/audit';
import {
  AppShell,
  PageHeader,
  EmptyState,
  Skeleton,
  Button,
  Card,
  CardContent,
} from '@ois/shared-ui';
import { useSession } from 'next-auth/react';
import { useRouter, useParams } from 'next/navigation';
import { useEffect } from 'react';
import Link from 'next/link';
import { ArrowLeft } from 'lucide-react';
import { SIDEBAR_CONFIG } from '@/lib/constants';

export default function AuditEventDetailPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const params = useParams();
  const eventId = params.id as string;

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: event, isLoading } = useQuery<AuditEvent | null>({
    queryKey: ['audit-event', eventId],
    queryFn: () => getAuditEvent(eventId),
    enabled: !!eventId && status === 'authenticated',
  });

  if (status === 'loading') {
    return <div className="p-8">Загрузка...</div>;
  }

  if (!session) {
    return null;
  }

  if (isLoading) {
    return (
      <AppShell user={session.user} sidebar={SIDEBAR_CONFIG}>
        <Skeleton className="h-64 w-full" variant="rectangular" />
      </AppShell>
    );
  }

  if (!event) {
    return (
      <AppShell user={session.user} sidebar={SIDEBAR_CONFIG}>
        <EmptyState
          title="Событие не найдено"
          description="Запрашиваемое событие аудита не существует"
        />
      </AppShell>
    );
  }

  return (
    <AppShell user={session.user} sidebar={SIDEBAR_CONFIG}>
      <PageHeader
        title={`Событие ${eventId.slice(0, 8)}`}
        description="Детали события аудита"
        breadcrumbs={[{ label: 'Аудит', href: '/audit' }, { label: eventId.slice(0, 8) }]}
        actions={
          <Button asChild variant="secondary">
            <Link href="/audit" className="flex items-center gap-2">
              <ArrowLeft className="h-4 w-4" />
              Назад
            </Link>
          </Button>
        }
      />

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <CardContent className="p-6">
            <h2 className="text-lg font-semibold text-text-primary mb-4">Информация о событии</h2>
            <EventInfoList event={event} />
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <h2 className="text-lg font-semibold text-text-primary mb-4">Детали запроса</h2>
            <RequestDetailsSection event={event} />
          </CardContent>
        </Card>
      </div>

      {event.payload && Object.keys(event.payload).length > 0 && (
        <Card className="mt-6">
          <CardContent className="p-6">
            <h2 className="text-lg font-semibold text-text-primary mb-4">Данные</h2>
            <pre className="bg-background p-4 rounded-md overflow-auto text-sm text-text-primary font-mono">
              {JSON.stringify(event.payload, null, 2)}
            </pre>
          </CardContent>
        </Card>
      )}
    </AppShell>
  );
}

function EventInfoList({ event }: { event: AuditEvent }) {
  return (
    <div className="space-y-3 text-sm">
      <InfoRow label="Идентификатор" value={event.id} mono />
      <InfoRow label="Время" value={new Date(event.timestamp).toLocaleString()} />
      <InfoRow label="Актор" value={event.actorName || event.actor} />
      <InfoRow label="Действие" value={event.action} bold />
      <InfoRow label="Сущность" value={event.entity} />
      {event.entityId && <InfoRow label="ID сущности" value={event.entityId} mono />}
      {event.result && <InfoRow label="Результат" value={event.result} />}
    </div>
  );
}

function RequestDetailsSection({ event }: { event: AuditEvent }) {
  return (
    <div className="space-y-3 text-sm">
      {event.ip && <InfoRow label="IP-адрес" value={event.ip} mono />}
      {event.userAgent && (
        <div className="flex flex-col">
          <span className="text-text-secondary mb-1">User Agent:</span>
          <span className="text-text-primary text-xs break-all">{event.userAgent}</span>
        </div>
      )}
    </div>
  );
}

function InfoRow({
  label,
  value,
  mono,
  bold,
}: {
  label: string;
  value: string;
  mono?: boolean;
  bold?: boolean;
}) {
  return (
    <div className="flex justify-between">
      <span className="text-text-secondary">{label}:</span>
      <span className={`text-text-primary ${mono ? 'font-mono' : ''} ${bold ? 'font-medium' : ''}`}>
        {value}
      </span>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/app/kyc/components/KycDetails.tsx">
'use client';

import { useState } from 'react';
import { Card, CardContent, Badge, Button } from '@ois/shared-ui';
import { KycTask, KycDocument } from '@/lib/api/compliance';
import { FileText, CheckCircle, XCircle } from 'lucide-react';
import { getStatusBadgeIntent } from '@/lib/constants';
import { DocumentItem } from './DocumentItem';
import { DocumentPreviewModal } from './DocumentPreviewModal';

interface KycDetailsProps {
  request: KycTask;
  documents: KycDocument[];
  onApprove: (id: string, comment: string) => void;
  onReject: (id: string, comment: string) => void;
  onCancel: () => void;
  isSubmitting: boolean;
}

export function KycDetails({
  request,
  documents,
  onApprove,
  onReject,
  onCancel,
  isSubmitting,
}: KycDetailsProps) {
  const [comment, setComment] = useState('');
  const [previewDoc, setPreviewDoc] = useState<KycDocument | null>(null);

  return (
    <Card>
      <CardContent className="p-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-text-primary">
            Заявка от {request.investorId}
          </h2>
          <Badge intent={getStatusBadgeIntent(request.status)}>{request.status}</Badge>
        </div>

        {/* Documents Section */}
        <div className="space-y-3">
          <div className="flex items-center justify-between">
            <h3 className="text-sm font-medium text-text-secondary">Документы</h3>
            <span className="text-xs text-text-tertiary">{documents.length} файл(ов)</span>
          </div>
          {documents.length > 0 ? (
            <div className="grid grid-cols-1 gap-3">
              {documents.map(doc => (
                <DocumentItem key={doc.id} document={doc} onPreview={setPreviewDoc} />
              ))}
            </div>
          ) : (
            <div className="rounded-lg border border-dashed border-border p-8 text-center">
              <FileText className="h-10 w-10 text-text-tertiary mx-auto mb-2" />
              <p className="text-sm text-text-tertiary">Нет прикрепленных документов</p>
            </div>
          )}
        </div>

        {/* Document Preview Modal */}
        <DocumentPreviewModal document={previewDoc} onClose={() => setPreviewDoc(null)} />

        {/* Reason */}
        {request.reason && (
          <div className="rounded-md bg-warning-50 p-4 border border-warning-200">
            <h3 className="text-sm font-medium text-warning-800 mb-2">Комментарий</h3>
            <p className="text-sm text-warning-700">{request.reason}</p>
          </div>
        )}

        {/* Decision Form */}
        <div className="space-y-3 pt-4 border-t border-border">
          <h3 className="text-sm font-medium text-text-secondary">Решение</h3>
          <textarea
            className="w-full rounded-md border border-border bg-surface px-3 py-2 text-sm text-text-primary placeholder:text-text-tertiary focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
            placeholder="Комментарий к решению..."
            rows={3}
            value={comment}
            onChange={e => setComment(e.target.value)}
          />
          <div className="flex gap-2">
            <Button
              variant="primary"
              disabled={isSubmitting}
              onClick={() => onApprove(request.id, comment)}
              className="bg-success-600 hover:bg-success-700"
            >
              <CheckCircle className="mr-2 h-4 w-4" />
              Одобрить
            </Button>
            <Button
              variant="danger"
              disabled={isSubmitting}
              onClick={() => onReject(request.id, comment)}
            >
              <XCircle className="mr-2 h-4 w-4" />
              Отклонить
            </Button>
            <Button variant="ghost" onClick={onCancel}>
              Отмена
            </Button>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/portal-investor/src/app/auth/signin/page.tsx">
'use client';

import { Suspense, useEffect, useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Badge, Button, Card, Input, Spinner } from '@ois/shared-ui';
import { Building2, Lock, User } from 'lucide-react';
import { toast } from 'sonner';

function KeycloakButton({ callbackUrl }: { callbackUrl: string }) {
  const [loading, setLoading] = useState(false);

  const handleKeycloakSignIn = async () => {
    setLoading(true);
    try {
      await signIn('keycloak', { callbackUrl });
    } catch {
      toast.error('Ошибка входа через Keycloak');
      setLoading(false);
    }
  };

  return (
    <Button
      type="button"
      variant="secondary"
      className="w-full"
      onClick={handleKeycloakSignIn}
      loading={loading}
    >
      <svg className="mr-2 h-5 w-5" viewBox="0 0 24 24" fill="currentColor">
        <path d="M11.5 0L0 6v12l11.5 6L23 18V6L11.5 0zm7.8 17.2l-7.8 4.1-7.8-4.1V6.8l7.8-4.1 7.8 4.1v10.4z" />
      </svg>
      Войти через Keycloak
    </Button>
  );
}

function SignInContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get('callbackUrl') || '/portfolio';
  const [email, setEmail] = useState('investor@demo.local');
  const [password, setPassword] = useState('demo123');
  const [showPassword, setShowPassword] = useState(false);
  const [remember, setRemember] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const error = searchParams.get('error');

  useEffect(() => {
    if (error === 'OAuthSignin') {
      toast.error('Ошибка входа: OAuthSignin. Проверьте доступность Keycloak.');
    }
  }, [error]);

  const handleMockLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    try {
      const result = await signIn('credentials', {
        email,
        password,
        redirect: false,
        callbackUrl,
      });
      if (result?.error) {
        toast.error('Неверные учетные данные');
        setIsSubmitting(false);
        return;
      }
      router.push(callbackUrl);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Ошибка входа';
      toast.error(message);
      setIsSubmitting(false);
    }
  };

  return (
    <div className="relative min-h-screen bg-gradient-to-br from-primary-50 via-background to-surface px-4 py-8">
      <div className="mx-auto max-w-3xl">
        <Card className="p-6 lg:p-8 shadow-lg border-border/70 max-w-2xl mx-auto">
          <div className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-3">
              <div className="h-10 w-10 rounded-lg bg-primary-100 text-primary-700 flex items-center justify-center">
                <Building2 className="h-5 w-5" />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-text-primary">Вход для инвесторов</h1>
                <p className="text-sm text-text-secondary">Доступ к портфелю и сделкам</p>
              </div>
            </div>
            <Badge intent="info">Dev</Badge>
          </div>

          <KeycloakButton callbackUrl={callbackUrl} />

          <div className="relative my-6">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-border" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-surface text-text-tertiary">или mock-аккаунт</span>
            </div>
          </div>

          <form onSubmit={handleMockLogin} className="space-y-4">
            <Input
              label="Email"
              inputSize="lg"
              leftIcon={<User className="h-4 w-4 text-text-tertiary" />}
              value={email}
              onChange={e => setEmail(e.target.value)}
              autoComplete="email"
            />
            <Input
              label="Пароль"
              inputSize="lg"
              type={showPassword ? 'text' : 'password'}
              leftIcon={<Lock className="h-4 w-4 text-text-tertiary" />}
              value={password}
              onChange={e => setPassword(e.target.value)}
              autoComplete="current-password"
              rightIcon={
                <button
                  type="button"
                  aria-label={showPassword ? 'Скрыть пароль' : 'Показать пароль'}
                  className="text-xs font-medium text-primary-600 hover:text-primary-700"
                  onClick={() => setShowPassword(prev => !prev)}
                >
                  {showPassword ? 'Скрыть' : 'Показать'}
                </button>
              }
            />

            <div className="flex items-center justify-between text-sm text-text-secondary">
              <label className="flex items-center gap-2 cursor-pointer select-none">
                <input
                  type="checkbox"
                  className="accent-primary-600"
                  checked={remember}
                  onChange={e => setRemember(e.target.checked)}
                />
                Запомнить сессию
              </label>
              <button
                type="button"
                className="text-primary-600 hover:text-primary-700"
                onClick={() => toast.info('Обратитесь к администратору для сброса пароля')}
              >
                Забыли пароль?
              </button>
            </div>

            <Button
              type="submit"
              variant="primary"
              size="lg"
              className="w-full"
              disabled={isSubmitting}
            >
              {isSubmitting ? 'Входим...' : 'Войти в портал'}
            </Button>
          </form>

          <div className="mt-6 rounded-lg border border-dashed border-border bg-surface-alt p-4 text-sm text-text-secondary">
            <div className="flex items-center justify-between">
              <div>
                <p className="font-semibold text-text-primary">Демо доступ</p>
                <p className="text-xs text-text-tertiary">
                  Используйте mock-данные для быстрого входа
                </p>
              </div>
              <Badge intent="neutral">Mock</Badge>
            </div>
            <div className="mt-3 grid grid-cols-2 gap-3 text-sm">
              <div className="rounded-md bg-background p-3 border border-border">
                <p className="text-text-tertiary text-xs">Инвестор</p>
                <p className="text-text-primary font-medium">investor@demo.local / demo123</p>
              </div>
              <div className="rounded-md bg-background p-3 border border-border">
                <p className="text-text-tertiary text-xs">Роль</p>
                <p className="text-text-primary font-medium">investor</p>
              </div>
            </div>
          </div>
        </Card>
      </div>
    </div>
  );
}

export default function SignInPage() {
  return (
    <Suspense
      fallback={
        <div className="min-h-screen flex items-center justify-center">
          <Spinner size="lg" />
        </div>
      }
    >
      <SignInContent />
    </Suspense>
  );
}
</file>

<file path="apps/portal-investor/src/app/profile/page.tsx">
'use client';

import { useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { signOut, useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { apiClient } from '@/lib/api-client';
import {
  AppShell,
  PageHeader,
  Card,
  CardContent,
  Badge,
  Skeleton,
  EmptyState,
} from '@ois/shared-ui';
import { investorNavItems } from '@/lib/navigation';

const statusIntentMap: Record<string, 'success' | 'warning' | 'danger' | 'neutral'> = {
  pass: 'success',
  qualified: 'success',
  professional: 'success',
  pending: 'warning',
  review: 'warning',
  not_started: 'neutral',
  unqualified: 'danger',
  fail: 'danger',
};

export default function ProfilePage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const investorId = (session?.user as any)?.id;

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const {
    data: compliance,
    isLoading,
    error,
  } = useQuery({
    queryKey: ['investor-status', investorId],
    queryFn: async () => {
      const response = await apiClient.getInvestorStatus(investorId);
      return response.data;
    },
    enabled: status === 'authenticated' && Boolean(investorId),
  });

  if (status === 'loading') {
    return <div className="p-8">Загрузка...</div>;
  }

  if (!session) {
    return null;
  }

  return (
    <AppShell
      appName="ЛК Инвестора"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: investorNavItems }}
    >
      <PageHeader
        title="Профиль инвестора"
        description="Статус KYC, квалификация и контактные данные"
      />

      {isLoading && (
        <div className="space-y-4">
          <Skeleton className="h-24 w-full" variant="rectangular" />
          <Skeleton className="h-24 w-full" variant="rectangular" />
        </div>
      )}

      {!isLoading && error && (
        <EmptyState
          title="Не удалось загрузить данные"
          description="Проверьте подключение и повторите попытку"
        />
      )}

      {!isLoading && !error && (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <Card>
            <CardContent className="p-6 space-y-4">
              <div>
                <p className="text-sm text-text-secondary">Инвестор ID</p>
                <p className="text-lg font-semibold text-text-primary font-mono">{investorId}</p>
              </div>
              <div>
                <p className="text-sm text-text-secondary">Email</p>
                <p className="text-lg font-semibold text-text-primary">
                  {session.user?.email || '—'}
                </p>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6 space-y-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-text-secondary">KYC статус</p>
                  <div className="flex items-center gap-2">
                    <Badge intent={statusIntentMap[compliance?.kyc || 'neutral'] || 'neutral'}>
                      {compliance?.kyc || 'unknown'}
                    </Badge>
                  </div>
                </div>
                <div>
                  <p className="text-sm text-text-secondary">Квалификация</p>
                  <Badge
                    intent={
                      statusIntentMap[compliance?.qualificationTier || 'neutral'] || 'neutral'
                    }
                  >
                    {compliance?.qualificationTier || 'unknown'}
                  </Badge>
                </div>
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <p className="text-sm text-text-secondary">Лимит</p>
                  <p className="text-lg font-semibold text-text-primary">
                    {compliance?.qualificationLimit
                      ? `₽${Number(compliance.qualificationLimit).toLocaleString()}`
                      : '—'}
                  </p>
                </div>
                <div>
                  <p className="text-sm text-text-secondary">Использовано</p>
                  <p className="text-lg font-semibold text-text-primary">
                    {compliance?.qualificationUsed
                      ? `₽${Number(compliance.qualificationUsed).toLocaleString()}`
                      : '—'}
                  </p>
                </div>
              </div>
              <p className="text-sm text-text-tertiary">
                Обновлено:{' '}
                {(compliance as any)?.updatedAt
                  ? new Date((compliance as any).updatedAt).toLocaleString('ru-RU')
                  : '—'}
              </p>
            </CardContent>
          </Card>
        </div>
      )}
    </AppShell>
  );
}
</file>

<file path="apps/portal-issuer/src/app/auth/signin/page.tsx">
'use client';

import { useState, Suspense } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Badge, Button, Card, Input, Spinner } from '@ois/shared-ui';
import { Building2, Lock, User } from 'lucide-react';
import { toast } from 'sonner';

function KeycloakButton({ callbackUrl }: { callbackUrl: string }) {
  const [loading, setLoading] = useState(false);

  const handleKeycloakSignIn = async () => {
    setLoading(true);
    try {
      await signIn('keycloak', { callbackUrl });
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Ошибка входа через Keycloak';
      toast.error(message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button
      type="button"
      variant="secondary"
      className="w-full"
      onClick={handleKeycloakSignIn}
      loading={loading}
    >
      <svg className="mr-2 h-5 w-5" viewBox="0 0 24 24" fill="currentColor">
        <path d="M11.5 0L0 6v12l11.5 6L23 18V6L11.5 0zm7.8 17.2l-7.8 4.1-7.8-4.1V6.8l7.8-4.1 7.8 4.1v10.4z" />
      </svg>
      Войти через Keycloak
    </Button>
  );
}

export default function SignInPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  // Валидация callbackUrl для предотвращения Open Redirect
  const rawCallbackUrl = searchParams.get('callbackUrl') || '/dashboard';
  const callbackUrl = rawCallbackUrl.startsWith('/') ? rawCallbackUrl : '/dashboard';

  const [email, setEmail] = useState('issuer@demo.local');
  const [password, setPassword] = useState('demo123');
  const [showPassword, setShowPassword] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleMockLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    try {
      const result = await signIn('credentials', {
        email,
        password,
        redirect: false,
      });
      if (result?.error) {
        toast.error('Неверные учетные данные');
        setIsSubmitting(false);
        return;
      }
      router.push(callbackUrl);
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Ошибка входа';
      toast.error(message);
      setIsSubmitting(false);
    }
  };

  return (
    <div className="relative min-h-screen bg-gradient-to-br from-primary-50 via-background to-surface px-4 py-8">
      <div className="mx-auto max-w-3xl">
        <Card className="p-6 lg:p-8 shadow-lg border-border/70 max-w-2xl mx-auto">
          <div className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-3">
              <div className="h-10 w-10 rounded-lg bg-primary-100 text-primary-700 flex items-center justify-center">
                <Building2 className="h-5 w-5" />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-text-primary">Вход для эмитентов</h1>
                <p className="text-sm text-text-secondary">
                  Доступ к управлению выпусками и отчетам
                </p>
              </div>
            </div>
            <Badge intent="info">Dev</Badge>
          </div>

          <Suspense fallback={<Spinner size="md" className="mx-auto" />}>
            <KeycloakButton callbackUrl={callbackUrl} />
          </Suspense>

          <div className="relative my-6">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-border" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-surface text-text-tertiary">или mock-аккаунт</span>
            </div>
          </div>

          <form onSubmit={handleMockLogin} className="space-y-4">
            <Input
              label="Email"
              inputSize="lg"
              leftIcon={<User className="h-4 w-4 text-text-tertiary" />}
              value={email}
              onChange={e => setEmail(e.target.value)}
              autoComplete="email"
            />
            <Input
              label="Пароль"
              inputSize="lg"
              type={showPassword ? 'text' : 'password'}
              leftIcon={<Lock className="h-4 w-4 text-text-tertiary" />}
              value={password}
              onChange={e => setPassword(e.target.value)}
              autoComplete="current-password"
              rightIcon={
                <button
                  type="button"
                  aria-label={showPassword ? 'Скрыть пароль' : 'Показать пароль'}
                  className="text-xs font-medium text-primary-600 hover:text-primary-700"
                  onClick={() => setShowPassword(prev => !prev)}
                >
                  {showPassword ? 'Скрыть' : 'Показать'}
                </button>
              }
            />

            <div className="flex items-center justify-end text-sm text-text-secondary">
              <button
                type="button"
                className="text-primary-600 hover:text-primary-700"
                onClick={() => toast.info('Обратитесь к администратору для сброса пароля')}
              >
                Забыли пароль?
              </button>
            </div>

            <Button
              type="submit"
              variant="primary"
              size="lg"
              className="w-full"
              disabled={isSubmitting}
            >
              {isSubmitting ? 'Входим...' : 'Войти в портал'}
            </Button>
          </form>

          <div className="mt-6 rounded-lg border border-dashed border-border bg-surface-alt p-4 text-sm text-text-secondary">
            <div className="flex items-center justify-between">
              <div>
                <p className="font-semibold text-text-primary">Демо доступ</p>
                <p className="text-xs text-text-tertiary">
                  Используйте mock-данные для быстрого входа
                </p>
              </div>
              <Badge intent="neutral">Mock</Badge>
            </div>
            <div className="mt-3 grid grid-cols-2 gap-3 text-sm">
              <div className="rounded-md bg-background p-3 border border-border">
                <p className="text-text-tertiary text-xs">Эмитент</p>
                <p className="text-text-primary font-medium">issuer@demo.local / demo123</p>
              </div>
              <div className="rounded-md bg-background p-3 border border-border">
                <p className="text-text-tertiary text-xs">Роль</p>
                <p className="text-text-primary font-medium">issuer</p>
              </div>
            </div>
          </div>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="apps/portal-issuer/src/app/issuances/create/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { signOut, useSession } from 'next-auth/react';
import { z } from 'zod';
import { toast } from 'sonner';
import { AppShell, PageHeader, Button, Card, CardContent, Input } from '@ois/shared-ui';
import { ArrowLeft, Save } from 'lucide-react';
import { createIssuance, MOCK_ISSUER_ID } from '@/lib/mocks/issuances';
import { issuerNavItems } from '@/lib/navigation';

const createIssuanceSchema = z.object({
  assetId: z.string().uuid('ID актива должен быть UUID'),
  issuerId: z.string().uuid('ID эмитента должен быть UUID'),
  totalAmount: z.number().positive('Сумма должна быть положительной'),
  nominal: z.number().positive('Номинал должен быть положительным'),
  issueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Неверный формат даты'),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Неверный формат даты'),
});

export default function CreateIssuancePage() {
  const router = useRouter();
  const queryClient = useQueryClient();
  const { data: session, status } = useSession();

  const [formData, setFormData] = useState({
    assetId: '',
    issuerId: MOCK_ISSUER_ID,
    totalAmount: '',
    nominal: '',
    issueDate: '',
    maturityDate: '',
  });

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const mutation = useMutation({
    mutationFn: async (data: z.infer<typeof createIssuanceSchema>) => {
      // Use mock function
      return createIssuance(data);
    },
    onSuccess: data => {
      toast.success('Выпуск успешно создан');
      queryClient.invalidateQueries({ queryKey: ['issuances'] });
      router.push(`/issuances/${data.id}`);
    },
    onError: (error: unknown) => {
      const message = error instanceof Error ? error.message : 'Не удалось создать выпуск';
      toast.error(message);
    },
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      const validated = createIssuanceSchema.parse({
        ...formData,
        totalAmount: parseFloat(formData.totalAmount),
        nominal: parseFloat(formData.nominal),
      });

      mutation.mutate(validated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        toast.error(error.errors[0].message);
      }
    }
  };

  // Generate random UUID for asset
  const generateAssetId = () => {
    const uuid = crypto.randomUUID();
    setFormData({ ...formData, assetId: uuid });
  };

  if (status === 'loading') {
    return <div className="p-8">Загрузка...</div>;
  }

  if (!session) {
    return null;
  }

  return (
    <AppShell
      appName="ЛК Эмитента"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: issuerNavItems }}
    >
      <PageHeader
        title="Создание выпуска"
        description="Заполните данные для создания нового выпуска"
        breadcrumbs={[{ label: 'Выпуски', href: '/issuances' }, { label: 'Создание' }]}
        actions={
          <Button variant="secondary" onClick={() => router.back()}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Назад
          </Button>
        }
      />

      <div className="max-w-2xl">
        <Card>
          <CardContent className="p-6">
            <form onSubmit={handleSubmit} className="space-y-6">
              <div className="space-y-2">
                <div className="flex gap-2 items-end">
                  <Input
                    label="ID актива *"
                    value={formData.assetId}
                    onChange={e => setFormData({ ...formData, assetId: e.target.value })}
                    placeholder="UUID актива"
                    required
                  />
                  <Button type="button" variant="secondary" onClick={generateAssetId}>
                    Сгенерировать
                  </Button>
                </div>
                <p className="text-xs text-text-tertiary">UUID идентификатор актива ЦФА</p>
              </div>

              <Input
                label="ID эмитента *"
                value={formData.issuerId}
                onChange={e => setFormData({ ...formData, issuerId: e.target.value })}
                placeholder="UUID эмитента"
                required
              />

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <Input
                  label="Общая сумма (₽) *"
                  type="number"
                  step="0.01"
                  min="0"
                  value={formData.totalAmount}
                  onChange={e => setFormData({ ...formData, totalAmount: e.target.value })}
                  placeholder="100000000"
                  required
                />

                <Input
                  label="Номинал (₽) *"
                  type="number"
                  step="0.01"
                  min="0"
                  value={formData.nominal}
                  onChange={e => setFormData({ ...formData, nominal: e.target.value })}
                  placeholder="1000"
                  required
                />
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <Input
                  label="Дата выпуска *"
                  type="date"
                  value={formData.issueDate}
                  onChange={e => setFormData({ ...formData, issueDate: e.target.value })}
                  required
                />

                <Input
                  label="Дата погашения *"
                  type="date"
                  value={formData.maturityDate}
                  onChange={e => setFormData({ ...formData, maturityDate: e.target.value })}
                  required
                />
              </div>

              <div className="flex gap-4 pt-4 border-t border-border">
                <Button type="submit" variant="primary" disabled={mutation.isPending}>
                  <Save className="h-4 w-4 mr-2" />
                  {mutation.isPending ? 'Создание...' : 'Создать черновик'}
                </Button>
                <Button type="button" variant="secondary" onClick={() => router.back()}>
                  Отмена
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>
      </div>
    </AppShell>
  );
}
</file>

<file path="apps/backoffice/src/app/kyc/components/QualificationList.tsx">
'use client';

import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { listQualificationTasks, listKycDocuments } from '@/lib/api/compliance';
import { Button, Card, CardContent, Skeleton } from '@ois/shared-ui';
import { getStatusLabel } from '@/lib/constants';
import { useQualificationMutations } from '../hooks/useQualificationMutations';
import { QualificationTaskItem } from './QualificationTaskItem';
import { QualificationDetailsPanel } from './QualificationDetailsPanel';

const STATUSES = ['open', 'approved', 'rejected'] as const;
type Status = (typeof STATUSES)[number];

export function QualificationList() {
  const [activeStatus, setActiveStatus] = useState<Status>('open');
  const [selectedId, setSelectedId] = useState<string | null>(null);

  const { data: tasks, isLoading } = useQuery({
    queryKey: ['qualification-tasks', activeStatus],
    queryFn: () => listQualificationTasks(activeStatus),
  });

  const selected = tasks?.find(task => task.id === selectedId);

  const { data: documents = [] } = useQuery({
    queryKey: ['kyc-documents', selected?.investorId],
    queryFn: () => listKycDocuments(selected!.investorId),
    enabled: !!selected?.investorId,
  });

  const { approveMutation, rejectMutation, isSubmitting } = useQualificationMutations(() => {
    setSelectedId(null);
  });

  const handleStatusChange = (status: Status) => {
    setActiveStatus(status);
    setSelectedId(null);
  };

  return (
    <div className="space-y-6">
      {/* Status Filter */}
      <div className="flex items-center gap-2">
        {STATUSES.map(status => (
          <Button
            key={status}
            onClick={() => handleStatusChange(status)}
            variant={activeStatus === status ? 'primary' : 'secondary'}
            size="sm"
          >
            {getStatusLabel(status)}
          </Button>
        ))}
      </div>

      <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
        {/* List Panel */}
        <Card>
          <CardContent className="p-0">
            <div className="divide-y divide-border">
              {isLoading && (
                <div className="p-4 space-y-2">
                  <Skeleton className="h-12 w-full" />
                  <Skeleton className="h-12 w-full" />
                </div>
              )}
              {!isLoading && tasks?.length === 0 && (
                <div className="p-8 text-center text-text-tertiary">Нет заявок в этом статусе</div>
              )}
              {tasks?.map(task => (
                <QualificationTaskItem
                  key={task.id}
                  task={task}
                  isSelected={selectedId === task.id}
                  onClick={() => setSelectedId(task.id)}
                />
              ))}
            </div>
          </CardContent>
        </Card>

        {/* Details Panel */}
        {selected ? (
          <QualificationDetailsPanel
            task={selected}
            documents={documents}
            onApprove={approveMutation.mutate}
            onReject={rejectMutation.mutate}
            isSubmitting={isSubmitting}
          />
        ) : (
          <div className="hidden lg:flex items-center justify-center rounded-lg border-2 border-dashed border-border p-12 text-text-tertiary">
            Выберите заявку для просмотра
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="apps/backoffice/src/lib/api/compliance.ts">
/**
 * Compliance API Client
 * @deprecated Import from '@/lib/api/compliance/' instead
 *
 * This file re-exports from the new modular structure for backward compatibility.
 */

// export type KycRequest = {
//   id: string;
//   investorId: string;
//   status: 'pending' | 'approved' | 'rejected';
//   createdAt: string;
//   resolvedAt?: string;
//   reason?: string | null;
//   amlFlags?: string[];
//   documents?: Array<{ id: string; name: string; url?: string }>;
// };

// export type UserRecord = {
//   id: string;
//   email: string;
//   roles: string[];
//   status: 'active' | 'blocked' | 'invited';
//   createdAt: string;
// };

// async function call<T>(path: string, init?: RequestInit): Promise<T> {
//   const response = await fetch(`${API_BASE}${path}`, {
//     ...init,
//     headers: {
//       'Content-Type': 'application/json',
//       ...(init?.headers ?? {}),
//     },
//     cache: 'no-store',
//   });

//   if (!response.ok) {
//     throw new Error(`Compliance API error: ${response.status}`);
//   }

//   return (await response.json()) as T;
// }

// export async function listKycRequests(status?: string): Promise<KycRequest[]> {
//   const query = status ? `?status=${status}` : '';
//   return await call<KycRequest[]>(`/v1/compliance/kyc${query}`).catch(() => {
//     if (!COMPLIANCE_MOCK_MODE) throw new Error('KYC list unavailable');
//     return [
//       {
//         id: 'mock-kyc-1',
//         investorId: 'investor-001',
//         status: 'pending',
//         createdAt: new Date().toISOString(),
//         reason: 'mock application',
//         amlFlags: ['PEP'],
//       },
//     ];
//   });
// }

// export async function submitKycDecision(
//   id: string,
//   decision: 'approved' | 'rejected',
//   comment?: string,
// ): Promise<void> {
//   await call(`/v1/compliance/kyc/${id}/decision`, {
//     method: 'POST',
//     body: JSON.stringify({ decision, comment }),
//   });
// }

// export async function listUsers(query?: string): Promise<UserRecord[]> {
//   const search = query ? `?query=${encodeURIComponent(query)}` : '';
//   return await call<UserRecord[]>(`/v1/identity/users${search}`).catch(() => {
//     if (!COMPLIANCE_MOCK_MODE) throw new Error('Users listing unavailable');
//     return [
//       {
//         id: 'user-mock-1',
//         email: 'demo@example.com',
//         roles: ['issuer'],
//         status: 'active',
//         createdAt: new Date().toISOString(),
//       },
//     ];
//   });
// }

// MERGE CONFLICT RESOLUTION - TEMPORARY
// TODO: Fix this properly after merge
// Both versions are commented out to unblock merge
// Original HEAD version is above (commented)
// Develop version would be: export * from './compliance/index';
export * from './compliance/index';
</file>

<file path="apps/portal-investor/src/app/orders/new/page.tsx">
'use client';

import { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import { useMutation, useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { z } from 'zod';
import { toast } from 'sonner';
import { AppShell, Button, Input, Card, CardContent, PageHeader, Badge } from '@ois/shared-ui';
import { signOut, useSession } from 'next-auth/react';
import { investorNavItems } from '@/lib/navigation';
import { AlertCircle } from 'lucide-react';
import Link from 'next/link';

const createOrderSchema = z.object({
  investorId: z.string().uuid(),
  issuanceId: z.string().uuid(),
  amount: z.number().positive(),
});

export default function NewOrderPage() {
  const router = useRouter();
  const { data: session, status } = useSession();
  const investorId = (session?.user as any)?.id || '';
  const [formData, setFormData] = useState({
    issuanceId: '',
    amount: '',
  });
  const idemKey = useMemo(() => crypto.randomUUID(), []);

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: complianceStatus, isLoading: complianceLoading } = useQuery({
    queryKey: ['investor-status', investorId],
    queryFn: async () => {
      const response = await apiClient.getInvestorStatus(investorId);
      return response.data;
    },
    enabled: status === 'authenticated' && Boolean(investorId),
  });

  const kycStatus = complianceStatus?.kyc;
  const isKycPassed = kycStatus === 'pass';
  const qualificationLimit = complianceStatus?.qualificationLimit;
  const qualificationUsed = complianceStatus?.qualificationUsed || 0;

  const mutation = useMutation({
    mutationFn: async (data: any) => {
      const response = await apiClient.createOrder(
        {
          investorId: data.investorId,
          issuanceId: data.issuanceId,
          amount: parseFloat(data.amount),
        },
        {
          headers: {
            'Idempotency-Key': idemKey,
          },
        }
      );
      return response.data;
    },
    onSuccess: () => {
      toast.success('Order placed successfully');
      router.push('/portfolio');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to place order');
    },
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!isKycPassed) {
      toast.error('Необходимо пройти KYC верификацию');
      return;
    }

    const orderAmount = parseFloat(formData.amount);
    if (qualificationLimit && orderAmount > qualificationLimit - qualificationUsed) {
      toast.error(
        `Сумма превышает доступный лимит: ${(qualificationLimit - qualificationUsed).toLocaleString()} ₽`
      );
      return;
    }

    try {
      const validated = createOrderSchema.parse({
        investorId,
        ...formData,
        amount: orderAmount,
      });

      mutation.mutate(validated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        toast.error(error.errors[0].message);
      }
    }
  };

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  return (
    <AppShell
      appName="ЛК Инвестора"
      user={session?.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: investorNavItems }}
    >
      <div className="max-w-2xl">
        <PageHeader
          title="Создать заявку на покупку"
          description={
            investorId ? 'Заполните данные заявки' : 'Не найден Investor ID. Перезайдите в систему.'
          }
        />

        {investorId && !complianceLoading && !isKycPassed && (
          <Card className="mb-6 border-yellow-500 bg-yellow-50">
            <CardContent className="p-6">
              <div className="flex items-start gap-4">
                <AlertCircle className="h-6 w-6 text-yellow-600 flex-shrink-0 mt-0.5" />
                <div>
                  <h3 className="text-lg font-semibold text-yellow-800">
                    Требуется KYC верификация
                  </h3>
                  <p className="text-sm text-yellow-700 mt-1">
                    Для создания заявок необходимо пройти KYC верификацию. После подтверждения
                    личности вы сможете совершать операции на платформе.
                  </p>
                  <Link href="/kyc">
                    <Button variant="primary" size="sm" className="mt-3">
                      Пройти верификацию
                    </Button>
                  </Link>
                </div>
              </div>
            </CardContent>
          </Card>
        )}

        {investorId && !complianceLoading && isKycPassed && qualificationLimit && (
          <Card className="mb-6">
            <CardContent className="p-4">
              <div className="flex justify-between items-center text-sm">
                <span className="text-text-secondary">Доступный лимит:</span>
                <span className="font-semibold text-text-primary">
                  {(qualificationLimit - qualificationUsed).toLocaleString()} ₽
                </span>
              </div>
            </CardContent>
          </Card>
        )}

        {investorId && (
          <Card>
            <CardContent className="p-6">
              <form onSubmit={handleSubmit} className="space-y-4">
                <Input
                  label="ID выпуска"
                  type="text"
                  value={formData.issuanceId}
                  onChange={e => setFormData({ ...formData, issuanceId: e.target.value })}
                  required
                  disabled={!isKycPassed}
                />

                <Input
                  label="Сумма"
                  type="number"
                  step="0.01"
                  value={formData.amount}
                  onChange={e => setFormData({ ...formData, amount: e.target.value })}
                  required
                  disabled={!isKycPassed}
                  helpText={
                    qualificationLimit
                      ? `Максимум: ${(qualificationLimit - qualificationUsed).toLocaleString()} ₽`
                      : undefined
                  }
                />

                <div className="flex gap-4 pt-4">
                  <Button
                    type="submit"
                    variant="primary"
                    disabled={mutation.isPending || !isKycPassed || complianceLoading}
                  >
                    {mutation.isPending ? 'Отправляем...' : 'Создать заявку'}
                  </Button>
                  <Button type="button" variant="secondary" onClick={() => router.back()}>
                    Отмена
                  </Button>
                </div>
              </form>
            </CardContent>
          </Card>
        )}
      </div>
    </AppShell>
  );
}
</file>

<file path="apps/portal-investor/src/app/portfolio/page.tsx">
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { signOut, useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';
import { AppShell, PageHeader, Card, CardContent, Skeleton, EmptyState } from '@ois/shared-ui';
import { Wallet, Briefcase } from 'lucide-react';
import { investorNavItems } from '@/lib/navigation';

export default function PortfolioPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const investorId = session?.user?.id || '';

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: wallet, isLoading } = useQuery({
    queryKey: ['wallet', investorId],
    queryFn: async () => {
      const response = await apiClient.getWallet(investorId);
      return response.data;
    },
    enabled: !!investorId && status === 'authenticated' && !!session,
  });

  if (status === 'loading') {
    return <div className="p-8">Загрузка...</div>;
  }

  if (!session) {
    return null;
  }

  if (!investorId) {
    return (
      <AppShell
        user={session.user}
        onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
        sidebar={{ items: investorNavItems }}
      >
        <EmptyState
          title="Не найден Investor ID"
          description="Перезайдите в систему, чтобы обновить сессию."
        />
      </AppShell>
    );
  }

  return (
    <AppShell
      appName="ЛК Инвестора"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: investorNavItems }}
    >
      <PageHeader title="Портфель" description="Баланс кошелька и ваши активы" />

      {isLoading && (
        <div className="space-y-6">
          <Skeleton className="h-32 w-full" variant="rectangular" />
          <Skeleton className="h-48 w-full" variant="rectangular" />
        </div>
      )}

      {!isLoading && wallet && (
        <div className="space-y-6">
          <Card>
            <CardContent className="p-6">
              <div className="flex items-center gap-2 mb-4">
                <Wallet className="h-5 w-5 text-primary-600" />
                <h2 className="text-xl font-semibold text-text-primary">Кошелёк</h2>
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <p className="text-text-secondary">Баланс</p>
                  <p className="text-2xl font-bold text-text-primary">
                    ₽{(wallet.balance || 0).toLocaleString()}
                  </p>
                </div>
                <div>
                  <p className="text-text-secondary">Заблокировано</p>
                  <p className="text-2xl font-bold text-text-primary">
                    ₽{(wallet.blocked || 0).toLocaleString()}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6">
              <div className="flex items-center gap-2 mb-4">
                <Briefcase className="h-5 w-5 text-primary-600" />
                <h2 className="text-xl font-semibold text-text-primary">Активы</h2>
              </div>
              {wallet.holdings && wallet.holdings.length > 0 ? (
                <div className="space-y-4">
                  {wallet.holdings.map((holding: any, index: number) => {
                    const key =
                      holding.assetId ||
                      holding.issuanceId ||
                      holding.assetCode ||
                      `holding-${index}`;
                    return (
                      <div
                        key={key}
                        className="border-b border-border pb-4 last:border-b-0 last:pb-0"
                      >
                        <p className="font-semibold text-text-primary">
                          {holding.assetName || holding.assetCode || 'Выпуск'}
                        </p>
                        <p className="text-text-secondary">
                          Количество: {holding.amount ?? holding.quantity ?? 0}
                        </p>
                      </div>
                    );
                  })}
                </div>
              ) : (
                <EmptyState
                  title="Активов пока нет"
                  description="Начните инвестировать чтобы увидеть ваши активы"
                />
              )}
            </CardContent>
          </Card>
        </div>
      )}
    </AppShell>
  );
}
</file>

<file path="apps/portal-investor/src/lib/api-client.ts">
import { getSession } from 'next-auth/react';
import { OisApiClient } from '@ois/api-client';
import {
  mockCatalog,
  mockCompliance,
  mockIssuanceDetail,
  mockOrder,
  mockPayouts,
  mockTransactions,
  mockWallet,
} from './mocks';

const baseURL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';
const USE_MOCKS = process.env.NEXT_PUBLIC_USE_MOCKS === 'true';

// Types for API parameters
interface MarketIssuancesParams {
  limit?: number;
  offset?: number;
  status?: 'open' | 'closed' | 'all';
  sort?: string;
}

interface TransactionsParams {
  from?: string;
  to?: string;
  type?: string;
  limit?: number;
  offset?: number;
}

interface PayoutsParams {
  from?: string;
  to?: string;
  limit?: number;
  offset?: number;
}

interface CreateOrderData {
  investorId: string;
  issuanceId: string;
  amount: number;
}

// Helper to create client with token
async function getClient(): Promise<OisApiClient> {
  try {
    const session = await getSession();
    if (!session?.accessToken) {
      console.warn('[api] No active session or access token');
    }
    return new OisApiClient({
      baseURL,
      accessToken: session?.accessToken || undefined,
    });
  } catch (error) {
    console.error('[api] Failed to initialize client:', error);
    throw error;
  }
}

// SDK wrapper with NextAuth integration
export const apiClient = {
  // Market
  async getMarketIssuances(params?: MarketIssuancesParams) {
    try {
      const client = await getClient();
      const data = await client.getMarketIssuances(params);
      return { data };
    } catch (error) {
      if (USE_MOCKS) {
        console.warn('[api] getMarketIssuances failed, using mocks', error);
        return { data: mockCatalog };
      }
      throw error;
    }
  },

  async getMarketIssuance(id: string) {
    try {
      const client = await getClient();
      const data = await client.getMarketIssuance(id);
      return { data };
    } catch (error) {
      if (USE_MOCKS) {
        console.warn('[api] getMarketIssuance failed, using mock', error);
        return { data: mockIssuanceDetail(id) };
      }
      throw error;
    }
  },

  // Orders
  async createOrder(data: CreateOrderData, options?: { headers?: Record<string, string> }) {
    try {
      const client = await getClient();
      const orderData = await client.createOrder(data, {
        headers: options?.headers,
      });
      return { data: orderData };
    } catch (error) {
      if (USE_MOCKS) {
        console.warn('[api] createOrder failed, using mock', error);
        return { data: mockOrder(data) };
      }
      throw error;
    }
  },

  // Wallet
  async getWallet(investorId: string) {
    try {
      const client = await getClient();
      const wallet = await (client as any).getWallet(investorId);
      return { data: wallet };
    } catch (error) {
      if (USE_MOCKS) {
        console.warn('[api] getWallet failed, using mock', error);
        return { data: mockWallet };
      }
      throw error;
    }
  },

  // Investor
  async getInvestorTransactions(investorId: string, params?: TransactionsParams) {
    try {
      const client = await getClient();
      const transactions = await client.getInvestorTransactions(investorId, params);
      return { data: transactions };
    } catch (error) {
      if (USE_MOCKS) {
        console.warn('[api] getInvestorTransactions failed, using mock', error);
        const { type, limit = 10, offset = 0 } = params || {};
        return { data: mockTransactions(type, limit, offset) };
      }
      throw error;
    }
  },

  async getInvestorPayouts(investorId: string, params?: PayoutsParams) {
    try {
      const client = await getClient();
      const payouts = await client.getInvestorPayouts(investorId, params);
      return { data: payouts };
    } catch (error) {
      if (USE_MOCKS) {
        console.warn('[api] getInvestorPayouts failed, using mock', error);
        const { limit = 10, offset = 0 } = params || {};
        return { data: mockPayouts(limit, offset) };
      }
      throw error;
    }
  },

  async getInvestorStatus(investorId: string) {
    try {
      const client = await getClient();
      const status = await client.getInvestorStatus(investorId);
      return { data: status };
    } catch (error) {
      if (USE_MOCKS) {
        console.warn('[api] getInvestorStatus failed, using mock', error);
        return { data: mockCompliance };
      }
      throw error;
    }
  },

  // Legacy compatibility methods
  placeOrder: async (data: CreateOrderData, options?: { headers?: Record<string, string> }) => {
    return apiClient.createOrder(data, options);
  },

  // KYC Methods
  async submitKyc(data: KycCheckRequest) {
    try {
      const response = await fetch(`${baseURL}/v1/compliance/kyc/check`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${(await getSession())?.accessToken}`,
        },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error(`KYC submission failed: ${response.status}`);
      return { data: await response.json() };
    } catch (error) {
      console.error('[api] submitKyc failed:', error);
      throw error;
    }
  },

  async uploadKycDocument(investorId: string, documentType: string, file: File) {
    try {
      const formData = new FormData();
      formData.append('investorId', investorId);
      formData.append('documentType', documentType);
      formData.append('file', file);

      const session = await getSession();
      console.log('[api] uploadKycDocument session:', {
        hasSession: !!session,
        hasAccessToken: !!session?.accessToken,
        tokenPrefix: session?.accessToken?.substring(0, 50),
      });
      const response = await fetch(`${baseURL}/v1/kyc/documents`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${session?.accessToken}`,
        },
        body: formData,
      });
      if (!response.ok) throw new Error(`Document upload failed: ${response.status}`);
      return { data: await response.json() };
    } catch (error) {
      console.error('[api] uploadKycDocument failed:', error);
      throw error;
    }
  },

  async getKycDocuments(investorId: string) {
    try {
      const session = await getSession();
      const response = await fetch(`${baseURL}/v1/kyc/investors/${investorId}/documents`, {
        headers: {
          Authorization: `Bearer ${session?.accessToken}`,
        },
      });
      if (response.status === 404) {
        // Если документов нет — считаем как пустой список
        return { data: [] };
      }
      if (!response.ok) throw new Error(`Get documents failed: ${response.status}`);
      return { data: await response.json() };
    } catch (error) {
      console.error('[api] getKycDocuments failed:', error);
      if (USE_MOCKS) return { data: [] };
      throw error;
    }
  },

  async deleteKycDocument(documentId: string) {
    try {
      const session = await getSession();
      const response = await fetch(`${baseURL}/v1/kyc/documents/${documentId}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${session?.accessToken}`,
        },
      });
      if (!response.ok) throw new Error(`Delete document failed: ${response.status}`);
      return { success: true };
    } catch (error) {
      console.error('[api] deleteKycDocument failed:', error);
      throw error;
    }
  },

  // Qualification Methods
  async submitQualificationTask(data: CreateQualificationTaskRequest) {
    try {
      const session = await getSession();
      const response = await fetch(`${baseURL}/v1/qualification/tasks`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${session?.accessToken}`,
        },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error(`Qualification submission failed: ${response.status}`);
      return { data: await response.json() };
    } catch (error) {
      console.error('[api] submitQualificationTask failed:', error);
      throw error;
    }
  },

  async evaluateQualification(investorId: string, amount: number) {
    try {
      const session = await getSession();
      const response = await fetch(`${baseURL}/v1/compliance/qualification/evaluate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${session?.accessToken}`,
        },
        body: JSON.stringify({ investorId, amount }),
      });
      if (!response.ok) throw new Error(`Qualification evaluation failed: ${response.status}`);
      return { data: await response.json() };
    } catch (error) {
      console.error('[api] evaluateQualification failed:', error);
      throw error;
    }
  },
};

// KYC Types
export interface KycCheckRequest {
  investorId: string;
  personalData: {
    lastName: string;
    firstName: string;
    middleName?: string;
    birthDate: string;
    birthPlace?: string;
  };
  identityDocument: {
    type:
      | 'passport_rf'
      | 'passport_foreign'
      | 'residence_permit'
      | 'refugee_certificate'
      | 'temporary_asylum';
    series: string;
    number: string;
    issuedBy: string;
    issuedAt: string;
    departmentCode?: string;
    expiresAt?: string;
  };
  address: {
    country: string;
    postalCode?: string;
    region: string;
    city: string;
    street: string;
    house: string;
    building?: string;
    apartment?: string;
  };
  contacts: {
    phone: string;
    email: string;
    additionalPhone?: string;
  };
  inn?: string;
  snils?: string;
  citizenship?: string;
  isResident?: boolean;
  isPep?: boolean;
  isBeneficialOwner?: boolean;
  consentToProcessing?: boolean;
}

export interface CreateQualificationTaskRequest {
  investorId: string;
  qualificationBasis:
    | 'trading_turnover'
    | 'total_assets'
    | 'annual_income'
    | 'work_experience'
    | 'education'
    | 'certificate';
  tradingTurnover?: number;
  tradingFrequency?: number;
  totalAssets?: number;
  annualIncome?: number;
  documentIds?: string[];
}
</file>

<file path="apps/portal-issuer/src/app/payouts/schedule/page.tsx">
'use client';

import { useState } from 'react';
import { signOut, useSession } from 'next-auth/react';
import { AppShell, PageHeader, EmptyState } from '@ois/shared-ui';
import { issuerNavWithSchedule } from '@/lib/navigation';

// Типы для элемента графика выплат
type PayoutStatus = 'planned' | 'executing' | 'done' | 'cancelled';

interface PayoutScheduleItem {
  id: string;
  date: string;
  amount: string;
  status: PayoutStatus;
}

export default function PayoutsSchedulePage() {
  const { data: session, status } = useSession();
  const [issuanceId, setIssuanceId] = useState('');
  const [items, setItems] = useState<PayoutScheduleItem[]>([]);

  if (status === 'loading') return <div className="p-8">Загрузка...</div>;
  if (!session) return null;

  const addItem = () => {
    setItems(prev => [
      ...prev,
      {
        id: crypto.randomUUID(),
        date: new Date().toISOString().split('T')[0],
        amount: '0',
        status: 'planned',
      },
    ]);
  };

  const removeItem = (id: string) => setItems(prev => prev.filter(i => i.id !== id));

  return (
    <AppShell
      appName="ЛК Эмитента"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: issuerNavWithSchedule }}
    >
      <PageHeader
        title="График выплат"
        description="Черновик графика выплат по выпуску (только просмотр)"
      />

      <div className="space-y-6">
        <div className="flex gap-4 items-end">
          <div>
            <label
              htmlFor="issuanceId"
              className="block text-sm font-medium text-text-primary mb-1"
            >
              ID выпуска
            </label>
            <input
              id="issuanceId"
              placeholder="00000000-0000-4000-8000-000000000000"
              className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary"
              value={issuanceId}
              onChange={e => setIssuanceId(e.target.value)}
            />
          </div>
          <button
            onClick={addItem}
            className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover"
          >
            Добавить
          </button>
          <button
            aria-disabled="true"
            aria-describedby="save-tooltip"
            disabled
            className="px-4 py-2 rounded-md bg-neutral-200 text-text-tertiary cursor-not-allowed"
          >
            Сохранить график
          </button>
          <span id="save-tooltip" className="sr-only">
            API эндпоинты отсутствуют в спецификации
          </span>
        </div>

        {items.length === 0 ? (
          <EmptyState
            title="Нет элементов графика"
            description="Добавьте элементы для создания черновика (не сохраняется)"
          />
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead>
                <tr className="text-left text-text-secondary">
                  <th className="py-2 pr-4">Дата</th>
                  <th className="py-2 pr-4">Сумма</th>
                  <th className="py-2 pr-4">Статус</th>
                  <th className="py-2 pr-4">Действия</th>
                </tr>
              </thead>
              <tbody>
                {items.map(i => (
                  <tr key={i.id} className="border-t border-border">
                    <td className="py-2 pr-4">
                      <input
                        type="date"
                        value={i.date}
                        onChange={e =>
                          setItems(prev =>
                            prev.map(x => (x.id === i.id ? { ...x, date: e.target.value } : x))
                          )
                        }
                        className="px-2 py-1 border border-border rounded"
                      />
                    </td>
                    <td className="py-2 pr-4">
                      <input
                        type="number"
                        step="0.01"
                        value={i.amount}
                        onChange={e =>
                          setItems(prev =>
                            prev.map(x => (x.id === i.id ? { ...x, amount: e.target.value } : x))
                          )
                        }
                        className="px-2 py-1 border border-border rounded"
                      />
                    </td>
                    <td className="py-2 pr-4">
                      <select
                        value={i.status}
                        onChange={e =>
                          setItems(prev =>
                            prev.map(x =>
                              x.id === i.id ? { ...x, status: e.target.value as PayoutStatus } : x
                            )
                          )
                        }
                        className="px-2 py-1 border border-border rounded"
                      >
                        <option value="planned">Запланировано</option>
                        <option value="executing">Выполняется</option>
                        <option value="done">Выполнено</option>
                        <option value="cancelled">Отменено</option>
                      </select>
                    </td>
                    <td className="py-2 pr-4">
                      <button
                        onClick={() => removeItem(i.id)}
                        className="text-danger-600 hover:underline"
                      >
                        Удалить
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </AppShell>
  );
}
</file>

<file path="apps/portal-investor/src/app/catalog/page.tsx">
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import {
  AppShell,
  PageHeader,
  EmptyState,
  Skeleton,
  Select,
  Button,
  Badge,
  Card,
  CardContent,
  Input,
} from '@ois/shared-ui';
import { signOut, useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';
import Link from 'next/link';
import { TrendingUp, Calendar, DollarSign } from 'lucide-react';
import { investorNavItems } from '@/lib/navigation';

type MarketIssuance = {
  id: string;
  assetName: string;
  issuerName: string;
  totalAmount: number;
  nominal: number;
  availableAmount: number;
  issueDate: string;
  maturityDate: string;
  yield: number;
  status: 'open' | 'closed';
};

type MarketIssuancesResponse = {
  items: MarketIssuance[];
  total: number;
  limit: number;
  offset: number;
};

export default function CatalogPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [filters, setFilters] = useState({
    status: 'open' as 'open' | 'closed' | 'all',
    sort: '-yield' as string,
    limit: 20,
    offset: 0,
    search: '',
  });
  const [showFilters, setShowFilters] = useState(false);

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data, isLoading, error } = useQuery<MarketIssuancesResponse>({
    queryKey: ['market-issuances', filters],
    queryFn: async () => {
      const response = await apiClient.getMarketIssuances(filters);
      return response.data as MarketIssuancesResponse;
    },
    enabled: status === 'authenticated' && !!session,
  });

  if (status === 'loading') {
    return <div className="p-8">Загрузка...</div>;
  }

  if (!session) {
    return null;
  }

  return (
    <AppShell
      appName="ЛК Инвестора"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: investorNavItems }}
    >
      <PageHeader
        title="Каталог ЦФА"
        description="Доступные выпуски ЦФА"
        actions={
          <Button
            variant="secondary"
            size="sm"
            onClick={() => setShowFilters(prev => !prev)}
            className="md:hidden"
          >
            {showFilters ? 'Скрыть фильтры' : 'Фильтры'}
          </Button>
        }
      />

      {/* Filters */}
      <div
        className={`mb-6 flex flex-col gap-3 rounded-lg border border-border bg-surface p-4 shadow-sm ${showFilters ? 'flex' : 'hidden md:flex md:flex-row md:items-end md:gap-4'}`}
      >
        <div className="flex flex-col md:flex-1">
          <Select
            label="Статус"
            value={filters.status}
            onChange={e => setFilters({ ...filters, status: e.target.value as any, offset: 0 })}
            options={[
              { value: 'open', label: 'Открытые' },
              { value: 'closed', label: 'Закрытые' },
              { value: 'all', label: 'Все' },
            ]}
          />
        </div>

        <div className="flex flex-col md:flex-1">
          <Select
            label="Сортировка"
            value={filters.sort}
            onChange={e => setFilters({ ...filters, sort: e.target.value, offset: 0 })}
            options={[
              { value: '-yield', label: 'Доходность: по убыванию' },
              { value: 'yield', label: 'Доходность: по возрастанию' },
              { value: '-maturityDate', label: 'Погашение: позже' },
              { value: 'maturityDate', label: 'Погашение: раньше' },
              { value: '-totalAmount', label: 'Сумма: больше' },
              { value: 'totalAmount', label: 'Сумма: меньше' },
            ]}
          />
        </div>

        <div className="flex flex-col md:flex-1">
          <Input
            label="Поиск по названию"
            placeholder="Например, Газпром"
            inputSize="md"
            value={filters.search}
            onChange={e => setFilters({ ...filters, search: e.target.value, offset: 0 })}
          />
        </div>

        <Button
          variant="ghost"
          size="sm"
          onClick={() =>
            setFilters({
              status: 'open',
              sort: '-yield',
              limit: 20,
              offset: 0,
              search: '',
            })
          }
          className="md:ml-auto"
        >
          Сбросить
        </Button>
      </div>

      {/* Results */}
      {isLoading && (
        <div className="space-y-4">
          {[1, 2, 3].map(i => (
            <Skeleton key={i} className="h-32 w-full" variant="rectangular" />
          ))}
        </div>
      )}

      {error && <div className="text-danger-600">Ошибка загрузки выпусков</div>}

      {data && data.items && data.items.length === 0 && (
        <EmptyState title="Выпуски не найдены" description="Попробуйте изменить фильтры" />
      )}

      {data && data.items && data.items.length > 0 && (
        <>
          <div className="flex items-center justify-between mb-4 text-sm text-text-secondary">
            <div>
              Найдено выпусков:{' '}
              <span className="font-semibold text-text-primary">
                {data.total || data.items.length}
              </span>
            </div>
            <div className="hidden md:flex gap-2">
              <Badge intent="info">Статус: {filters.status}</Badge>
              <Badge intent="info">Сортировка: {filters.sort}</Badge>
              {filters.search && <Badge intent="info">Поиск: “{filters.search}”</Badge>}
            </div>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 mb-8">
            {data.items
              .filter((issuance: any) =>
                filters.search
                  ? issuance.assetName.toLowerCase().includes(filters.search.toLowerCase())
                  : true
              )
              .map((issuance: any) => (
                <Link key={issuance.id} href={`/issuances/${issuance.id}`} className="block">
                  <Card className="hover:shadow-lg transition-shadow h-full">
                    <CardContent className="p-6 space-y-4 h-full">
                      <div className="flex items-start justify-between">
                        <div>
                          <h3 className="text-lg font-semibold text-text-primary">
                            {issuance.assetName}
                          </h3>
                          <p className="text-sm text-text-secondary">{issuance.issuerName}</p>
                        </div>
                        <Badge intent={issuance.status === 'open' ? 'success' : 'neutral'}>
                          {issuance.status}
                        </Badge>
                      </div>

                      <div className="space-y-2">
                        <div className="flex items-center gap-2 text-sm">
                          <TrendingUp className="h-4 w-4 text-success-600" />
                          <span className="text-text-primary font-medium">
                            {issuance.yield}% доходность
                          </span>
                        </div>
                        <div className="flex items-center gap-2 text-sm">
                          <DollarSign className="h-4 w-4 text-text-tertiary" />
                          <span className="text-text-secondary">
                            {issuance.availableAmount.toLocaleString()} доступно
                          </span>
                        </div>
                        <div className="flex items-center gap-2 text-sm">
                          <Calendar className="h-4 w-4 text-text-tertiary" />
                          <span className="text-text-secondary">
                            Погашение: {new Date(issuance.maturityDate).toLocaleDateString()}
                          </span>
                        </div>
                      </div>

                      <div className="text-sm text-text-secondary">
                        Номинал: ₽{issuance.nominal.toLocaleString()}
                      </div>
                    </CardContent>
                  </Card>
                </Link>
              ))}
          </div>

          {/* Pagination */}
          {data.total > filters.limit && (
            <div className="flex items-center justify-between">
              <div className="text-sm text-text-secondary">
                Показано {filters.offset + 1} –{' '}
                {Math.min(filters.offset + filters.limit, data.total)} из {data.total}
              </div>
              <div className="flex gap-2">
                <Button
                  variant="secondary"
                  onClick={() =>
                    setFilters({
                      ...filters,
                      offset: Math.max(0, filters.offset - filters.limit),
                    })
                  }
                  disabled={filters.offset === 0}
                >
                  Назад
                </Button>
                <Button
                  variant="secondary"
                  onClick={() =>
                    setFilters({
                      ...filters,
                      offset: filters.offset + filters.limit,
                    })
                  }
                  disabled={filters.offset + filters.limit >= data.total}
                >
                  Далее
                </Button>
              </div>
            </div>
          )}
        </>
      )}
    </AppShell>
  );
}
</file>

<file path="apps/portal-investor/src/app/kyc/page.tsx">
'use client';

import { useEffect, useState } from 'react';
// MERGE CONFLICT RESOLUTION - TEMPORARY
// TODO: Fix this properly after merge
// HEAD version (commented out):
// import { useSession } from 'next-auth/react';
// import { useRouter } from 'next/navigation';
// import { useQuery, useMutation } from '@tanstack/react-query';
// import { AppShell, PageHeader, Skeleton, EmptyState } from '../../../../shared-ui/src';
// import { investorNav } from '@/lib/nav';
// import { fetchKycStatus, submitKycApplication } from '@/lib/api/compliance';
// import { toast } from 'sonner';
// export default function InvestorKycPage() {
//   const { data: session, status } = useSession();
//   const router = useRouter();
//   const [form, setForm] = useState({
//     fullName: '',
//     documentType: 'passport',
//     documentNumber: '',
//     comment: '',
//   });
//   const investorId = (session?.user as any)?.id || '';

// Develop version (using):
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { signOut, useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';
import { apiClient, KycCheckRequest } from '@/lib/api-client';
import { AppShell, Button, Card, CardContent, PageHeader, Skeleton } from '@ois/shared-ui';
import { investorNavItems } from '@/lib/navigation';
import { AddressStep } from './components/steps/AddressStep';
import { ContactsStep } from './components/steps/ContactsStep';
import { DocumentsStep } from './components/steps/DocumentsStep';
import { IdentityStep } from './components/steps/IdentityStep';
import { PersonalStep } from './components/steps/PersonalStep';
import { KycStepper } from './components/KycStepper';
import { KycStatusCard } from './components/KycStatusCard';
import { STEPS, REQUIRED_DOCUMENTS } from './constants';
import { validateStep } from './validation';
import { FormData, FormErrors, LocalDocument } from './types';
import type { InvestorStatusResponse } from '@ois/api-client';

type ExtendedInvestorStatus = Omit<InvestorStatusResponse, 'kyc'> & {
  kyc: 'not_started' | 'pending' | 'review' | 'pass' | 'fail';
  qualificationTier?: string;
  qualificationLimit?: number | null;
  qualificationUsed?: number | null;
  updatedAt?: string;
  rejectionReason?: string | null;
  canUploadDocuments?: boolean;
};

const initialFormData: FormData = {
  personalData: {
    lastName: '',
    firstName: '',
    middleName: '',
    birthDate: '',
    birthPlace: '',
  },
  identityDocument: {
    type: 'passport_rf',
    series: '',
    number: '',
    issuedBy: '',
    issuedAt: '',
    departmentCode: '',
    expiresAt: '',
  },
  address: {
    country: 'Россия',
    postalCode: '',
    region: '',
    city: '',
    street: '',
    house: '',
    building: '',
    apartment: '',
  },
  contacts: {
    phone: '',
    email: '',
    additionalPhone: '',
  },
  inn: '',
  snils: '',
  citizenship: 'Россия',
  isResident: true,
  isPep: false,
  isBeneficialOwner: true,
  consentToProcessing: false,
};

export default function KycPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const queryClient = useQueryClient();
  const investorId = (session?.user as any)?.id;
  const storageKey = investorId ? `kyc-form-${investorId}` : null;

  const [currentStep, setCurrentStep] = useState(0);
  const [formData, setFormData] = useState<FormData>(initialFormData);
  const [localDocuments, setLocalDocuments] = useState<LocalDocument[]>([]);
  const [selectedDocType, setSelectedDocType] = useState('passport_main');
  const [errors, setErrors] = useState<FormErrors>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Восстанавливаем сохраненные данные формы (чтобы после отказа не вводить все заново)
  useEffect(() => {
    if (!storageKey) return;
    try {
      const raw = localStorage.getItem(storageKey);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      setFormData(prev => ({
        ...prev,
        ...parsed,
        personalData: { ...prev.personalData, ...(parsed.personalData || {}) },
        identityDocument: { ...prev.identityDocument, ...(parsed.identityDocument || {}) },
        address: { ...prev.address, ...(parsed.address || {}) },
        contacts: { ...prev.contacts, ...(parsed.contacts || {}) },
      }));
    } catch (error) {
      console.warn('[kyc] Failed to restore form from storage', error);
    }
  }, [storageKey]);

  // Сохраняем ввод пользователя локально
  useEffect(() => {
    if (!storageKey) return;
    try {
      localStorage.setItem(storageKey, JSON.stringify(formData));
    } catch (error) {
      console.warn('[kyc] Failed to persist form to storage', error);
    }
  }, [formData, storageKey]);

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

// MERGE CONFLICT RESOLUTION - TEMPORARY
// TODO: Fix this properly after merge
// HEAD version (commented out):
  const {
    data: kycStatus,
    isLoading: statusLoading,
    refetch,
  } = useQuery({
    queryKey: ['investor-kyc-status', investorId],
    queryFn: () => fetchKycStatus(investorId),
    enabled: status === 'authenticated' && !!investorId,
  });

  const submitMutation = useMutation({
    mutationFn: async () =>
      submitKycApplication({
        investorId,
        ...form,
      }),
    onSuccess: () => {
      toast.success('KYC application submitted');
      refetch();
    },
    onError: (error: any) => {
      toast.error(error?.message ?? 'Failed to submit KYC');
    },
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) return null;

  const statusLabel = kycStatus?.kyc ?? 'not-submitted';
  const isSubmitted = statusLabel !== 'not-submitted';

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: investorNav }}
    >
      <PageHeader
        title="KYC verification"
        description="Submit your KYC details for compliance review"
      />

      <section className="grid gap-6 lg:grid-cols-2">
        <div className="rounded-lg border border-border bg-surface p-6 space-y-4">
          <h2 className="text-lg font-semibold text-text-primary">Current status</h2>
          {statusLoading ? (
            <Skeleton className="h-20 w-full" variant="rectangular" />
          ) : isSubmitted ? (
            <div className="space-y-2">
              <div className="text-sm text-text-secondary">Status</div>
              <div className="text-2xl font-bold text-text-primary capitalize">
                {statusLabel}
              </div>
              <div className="text-sm text-text-secondary">
                Updated at:{' '}
                {kycStatus?.updatedAt
                  ? new Date(kycStatus.updatedAt).toLocaleString()
                  : '—'}
              </div>
            </div>
          ) : (
            <EmptyState
              title="No KYC on file"
              description="Submit your details to start verification."
            />
          )}
        </div>

        <div className="rounded-lg border border-border bg-surface p-6 space-y-4">
          <h2 className="text-lg font-semibold text-text-primary">Submit application</h2>
          <form
            className="space-y-4"
            onSubmit={(e) => {
              e.preventDefault();
              submitMutation.mutate();
            }}
          >
            <div className="space-y-2">
              <label className="text-sm text-text-secondary">Full name</label>
              <input
                type="text"
                value={form.fullName}
                onChange={(e) => setForm({ ...form, fullName: e.target.value })}
                className="w-full rounded-md border border-border px-3 py-2"
                placeholder="Ivan Ivanov"
              />
            </div>

            <div className="grid gap-4 sm:grid-cols-2">
              <div className="space-y-2">
                <label className="text-sm text-text-secondary">Document type</label>
                <select
                  value={form.documentType}
                  onChange={(e) => setForm({ ...form, documentType: e.target.value })}
                  className="w-full rounded-md border border-border px-3 py-2"
                >
                  <option value="passport">Passport</option>
                  <option value="inn">INN</option>
                  <option value="snils">SNILS</option>
                  <option value="other">Other</option>
                </select>
              </div>
              <div className="space-y-2">
                <label className="text-sm text-text-secondary">Document number</label>
                <input
                  type="text"
                  value={form.documentNumber}
                  onChange={(e) => setForm({ ...form, documentNumber: e.target.value })}
                  className="w-full rounded-md border border-border px-3 py-2"
                  placeholder="00 00 000000"
                />
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-sm text-text-secondary">Comment</label>
              <textarea
                value={form.comment}
                onChange={(e) => setForm({ ...form, comment: e.target.value })}
                className="w-full rounded-md border border-border px-3 py-2"
                rows={3}
                placeholder="Any additional info for backoffice"
              />
            </div>

            <button
              type="submit"
              className="rounded-md bg-primary-600 px-4 py-2 text-sm font-medium text-white hover:bg-primary-700 disabled:opacity-50"
              disabled={submitMutation.isPending || !investorId}
            >
              {submitMutation.isPending ? 'Submitting…' : 'Submit KYC'}
            </button>
            {!investorId && (
              <p className="text-xs text-danger-600">
                Missing investor id in session; cannot submit.
              </p>
            )}
          </form>
        </div>
      </section>
// MERGE CONFLICT RESOLUTION - TEMPORARY
// TODO: Fix this properly after merge
// HEAD version ends above (commented out)
// Develop version continues below:

  useEffect(() => {
    if (session?.user?.email) {
      setFormData(prev => ({
        ...prev,
        contacts: { ...prev.contacts, email: session.user?.email || '' },
      }));
    }
  }, [session?.user?.email]);

  const { data: complianceStatus, isLoading: statusLoading } = useQuery<ExtendedInvestorStatus>({
    queryKey: ['investor-status', investorId],
    queryFn: async () => {
      const response = await apiClient.getInvestorStatus(investorId);
      return response.data as ExtendedInvestorStatus;
    },
    enabled: status === 'authenticated' && Boolean(investorId),
  });

  const kycStatus = complianceStatus?.kyc;
  const rejectionReason = complianceStatus?.rejectionReason ?? undefined;
  const canUpload = complianceStatus?.canUploadDocuments ?? true;

  // Если KYC полностью пройден — удаляем сохраненные черновики формы
  useEffect(() => {
    if (!storageKey) return;
    if (kycStatus === 'pass') {
      localStorage.removeItem(storageKey);
    }
  }, [kycStatus, storageKey]);

  // Handlers для локальных документов
  const handleAddDocument = (doc: LocalDocument) => {
    setLocalDocuments(prev => [...prev, doc]);
  };

  const handleRemoveDocument = (id: string) => {
    setLocalDocuments(prev => {
      const doc = prev.find(d => d.id === id);
      if (doc?.preview) {
        URL.revokeObjectURL(doc.preview);
      }
      return prev.filter(d => d.id !== id);
    });
  };

  const validateCurrentStep = (stepIndex: number): boolean => {
    const validation = validateStep(formData, stepIndex);
    setErrors(prev => ({ ...prev, ...validation }));
    const stepKey = STEPS[stepIndex];
    return Object.keys(validation[stepKey] || {}).length === 0;
  };

  const goToStep = (next: number) => {
    if (next > currentStep && !validateCurrentStep(currentStep)) return;
    setCurrentStep(next);
  };

  const handleSubmit = async () => {
    if (!validateCurrentStep(currentStep)) return;

    if (!formData.consentToProcessing) {
      toast.error('Необходимо согласие на обработку персональных данных');
      return;
    }

    // Проверяем наличие обязательных документов
    const uploadedTypes = new Set(localDocuments.map(d => d.documentType));
    const missingRequired = REQUIRED_DOCUMENTS.filter(d => !uploadedTypes.has(d.value));
    if (missingRequired.length > 0) {
      toast.error(
        `Загрузите обязательные документы: ${missingRequired.map(d => d.label).join(', ')}`
      );
      return;
    }

    setIsSubmitting(true);

    try {
      // 1. Сначала загружаем все документы на сервер
      for (const doc of localDocuments) {
        await apiClient.uploadKycDocument(investorId, doc.documentType, doc.file);
      }

      // 2. Затем отправляем KYC заявку
      const kycRequest: KycCheckRequest = {
        investorId,
        personalData: {
          lastName: formData.personalData.lastName,
          firstName: formData.personalData.firstName,
          middleName: formData.personalData.middleName || undefined,
          birthDate: formData.personalData.birthDate,
          birthPlace: formData.personalData.birthPlace || undefined,
        },
        identityDocument: {
          type: formData.identityDocument.type,
          series: formData.identityDocument.series,
          number: formData.identityDocument.number,
          issuedBy: formData.identityDocument.issuedBy,
          issuedAt: formData.identityDocument.issuedAt,
          departmentCode: formData.identityDocument.departmentCode || undefined,
          expiresAt: formData.identityDocument.expiresAt || undefined,
        },
        address: {
          country: formData.address.country,
          postalCode: formData.address.postalCode || undefined,
          region: formData.address.region,
          city: formData.address.city,
          street: formData.address.street,
          house: formData.address.house,
          building: formData.address.building || undefined,
          apartment: formData.address.apartment || undefined,
        },
        contacts: {
          phone: formData.contacts.phone,
          email: formData.contacts.email,
          additionalPhone: formData.contacts.additionalPhone || undefined,
        },
        inn: formData.inn || undefined,
        snils: formData.snils || undefined,
        citizenship: formData.citizenship || undefined,
        isResident: formData.isResident,
        isPep: formData.isPep,
        isBeneficialOwner: formData.isBeneficialOwner,
        consentToProcessing: formData.consentToProcessing,
      };

      await apiClient.submitKyc(kycRequest);

      toast.success('KYC заявка успешно отправлена');
      queryClient.setQueryData(['investor-status', investorId], (prev: any) => ({
        ...(prev || {}),
        investorId,
        kyc: 'pending',
        canUploadDocuments: false,
        updatedAt: new Date().toISOString(),
      }));
      queryClient.invalidateQueries({ queryKey: ['investor-status', investorId] });

      // Очищаем локальные документы после успешной отправки
      localDocuments.forEach(doc => {
        if (doc.preview) URL.revokeObjectURL(doc.preview);
      });
      setLocalDocuments([]);
      setCurrentStep(0);
      setFormData(initialFormData);
      if (storageKey) {
        localStorage.removeItem(storageKey);
      }
    } catch (error: any) {
      toast.error(error.message || 'Ошибка при отправке KYC');
    } finally {
      setIsSubmitting(false);
    }
  };

  const updateFormData = (section: keyof FormData, field: any, value: any) => {
    setFormData(prev => ({
      ...prev,
      [section]: {
        ...(prev[section] as object),
        [field]: value,
      },
    }));
  };

  if (status === 'loading' || statusLoading) {
    return (
      <AppShell
        appName="ЛК Инвестора"
        user={session?.user}
        onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
        sidebar={{ items: investorNavItems }}
      >
        <PageHeader title="KYC верификация" />
        <div className="space-y-4">
          <Skeleton className="h-24 w-full" variant="rectangular" />
          <Skeleton className="h-96 w-full" variant="rectangular" />
        </div>
      </AppShell>
    );
  }

  if (!session) {
    return null;
  }

  const isKycPassed = kycStatus === 'pass';
  const isKycPending = kycStatus === 'pending' || kycStatus === 'review';
  const isKycRejected = kycStatus === 'fail';
  const showForm = canUpload && !isKycPassed && !isKycPending;

  return (
    <AppShell
      appName="ЛК Инвестора"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: investorNavItems }}
    >
      <PageHeader
        title="KYC верификация"
        description="Идентификация клиента в соответствии с 115-ФЗ"
      />

      <KycStatusCard
        kycStatus={kycStatus}
        rejectionReason={rejectionReason}
        updatedAt={complianceStatus?.updatedAt}
      />

      {isKycPending && (
        <Card className="mb-6">
          <CardContent className="p-6">
            <p className="text-lg font-semibold text-text-primary mb-2">Документы на проверке</p>
            <p className="text-text-secondary">
              Заявка отправлена, статус автоматически обновлён на «На проверке». Форма отправки
              закрыта, пока проверка не завершена.
            </p>
          </CardContent>
        </Card>
      )}

      {isKycRejected && (
        <Card className="mb-6">
          <CardContent className="p-6">
            <p className="text-lg font-semibold text-text-primary mb-2">Заявка отклонена</p>
            <p className="text-text-secondary">
              {rejectionReason
                ? `Причина: ${rejectionReason}. Вы можете обновить данные и отправить снова.`
                : 'Вы можете обновить данные и отправить заявку повторно.'}
            </p>
          </CardContent>
        </Card>
      )}

      {showForm && (
        <>
          <KycStepper currentStep={currentStep} onStepChange={goToStep} />

          <Card>
            <CardContent className="p-6">
              {currentStep === 0 && (
                <PersonalStep
                  data={formData}
                  errors={errors}
                  onChange={updateFormData}
                  setData={setFormData}
                />
              )}

              {currentStep === 1 && (
                <IdentityStep data={formData} errors={errors} onChange={updateFormData} />
              )}

              {currentStep === 2 && (
                <AddressStep data={formData} errors={errors} onChange={updateFormData} />
              )}

              {currentStep === 3 && (
                <ContactsStep
                  data={formData}
                  errors={errors}
                  onChange={updateFormData}
                  setData={setFormData}
                />
              )}

              {currentStep === 4 && (
                <DocumentsStep
                  selectedDocType={selectedDocType}
                  onDocTypeChange={setSelectedDocType}
                  localDocuments={localDocuments}
                  onAddDocument={handleAddDocument}
                  onRemoveDocument={handleRemoveDocument}
                  disableActions={isSubmitting}
                />
              )}

              <div className="flex justify-between mt-8 pt-4 border-t">
                <Button
                  variant="secondary"
                  onClick={() => goToStep(Math.max(0, currentStep - 1))}
                  disabled={currentStep === 0}
                >
                  Назад
                </Button>
                {currentStep < STEPS.length - 1 ? (
                  <Button onClick={() => goToStep(currentStep + 1)}>Далее</Button>
                ) : (
                  <Button
                    onClick={handleSubmit}
                    loading={isSubmitting}
                    disabled={!formData.consentToProcessing}
                  >
                    Отправить на проверку
                  </Button>
                )}
              </div>
            </CardContent>
          </Card>
        </>
      )}

      {isKycPassed && (
        <Card>
          <CardContent className="p-8 text-center">
            <p className="text-xl font-semibold text-text-primary mb-2">KYC верификация пройдена</p>
            <p className="text-text-secondary">
              Ваша личность подтверждена. Вы можете совершать операции на платформе.
            </p>
          </CardContent>
        </Card>
      )}
    </AppShell>
  );
}
</file>

<file path="apps/portal-issuer/src/app/dashboard/page.tsx">
'use client';

import { signOut, useSession } from 'next-auth/react';
import { redirect } from 'next/navigation';
import { AppShell, PageHeader, KPIGrid, Skeleton, Button } from '@ois/shared-ui';
import { FileText, DollarSign, Users } from 'lucide-react';
import Link from 'next/link';
import { useQuery } from '@tanstack/react-query';
import { getIssuerReports } from '@/lib/api/issuances';
import { issuerNavItems } from '@/lib/navigation';

export default function DashboardPage() {
  const { data: session, status } = useSession();

  // Типизированный доступ к данным пользователя
  interface IssuerUser {
    issuerId?: string;
    id?: string | null;
    roles?: string[];
  }
  const issuerUser = session?.user as IssuerUser | undefined;
  const issuerId = issuerUser?.issuerId || issuerUser?.id || '';

  const {
    data: issuancesReport,
    isLoading: reportLoading,
    isError: reportError,
    error,
  } = useQuery({
    queryKey: ['issuer-dashboard-report', issuerId],
    queryFn: async () => getIssuerReports(issuerId),
    enabled: status === 'authenticated' && !!issuerId,
    retry: 0,
  });

  if (status === 'loading') {
    return (
      <div className="p-8 flex items-center justify-center">
        <Skeleton className="h-8 w-32" />
      </div>
    );
  }

  if (!session) {
    redirect('/auth/signin');
  }

  const roles = issuerUser?.roles || [];
  if (!roles.includes('issuer')) {
    return <div className="p-8">Доступ запрещён. Требуется роль эмитента.</div>;
  }

  const summary = issuancesReport?.summary;
  const formatCurrency = (value?: number) =>
    typeof value === 'number'
      ? new Intl.NumberFormat('ru-RU', {
          style: 'currency',
          currency: 'RUB',
          maximumFractionDigits: 0,
        }).format(value)
      : '-';

  const kpiData = [
    {
      title: 'Всего выпусков',
      value: summary ? summary.totalIssuances.toString() : '-',
      description: 'Все выпуски эмитента',
      icon: FileText,
    },
    {
      title: 'Общая сумма',
      value: formatCurrency(summary?.totalAmount),
      description: 'Совокупный номинал',
      icon: DollarSign,
    },
    {
      title: 'Инвесторы',
      value: summary ? summary.totalInvestors.toString() : '-',
      description: 'Инвесторы по всем выпускам',
      icon: Users,
    },
  ];

  return (
    <AppShell
      appName="ЛК Эмитента"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: issuerNavItems }}
    >
      <PageHeader title="Главная" description="Обзор ваших выпусков и активности" />

      {reportLoading ? (
        <div className="grid grid-cols-1 gap-4 mb-8 md:grid-cols-3">
          {[0, 1, 2].map(i => (
            <Skeleton key={i} className="h-32 w-full rounded-xl" />
          ))}
        </div>
      ) : (
        <KPIGrid items={kpiData} columns={3} className="mb-8" />
      )}

      {reportError && (
        <div className="mb-4 rounded-md border border-danger-200 bg-danger-50 p-4 text-sm text-danger-800">
          Не удалось загрузить данные: {(error as Error)?.message ?? 'Неизвестная ошибка'}
        </div>
      )}

      <div className="flex flex-wrap gap-4">
        <Link href="/issuances">
          <Button variant="primary" size="lg">
            Список выпусков
          </Button>
        </Link>
        <Link href="/issuances/create">
          <Button variant="secondary" size="lg">
            Создать выпуск
          </Button>
        </Link>
      </div>
    </AppShell>
  );
}
</file>

<file path="apps/portal-issuer/src/app/issuances/page.tsx">
'use client';

import { useQuery } from '@tanstack/react-query';
import Link from 'next/link';
import { signOut, useSession } from 'next-auth/react';
import { redirect } from 'next/navigation';
import {
  AppShell,
  PageHeader,
  Button,
  Card,
  CardContent,
  Skeleton,
  EmptyState,
  DataTable,
  Badge,
} from '@ois/shared-ui';
import { ColumnDef } from '@tanstack/react-table';
import { Plus, Eye, FileText, TrendingUp } from 'lucide-react';
import { getIssuances, type Issuance, type IssuanceStatus } from '@/lib/mocks/issuances';
import { issuerNavItems } from '@/lib/navigation';

const statusLabels: Record<IssuanceStatus, string> = {
  draft: 'Черновик',
  published: 'Опубликован',
  closed: 'Закрыт',
  redeemed: 'Погашен',
};

const statusIntent: Record<IssuanceStatus, Parameters<typeof Badge>[0]['intent']> = {
  draft: 'neutral',
  published: 'success',
  closed: 'warning',
  redeemed: 'info',
};

export default function IssuancesPage() {
  const { data: session, status } = useSession();

  const {
    data: issuances,
    isLoading,
    error,
  } = useQuery({
    queryKey: ['issuances'],
    queryFn: async () => {
      // Use mock data
      return getIssuances();
    },
    enabled: status === 'authenticated',
  });

  if (status === 'loading') {
    return (
      <div className="p-8 flex items-center justify-center">
        <Skeleton className="h-8 w-32" variant="rectangular" />
      </div>
    );
  }

  if (!session) {
    redirect('/auth/signin');
  }

  const columns: ColumnDef<Issuance>[] = [
    {
      accessorKey: 'assetCode',
      header: 'Код',
      cell: ({ row }) => (
        <span className="font-mono text-sm text-text-primary">{row.original.assetCode}</span>
      ),
    },
    {
      accessorKey: 'assetName',
      header: 'Название',
      cell: ({ row }) => (
        <div className="flex items-center gap-2">
          <FileText className="h-4 w-4 text-text-tertiary" />
          <span className="font-medium text-text-primary">{row.original.assetName}</span>
        </div>
      ),
    },
    {
      accessorKey: 'totalAmount',
      header: 'Объем',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">
          {new Intl.NumberFormat('ru-RU', {
            style: 'currency',
            currency: 'RUB',
            maximumFractionDigits: 0,
          }).format(row.original.totalAmount)}
        </span>
      ),
    },
    {
      accessorKey: 'apy',
      header: 'Доходность',
      cell: ({ row }) => (
        <div className="flex items-center gap-1">
          <TrendingUp className="h-4 w-4 text-success-600" />
          <span className="text-sm font-medium text-success-600">{row.original.apy}%</span>
        </div>
      ),
    },
    {
      accessorKey: 'status',
      header: 'Статус',
      cell: ({ row }) => {
        const st = row.original.status;
        return <Badge intent={statusIntent[st]}>{statusLabels[st]}</Badge>;
      },
    },
    {
      accessorKey: 'maturityDate',
      header: 'Погашение',
      cell: ({ row }) => (
        <span className="text-sm text-text-secondary">
          {new Date(row.original.maturityDate).toLocaleDateString('ru-RU')}
        </span>
      ),
    },
    {
      id: 'actions',
      header: '',
      cell: ({ row }) => (
        <Link href={`/issuances/${row.original.id}`}>
          <Button variant="ghost" size="sm" aria-label={`Открыть выпуск ${row.original.assetCode}`}>
            <Eye className="h-4 w-4 mr-1" />
            Открыть
          </Button>
        </Link>
      ),
    },
  ];

  // Mobile card view for smaller screens
  const renderMobileCards = () => (
    <div className="space-y-4 md:hidden">
      {issuances?.map(issuance => (
        <Card key={issuance.id}>
          <CardContent className="p-4">
            <div className="flex justify-between items-start mb-3">
              <div>
                <p className="font-mono text-xs text-text-tertiary">{issuance.assetCode}</p>
                <h3 className="font-semibold text-text-primary">{issuance.assetName}</h3>
              </div>
              <Badge intent={statusIntent[issuance.status]}>{statusLabels[issuance.status]}</Badge>
            </div>
            <div className="grid grid-cols-2 gap-2 text-sm mb-3">
              <div>
                <p className="text-text-tertiary">Объем</p>
                <p className="font-medium text-text-primary">
                  {new Intl.NumberFormat('ru-RU', {
                    style: 'currency',
                    currency: 'RUB',
                    maximumFractionDigits: 0,
                  }).format(issuance.totalAmount)}
                </p>
              </div>
              <div>
                <p className="text-text-tertiary">Доходность</p>
                <p className="font-medium text-success-600">{issuance.apy}%</p>
              </div>
              <div>
                <p className="text-text-tertiary">Погашение</p>
                <p className="text-text-primary">
                  {new Date(issuance.maturityDate).toLocaleDateString('ru-RU')}
                </p>
              </div>
            </div>
            <Link href={`/issuances/${issuance.id}`}>
              <Button variant="secondary" size="sm" className="w-full">
                <Eye className="h-4 w-4 mr-1" />
                Подробнее
              </Button>
            </Link>
          </CardContent>
        </Card>
      ))}
    </div>
  );

  return (
    <AppShell
      appName="ЛК Эмитента"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: issuerNavItems }}
    >
      <PageHeader
        title="Выпуски"
        description="Управление вашими выпусками ЦФА"
        actions={
          <Link href="/issuances/create">
            <Button variant="primary">
              <Plus className="h-4 w-4 mr-2" />
              Создать выпуск
            </Button>
          </Link>
        }
      />

      {isLoading && (
        <div className="space-y-4">
          <Skeleton className="h-24 w-full" variant="rectangular" />
          <Skeleton className="h-24 w-full" variant="rectangular" />
          <Skeleton className="h-24 w-full" variant="rectangular" />
        </div>
      )}

      {error && (
        <div className="text-danger-600 p-4 bg-danger-50 border border-danger-200 rounded-md">
          Ошибка загрузки выпусков
        </div>
      )}

      {!isLoading && issuances && issuances.length === 0 && (
        <EmptyState
          title="Выпуски не найдены"
          description="Создайте первый выпуск для начала работы"
        />
      )}

      {!isLoading && issuances && issuances.length > 0 && (
        <>
          {/* Desktop table */}
          <div className="hidden md:block">
            <DataTable
              columns={columns}
              data={issuances}
              searchable
              labels={{ searchPlaceholder: "Поиск по коду или названию..." }}
              pageSize={10}
            />
          </div>

          {/* Mobile cards */}
          {renderMobileCards()}
        </>
      )}
    </AppShell>
  );
}
</file>

<file path="docs/deploy/API-DOCS-SWAGGER-ASYNCAPI.md">
---
created: 2025-11-23 13:30
updated: 2025-11-24 11:20
type: doc
sphere: exchange
topic: swagger-asyncapi-inventory
author: codex-8c38
agentID: 019aa5f8-8c38-7531-8809-841d16d27c63
partAgentID: [co-8c38, co-76ca]
version: 1.0.0
tags: [swagger, asyncapi, docs, cfa1]
---

# Swagger / AsyncAPI inventory (dev vs CFA1)

| Service | Swagger (dev) | Swagger (CFA1) | CFA1 HTTP (2025-11-24) | Protection / Notes |
| --- | --- | --- | --- | --- |
| API Gateway (`apps/api-gateway`) | http://localhost:5000/swagger/index.html | https://api.cfa1.llmneighbors.com/swagger/index.html | 200 | Public demo; add nginx basic auth / IP allowlist for prod |
| Identity (`services/identity`) | http://localhost:55001/swagger/index.html | http://87.249.49.56:55001/swagger/index.html | 200 | Internal IP access; keep behind VPN/SSH tunnel |
| Issuance (`services/issuance`) | http://localhost:55005/swagger/index.html | http://87.249.49.56:55005/swagger/index.html | 404 (Swagger disabled) | Enable via `Swagger__Enabled=true` + redeploy; Kafka off by default |
| Registry (`services/registry`) | http://localhost:55006/swagger/index.html | http://87.249.49.56:55006/swagger/index.html | 404 (Swagger disabled) | Enable via `Swagger__Enabled=true` + redeploy; Kafka off by default |
| Settlement (`services/settlement`) | http://localhost:55007/swagger/index.html | http://87.249.49.56:55007/swagger/index.html | 404 (Swagger disabled) | Enable via `Swagger__Enabled=true` + redeploy; Kafka off by default |
| Compliance (`services/compliance`) | http://localhost:55008/swagger/index.html | http://87.249.49.56:55008/swagger/index.html | 404 (Swagger disabled) | Enable via `Swagger__Enabled=true` + redeploy; Kafka off by default |

**Flags:** `Swagger__Enabled` read by all services even in Production; `docker-compose.services.yml` exports `SWAGGER_ENABLED=true`. Kafka now gated by `Kafka__Enabled` (default `false`) and `Kafka__BootstrapServers`.

## Runtime modes matrix

| Env | Swagger | Kafka | Mocks / notes |
| --- | --- | --- | --- |
| Dev/local (compose) | Enabled by default via `SWAGGER_ENABLED=true`; reachable on localhost ports from `.env` | Disabled by default (`KAFKA_ENABLED=false`); broker `kafka:9092` available if enabled | Ledger adapters use mocks; migrations off (`MIGRATE_ON_STARTUP=false`) |
| CFA1 demo | Gateway + identity 200; core services currently 404 until redeploy with `SWAGGER_ENABLED=true` | Disabled (`Kafka__Enabled=false`); outbox collects events; enable once broker stable | Access via `api.cfa1.llmneighbors.com` and `87.249.49.56:{55001..55008}`; add basic auth/VPN for exposure |
| UK1 reference | Read-only, no changes | Assumed disabled; do not modify | Reference only |

## Kafka & events status

- `Kafka:Enabled` flag added to issuance/registry/settlement/compliance; when `false` MassTransit and outbox publishers are skipped, HTTP + Swagger continue to work.
- Topics mapped explicitly to AsyncAPI names (`ois.issuance.published/closed`, `ois.order.*`, `ois.compliance.flagged`, `ois.audit.logged`, `ois.payout.executed`).
- Minimal flow: issuance `PublishAsync` writes `ois.issuance.published` (with `dltTxHash`) to outbox; when Kafka is enabled it publishes to the same topic.
- AsyncAPI bumped to 1.1.0 (ledger hashes added, CFA1 server entry). Validation via `ops/scripts/validate-specs.sh` passes (only info-level notice to upgrade to AsyncAPI 3.0.0); latest run 2025-11-24.

## Current checks (2025-11-24)

- `PATH=$HOME/.dotnet:$PATH dotnet test services/compliance/compliance.csproj` ✓ (NU1504 warning about duplicate PackageReference).
- Playwright `swagger-availability.spec.ts` ✓ (gateway 200).
- Playwright `swagger-all-services.spec.ts` ❌ on CFA1 for issuance/registry/settlement/compliance (HTTP 404 — Swagger disabled there). Redeploy with `SWAGGER_ENABLED=true` expected to flip to 200.
- `bash ops/scripts/validate-specs.sh` ✓ (AsyncAPI info: suggest upgrade to v3.0.0; latest run 2025-11-24).
</file>

<file path="services/compliance/Program.cs">
using Microsoft.EntityFrameworkCore;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using System.Collections.Generic;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using OIS.Compliance.Services;
using OIS.Compliance.Infrastructure;
using MassTransit;
using OIS.Contracts.Events;
using Serilog;
using System.Text;
using System.Text.Json;
using Microsoft.AspNetCore.RateLimiting;
using System.Threading.RateLimiting;

// Import DTOs
using KycDocumentDto = OIS.Compliance.DTOs.KycDocumentDto;
using QualificationTaskDto = OIS.Compliance.DTOs.QualificationTaskDto;
using CreateQualificationTaskRequest = OIS.Compliance.DTOs.CreateQualificationTaskRequest;
using QualificationDecisionRequest = OIS.Compliance.DTOs.QualificationDecisionRequest;
using ComplaintReplyRequest = OIS.Compliance.DTOs.ComplaintReplyRequest;
using ComplaintResolveRequest = OIS.Compliance.DTOs.ComplaintResolveRequest;

// Helper function to extract user ID from ClaimsPrincipal
static Guid? GetUserId(ClaimsPrincipal user)
{
    var claim = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    if (claim != null && Guid.TryParse(claim, out var guid))
        return guid;
    return null;
}

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("compliance-service"))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Database
var complianceMigrationsAssembly = typeof(ComplianceDbContext).Assembly.GetName().Name;
builder.Services.AddDbContext<ComplianceDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions => npgsqlOptions.MigrationsAssembly(complianceMigrationsAssembly))
    .ConfigureWarnings(warnings => warnings.Ignore(Microsoft.EntityFrameworkCore.Diagnostics.RelationalEventId.PendingModelChangesWarning)));

// Services
builder.Services.AddScoped<IWatchlistsService, WatchlistsServiceStub>();
builder.Services.AddScoped<IQualificationPolicyService, QualificationPolicyService>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IComplianceService, ComplianceService>();

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<ComplianceDbContext>();

// Rate limiting
builder.Services.AddRateLimiter(options =>
{
    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
    options.AddPolicy("sensitive", httpContext =>
    {
        var key = httpContext.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
        if (!string.IsNullOrEmpty(key)) key = $"user:{key}"; else key = $"ip:{httpContext.Connection.RemoteIpAddress}";
        return RateLimitPartition.GetTokenBucketLimiter(key!, _ => new TokenBucketRateLimiterOptions
        {
            TokenLimit = 10,
            TokensPerPeriod = 10,
            ReplenishmentPeriod = TimeSpan.FromSeconds(1),
            AutoReplenishment = true,
            QueueLimit = 0,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst
        });
    });
});

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        var audienceConfig = builder.Configuration["Keycloak:Audience"] ?? builder.Configuration["Keycloak:ClientId"];
        // ValidIssuer can be different from Authority in Docker environments
        // Authority = URL for fetching JWKS (internal Docker network)
        // ValidIssuer = The 'iss' claim in JWT tokens (public URL)
        var validIssuer = builder.Configuration["Keycloak:ValidIssuer"] ?? authority;
        if (string.IsNullOrWhiteSpace(authority))
            throw new InvalidOperationException("Keycloak:Authority must be configured for JWT validation");
        if (string.IsNullOrWhiteSpace(audienceConfig))
            throw new InvalidOperationException("Keycloak:Audience (or ClientId) must be configured for JWT validation");

        // Support comma-separated list of valid audiences (e.g., "compliance-service,portal-investor,account")
        var validAudiences = audienceConfig.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        options.Authority = authority;
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidIssuer = validIssuer.TrimEnd('/'),
            ValidateAudience = true,
            ValidAudiences = validAudiences,
            ValidateLifetime = true,
            RoleClaimType = ClaimTypes.Role
        };
        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx => { MapKeycloakRoles(ctx); return Task.CompletedTask; }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:investor", p => p.RequireRole("investor"));
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:backoffice", p => p.RequireRole("backoffice"));
    options.AddPolicy("role:investor-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
    options.AddPolicy("role:issuer-or-investor-or-backoffice", p =>
        p.RequireAssertion(ctx =>
            ctx.User.IsInRole("issuer") || ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
});

// MassTransit + Kafka for publishing
var kafkaEnabled = builder.Configuration.GetValue<bool>("Kafka:Enabled", false);
var kafkaBootstrap = builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092";
if (kafkaEnabled)
{
    builder.Services.AddMassTransit(x =>
    {
        // In-memory transport ensures IBus/IPublishEndpoint are available for outbox publishing
        x.UsingInMemory((context, cfg) =>
        {
            cfg.ConfigureEndpoints(context);
        });

        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(kafkaBootstrap);
                cfg.Message<ComplianceFlagged>(m => m.SetEntityName("ois.compliance.flagged"));
                cfg.Message<KycUpdated>(m => m.SetEntityName("ois.kyc.updated"));
                cfg.Message<AuditLogged>(m => m.SetEntityName("ois.audit.logged"));
            });
        });
    });

    builder.Services.AddHostedService<OIS.Compliance.Background.OutboxPublisher>();
}

var app = builder.Build();

// Apply migrations (optional, via MIGRATE_ON_STARTUP=true)
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<ComplianceDbContext>();
    db.Database.Migrate();
}

// Configure pipeline
var swaggerEnabled = app.Configuration.GetValue<bool?>("Swagger:Enabled") ?? app.Environment.IsDevelopment();
if (swaggerEnabled)
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");
app.UseRateLimiter();

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();
    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// (Kafka rider configured above)

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Compliance").RequireAuthorization();

api.MapPost("/compliance/kyc/check", async (
    KycCheckRequest request,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.CheckKycAsync(request, ct);
    return Results.Ok(result);
})
.WithName("CheckKyc")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapPost("/compliance/qualification/evaluate", async (
    QualificationEvaluateRequest request,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.EvaluateQualificationAsync(request, ct);
    return Results.Ok(result);
})
.WithName("EvaluateQualification")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapGet("/compliance/investors/{id:guid}/status", async (
    Guid id,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.GetInvestorStatusAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetInvestorStatus")
.RequireAuthorization("role:issuer-or-investor-or-backoffice")
.WithOpenApi();

var complaintsApi = app.MapGroup("/v1/complaints").WithTags("Complaints").RequireAuthorization();

complaintsApi.MapPost("", async (
    CreateComplaintRequest request,
    HttpContext httpContext,
    IComplianceService service,
    CancellationToken ct) =>
{
    string? idemKey = null;
    if (httpContext.Request.Headers.TryGetValue("Idempotency-Key", out var idemKeyValues))
    {
        idemKey = idemKeyValues.FirstOrDefault();
    }

    var userId = GetUserId(httpContext.User);
    var isInvestor = httpContext.User.IsInRole("investor");
    var isBackoffice = httpContext.User.IsInRole("backoffice");

    Guid? investorId = request.InvestorId;
    if (isInvestor)
    {
        if (userId is null) return Results.BadRequest(new { error = "Не удалось определить пользователя" });
        if (investorId.HasValue && investorId != userId) return Results.Forbid();
        investorId = userId;
    }
    else if (!isBackoffice)
    {
        return Results.Forbid();
    }

    if (!investorId.HasValue)
        return Results.BadRequest(new { error = "investorId обязателен" });

    var normalized = request with { InvestorId = investorId };
    var result = await service.CreateComplaintAsync(normalized, idemKey, ct);
    return Results.Created($"/v1/complaints/{result.Id}", result);
})
.WithName("CreateComplaint")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

complaintsApi.MapGet("/{id:guid}", async (
    Guid id,
    HttpContext httpContext,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.GetComplaintAsync(id, ct);
    if (result == null) return Results.NotFound();

    if (httpContext.User.IsInRole("investor"))
    {
        var userId = GetUserId(httpContext.User);
        if (userId is null || (result.InvestorId.HasValue && result.InvestorId != userId))
            return Results.Forbid();
    }

    return Results.Ok(result);
})
.WithName("GetComplaint")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

// KYC endpoints
var kycApi = app.MapGroup("/v1/compliance/kyc").WithTags("KYC");

kycApi.MapPost("", async (
    KycApplicationRequest request,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actorId = TryGetUserId(http);
    var investorId = request.InvestorId ?? actorId;
    if (investorId is null)
    {
        return Results.BadRequest(new { error = "investorId is required" });
    }

    var reasonParts = new List<string>();
    if (!string.IsNullOrWhiteSpace(request.FullName)) reasonParts.Add($"name={request.FullName}");
    if (!string.IsNullOrWhiteSpace(request.DocumentType) || !string.IsNullOrWhiteSpace(request.DocumentNumber))
    {
        var doc = $"{request.DocumentType} {request.DocumentNumber}".Trim();
        if (!string.IsNullOrWhiteSpace(doc)) reasonParts.Add($"doc={doc}");
    }
    if (!string.IsNullOrWhiteSpace(request.Comment)) reasonParts.Add($"comment={request.Comment}");
    var reason = reasonParts.Count > 0 ? string.Join("; ", reasonParts) : "kyc submitted";

    await service.UpdateKycStatusAsync(investorId.Value, "pending", actorId, reason, ct);
    var task = await service.CreateKycTaskAsync(investorId.Value, reason, ct);

    var dto = new KycRequestDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        Status = NormalizeKycStatus(task.Status),
        Reason = task.Reason,
        CreatedAt = task.CreatedAt,
        ResolvedAt = task.ResolvedAt
    };

    return Results.Created($"/v1/compliance/kyc/{dto.Id}", dto);
})
.WithName("SubmitKycApplication")
.RequireAuthorization("role:issuer-or-investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

var kycAdminApi = kycApi.RequireAuthorization("role:backoffice");

kycAdminApi.MapPost("/investors/{id:guid}/approve", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actor = TryGetUserId(http);
    var result = await service.UpdateKycStatusAsync(id, "pass", actor, null, ct);
    return Results.Ok(result);
})
.WithName("ApproveKyc")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycAdminApi.MapPost("/investors/{id:guid}/reject", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actor = TryGetUserId(http);
    var result = await service.UpdateKycStatusAsync(id, "fail", actor, null, ct);
    return Results.Ok(result);
})
.WithName("RejectKyc")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// Backoffice KYC list + decision (UI expects /v1/compliance/kyc and /v1/compliance/kyc/{id}/decision)
kycAdminApi.MapGet("", async (
    string? status,
    IComplianceService service,
    CancellationToken ct) =>
{
    var tasks = await service.ListKycTasksAsync(status switch
    {
        "pending" => "open",
        "approved" => "approved",
        "rejected" => "rejected",
        _ => null
    }, ct);

    var mapped = tasks.Select(t => new KycRequestDto
    {
        Id = t.Id,
        InvestorId = t.InvestorId,
        Status = NormalizeKycStatus(t.Status),
        Reason = t.Reason,
        CreatedAt = t.CreatedAt,
        ResolvedAt = t.ResolvedAt
    }).ToArray();

    return Results.Ok(mapped);
})
.WithName("ListKycRequests")
.WithOpenApi();

kycAdminApi.MapPost("/{id:guid}/decision", async (
    Guid id,
    KycDecisionRequest body,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var action = body.Decision?.ToLowerInvariant() == "approved" ? "approve" : "reject";
    var actor = TryGetUserId(http);

    var task = await service.ResolveKycTaskAsync(id, action, actor, body.Comment, ct);
    if (task == null) return Results.NotFound();

    var dto = new KycRequestDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        Status = NormalizeKycStatus(task.Status),
        Reason = task.Reason,
        CreatedAt = task.CreatedAt,
        ResolvedAt = task.ResolvedAt
    };
    return Results.Ok(dto);
})
.WithName("ResolveKycRequest")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// KYC tasks queue
var kycTasks = app.MapGroup("/v1/kyc/tasks").WithTags("KYC Tasks").RequireAuthorization("role:backoffice");

kycTasks.MapPost("", async (
    CreateKycTaskRequest req,
    IComplianceService service,
    CancellationToken ct) =>
{
    var task = await service.CreateKycTaskAsync(req.InvestorId, req.Reason, ct);
    return Results.Created($"/v1/kyc/tasks/{task.Id}", task);
})
.WithName("CreateKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycTasks.MapGet("", async (
    string? status,
    IComplianceService service,
    CancellationToken ct) =>
{
    var list = await service.ListKycTasksAsync(status, ct);
    return Results.Ok(list);
})
.WithName("ListKycTasks")
.WithOpenApi();

kycTasks.MapPost("/{id:guid}/approve", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    Guid? actor = http.User.Identity?.IsAuthenticated == true ?
        http.User.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.NameIdentifier)?.Value is string s && Guid.TryParse(s, out var g) ? g : null
        : null;

    var task = await service.ResolveKycTaskAsync(id, "approve", actor, null, ct);
    return task != null ? Results.Ok(task) : Results.NotFound();
})
.WithName("ApproveKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycTasks.MapPost("/{id:guid}/reject", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    Guid? actor = http.User.Identity?.IsAuthenticated == true ?
        http.User.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.NameIdentifier)?.Value is string s && Guid.TryParse(s, out var g) ? g : null
        : null;

    var task = await service.ResolveKycTaskAsync(id, "reject", actor, null, ct);
    return task != null ? Results.Ok(task) : Results.NotFound();
})
.WithName("RejectKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// ============================================
// KYC Documents API
// ============================================
var kycDocsApi = app.MapGroup("/v1/kyc/documents").WithTags("KYC Documents").RequireAuthorization();

kycDocsApi.MapPost("", async (
    HttpRequest request,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var user = request.HttpContext.User;
    var userId = GetUserId(user);
    var isInvestor = user.IsInRole("investor");
    var isBackoffice = user.IsInRole("backoffice");

    if (!request.HasFormContentType)
        return Results.BadRequest(new { error = "Request must be multipart/form-data" });

    var form = await request.ReadFormAsync(ct);
    var file = form.Files.GetFile("file");
    var investorIdStr = form["investorId"].FirstOrDefault();
    var documentType = form["documentType"].FirstOrDefault() ?? "other";

    if (file == null || file.Length == 0)
        return Results.BadRequest(new { error = "File is required" });

    if (!Guid.TryParse(investorIdStr, out var investorId))
        return Results.BadRequest(new { error = "Valid investorId is required" });

    // Validate file size (max 10MB)
    if (file.Length > 10 * 1024 * 1024)
        return Results.BadRequest(new { error = "File size must not exceed 10MB" });

    // Validate mime type
    var allowedTypes = new[] { "application/pdf", "image/jpeg", "image/png", "image/jpg" };
    if (!allowedTypes.Contains(file.ContentType.ToLower()))
        return Results.BadRequest(new { error = "Only PDF, JPG, and PNG files are allowed" });

    if (isInvestor)
    {
        if (userId is null) return Results.BadRequest(new { error = "Не удалось определить пользователя" });
        if (investorId != userId) return Results.Forbid();
    }
    else if (!isBackoffice)
    {
        return Results.Forbid();
    }

    using var ms = new MemoryStream();
    await file.CopyToAsync(ms, ct);

    var doc = new KycDocumentEntity
    {
        Id = Guid.NewGuid(),
        InvestorId = investorId,
        DocumentType = documentType,
        FileName = file.FileName,
        FileSize = file.Length,
        MimeType = file.ContentType,
        Status = "uploaded",
        FileData = ms.ToArray(),
        UploadedAt = DateTime.UtcNow
    };

    db.KycDocuments.Add(doc);
    await db.SaveChangesAsync(ct);

    return Results.Created($"/v1/kyc/documents/{doc.Id}", new KycDocumentDto
    {
        Id = doc.Id,
        InvestorId = doc.InvestorId,
        DocumentType = doc.DocumentType,
        FileName = doc.FileName,
        FileSize = doc.FileSize,
        MimeType = doc.MimeType,
        Status = doc.Status,
        UploadedAt = doc.UploadedAt
    });
})
.WithName("UploadKycDocument")
.RequireAuthorization("role:investor-or-backoffice")
.DisableAntiforgery()
.WithOpenApi();

kycDocsApi.MapGet("/{id:guid}", async (
    Guid id,
    ComplianceDbContext db,
    HttpContext httpContext,
    CancellationToken ct) =>
{
    var doc = await db.KycDocuments.FindAsync(new object[] { id }, ct);
    if (doc == null) return Results.NotFound();

    if (httpContext.User.IsInRole("investor"))
    {
        var userId = GetUserId(httpContext.User);
        if (userId is null || doc.InvestorId != userId) return Results.Forbid();
    }

    return Results.Ok(new KycDocumentDto
    {
        Id = doc.Id,
        InvestorId = doc.InvestorId,
        DocumentType = doc.DocumentType,
        FileName = doc.FileName,
        FileSize = doc.FileSize,
        MimeType = doc.MimeType,
        Status = doc.Status,
        RejectionReason = doc.RejectionReason,
        UploadedAt = doc.UploadedAt,
        VerifiedAt = doc.VerifiedAt
    });
})
.WithName("GetKycDocument")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

kycDocsApi.MapDelete("/{id:guid}", async (
    Guid id,
    ComplianceDbContext db,
    HttpContext httpContext,
    CancellationToken ct) =>
{
    var doc = await db.KycDocuments.FindAsync(new object[] { id }, ct);
    if (doc == null) return Results.NotFound();

    if (httpContext.User.IsInRole("investor"))
    {
        var userId = GetUserId(httpContext.User);
        if (userId is null || doc.InvestorId != userId) return Results.Forbid();
    }

    db.KycDocuments.Remove(doc);
    await db.SaveChangesAsync(ct);

    return Results.NoContent();
})
.WithName("DeleteKycDocument")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

kycDocsApi.MapGet("/{id:guid}/download", async (
    Guid id,
    ComplianceDbContext db,
    HttpContext httpContext,
    CancellationToken ct) =>
{
    var doc = await db.KycDocuments.FindAsync(new object[] { id }, ct);
    if (doc == null) return Results.NotFound();

    if (httpContext.User.IsInRole("investor"))
    {
        var userId = GetUserId(httpContext.User);
        if (userId is null || doc.InvestorId != userId) return Results.Forbid();
    }

    return Results.File(doc.FileData, doc.MimeType, doc.FileName);
})
.WithName("DownloadKycDocument")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

var kycInvestorDocsApi = app.MapGroup("/v1/kyc/investors").WithTags("KYC Documents").RequireAuthorization();

kycInvestorDocsApi.MapGet("/{investorId:guid}/documents", async (
    Guid investorId,
    ComplianceDbContext db,
    HttpContext httpContext,
    CancellationToken ct) =>
{
    if (httpContext.User.IsInRole("investor"))
    {
        var userId = GetUserId(httpContext.User);
        if (userId is null || userId != investorId) return Results.Forbid();
    }

    var docs = await db.KycDocuments
        .Where(d => d.InvestorId == investorId)
        .OrderByDescending(d => d.UploadedAt)
        .Select(d => new KycDocumentDto
        {
            Id = d.Id,
            InvestorId = d.InvestorId,
            DocumentType = d.DocumentType,
            FileName = d.FileName,
            FileSize = d.FileSize,
            MimeType = d.MimeType,
            Status = d.Status,
            RejectionReason = d.RejectionReason,
            UploadedAt = d.UploadedAt,
            VerifiedAt = d.VerifiedAt
        })
        .ToListAsync(ct);

    return Results.Ok(docs);
})
.WithName("ListInvestorKycDocuments")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

// ============================================
// Qualification Tasks API
// ============================================
var qualTasksApi = app.MapGroup("/v1/qualification/tasks").WithTags("Qualification Tasks").RequireAuthorization();

qualTasksApi.MapGet("", async (
    string? status,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var query = db.QualificationTasks.AsQueryable();
    if (!string.IsNullOrEmpty(status))
        query = query.Where(t => t.Status == status);

    var rawTasks = await query
        .OrderByDescending(t => t.CreatedAt)
        .ToListAsync(ct);

    var tasks = rawTasks.Select(t => new QualificationTaskDto
    {
        Id = t.Id,
        InvestorId = t.InvestorId,
        QualificationBasis = t.QualificationBasis,
        Status = t.Status,
        AssignedTier = t.AssignedTier,
        AssignedLimit = t.AssignedLimit,
        Reason = t.Reason,
        DocumentIds = string.IsNullOrEmpty(t.DocumentIds) ? null : JsonSerializer.Deserialize<List<Guid>>(t.DocumentIds),
        CreatedAt = t.CreatedAt,
        ResolvedAt = t.ResolvedAt,
        ResolvedBy = t.ResolvedBy,
        ExpiresAt = t.ExpiresAt
    }).ToList();

    return Results.Ok(tasks);
})
.WithName("ListQualificationTasks")
.RequireAuthorization("role:backoffice")
.WithOpenApi();

qualTasksApi.MapPost("", async (
    CreateQualificationTaskRequest req,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var details = JsonSerializer.Serialize(new
    {
        req.TradingTurnover,
        req.TradingFrequency,
        req.TotalAssets,
        req.AnnualIncome,
        req.WorkExperience,
        req.Education,
        req.QualificationCertificate
    });

    var task = new QualificationTaskEntity
    {
        Id = Guid.NewGuid(),
        InvestorId = req.InvestorId,
        QualificationBasis = req.QualificationBasis,
        Status = "open",
        DocumentIds = req.DocumentIds != null ? JsonSerializer.Serialize(req.DocumentIds) : null,
        Reason = details,
        CreatedAt = DateTime.UtcNow
    };

    db.QualificationTasks.Add(task);
    await db.SaveChangesAsync(ct);

    return Results.Created($"/v1/qualification/tasks/{task.Id}", new QualificationTaskDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        QualificationBasis = task.QualificationBasis,
        Status = task.Status,
        CreatedAt = task.CreatedAt
    });
})
.WithName("CreateQualificationTask")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

qualTasksApi.MapGet("/{id:guid}", async (
    Guid id,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var task = await db.QualificationTasks.FindAsync(new object[] { id }, ct);
    if (task == null) return Results.NotFound();

    return Results.Ok(new QualificationTaskDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        QualificationBasis = task.QualificationBasis,
        Status = task.Status,
        AssignedTier = task.AssignedTier,
        AssignedLimit = task.AssignedLimit,
        Reason = task.Reason,
        DocumentIds = string.IsNullOrEmpty(task.DocumentIds) ? null : JsonSerializer.Deserialize<List<Guid>>(task.DocumentIds),
        CreatedAt = task.CreatedAt,
        ResolvedAt = task.ResolvedAt,
        ResolvedBy = task.ResolvedBy,
        ExpiresAt = task.ExpiresAt
    });
})
.WithName("GetQualificationTask")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

qualTasksApi.MapPost("/{id:guid}/approve", async (
    Guid id,
    QualificationDecisionRequest? body,
    HttpContext http,
    ComplianceDbContext db,
    IComplianceService service,
    CancellationToken ct) =>
{
    var task = await db.QualificationTasks.FindAsync(new object[] { id }, ct);
    if (task == null) return Results.NotFound();

    Guid? actor = http.User.Identity?.IsAuthenticated == true
        ? http.User.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.NameIdentifier)?.Value is string s && Guid.TryParse(s, out var g) ? g : null
        : null;

    task.Status = "approved";
    task.AssignedTier = body?.Tier ?? "qualified";
    task.AssignedLimit = body?.Limit;
    task.Reason = body?.Reason;
    task.ResolvedAt = DateTime.UtcNow;
    task.ResolvedBy = actor;
    task.ExpiresAt = DateTime.UtcNow.AddYears(1); // Qualification valid for 1 year

    // Update investor qualification status
    var investor = await db.InvestorsCompliance.FindAsync(new object[] { task.InvestorId }, ct);
    if (investor != null)
    {
        investor.QualificationTier = task.AssignedTier ?? "qualified";
        investor.QualLimit = task.AssignedLimit;
        investor.UpdatedAt = DateTime.UtcNow;
    }

    await db.SaveChangesAsync(ct);

    return Results.Ok(new QualificationTaskDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        QualificationBasis = task.QualificationBasis,
        Status = task.Status,
        AssignedTier = task.AssignedTier,
        AssignedLimit = task.AssignedLimit,
        Reason = task.Reason,
        ResolvedAt = task.ResolvedAt,
        ResolvedBy = task.ResolvedBy,
        ExpiresAt = task.ExpiresAt
    });
})
.WithName("ApproveQualificationTask")
.RequireAuthorization("role:backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

qualTasksApi.MapPost("/{id:guid}/reject", async (
    Guid id,
    QualificationDecisionRequest body,
    HttpContext http,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var task = await db.QualificationTasks.FindAsync(new object[] { id }, ct);
    if (task == null) return Results.NotFound();

    Guid? actor = http.User.Identity?.IsAuthenticated == true
        ? http.User.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.NameIdentifier)?.Value is string s && Guid.TryParse(s, out var g) ? g : null
        : null;

    task.Status = "rejected";
    task.Reason = body.Reason ?? "Не соответствует критериям квалификации";
    task.ResolvedAt = DateTime.UtcNow;
    task.ResolvedBy = actor;

    await db.SaveChangesAsync(ct);

    return Results.Ok(new QualificationTaskDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        QualificationBasis = task.QualificationBasis,
        Status = task.Status,
        Reason = task.Reason,
        ResolvedAt = task.ResolvedAt,
        ResolvedBy = task.ResolvedBy
    });
})
.WithName("RejectQualificationTask")
.RequireAuthorization("role:backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// ============================================
// Complaints Reply/Resolve API
// ============================================
complaintsApi.MapPost("/{id:guid}/reply", async (
    Guid id,
    ComplaintReplyRequest body,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var complaint = await db.Complaints.FindAsync(new object[] { id }, ct);
    if (complaint == null) return Results.NotFound();

    // Update status to in_progress if it was open
    if (complaint.Status == "open")
        complaint.Status = "in_progress";

    // In a real implementation, you'd store replies in a separate table
    // For now, we just update the status
    await db.SaveChangesAsync(ct);

    return Results.Ok(new ComplaintResponse
    {
        Id = complaint.Id,
        InvestorId = complaint.InvestorId,
        Category = complaint.Category,
        Text = complaint.Text,
        Status = complaint.Status,
        SlaDue = complaint.SlaDue,
        CreatedAt = complaint.CreatedAt,
        ResolvedAt = complaint.ResolvedAt
    });
})
.WithName("ReplyToComplaint")
.RequireAuthorization("role:backoffice")
.WithOpenApi();

complaintsApi.MapPost("/{id:guid}/resolve", async (
    Guid id,
    ComplaintResolveRequest? body,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var complaint = await db.Complaints.FindAsync(new object[] { id }, ct);
    if (complaint == null) return Results.NotFound();

    var resolution = body?.Resolution ?? "resolved";
    complaint.Status = resolution == "rejected" ? "closed" : resolution;
    complaint.ResolvedAt = DateTime.UtcNow;

    await db.SaveChangesAsync(ct);

    return Results.Ok(new ComplaintResponse
    {
        Id = complaint.Id,
        InvestorId = complaint.InvestorId,
        Category = complaint.Category,
        Text = complaint.Text,
        Status = complaint.Status,
        SlaDue = complaint.SlaDue,
        CreatedAt = complaint.CreatedAt,
        ResolvedAt = complaint.ResolvedAt
    });
})
.WithName("ResolveComplaint")
.RequireAuthorization("role:backoffice")
.WithOpenApi();

// Audit reporting (immutable, from outbox write-ahead log)
var auditApi = app.MapGroup("/v1/audit").WithTags("Audit").RequireAuthorization("role:backoffice");

auditApi.MapGet("", async (
    Guid? actor,
    string? action,
    string? entity,
    DateTime? from,
    DateTime? to,
    int? limit,
    int? offset,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var take = Math.Clamp(limit ?? 20, 1, 100);
    var skip = Math.Max(offset ?? 0, 0);

    var baseQuery = db.OutboxMessages.Where(m => m.Topic == "ois.audit.logged");
    if (from.HasValue) baseQuery = baseQuery.Where(m => m.CreatedAt >= from.Value);
    if (to.HasValue) baseQuery = baseQuery.Where(m => m.CreatedAt <= to.Value);

    var rows = await baseQuery
        .OrderByDescending(m => m.CreatedAt)
        .Take(take + skip + 500) // small buffer for payload-level filters
        .ToListAsync(ct);

    var filtered = rows.Where(m =>
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            var root = doc.RootElement;
            if (actor.HasValue)
            {
                var actorVal = root.TryGetProperty("actor", out var el) ? el.GetString() : null;
                if (!Guid.TryParse(actorVal, out var a) || a != actor.Value) return false;
            }
            if (!string.IsNullOrEmpty(action))
            {
                var act = root.TryGetProperty("action", out var el) ? el.GetString() : null;
                if (!string.Equals(act, action, StringComparison.OrdinalIgnoreCase)) return false;
            }
            if (!string.IsNullOrEmpty(entity))
            {
                var ent = root.TryGetProperty("entity", out var el) ? el.GetString() : null;
                if (!string.Equals(ent, entity, StringComparison.OrdinalIgnoreCase)) return false;
            }
            var ts = root.TryGetProperty("timestamp", out var tsEl) && tsEl.ValueKind == JsonValueKind.String
                ? DateTime.Parse(tsEl.GetString()!)
                : m.CreatedAt;
            if (from.HasValue && ts < from.Value) return false;
            if (to.HasValue && ts > to.Value) return false;
            return true;
        }
        catch
        {
            return false;
        }
    });

    var page = filtered.Skip(skip).Take(take).Select(m => MapAudit(m)).ToList();

    return Results.Ok(new { items = page });
})
.WithName("GetAuditEvents")
.WithOpenApi();

auditApi.MapGet("/{id:guid}", async (
    Guid id,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var msg = await db.OutboxMessages
        .Where(m => m.Topic == "ois.audit.logged")
        .OrderByDescending(m => m.CreatedAt)
        .ToListAsync(ct);

    foreach (var m in msg)
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            if (doc.RootElement.TryGetProperty("id", out var idEl) && idEl.ValueKind == JsonValueKind.String)
            {
                if (Guid.TryParse(idEl.GetString(), out var aid) && aid == id)
                    return Results.Ok(MapAudit(m));
            }
        }
        catch { }
    }
    return Results.NotFound();
})
.WithName("GetAuditEvent")
.WithOpenApi();

auditApi.MapGet("/export.csv", async (
    Guid? actor,
    string? action,
    string? entity,
    DateTime? from,
    DateTime? to,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var sb = new StringBuilder();
    // Stable header
    sb.AppendLine("id,actor,actorName,action,entity,entityId,result,timestamp,ip,userAgent");

    var query = db.OutboxMessages
        .Where(m => m.Topic == "ois.audit.logged");
    if (from.HasValue) query = query.Where(m => m.CreatedAt >= from.Value);
    if (to.HasValue) query = query.Where(m => m.CreatedAt <= to.Value);

    var rows = query
        .OrderBy(m => m.CreatedAt) // chronological for exports
        .Take(10000) // safety cap
        .AsEnumerable();

    foreach (var m in rows)
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            var r = doc.RootElement;
            var idStr = r.TryGetProperty("id", out var idEl) ? idEl.GetString() : null;
            var actorStr = r.TryGetProperty("actor", out var actEl) ? actEl.GetString() : null;
            var actorName = r.TryGetProperty("actorName", out var anEl) ? anEl.GetString() : null;
            var actionStr = r.TryGetProperty("action", out var acEl) ? acEl.GetString() : null;
            var entityStr = r.TryGetProperty("entity", out var enEl) ? enEl.GetString() : null;
            var entityId = r.TryGetProperty("entityId", out var eiEl) ? eiEl.GetString() : null;
            var result = r.TryGetProperty("result", out var resEl) ? resEl.GetString() : null;
            var ts = r.TryGetProperty("timestamp", out var tsEl) ? tsEl.GetString() : m.CreatedAt.ToString("O");
            var ip = r.TryGetProperty("ip", out var ipEl) ? ipEl.GetString() : null;
            var ua = r.TryGetProperty("userAgent", out var uaEl) ? uaEl.GetString() : null;

            // Filter checks
            if (actor.HasValue && (!Guid.TryParse(actorStr, out var a) || a != actor.Value)) continue;
            if (!string.IsNullOrEmpty(action) && !string.Equals(actionStr, action, StringComparison.OrdinalIgnoreCase)) continue;
            if (!string.IsNullOrEmpty(entity) && !string.Equals(entityStr, entity, StringComparison.OrdinalIgnoreCase)) continue;
            if (from.HasValue && DateTime.Parse(ts) < from.Value) continue;
            if (to.HasValue && DateTime.Parse(ts) > to.Value) continue;

            sb.AppendLine(string.Join(',', new[]
            {
                Csv(idStr), Csv(actorStr), Csv(actorName), Csv(actionStr), Csv(entityStr), Csv(entityId), Csv(result), Csv(ts), Csv(ip), Csv(ua)
            }));
        }
        catch { }
    }

    return Results.Text(sb.ToString(), "text/csv", Encoding.UTF8);
})
.WithName("ExportAuditCsv")
.WithOpenApi();

static string Csv(string? s)
{
    if (s is null) return "";
    var needsQuotes = s.Contains(',') || s.Contains('"') || s.Contains('\n') || s.Contains('\r');
    var escaped = s.Replace("\"", "\"\"");
    return needsQuotes ? $"\"{escaped}\"" : escaped;
}

static object MapAudit(OutboxMessage m)
{
    try
    {
        using var doc = JsonDocument.Parse(m.Payload);
        var r = doc.RootElement;
        return new
        {
            id = Guid.TryParse(r.TryGetProperty("id", out var idEl) ? idEl.GetString() : null, out var aid) ? aid : m.Id,
            actor = r.TryGetProperty("actor", out var actEl) ? actEl.GetString() : null,
            actorName = r.TryGetProperty("actorName", out var anEl) ? anEl.GetString() : null,
            action = r.TryGetProperty("action", out var acEl) ? acEl.GetString() : null,
            entity = r.TryGetProperty("entity", out var enEl) ? enEl.GetString() : null,
            entityId = r.TryGetProperty("entityId", out var eiEl) ? eiEl.GetString() : null,
            payload = r.TryGetProperty("payload", out var pEl) ? pEl : default(JsonElement?),
            ip = r.TryGetProperty("ip", out var ipEl) ? ipEl.GetString() : null,
            userAgent = r.TryGetProperty("userAgent", out var uaEl) ? uaEl.GetString() : null,
            timestamp = r.TryGetProperty("timestamp", out var tsEl) ? tsEl.GetString() : m.CreatedAt.ToString("O"),
            result = r.TryGetProperty("result", out var resEl) ? resEl.GetString() : null
        };
    }
    catch
    {
        return new { id = m.Id, timestamp = m.CreatedAt.ToString("O") };
    }
}

app.Run();

static string NormalizeKycStatus(string status) => status switch
{
    "open" => "pending",
    "approved" => "approved",
    "rejected" => "rejected",
    _ => "pending"
};

static Guid? TryGetUserId(HttpContext http)
{
    var raw =
        http.User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value ??
        http.User.Claims.FirstOrDefault(c => c.Type == "sub")?.Value;
    return Guid.TryParse(raw, out var id) ? id : null;
}

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { }
}

public partial class Program { }
</file>

<file path="apps/backoffice/src/app/kyc/page.tsx">
'use client';

import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { listKycTasks, listKycDocuments, submitKycDecision, KycTask } from '@/lib/api/compliance';
import { Button, Card, CardContent, Badge, Skeleton, PageHeader } from '@ois/shared-ui';
import { toast } from 'sonner';
import { KycDetails } from './components/KycDetails';
import { QualificationList } from './components/QualificationList';
import { getStatusBadgeIntent, getStatusLabel } from '@/lib/constants';

const STATUSES = ['open', 'approved', 'rejected'] as const;
type Status = (typeof STATUSES)[number];

export default function KycPage() {
  const queryClient = useQueryClient();
  const [activeTab, setActiveTab] = useState<'kyc' | 'qualification'>('kyc');
  const [activeStatus, setActiveStatus] = useState<Status>('open');
  const [selectedId, setSelectedId] = useState<string | null>(null);

  const { data: requests, isLoading } = useQuery({
    queryKey: ['kyc-tasks', activeStatus],
    queryFn: () => listKycTasks(activeStatus),
    enabled: activeTab === 'kyc',
  });

  const selected = requests?.find(req => req.id === selectedId);

  // Fetch documents for selected investor
  const { data: documents = [] } = useQuery({
    queryKey: ['kyc-documents', selected?.investorId],
    queryFn: () => listKycDocuments(selected!.investorId),
    enabled: !!selected?.investorId,
  });

  const decisionMutation = useMutation({
    mutationFn: ({
      id,
      decision,
      comment,
    }: {
      id: string;
      decision: 'approved' | 'rejected';
      comment: string;
    }) => submitKycDecision(id, decision, comment),
    onSuccess: () => {
      setSelectedId(null);
      queryClient.invalidateQueries({ queryKey: ['kyc-tasks'] });
      toast.success('Решение сохранено');
    },
    onError: () => toast.error('Ошибка сохранения решения'),
  });

  const handleTabChange = (tab: 'kyc' | 'qualification') => {
    setActiveTab(tab);
    setSelectedId(null);
  };

  const handleStatusChange = (status: Status) => {
    setActiveStatus(status);
    setSelectedId(null);
  };

  return (
    <main className="mx-auto max-w-6xl px-6 py-10 space-y-8">
      <PageHeader
        title="KYC и Комплаенс"
        description="Проверка заявок инвесторов и управление квалификацией."
      />

      {/* Main Tabs */}
      <div className="flex gap-2">
        <Button
          variant={activeTab === 'kyc' ? 'primary' : 'secondary'}
          size="sm"
          onClick={() => handleTabChange('kyc')}
        >
          KYC Заявки
        </Button>
        <Button
          variant={activeTab === 'qualification' ? 'primary' : 'secondary'}
          size="sm"
          onClick={() => handleTabChange('qualification')}
        >
          Квалификация
        </Button>
      </div>

      {activeTab === 'kyc' ? (
        <div className="space-y-6">
          {/* Status filter tabs */}
          <section className="flex items-center gap-2">
            {STATUSES.map(status => (
              <Button
                key={status}
                onClick={() => handleStatusChange(status)}
                variant={activeStatus === status ? 'primary' : 'secondary'}
                size="sm"
              >
                {getStatusLabel(status)}
              </Button>
            ))}
          </section>

      // {selected && (
      //   <section className="rounded-lg border border-gray-200 bg-white p-4 space-y-3">
      //     <h2 className="text-lg font-semibold">Decision for {selected.investorId}</h2>
      //     <p className="text-sm text-gray-500">
      //       Status: <span className="font-medium">{selected.status}</span>
      //     </p>
      //     {selected.reason && (
      //       <p className="text-sm text-gray-500">
      //         Reason: <span className="font-medium">{selected.reason}</span>
      //       </p>
      //     )}
      //     {selected.resolvedAt && (
      //       <p className="text-xs text-gray-400">
      //         Resolved at: {new Date(selected.resolvedAt).toLocaleString()}
      //       </p>
      //     )}
      //     <textarea
      //       className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm"
      //       placeholder="Decision comment"
      //       value={comment}
      //       onChange={(e) => setComment(e.target.value)}
      //     />
      //     <div className="flex gap-2">
      //       <button
      //         className="rounded-md bg-green-600 px-4 py-2 text-sm text-white disabled:opacity-40"
      //         disabled={decisionMutation.isPending}
      //         onClick={() => decisionMutation.mutate({ id: selected.id, decision: 'approved' })}
      //       >
      //         Approve
      //       </button>
      //       <button
      //         className="rounded-md bg-red-600 px-4 py-2 text-sm text-white disabled:opacity-40"
      //         disabled={decisionMutation.isPending}
      //         onClick={() => decisionMutation.mutate({ id: selected.id, decision: 'rejected' })}
      //       >
      //         Reject
      //       </button>
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
            {/* List */}
            <Card>
              <CardContent className="p-0">
                <div className="divide-y divide-border">
                  {isLoading && (
                    <div className="p-4 space-y-2">
                      <Skeleton className="h-12 w-full" />
                      <Skeleton className="h-12 w-full" />
                    </div>
                  )}
                  {!isLoading && requests?.length === 0 && (
                    <div className="p-8 text-center text-text-tertiary">
                      Нет заявок в этом статусе
                    </div>
                  )}
                  {requests?.map((request: KycTask) => (
                    <div
                      key={request.id}
                      className={`flex items-center justify-between p-4 cursor-pointer transition-all border-l-4 ${
                        selectedId === request.id
                          ? 'bg-primary-50 border-primary-500 shadow-sm'
                          : 'border-transparent hover:bg-surface-hover'
                      }`}
                      onClick={() => setSelectedId(request.id)}
                    >
                      <div>
                        <div className="font-medium text-text-primary">{request.investorId}</div>
                        <div className="text-xs text-text-secondary">
                          {new Date(request.createdAt).toLocaleDateString('ru-RU')}
                        </div>
                        {request.reason && (
                          <div className="mt-1 text-xs text-text-tertiary">{request.reason}</div>
                        )}
                      </div>
                      <Badge intent={getStatusBadgeIntent(request.status)}>{request.status}</Badge>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>

            {/* Details Panel */}
            {selected ? (
              <KycDetails
                request={selected}
                documents={documents}
                isSubmitting={decisionMutation.isPending}
                onApprove={(id, comment) =>
                  decisionMutation.mutate({ id, decision: 'approved', comment })
                }
                onReject={(id, comment) =>
                  decisionMutation.mutate({ id, decision: 'rejected', comment })
                }
                onCancel={() => setSelectedId(null)}
              />
            ) : (
              <div className="hidden lg:flex items-center justify-center rounded-lg border-2 border-dashed border-border p-12 text-text-tertiary">
                Выберите заявку для просмотра
              </div>
            )}
          </div>
        </div>
      ) : (
        <QualificationList />
      )}
    </main>
  );
}
</file>

<file path="apps/portal-investor/src/app/issuances/[id]/page.tsx">
'use client';

import { useQuery, useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { AppShell, PageHeader, EmptyState, Skeleton, Button } from '@ois/shared-ui';
import { signOut, useSession } from 'next-auth/react';
import { useParams, useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';
import Link from 'next/link';
import { ArrowLeft } from 'lucide-react';
import { toast } from 'sonner';
import { investorNavItems } from '@/lib/navigation';
import { MetricsCard } from './components/MetricsCard';
import { YieldChartSection } from './components/YieldChartSection';
import { ScheduleSection } from './components/ScheduleSection';
import { DocumentsSection } from './components/DocumentsSection';
import { OrderPanel } from './components/OrderPanel';

type IssuanceDetails = {
  id: string;
  assetName: string;
  issuerName: string;
  totalAmount: number;
  availableAmount: number;
  nominal: number;
  yield: number;
  issueDate: string;
  maturityDate: string;
  scheduleJson?: Record<string, number | string>;
  documents?: Array<{
    id: string;
    title: string;
    type?: string;
    url: string;
    publishedAt?: string;
  }>;
};

export default function IssuanceDetailPage() {
  const { data: session, status } = useSession();
  const params = useParams();
  const router = useRouter();
  const id = params.id as string;
  const [orderAmount, setOrderAmount] = useState('');

  const investorId = session?.user?.id || '';

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: issuance, isLoading } = useQuery<IssuanceDetails>({
    queryKey: ['market-issuance', id],
    queryFn: async () => {
      const response = await apiClient.getMarketIssuance(id);
      return response.data as IssuanceDetails;
    },
    enabled: !!id && status === 'authenticated' && !!session,
  });

  const orderMutation = useMutation({
    mutationFn: async (amount: number) => {
      const response = await apiClient.createOrder(
        {
          investorId,
          issuanceId: id,
          amount,
        },
        {
          headers: {
            'Idempotency-Key': crypto.randomUUID(),
          },
        }
      );
      return response.data;
    },
    onSuccess: () => {
      toast.success('Заявка успешно создана');
      router.push('/portfolio');
    },
    onError: (error: unknown) => {
      const message = error instanceof Error ? error.message : 'Ошибка при создании заявки';
      toast.error(message);
    },
  });

  if (status === 'loading') {
    return <div className="p-8">Загрузка...</div>;
  }

  if (!session) {
    return null;
  }

  const handleBuy = () => {
    const amount = parseFloat(orderAmount);
    if (!amount || amount <= 0) {
      toast.error('Введите корректную сумму');
      return;
    }
    if (issuance && amount > issuance.availableAmount) {
      toast.error('Сумма превышает доступную');
      return;
    }
    orderMutation.mutate(amount);
  };

  // Generate mock yield chart data
  const yieldChartData = issuance
    ? Array.from({ length: 12 }, (_, i) => {
        const date = new Date();
        date.setMonth(date.getMonth() - (11 - i));
        return {
          name: date.toLocaleDateString('ru-RU', { month: 'short', year: 'numeric' }),
          yield: issuance.yield + (Math.random() * 2 - 1),
        };
      })
    : [];

  const mockDocuments = [
    {
      id: 'terms',
      title: 'Инвестиционный меморандум',
      type: 'terms',
      url: '#',
      publishedAt: new Date().toISOString(),
    },
    {
      id: 'report',
      title: 'Отчёт эмитента Q1',
      type: 'report',
      url: '#',
      publishedAt: new Date().toISOString(),
    },
  ];

  const documents = (
    issuance as {
      documents?: Array<{
        id: string;
        title: string;
        type?: string;
        url: string;
        publishedAt?: string;
      }>;
    }
  )?.documents?.length
    ? (
        issuance as {
          documents: Array<{
            id: string;
            title: string;
            type?: string;
            url: string;
            publishedAt?: string;
          }>;
        }
      ).documents
    : mockDocuments;

  return (
    <AppShell
      appName="ЛК Инвестора"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: investorNavItems }}
    >
      {isLoading && (
        <div className="space-y-6">
          <Skeleton className="h-8 w-64" variant="text" />
          <Skeleton className="h-64 w-full" variant="rectangular" />
        </div>
      )}

      {!isLoading && !issuance && (
        <EmptyState
          title="Выпуск не найден"
          description="Запрашиваемый выпуск не существует или был удалён"
          action={
            <Link
              href="/catalog"
              className="px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              Вернуться в каталог
            </Link>
          }
        />
      )}

      {!isLoading && issuance && (
        <>
          <PageHeader
            title={issuance.assetName}
            description={`Эмитент: ${issuance.issuerName}`}
            breadcrumbs={[{ label: 'Каталог', href: '/catalog' }, { label: issuance.assetName }]}
            actions={
              <Link href="/catalog">
                <Button variant="secondary" size="md" leftIcon={<ArrowLeft className="h-4 w-4" />}>
                  Назад
                </Button>
              </Link>
            }
          />

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <div className="lg:col-span-2 space-y-6">
              <MetricsCard issuance={issuance} />
              <YieldChartSection data={yieldChartData} />
              <ScheduleSection scheduleJson={issuance.scheduleJson as Record<string, any>} />
              <DocumentsSection documents={documents} />
            </div>
            <div className="lg:col-span-1">
              <OrderPanel
                availableAmount={issuance.availableAmount}
                yieldPercent={issuance.yield}
                amount={orderAmount}
                onAmountChange={setOrderAmount}
                onBuy={handleBuy}
                isSubmitting={orderMutation.isPending}
              />
            </div>
          </div>
        </>
      )}
    </AppShell>
  );
}
</file>

<file path="apps/portal-issuer/src/app/issuances/[id]/page.tsx">
'use client';

import { useEffect, useMemo, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { AppShell, PageHeader, Button, Card, CardContent, EmptyState, Skeleton, Input, Select } from '@ois/shared-ui';
import { ArrowLeft, DollarSign, Calendar, FileText, AlertTriangle } from 'lucide-react';
import type { PayoutScheduleItem, PayoutStatus, PayoutType } from '@/lib/mocks/issuances';
import { issuerNavItems } from '@/lib/navigation';
import { StatusBadges } from './components/StatusBadges';
import { DocumentsCard } from './components/DocumentsCard';
import { PayoutScheduleTable } from './components/PayoutScheduleTable';
import { useIssuanceDetail } from './hooks/useIssuanceDetail';

export default function IssuanceDetailPage() {
  const params = useParams();
  const router = useRouter();
  const id = params.id as string;

  const { data: issuance, isLoading, isError, publish, close, updateSchedule, isPublishing, isClosing, isUpdatingSchedule, handleSignOut } =
    useIssuanceDetail(id);

  const [isEditingSchedule, setIsEditingSchedule] = useState(false);
  const [scheduleDraft, setScheduleDraft] = useState<PayoutScheduleItem[]>([]);

  useEffect(() => {
    if (issuance?.scheduleJson) setScheduleDraft(issuance.scheduleJson);
  }, [issuance]);

  const scheduleToRender = useMemo(
    () => (isEditingSchedule ? scheduleDraft : issuance?.scheduleJson ?? []),
    [isEditingSchedule, scheduleDraft, issuance?.scheduleJson],
  );

  const formatCurrency = (value: number) =>
    new Intl.NumberFormat('ru-RU', { style: 'currency', currency: 'RUB', maximumFractionDigits: 0 }).format(value);

  if (isLoading) {
    return (
      <AppShell sidebar={{ items: issuerNavItems }} onSignOut={handleSignOut}>
        <div className="p-6 space-y-4">
          <Skeleton className="h-6 w-48" />
          <Skeleton className="h-40 w-full" />
          <Skeleton className="h-64 w-full" />
        </div>
      </AppShell>
    );
  }

  if (isError || !issuance) {
    return (
      <AppShell sidebar={{ items: issuerNavItems }} onSignOut={handleSignOut}>
        <div className="p-6">
          <EmptyState
            icon={AlertTriangle}
            title={isError ? 'Не удалось загрузить выпуск' : 'Выпуск не найден'}
            description="Попробуйте обновить страницу или вернуться позже."
            action={
              <Button variant="secondary" leftIcon={<ArrowLeft className="h-4 w-4" />} onClick={() => router.push('/issuances')}>
                Вернуться к списку
              </Button>
            }
          />
        </div>
      </AppShell>
    );
  }

  const addScheduleItem = () => {
    const today = new Date().toISOString().split('T')[0];
    setScheduleDraft((prev) => [
      ...prev,
      {
        id: crypto.randomUUID(),
        issuanceId: issuance.id,
        date: today,
        amount: 0,
        type: 'coupon',
        status: 'planned',
      },
    ]);
  };

  const updateScheduleItem = (itemId: string, patch: Partial<PayoutScheduleItem>) => {
    setScheduleDraft((prev) => prev.map((item) => (item.id === itemId ? { ...item, ...patch } : item)));
  };

  const removeScheduleItem = (itemId: string) => {
    setScheduleDraft((prev) => prev.filter((i) => i.id !== itemId));
  };

  const saveSchedule = () => {
    updateSchedule({ issuanceId: issuance.id, scheduleJson: scheduleDraft });
    setIsEditingSchedule(false);
  };

  return (
    <AppShell sidebar={{ items: issuerNavItems }} onSignOut={handleSignOut}>
      <div className="p-6 space-y-6">
        <PageHeader
          title={issuance.assetName}
          description={issuance.assetCode}
          breadcrumbs={[{ label: 'Выпуски', href: '/issuances' }, { label: issuance.assetCode }]}
          actions={
            <Button variant="ghost" size="sm" leftIcon={<ArrowLeft className="h-4 w-4" />} onClick={() => router.back()}>
              Назад
            </Button>
          }
        />

        <div className="flex flex-wrap items-center justify-between gap-3">
          <StatusBadges status={issuance.status} apy={issuance.apy} maturityDate={issuance.maturityDate} />
          <div className="flex flex-wrap gap-2">
            <Button variant="secondary" size="sm" leftIcon={<FileText className="h-4 w-4" />} onClick={() => setIsEditingSchedule(true)}>
              Редактировать график
            </Button>
            <Button variant="ghost" size="sm" disabled={issuance.status !== 'draft' || isPublishing} onClick={() => publish()}>
              Опубликовать
            </Button>
            <Button variant="danger" size="sm" disabled={issuance.status !== 'published' || isClosing} onClick={() => close()}>
              Закрыть
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-1 gap-4 lg:grid-cols-2">
          <Card>
            <CardContent className="p-6 space-y-3">
              <h3 className="text-lg font-semibold flex items-center gap-2">
                <DollarSign className="h-5 w-5 text-primary-600" />
                Финансы
              </h3>
              <InfoRow label="Общий объем" value={formatCurrency(issuance.totalAmount)} />
              <InfoRow label="Номинал" value={formatCurrency(issuance.nominal)} />
              <InfoRow label="Доступно" value={formatCurrency(issuance.availableAmount)} />
              <InfoRow label="Доходность" value={`${issuance.apy}% годовых`} />
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6 space-y-3">
              <h3 className="text-lg font-semibold flex items-center gap-2">
                <Calendar className="h-5 w-5 text-primary-600" />
                Даты
              </h3>
              <InfoRow label="Дата выпуска" value={new Date(issuance.issueDate).toLocaleDateString('ru-RU')} />
              <InfoRow label="Дата погашения" value={new Date(issuance.maturityDate).toLocaleDateString('ru-RU')} />
              {issuance.publishedAt && <InfoRow label="Опубликован" value={new Date(issuance.publishedAt).toLocaleDateString('ru-RU')} />}
              {issuance.dltTxHash && <InfoRow label="DLT транзакция" value={issuance.dltTxHash} mono />}
            </CardContent>
          </Card>
        </div>

        <Card>
          <CardContent className="p-6 space-y-4">
            <div className="flex items-center justify-between gap-2">
              <div className="flex items-center gap-2">
                <DollarSign className="h-5 w-5 text-primary-600" />
                <h3 className="text-lg font-semibold">График выплат</h3>
              </div>
              {isEditingSchedule ? (
                <div className="flex gap-2">
                  <Button variant="ghost" size="sm" onClick={() => setIsEditingSchedule(false)}>
                    Отмена
                  </Button>
                  <Button variant="primary" size="sm" disabled={isUpdatingSchedule} onClick={saveSchedule}>
                    {isUpdatingSchedule ? 'Сохраняем...' : 'Сохранить'}
                  </Button>
                </div>
              ) : (
                <Button variant="secondary" size="sm" onClick={() => setIsEditingSchedule(true)}>
                  Редактировать
                </Button>
              )}
            </div>

            {isEditingSchedule && (
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Button variant="ghost" size="sm" onClick={addScheduleItem}>
                  Добавить выплату
                </Button>
                <span>Изменения сохраняются в мок-данных</span>
              </div>
            )}

            {scheduleToRender.length > 0 ? (
              isEditingSchedule ? (
                <div className="space-y-2">
                  {scheduleDraft.map((item) => (
                    <div key={item.id} className="grid grid-cols-1 gap-2 rounded-md border p-3 md:grid-cols-5 md:items-center">
                      <Input type="date" value={item.date.split('T')[0]} onChange={(e) => updateScheduleItem(item.id, { date: e.target.value })} inputSize="sm" />
                      <Select
                        value={item.type}
                        onChange={(e) => updateScheduleItem(item.id, { type: e.target.value as PayoutType })}
                        selectSize="sm"
                        options={[
                          { value: 'coupon', label: 'Купон' },
                          { value: 'redemption', label: 'Погашение' },
                        ]}
                      />
                      <Input
                        type="number"
                        inputSize="sm"
                        value={item.amount}
                        onChange={(e) => updateScheduleItem(item.id, { amount: Number(e.target.value) })}
                      />
                      <Select
                        value={item.status}
                        onChange={(e) => updateScheduleItem(item.id, { status: e.target.value as PayoutStatus })}
                        selectSize="sm"
                        options={[
                          { value: 'planned', label: 'Запланировано' },
                          { value: 'processing', label: 'В обработке' },
                          { value: 'paid', label: 'Выплачено' },
                          { value: 'cancelled', label: 'Отменено' },
                        ]}
                      />
                      <Button variant="ghost" size="sm" onClick={() => removeScheduleItem(item.id)}>
                        Удалить
                      </Button>
                    </div>
                  ))}
                </div>
              ) : (
                <PayoutScheduleTable items={scheduleToRender} />
              )
            ) : (
              <EmptyState title="График пуст" description="Добавьте выплаты, чтобы увидеть график." />
            )}
          </CardContent>
        </Card>

        <DocumentsCard documents={issuance.documents} />
      </div>
    </AppShell>
  );
}

function InfoRow({ label, value, mono }: { label: string; value: string; mono?: boolean }) {
  return (
    <div className="flex justify-between gap-4 text-sm">
      <span className="text-muted-foreground">{label}</span>
      <span className={`font-medium ${mono ? 'font-mono text-xs' : ''}`}>{value}</span>
    </div>
  );
}
</file>

<file path="apps/portal-investor/src/app/history/page.tsx">
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { AppShell, PageHeader, DataTable, EmptyState, Skeleton, Button } from '@ois/shared-ui';
import { signOut, useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';
import { Download } from 'lucide-react';
import { investorNavItems } from '@/lib/navigation';
import { formatDateTime, formatCurrency } from '@/lib/format';
import { txColumns, payoutColumns } from './columns';
import { DateRangeFilter } from './components/DateRangeFilter';
import { HistoryTabs } from './components/HistoryTabs';

export default function HistoryPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<'orders' | 'payouts' | 'redemptions'>('orders');
  const [dateRange, setDateRange] = useState({
    from: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    to: new Date().toISOString().split('T')[0],
  });
  const pageSize = 10;

  const investorId = session?.user?.id || '';

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: ordersTx, isLoading: ordersLoading } = useQuery({
    queryKey: ['investor-orders', investorId, dateRange, pageSize],
    queryFn: async () => {
      const response = await apiClient.getInvestorTransactions(investorId, {
        from: dateRange.from,
        to: dateRange.to,
        type: 'transfer',
        limit: pageSize,
        offset: 0,
      });
      return response.data;
    },
    enabled: activeTab === 'orders' && !!investorId && status === 'authenticated',
  });

  const { data: redemptionsTx, isLoading: redemptionsLoading } = useQuery({
    queryKey: ['investor-redemptions', investorId, dateRange, pageSize],
    queryFn: async () => {
      const response = await apiClient.getInvestorTransactions(investorId, {
        from: dateRange.from,
        to: dateRange.to,
        type: 'redeem',
        limit: pageSize,
        offset: 0,
      });
      return response.data;
    },
    enabled: activeTab === 'redemptions' && !!investorId && status === 'authenticated',
  });

  const { data: payouts, isLoading: payoutsLoading } = useQuery({
    queryKey: ['investor-payouts', investorId, dateRange, pageSize],
    queryFn: async () => {
      const response = await apiClient.getInvestorPayouts(investorId, {
        from: dateRange.from,
        to: dateRange.to,
        limit: pageSize,
        offset: 0,
      });
      return response.data;
    },
    enabled: activeTab === 'payouts' && !!investorId && status === 'authenticated',
  });

  // totalItems можно использовать для пагинации; оставлено для будущего расширения
  void (activeTab === 'payouts'
    ? payouts?.total || 0
    : activeTab === 'orders'
      ? ordersTx?.total || 0
      : redemptionsTx?.total || 0);

  if (status === 'loading') {
    return <div className="p-8">Загрузка...</div>;
  }

  if (!session) {
    return null;
  }

  if (!investorId) {
    return (
      <AppShell
        user={session.user}
        onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
        sidebar={{ items: investorNavItems }}
      >
        <EmptyState
          title="Не найден Investor ID"
          description="Перезайдите в систему, чтобы обновить сессию."
        />
      </AppShell>
    );
  }

  const exportToCSV = (data: any[], filename: string) => {
    if (!data || data.length === 0) return;

    const headers =
      activeTab === 'payouts'
        ? ['Дата', 'ID выпуска', 'Сумма', 'Статус']
        : ['Дата', 'Тип', 'Выпуск', 'Сумма', 'Статус', 'DLT Hash'];

    const rows = data.map(item => {
      if (activeTab !== 'payouts') {
        return [
          formatDateTime(item.createdAt),
          item.type,
          item.issuanceCode,
          formatCurrency(item.amount),
          item.status,
          item.dltTxHash || '-',
        ];
      } else {
        return [
          formatDateTime(item.executedAt),
          item.issuanceId,
          formatCurrency(item.amount),
          item.status,
        ];
      }
    });

    const csv = [headers, ...rows].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    try {
      const a = document.createElement('a');
      a.href = url;
      a.download = `${filename}.csv`;
      a.click();
    } finally {
      window.URL.revokeObjectURL(url);
    }
  };

  return (
    <AppShell
      appName="ЛК Инвестора"
      user={session.user}
      onSignOut={() => signOut({ callbackUrl: '/auth/signin' })}
      sidebar={{ items: investorNavItems }}
    >
      <PageHeader
        title="История операций"
        description="Заявки, выплаты и погашения"
        actions={
          <Button
            onClick={() =>
              exportToCSV(
                activeTab === 'payouts'
                  ? payouts?.items?.slice(0, pageSize) || []
                  : activeTab === 'orders'
                    ? ordersTx?.items?.slice(0, pageSize) || []
                    : redemptionsTx?.items?.slice(0, pageSize) || [],
                `${activeTab}-page-1`
              )
            }
            variant="secondary"
            disabled={
              activeTab === 'payouts'
                ? !payouts?.items?.length
                : activeTab === 'orders'
                  ? !ordersTx?.items?.length
                  : !redemptionsTx?.items?.length
            }
          >
            <Download className="h-4 w-4" />
            Экспорт CSV
          </Button>
        }
      />

      <DateRangeFilter
        from={dateRange.from}
        to={dateRange.to}
        onChange={range => setDateRange(range)}
      />

      <HistoryTabs
        active={activeTab}
        counts={{
          orders: ordersTx?.total,
          payouts: payouts?.total,
          redemptions: redemptionsTx?.total,
        }}
        onChange={setActiveTab}
      />

      {/* Content */}
      {activeTab === 'orders' && (
        <>
          {ordersLoading && <Skeleton className="h-64 w-full" variant="rectangular" />}
          {!ordersLoading && ordersTx && (
            <div className="overflow-x-auto">
              <DataTable
                columns={txColumns}
                data={ordersTx.items || []}
                searchable
                labels={{ searchPlaceholder: 'Поиск по заявкам...' }}
                pageSize={pageSize}
              />
            </div>
          )}
          {!ordersLoading && (!ordersTx || ordersTx.items?.length === 0) && (
            <EmptyState title="Заявок нет" description="Здесь появятся ваши заявки" />
          )}
        </>
      )}

      {activeTab === 'payouts' && (
        <>
          {payoutsLoading && <Skeleton className="h-64 w-full" variant="rectangular" />}
          {!payoutsLoading && payouts && (
            <>
              {payouts.totalAmount && (
                <div className="mb-4 p-4 bg-surface-alt rounded-lg">
                  <p className="text-sm text-text-secondary">
                    Всего выплат: ₽{payouts.totalAmount.toLocaleString()}
                  </p>
                </div>
              )}
              <div className="overflow-x-auto">
                <DataTable
                  columns={payoutColumns}
                  data={payouts.items || []}
                  searchable
                  labels={{ searchPlaceholder: 'Поиск по выплатам...' }}
                  pageSize={pageSize}
                />
              </div>
            </>
          )}
          {!payoutsLoading && (!payouts || payouts.items?.length === 0) && (
            <EmptyState title="Выплаты не найдены" description="История выплат появится здесь" />
          )}
        </>
      )}

      {activeTab === 'redemptions' && (
        <>
          {redemptionsLoading && <Skeleton className="h-64 w-full" variant="rectangular" />}
          {!redemptionsLoading && redemptionsTx && (
            <div className="overflow-x-auto">
              <DataTable
                columns={txColumns}
                data={redemptionsTx.items || []}
                searchable
                labels={{ searchPlaceholder: 'Поиск по погашениям...' }}
                pageSize={pageSize}
              />
            </div>
          )}
          {!redemptionsLoading && (!redemptionsTx || redemptionsTx.items?.length === 0) && (
            <EmptyState
              title="Погашения не найдены"
              description="История погашений появится здесь"
            />
          )}
        </>
      )}
    </AppShell>
  );
}
</file>

<file path="apps/portal-issuer/src/app/reports/page.tsx">
'use client';

import { useState } from 'react';
import { AppShell, PageHeader, Button, BarChart, LineChart, ChartContainer, EmptyState, Skeleton, Input, Select, StatCard } from '@ois/shared-ui';
import { Download } from 'lucide-react';
import { issuerNavItems } from '@/lib/navigation';
import { IssuancesReportTable } from './components/IssuancesReportTable';
import { useReportsData } from './hooks/useReportsData';
import * as XLSX from 'xlsx';

export default function ReportsPage() {
  const [activeTab, setActiveTab] = useState<'issuances' | 'payouts'>('issuances');
  const [granularity, setGranularity] = useState<'day' | 'week' | 'month' | 'year'>('month');

  const { status, dateRange, setDateRange, issuancesQuery, payoutsQuery, mockIssuances, mockPayouts, handleLogout } =
    useReportsData(activeTab, granularity);

  const currentIssuances = issuancesQuery.data ?? mockIssuances;
  const currentPayouts = payoutsQuery.data ?? mockPayouts;

  const downloadCsv = () => {
    if (!currentIssuances) return;
    const ws = XLSX.utils.json_to_sheet(currentIssuances.items ?? []);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Issuances');
    XLSX.writeFile(wb, `issuances-report-${dateRange.from}-${dateRange.to}.xlsx`);
  };

  return (
    <AppShell sidebar={{ items: issuerNavItems }} onSignOut={handleLogout}>
      <PageHeader
        title="Отчеты"
        description="Сводка по выпускам и выплатам"
        actions={
          <Button variant="secondary" onClick={downloadCsv} leftIcon={<Download className="h-4 w-4" />}>
            Выгрузить XLSX
          </Button>
        }
      />

      <div className="mb-6 grid grid-cols-1 gap-3 md:grid-cols-3">
        <Input type="date" label="С" value={dateRange.from} onChange={(e) => setDateRange((prev) => ({ ...prev, from: e.target.value }))} />
        <Input type="date" label="По" value={dateRange.to} onChange={(e) => setDateRange((prev) => ({ ...prev, to: e.target.value }))} />
        <Select
          value={granularity}
          onChange={(e) => setGranularity(e.target.value as typeof granularity)}
          options={[
            { value: 'day', label: 'День' },
            { value: 'week', label: 'Неделя' },
            { value: 'month', label: 'Месяц' },
            { value: 'year', label: 'Год' },
          ]}
        />
      </div>

      <div className="mb-4 flex gap-2">
        <Button variant={activeTab === 'issuances' ? 'primary' : 'ghost'} onClick={() => setActiveTab('issuances')}>
          Выпуски
        </Button>
        <Button variant={activeTab === 'payouts' ? 'primary' : 'ghost'} onClick={() => setActiveTab('payouts')}>
          Выплаты
        </Button>
      </div>

      {status === 'loading' && (
        <div className="space-y-4">
          <Skeleton className="h-10 w-full" />
          <Skeleton className="h-64 w-full" />
        </div>
      )}

      {status === 'authenticated' && activeTab === 'issuances' && (
        <div className="space-y-4">
          {issuancesQuery.isLoading ? (
            <Skeleton className="h-64 w-full" />
          ) : (
            <>
              <IssuancesReportTable data={currentIssuances?.items} summary={currentIssuances?.summary} />
              <ChartContainer title="Динамика объема">
                <BarChart
                  data={
                    currentIssuances?.items?.map((i) => ({
                      name: i.assetName,
                      value: i.totalAmount,
                    })) ?? []
                  }
                  bars={[{ dataKey: 'value', name: 'Объем' }]}
                />
              </ChartContainer>
            </>
          )}
        </div>
      )}

      {status === 'authenticated' && activeTab === 'payouts' && (
        <div className="space-y-4">
          {payoutsQuery.isLoading ? (
            <Skeleton className="h-64 w-full" />
          ) : currentPayouts ? (
            <>
              <div className="grid grid-cols-1 gap-3 md:grid-cols-3">
                <StatCard title="Выплат" value={(currentPayouts.items?.length ?? 0).toLocaleString('ru-RU')} />
                <StatCard
                  title="Сумма"
                  value={(currentPayouts.items?.reduce((acc, cur) => acc + (cur.totalAmount ?? 0), 0) ?? 0).toLocaleString('ru-RU', {
                    style: 'currency',
                    currency: 'RUB',
                  })}
                />
                <StatCard title="Период" value={`${dateRange.from} — ${dateRange.to}`} />
              </div>
              <ChartContainer title="Динамика выплат">
                <LineChart
                  data={
                    currentPayouts.items?.map((item) => ({
                      name: item.period,
                      value: item.totalAmount,
                    })) ?? []
                  }
                  lines={[{ dataKey: 'value', name: 'Сумма выплат' }]}
                />
              </ChartContainer>
            </>
          ) : (
            <EmptyState title="Нет данных по выплатам" description="Попробуйте выбрать другой период" />
          )}
        </div>
      )}
    </AppShell>
  );
}
</file>

</files>
