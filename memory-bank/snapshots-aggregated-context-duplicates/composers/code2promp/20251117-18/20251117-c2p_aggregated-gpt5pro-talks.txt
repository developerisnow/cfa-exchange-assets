Project Path: aggregated-gpt5pro-talks

Source Tree:

```txt
aggregated-gpt5pro-talks
├── 20251117-1927-gpt5pro-step3-all-together-after-audit-feedback.gpt5p.md
├── 20251117-2103-gpt5pro-step4-all-and-nextsteps.gpt5p.md
├── 20251118-0905-feedback-gpt5pro-step4-all.md
├── 20251118-1321-gpt5pro-step5-cohere-json-markdown.gpt5p.md
├── 20251118-1322-gpt5pro-step5-reposcan.gpt5p.md
└── 20251118-1323-gpt5pro-step5-agents-and-codemachine.gpt5p.md

```

`aggregated-gpt5pro-talks/20251117-1927-gpt5pro-step3-all-together-after-audit-feedback.gpt5p.md`:

```md
# Prompt 1
You are Oracle, a focused one-shot problem solver. Emphasize direct answers, cite any files referenced, and clearly note when the search tool was used.  You are GPT‑5 Pro acting as the final "Oracle" reviewer for the `ois-cfa` codebase and its infra branch.  I have attached: - `c2p_ois-cfa.txt`: ~4MB code2prompt snapshot of the `ois-cfa` repo on branch `infra.defis.deploy` (structure + key files); - `20251116-1603-gpt5pro-audit-feedback-review.gpt5p.md`: your earlier deep V1‑audit of this repo (architecture + recommendations); - `20251117-1747-gpt5pro-next-steps-after-audit-feedback.gpt5p.md`: first follow-up "next steps" report based on V1‑audit; - `20251117-1748-gpt5pro-next-steps-after-audit-feedback.gpt5p.md`: second follow-up "next steps" report (another angle on priorities); - `20251117-1537-eywa1-co-3dd7.session.md`: detailed infra/devops log from AVA1/eywa1 (CFA1→UK1, Cloudflare, Postfix, Playwright, etc.); - `20251117-1713-feedback-to-co-3c63-from-eywa1-co-3dd7.md`: explicit feedback about what V1‑audit did not know and what changed after UK1 was brought up; - `20251114-agreements-gitflow-AlexA-and-AleksandrO.md`: agreements between Alex A. and Aleksandr O. about gitflow and branches (develop, tasks, infra.defis.deploy, etc.); - `20251117-1518-conversation-AlexA-AleksandrO.md`: conversation about NX-tasks and expectations for how to drive work from `tasks/` and `docs/context/`; - two architecture context files about Trees/Leaves/Agents ("vibe coding" doc and its transcript) — how we want to organize future AI-agent work.  High-level reality: - Repo `ois-cfa` on branch `infra.defis.deploy` now combines:   - Aleksandr's `infra` work (GitOps, observability, audit, AsyncAPI/contracts);   - Alex's `deploy`/UK1 work (docker-compose, Nginx, Cloudflare, Keycloak/SMTP, Playwright smoke, real working demo on UK1). - There are multiple GPT‑5 Pro reports already:   - V1‑audit (big architecture review);   - follow-up "next steps" drafts (1747/1748);   - plus live context from eywa1 sessions and agreements on gitflow. - The `tasks/` folder in `ois-cfa` (NX-01..NX-08) and `docs/context/*` are meant to be the driving interface for future work, including AI agents (Claude/Codex/GPT‑5).  Your job now is to produce a **single, coherent MASTER REPORT (V3)** that other agents (e.g. Codex CLI) can use as a zero-shot starting point.  What I need from you:  1) Consolidated picture from all GPT‑5 reports + logs    - Read your own V1‑audit, the two "next steps" reports, and the eywa1/feedback logs.    - In Russian (with B2-level English terms), summarise in 5–8 bullets the **consensus** across all these documents:      - how you see the architecture and infra (infra.defis.deploy + UK1);      - what are the key strengths/assets already in place;      - what are the main risks/gaps that remain.    - Explicitly call out any major contradictions between the reports and resolve them (which view you consider canonical now, and why).  2) Canonical "Current State" snapshot (for docs)    - Produce a section that can be almost copy-pasted into `docs/context/PROJECT-CONTEXT.md` as "Текущее состояние (infra.defis.deploy + UK1)".    - Structure: 6–10 bullets covering:      - domains/services (identity/issuance/registry/settlement/compliance);      - frontends (apps/*) + gateway;      - packages (contracts/sdks/dotnet-clients) and how they relate to services;      - infra/ops (ops/, audit/, docker-compose, observability) and the UK1 environment (DNS/Cloudflare, Nginx, SMTP, Playwright smoke);      - gitflow and main branches (main, develop, tasks, infra.defis.deploy) per the 20251114 agreements.  3) Unified 2–3 week roadmap (driven by `tasks/` and `docs/context/`)    - Using everything you know (NX-01..NX-08, docs/context/*, infra/UK1 status), design a **single 2–3 week roadmap** for ~40–60h of Alex's time + some AI-agent help.    - Output as a table with columns:      - `Task ID` (you can refer to NX-01..NX-08 or define sub-tasks like NX-03.a, NX-07.b, etc.);      - `Area` (frontend/backend/contracts/tests/ops/docs);      - `Goal` (1–2 lines);      - `Prereqs` (docs/specs/tests to read or update first);      - `Done-when` (4–6 bullet DoD);      - `Agent-friendly?` (yes/no/partial + 1-line why).    - The roadmap should be realistic and executable, not abstract. Assume UK1 is already up and running.  4) Structural refactor & hygiene plan (1–2 day budget)    - Based on all your audits + the gitflow agreements, propose a **minimal structural refactor plan** for `ois-cfa` root and key folders:      - ARCHIVE/audit/docs/memory-bank/chaincode/apps/ops/packages/services/tests/tools.    - Aim for 5–10 concrete steps of the form:      - "Move X to Y", "Rename folder Z", "Add README in folder K with these headings", "Index docs A/B/C in one central TOC".    - Focus on:      - easier onboarding for new devs,      - clearer separation of live infra vs historical artefacts,      - better ergonomics for AI agents (less noise, clearer contract/impl split).  5) Agentification playbook for Codex/Claude/GPT‑5    - Using the Trees/Leaves/Agents docs and all previous audits, design a short **Agentification playbook** for this repo:      - 5–10 typical "leaf" task patterns that can be safely delegated to AI agents (with human review);      - 3–5 "trunk/tree" patterns that should stay under manual control (or agents only as advisors).    - For each pattern, give:      - short name,      - 1–2 sentence description,      - example in `ois-cfa` (e.g. "add new Playwright spec for investor registration", "refine NX-03 issuance coverage tests", "refactor gateway routing config").    - This playbook should be something I can paste into AGENTS.md / internal docs so that future agents know what is safe/unsafe to do.  Output format & style: - Answer in Russian, with senior-engineer tone; English technical terms/slang OK. - Structure the answer as:   - TL;DR (3–5 bullets),   - Section 1: Consolidated picture,   - Section 2: Current State snapshot,   - Section 3: 2–3 week roadmap (table),   - Section 4: Structural refactor plan,   - Section 5: Agentification playbook,   - Final compact table: `Area` / `Key decision or issue` / `Your V3 recommendation`. - Do NOT restate the full contents of attached files; focus on synthesis, decisions, and concrete next steps that other agents can execute.¸

# Output 1 TL;DR


* Канон сейчас: **ветка `infra.defis.deploy` + стенд UK1** с docker‑compose, Cloudflare/nginx, Keycloak, Postfix/OpenDKIM и Playwright‑smoke (4 спека) — это рабочий reference‑env, а не план на будущее.
* Архитектура ровная: .NET‑сервисы по доменам (issuance/registry/settlement/compliance/identity), фронты (issuer/investor/backoffice), API‑gateway, spec‑first контракты в `packages/contracts`, GitOps/Timeweb/K8s‑infra и audit‑пак.
* Основные дырки: частично добитые NX‑02/03/04/05/06, нет минимальных CI‑гейтов, путаница в слоях `docs/audit/ARCHIVE/memory-bank`, неформализован UK1 как v1.0 runbook, EF/issuance и часть registry/settlement ещё не доведены до зелёного happy‑path.
* На ближайшие 2–3 недели: **забетонировать спеки+gateway+issuance (NX‑01..03) → протащить registry‑flow (NX‑04) → формализовать identity+CI (NX‑05/06)**, в фоне сделать маленький вертикальный срез по backoffice (NX‑07/08).
* Всё ниже основано на анализе через внутренний поиск по загруженным файлам (`file_search`: V1‑аудит, оба V2‑отчёта, логи eywa1/UK1, WBS/NX‑таски, TLA‑слайды, gitflow‑агримент, c2p‑snapshot).

---

## 1. Consolidated picture (V3)

### 1.1. Архитектура и infra (infra.defis.deploy + UK1)

**Архитектура репо**

* **Сервисы (`services/*`)** — доменные bounded contexts:
  `issuance`, `registry`, `settlement`, `compliance`, `identity`, плюс интеграции и `fabric-gateway`. Общий паттерн: `Program.cs` с OTEL/Prometheus, Auth/Z, RateLimiter, MassTransit, Hosted Outbox, EF‑контекст + миграции.
* **Фронты и edge (`apps/*`)** — Next.js порталы `portal-issuer`, `portal-investor`, `backoffice` + `shared-ui`; edge‑proxy `api-gateway` на ASP.NET Core/YARP.
* **Спеки и клиенты (`packages/*`)** —

  * `contracts`: OpenAPI/AsyncAPI/JSON Schema → истина по REST/events.
  * `domain`: общая доменная модель.
  * `dotnet-clients`, `sdks/ts`, `typescript-gateway`: сгенерированные клиенты и shared‑типы.
* **Chaincode/ops/audit** —

  * `chaincode/*`: Fabric‑контракты и K8s‑ориентированный DLT‑слой.
  * `ops/*`: Terraform/Timeweb, Helm‑чарты, GitOps через GitLab Agent, TwC CLI, K8s‑runbooks.
  * `audit/*`: CI/K8s‑аудит с рекомендациями (Kaniko вместо DinD, observability, security‑хардениг).
* **Docs/context/Tasks** —

  * `docs/context/PROJECT-CONTEXT.md`: общий контекст, bounded contexts, техстек.
  * `docs/context/WBS-OIS.md`: треки и milestones M1..M5, привязка NX‑01..06 к WBS.
  * `tasks/NX-0x-*.md`: тактические срезы работы (spec‑matrix, gateway, issuance, registry, identity, CI, backoffice KYC/audit).

**Ветка `infra.defis.deploy`**

* Собрана от **`deploy` + `infra`** по стратегии “база infra + поверх deploy”:

  * взяли infra‑реализации `Program.cs`/`*.csproj` (Auth, RateLimiter, Kafka, OTEL, Hosted Outbox),
  * поверх вернули runtime‑фиксы из deploy (динамический `MigrationsAssembly`, `MIGRATE_ON_STARTUP`, рабочие Dockerfile/compose, Keycloak bootstrap, gateway/порталы).
* Коммит `ed44ee6` фиксирует merge, ветка запушена в origin как рабочий стэк infra+deploy.

**UK1**

* UK1 — VPS с `/opt/ois-cfa`, docker‑compose стеком (.NET‑сервисы, gateway, Keycloak, PostgreSQL/Kafka/MinIO).
* Edge‑слой: **Cloudflare DNS+TLS → системный nginx → api‑gateway + порталы**, оформлен как runbook `docs/deploy/20251113-cloudflare-ingress.md` с чек‑листом DNS/SSL/nginx/Keycloak.
* SMTP: Postfix+OpenDKIM, забинден только на `127.0.0.1` и `172.18.0.1`, внешний 25 закрыт, проверка через mail.tm.
* Playwright‑smoke: 4 спека — issuer login, investor login/self‑registration (через mail.tm), backoffice admin login — проходят `npm test`, артефакты в `tests/e2e-playwright/test-results`.

### 1.2. Ключевые сильные стороны / assets

1. **Хорошо декомпозированная доменная модель** — отдельные bounded contexts, shared `packages/domain`, AsyncAPI/OpenAPI, UML/C4‑диаграммы и data‑model доки.
2. **Spec‑first подход зафиксирован в docs/context и WBS** — WBS‑OIS привязывает NX‑таски к milestones, в RULES‑SUMMARY/PROJECT‑CONTEXT прописано “сначала спека → потом реализация → потом верификация”.
3. **Продвинутый DevOps/infra слой** — Terraform/Timeweb, GitLab Agent GitOps, otel‑collector, Prometheus, сложный `.gitlab-ci.yml` с многостадийным pipeline и Terraform jobs.
4. **UK1 как реальный demo/reference** — не нужно “поднимать окружение с нуля”: Cloudflare, nginx, Keycloak, SMTP, Playwright уже отработаны и задокументированы.
5. **Плотный knowledge‑layer** — `docs/*`, `audit/*`, `memory-bank/Scrum/*` с таймлайнами, DoD, merge‑стратегиями, биллинг‑отчётами и т.п.
6. **Явная модель делегирования (Trees/Leaves/Agents)** — есть слайды/транскрипт и уже адаптированная под репо agentification‑V2 в предыдущих отчётах.

### 1.3. Основные риски и дыры

1. **NX‑02/03/04/05/06 не доведены до “зелёного”**

   * NX‑01 в основном сделан (матрица и lint есть), но поддерживается ad‑hoc.
   * NX‑02: gateway‑маршруты и health/metrics не полностью выровнены со спеками и не зафиксированы в одном markdown‑репорте.
   * NX‑03: есть `issuance.Tests`, но падение из‑за конфликта EF‑провайдеров (PostgreSQL+InMemory) и mock‑ledger; это ломает доверие к issuance‑API.
   * NX‑04: registry/settlement order‑flow и события Kafka (AsyncAPI) не замкнуты тестами и e2e до конца.
   * NX‑05/06: Identity baseline и CI‑quality gates прописаны в планах, но реализованы частично (SMTP/Keycloak есть, формализация и CI — нет).
2. **CI/CD ещё не даёт минимальных гарантий** — `.gitlab-ci.yml` сложный, но нет стабильного набора обязательных стадий (lint/spec‑lint/tests/coverage/Playwright) и нормальных артефактов; DinD ещё не заменён на Kaniko/аналог.
3. **Документы и артефакты расползлись по слоям** — новичку и агенту трудно отличить актуальное (`docs/deploy/20251113-cloudflare-ingress.md`, NX‑таски, PROJECT/FRONTEND‑CONTEXT) от исторического (`ARCHIVE`, старые логи, часть audit‑паков).
4. **Бранч‑модель ещё не доведена до steady‑state** — есть договорённость по `main/develop/tasks`, но фактически работа ведётся в `infra.defis.deploy`, MR в `develop/main` пока не сделан; ветка `tasks` используется как storage для md‑тасков, что частично противоречит изначальной критике этого подхода.
5. **DLT/Fabric и ops‑часть — “тяжёлый ствол” без полноценной v1‑включённости** — есть документация и Helm/Terraform, но нет зафиксированного, полностью прогнанного сценария с Fabric в прод‑подобном окружении; пока это больше “задел”.

### 1.4. Противоречия между отчётами и каноничный взгляд (V3)

**1. “Окружения теоретические” vs реальный UK1**

* V1‑аудит предполагал, что dev/prod‑окружения ещё нужно “bootstrap’ить”; UK1/Cloudflare/SMTP/Playwright рассматривались как будущие шаги.
* V2‑отчёты + eywa1‑лого однозначно показывают: UK1 уже работает как demo, runbook выполнен, SMTP и Playwright замкнуты.
* **V3‑канон:** UK1 — **reference dev/demo env**; CFA1/K8s — вспомогательные окружения для будущей K8s‑линии.

**2. “Нужно спроектировать merge‑стратегию infra vs deploy” vs уже созданная `infra.defis.deploy`**

* V1 рассматривал несколько стратегий merge как будущие опции.
* В логе 14.11 уже описан фактический merge, коммит `ed44ee6`, ответы на вопросы по конфликтам (`Program.cs`, `*.csproj`, `backoffice/package.json`, `.gitignore`).
* **V3‑канон:** `infra.defis.deploy` — текущая canonical‑ветка для работы; задача — стабилизировать её (NX‑02/03/06, smoke) и после этого мержить в `develop` по GitFlow.

**3. Статусы NX‑тасков**

* V1 изображал NX‑01..03 как в основном “planned”; V2 и WBS‑OIS фиксируют прогресс (NX‑01 ~done, NX‑02/03 частично, NX‑04/05/06 в планах).
* **V3‑канон:**

  * NX‑01 — режим maintenance (поддержка матрицы и lint).
  * NX‑02/03 — главная цель недели 1–1.5.
  * NX‑04 — цель недели 2.
  * NX‑05/06 — неделя 2–3.
  * NX‑07/08 — первые MVP‑срезы после стабилизации backends.

**4. Роль `memory-bank` и `tasks`**

* V1 ещё относился к `memory-bank` как к “шуму”; V2 фиксирует его как основной журнал решений и отчётов.
* В gitflow‑агрименте `tasks` первоначально — ветка с md‑тасками; отдельный анализ критикует такую ветку как SSOT для задач.
* **V3‑канон:**

  * `memory-bank` — **официальный knowledge‑журнал** (логи, отчёты, merge‑планы).
  * `tasks/` в `ois-cfa` — **интерфейс для агентов** (NX‑таски), не продуктовый таск‑трекер.
  * SSOT по задачам — внешняя система (YouGile/Jira), в коммитах — ссылки на её ID.

---

## 2. “Текущее состояние (infra.defis.deploy + UK1)” — canonical snapshot

(Можно почти копипастить в `docs/context/PROJECT-CONTEXT.md` как блок “Текущее состояние”.)

1. **Домены/сервисы**

   * Реализованы доменные сервисы: `issuance`, `registry`, `settlement`, `compliance`, `identity`, интеграции (банк, ЕСИА, Fabric‑gateway). Каждому соответствует OpenAPI/AsyncAPI контракт в `packages/contracts/*`, shared‑модель в `packages/domain`.

2. **Edge и фронты**

   * Edge‑слой: `apps/api-gateway` (YARP, Auth/Z, RateLimiter, health/metrics) плюс Next.js‑порталы `portal-issuer`, `portal-investor`, `backoffice` и `shared-ui`. В UK1 это всё прокинуто через Cloudflare DNS+TLS и системный nginx.

3. **Пакеты и клиенты**

   * Истина по REST/events — `packages/contracts` (OpenAPI/AsyncAPI/JSON Schema);
   * .NET‑клиенты в `packages/dotnet-clients` и TS‑SDK в `packages/sdks/ts`/`typescript-gateway` генерятся из этих спек; фронты используют TS‑SDK, сервисы — .NET‑клиенты там, где нужно.

4. **Infra/Ops и UK1**

   * K8s/Timeweb/Fabric: Terraform‑модули `ops/infra/timeweb/*`, Helm‑чарты, GitOps через `ops/gitops/gitlab-agent/*`. Это “production‑style” слой, пока без полностью выведенного в строй Fabric‑кластера.
   * UK1‑стенд: docker‑compose стэк из `docs/deploy/docker-compose-at-vps/*`, ingress описан в runbook `docs/deploy/20251113-cloudflare-ingress.md` (Cloudflare DNS+TLS, nginx vhost, Keycloak, SMTP).

5. **SMTP/Identity/Keycloak**

   * Postfix+OpenDKIM на UK1 заблокированы на localhost+docker‑bridge, работает verifyEmail/self‑registration инвестора и backoffice‑login через Keycloak, проверено Playwright‑спеками; конфиг realm/clients/roles описан частично в runbooks и memory‑логах, но ещё не вынесен в отдельный identity‑раздел docs.

6. **Тесты и E2E**

   * Unit/integration‑тесты по сервисам (включая `issuance.Tests` с TRX‑логами падения из‑за EF‑конфигурации);
   * Backend e2e (`tests/e2e`), FE‑e2e `tests/e2e-playwright` (4 сценария для UK1). EF/issuance и end‑to‑end‑путь investor→issuance/registry ещё не полностью зелёные.

7. **Docs, audit и memory-bank**

   * `docs/architecture/*`, `docs/security/*`, `docs/dlt/*` содержат C4‑диаграммы, UML, threat‑model, регуляторку;
   * `audit/*` — snapshot частного аудита infra/CI;
   * `memory-bank/Scrum/20251114-discovery-infra-branch/*` и связанные логи фиксируют merge‑историю `infra.defis.deploy`, риски и решения.

8. **Gitflow и ветки**

   * Целевая модель по договорённости: `main` (prod), `develop` (dev/pre‑prod), `feature/*` от `develop`, `tasks` — md‑таски, MR из `feature/*` в `develop`, затем `develop` → `main`.
   * Фактическая рабочая ветка сейчас — `infra.defis.deploy` (deploy+infra), от неё разумно продолжать работу до тех пор, пока NX‑02/03/06 не дадут приемлемый уровень стабильности, после чего делать MR → `develop`.

---

## 3. Единый 2–3 недельный roadmap (40–60h + агенты)

### План по неделям (словами)

* **Неделя 1:** добить NX‑01 (maintenance), выровнять NX‑02 (gateway routing/health/metrics) и починить NX‑03 (issuance tests + EF).
* **Неделя 2:** протащить core‑flow NX‑04 (registry order flow) и оформить UK1 identity baseline (NX‑05) на уровне docs+конфигов.
* **Неделя 3 (опционно):** включить минимальный CI‑gate (NX‑06) и сделать один вертикальный срез по backoffice KYC/Audit (микро‑подзадачи NX‑07/08).

### Таблица задач

| Task ID         | Area                | Goal                                                                                                                                                | Prereqs                                                                                                                                                    | Done-when (DoD)                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Agent-friendly?                                                                                                                     |
| --------------- | ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| **NX-01.m**     | contracts/docs      | Привести NX‑01 в режим поддерживаемого артефакта: актуальная API/Event‑матрица и spec‑lint без мусорных warning’ов.                                 | `docs/context/WBS-OIS.md`, существующий NX‑01 task, `packages/contracts/*`, имеющиеся отчёты матрицы.                                                      | • Spectral/AJV/AsyncAPI‑lint прогнаны и результаты сохранены в артефакт `artifacts/NX-01-report.md`.<br>• Матрица endpoint↔service и event↔topic обновлена и лежит в `docs/ops/api-event-matrix.md` (или аналог).<br>• В NX‑01‑файле зафиксирован статус “maintenance” и дата последней проверки.<br>• Нет красных ошибок в спеках; жёлтые warning’и явно откомментированы.                                                                                                               | **Yes (~80%)** — агенту можно отдать запуск линтеров и обновление таблиц; ты делаешь только финальный sanity‑чек.                   |
| **NX-02.a**     | backend/gateway     | Замкнуть gateway routing + health/metrics с NX‑01: реестр маршрутов, все сервисы отдают `/health` и `/metrics` по конвенции.                        | NX‑01.m готов, `apps/api-gateway/*`, OpenAPI сервисов, UK1 доступен.                                                                                       | • Есть doc `docs/ops/gateway-routing.md` с таблицей path→service→auth/roles→timeout.<br>• Все публичные маршруты из OpenAPI отражены в gateway‑конфиге, расхождения отмечены и либо исправлены, либо задокументированы.<br>• `/health` и `/metrics` всех доменных сервисов работают на UK1; есть скрипт `scripts/smoke-gateway.sh`, который проверяет базовый набор health‑эндпоинтов.<br>• Playwright‑smoke используется как acceptance: тесты логина порталов проходят после изменений. | **Partial (~60%)** — агент помогает собрать таблицы и diff’ы, но решения по auth/route‑naming/timeout принимает человек.            |
| **NX-03.a**     | backend/tests       | Починить EF/issuance и довести baseline issuance.Tests до зелёного на локальном compose/UK1 (без deep‑DLT).                                         | Логи падения issuance.Tests (TRX), `services/issuance/*`, AsyncAPI/OpenAPI issuance, NX‑01.m.                                                              | • EF‑конфиг не регистрирует одновременно InMemory и PostgreSQL провайдер; ошибка “two providers registered” устранена.<br>• Все существующие тесты в `issuance.Tests` зелёные; mock‑режим ledger явно задокументирован (e.g. `MOCK_LEDGER=true`).<br>• Добавлен минимум 1–2 теста на publish/close issuance, отражающие реальный контракт.<br>• В `tasks/NX-03-*.md` описаны покрытые endpoints и известные ограничения.                                                                  | **Yes, under review (~70%)** — агент может предложить EF‑конфиг и тесты, но ты проверяешь бизнес‑допущения и миграции.              |
| **NX-04.a**     | backend/e2e         | Реализовать и проверить happy‑path Registry order flow: investor place order → registry/settlement обновляют состояние → события Kafka по AsyncAPI. | NX‑02.a, NX‑03.a, AsyncAPI topics для orders/payouts, `services/registry/*`, `services/settlement/*`, existing e2e sample (`tests/e2e/lifecycle.spec.ts`). | • Для ключевых endpoints registry/settlement есть unit/integration‑тесты (order create→reserve→paid).<br>• AsyncAPI‑топики `ois.order.*` и `ois.registry.transferred` публикуются и консусятся в соответствии со спекой (минимальный тест/скрипт проверки).<br>• Обновлён e2e‑сценарий (Playwright или Node‑скрипт) investor‑journey, хотя бы против локального compose.<br>• В NX‑04‑таске зафиксированы known‑gaps (например, отсутствие реального ledger).                             | **Partial** — агент пишет тесты и wiring, человек решает по DLT‑инвариантам и финальной схеме.                                      |
| **NX-05.a**     | identity/ops/docs   | Формализовать Identity/Keycloak baseline: realm/clients/roles + связь с identity service и NextAuth во фронтах, опираясь на UK1.                    | UK1 runbook, `services/identity/*`, `FRONTEND-CONTEXT`, Playwright login‑сценарии.                                                                         | • В `docs/deploy/identity-keycloak.md` (или аналог) описан realm, клиенты, роли, SMTP‑настройка, tested flows (verifyEmail, forgot‑password).<br>• Identity‑service реализует OpenAPI‑контракт (спек‑тесты зелёные).<br>• Все три портала используют единый, явно описанный NextAuth конфиг с mapping ролей/claims.<br>• Playwright‑логины investor/issuer/backoffice зелёные на UK1 после обновлений.                                                                                    | **Partial** — агенты могут сгенерировать конфиги/спек‑тесты, но дизайн realm/ролей и security‑решения — руками.                     |
| **NX-06.a**     | ops/ci              | Включить минимальный CI‑gate: сборка, dotnet/npm тесты, spec‑lint, публикация TRX/coverage/Playwright‑артефактов.                                   | Текущий `.gitlab-ci.yml`, audit‑рекомендации, артефакты тестов, WBS‑OIS (M5).                                                                              | • В `.gitlab-ci.yml` есть стадии: `lint/spec-lint`, `test-backend`, `test-frontend`, `test-e2e` (Playwright), `publish-artifacts`.<br>• Spectral/AJV lint падает pipeline при критических ошибках в спеках.<br>• `dotnet test` и npm тесты работают хотя бы для core‑проектов (issuance/registry + один портал).<br>• TRX/junit/coverage отчёты собираются как artifacts или pages.<br>• В audit‑доках отмечен переход от “теоретических гейтов” к минимально рабочим.                    | **Yes (~80%)** — это повторяемая DevOps‑работа по шаблону; ты проверяешь только, что не завалены ресурсы и нет регрессий.           |
| **NX-07.s1**    | frontend/backoffice | Малый вертикальный срез KYC‑UI: список KYC‑тасков + просмотр деталей, без полного 5625‑У.                                                           | `FRONTEND-CONTEXT` раздел backoffice, KYC endpoints в compliance/identity, текущий backoffice UI, Playwright backoffice‑auth.                              | • В backoffice есть страница KYC‑тасков (таблица + детали по клику).<br>• Подключены существующие endpoint’ы `/v1/compliance/kyc/*` (или заменён mock на реальный API).<br>• Написан Playwright‑сценарий “admin просматривает KYC‑таск” (без approve/reject на этом этапе).<br>• В CONTEXT‑доках зафиксировано, какие регуляторные требования *пока* покрываются этим MVP.                                                                                                                | **Partial** — UI+SDK‑wiring может делать агент; трактовка регуляторки и full‑workflow остаются у тебя.                              |
| **NX-08.s1**    | frontend/backoffice | Малый срез Audit‑UI: страница с таблицей audit‑событий + базовые фильтры (по дате/actor/action), без CSV‑экспорта.                                  | OpenAPI `/v1/audit`, реализация audit‑эндпоинтов, `shared-ui` компоненты, `FRONTEND-CONTEXT`.                                                              | • Backoffice имеет страницу “Audit Log” с таблицей и фильтрами по дате и типу события.<br>• Backend audit‑эндпоинты соответствуют OpenAPI (простые спек‑тесты зелёные).<br>• Написан Playwright‑сценарий “admin фильтрует audit log по типу события”.<br>• CSV/advanced‑фичи явно отнесены в “дальше” (описано в NX‑08).                                                                                                                                                                  | **Yes/Partial** — wiring к уже существующему API и UI‑таблица — хороший leaf; финальная модель данных и retention‑политики — trunk. |
| **DOC-ROOT.v1** | docs                | Обновить root/контекстные доки под реальность: UK1 как reference env, `infra.defis.deploy` как рабочая ветка, роль NX‑тасков и memory‑bank.         | `docs/context/PROJECT-CONTEXT.md`, V1+V2 отчёты, `20251114-discovery-infra-branch` memory docs, gitflow‑агримент.                                          | • В `PROJECT-CONTEXT.md` есть блок “Текущее состояние (infra.defis.deploy + UK1)” (можно взять этот раздел).<br>• В корневом `README.md` есть диаграмма “как читать репо сейчас” с указанием веток и ролей директорий.<br>• В `docs/context/WBS-OIS.md` обновлены статусы NX‑M‑milestones (NX‑01 → “in maintenance”, NX‑02/03/… как “in progress/planned”).<br>• В одном doc описано, как использовать `tasks/` и `memory-bank` как интерфейс для агентов.                                | **Yes (~90%)** — хороший leaf: много копипасты и синхронизации текста; ты лишь проверяешь формулировки.                             |

Это всё укладывается в 40–60h при разумном объёме (NX‑02/03/04/05/06 — основные потребители времени; NX‑07/08.s1 и DOC‑ROOT.v1 — “хвостовые” задачи, которые можно делать параллельно или с агентами).

---

## 4. Структурный refactor & hygiene (1–2 дня)

Цель: **минимальные, но чёткие изменения**, чтобы onboarding и работа агентов стали проще, без больших переездов кода.

1. **Root `README.md` → “карта местности”**

   * Добавить разделы:

     * “Структура директорий” (apps/services/packages/ops/docs/audit/chaincode/memory-bank/tasks).
     * “Ветки и окружения” (main/develop/infra.defis.deploy/tasks + UK1/CFA1/K8s).
     * “Как запускать локально” (ссылка на docker‑compose runbooks).

2. **README в ключевых папках (`apps/`, `services/`, `ops/`, `docs/`, `audit/`)**

   * Шаблон: Purpose, Submodules, How to run/tests, Owners, Don’t touch (для агентов).
   * Особенно важно в `ops/` (разделить Timeweb/K8s vs UK1/docker-compose) и `audit/` (что исторический snapshot, не изменять).

3. **Явно пометить исторические артефакты в `ARCHIVE/` и части `audit/`**

   * Переместить устаревшие доки, которые не используются UK1/NX‑тасками, в `ARCHIVE/infra-legacy/` с коротким `INDEX.md`, описывающим что там и почему не трогаем.

4. **Отдельный индекс для UK1‑runbooks и ops‑cheklists**

   * В `docs/deploy/README.md` собрать ссылки на: docker-compose‑at‑vps/*, 20251113‑cloudflare‑ingress, identity/SMTP runbooks, Playwright smoke.
   * Цель — чтобы агент/новичок начинал отсюда при любых работах с UK1.

5. **Развести “контекст для агентов” и “официальную архитектуру”**

   * В `docs/context/README.md` описать, что это слой для AI/agents (PROJECT/FRONTEND/WBS/RULES/PROMPTS).
   * В `docs/architecture/README.md` — что это официальные архитектурные артефакты (C4/UML, NFR, threat‑model).

6. **Оформить `memory-bank` как knowledge‑журнал, а не “мусор”**

   * В корне `memory-bank/README.md` описать структуру (Scrum/<дата>/<тип>), правила (что сюда пишем, как ссылаемся из коммитов/MR).
   * В root `README` дать короткий раздел “Как читать memory-bank (для ревью/аудита)”.

7. **Отдельный индекс для `tasks/NX-*`**

   * Создать `tasks/INDEX.md` с таблицей: NX‑ID / Track / WBS‑Milestone / Status / Link to md.
   * Синхронизировать с WBS‑OIS, чтобы агенты однозначно понимали, какие NX‑таски активны.

8. **Сегрегация generated‑кода**

   * В `packages/dotnet-clients` и `packages/sdks/ts` добавить `README` с пометкой “generated; do not edit manually; регенерация по script”.
   * Опционально — завести поддиректории `generated/` vs `handwritten/`.

1. **Mini‑TOC для tests

   * В `tests/README.md` описать уровни тестов (unit/integration/e2e/e2e‑playwright), какие сценарии уже покрыты (особенно по NX‑03/04/07/08) и как запускать smoke против UK1.

Этот пакет реалистен на 1–2 дня и резко уменьшит когнитивную нагрузку для нового человека и для агентов.

---

## 5. Agentification playbook (Codex/Claude/GPT‑5)

Опираться на TLA: **Trunk/Tree** = архитектура, контракты, критичная infra; **Leaves** = повторяемые локальные изменения.

### 5.1. Leaf‑patterns (делегируемые задачи)

| Name                                  | Description                                                                                                                          | Example in `ois-cfa`                                                                                                                                     | Notes                                                                         |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Spec‑Lint & Matrix Update**         | Агент гоняет Spectral/AJV/AsyncAPI‑lint, обновляет markdown‑матрицы endpoints/events, не меняя сами бизнес‑контракты.                | Обновить NX‑01: `artifacts/NX-01-report.md` + `docs/ops/api-event-matrix.md` по OpenAPI/AsyncAPI из `packages/contracts/*`.                              | Leaf: чистая механика CLI+таблицы, blast‑radius минимальный.                  |
| **Gateway Route Consistency Check**   | Агент собирает таблицу path→service→auth/roles из YARP‑конфигов и OpenAPI, подсвечивает расхождения.                                 | NX‑02: построить `docs/ops/gateway-routing.md` по `apps/api-gateway` и OpenAPI сервисов.                                                                 | Agent = diff‑engine; решения по auth/типам маршрутов остаются человеку.       |
| **Health/Metrics Templating**         | В сервисах без health/metrics агент добавляет стандартный OTEL/Prometheus wiring (по шаблону других сервисов) и простые smoke‑тесты. | Пройтись по `services/*/Program.cs` и убедиться, что у всех есть `/health` и `/metrics` с одинаковой схемой.                                             | Leaf: copy‑paste шаблонов; главное — не трогать доменную логику.              |
| **Issuance/Registry Test Extensions** | Агент расширяет существующие xUnit‑тесты новыми кейсами, обновляет TRX‑описания; не меняет бизнес‑инварианты.                        | NX‑03/04: добавить кейсы publish/close, order paid, payout schedule в `issuance.Tests` и registry‑тестах.                                                | Leaf с moderate‑risk: финальный просмотр сценариев и инвариантов — человеком. |
| **Playwright Scenario Scaffolding**   | На основе уже существующих e2e‑спеков генерируются новые сценарии (KYC approve/reject, audit log фильтрация) с тем же стилем.        | Для NX‑07/08: добавить spec’и “admin просматривает KYC‑таск” и “admin фильтрует audit log”.                                                              | Leaf: шаги + локаторы легко ревьюить глазами, регрессии видны.                |
| **Runbook Checklists & Commands**     | Дополнение опер‑runbooks конкретными командами, expected‑outputs, таблицами статусов.                                                | Расширить `docs/deploy/20251113-cloudflare-ingress.md` и docker-compose‑runbooks шагами smoke‑проверок (curl/Playwright/SMTP).                           | Leaf: документация, не меняет поведение системы.                              |
| **Client Regeneration (.NET/TS)**     | Агент гоняет генераторы по OpenAPI/AsyncAPI, обновляет `packages/dotnet-clients` и `packages/sdks/ts`, не трогая ручной код.         | Обновить TS‑SDK и .NET‑клиенты после правок спек issuance/identity.                                                                                      | Leaf: важно жёстко соблюдать “generated only”.                                |
| **Minor UI Wiring & Reports**         | Подключение нового отчёта/списка в портале через существующий SDK; добавление фильтров/сортировки без изменения доменной логики.     | В `portal-issuer` подключить reporting endpoint (`GetIssuerPayoutsReport*`) как страницу “Payouts report”; в backoffice — простые фильтры в KYC‑таблице. | Leaf: small UI changes, хорошо ложится на агента под UX‑ревью.                |

### 5.2. Trunk/Tree‑patterns (ручной контроль)

| Name                                             | Description                                                                                                                                       | Example in `ois-cfa`                                                                                       | Why trunk                                                                                                       |
| ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Domain Contracts & Reg‑Driven Changes**        | Любые изменения доменных схем (issuance/registry/settlement/compliance/identity), OpenAPI/AsyncAPI, бизнес‑правил, связанных с ГОСТ/5625‑У/746‑П. | Расширение модели KYC, изменение формата audit‑events, пересмотр lifecycle ЦФА в UML/AsyncAPI.             | Любая ошибка здесь = регуляторный/бизнес‑риск; агент может подсветить diff, но не решать.                       |
| **DLT/Fabric Topology & Chaincode**              | Настройка ордереров, peers, HA, chaincode‑lifecycle, пересмотр логики в `chaincode/*`, интеграция Fabric с registry/settlement.                   | Добавление нового типа сделки в chaincode с изменением инвариантов балансов.                               | Высокий blast‑radius, сложный operational‑risk; требуется глубокий контекст.                                    |
| **Identity/Keycloak Realm Design**               | Проектирование realm, ролей, клиентов, политики доступа; SSO/NextAuth‑интеграция как security‑ядро.                                               | Решение, какие роли и claims нужны backoffice/issuer/investor, как ограничить доступ к critical‑операциям. | Любая оплошность = security incident; агент максимум генерирует черновики конфигов.                             |
| **Cross‑Service Refactors & AsyncAPI Re‑shapes** | Изменения, затрагивающие несколько сервисов/контекстов: разделение сервисов, смена инвариантов, редизайн AsyncAPI топиков.                        | Перенос части логики из registry в settlement, пересмотр `ois.order.*`/`ois.payout.*` схем.                | Нужна целостная архитектурная картина; агент может помочь переписать код после того, как человек спроектировал. |
| **Security/Compliance Decisions & Reports**      | Threat‑model, mitigations, SoC‑playbooks, официальные отчёты для аудита/ЦБ; выбор CI/ops‑guardrails.                                              | Обновление GOST‑57580‑mapping, изменение CI‑политик деплоя, составление отчётов для регулятора.            | Требует ответственности и понимания контекста компании; агент — только как помощник по тексту/чек‑листам.       |

---

## Финальная компактная таблица (V3-рекомендации)

| Area                    | Key decision or issue                                                             | V3 recommendation                                                                                                                                                                                                                                                                          |
| ----------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Environments & branches | Реальный UK1 vs “теоретические окружения”, статус `infra.defis.deploy` и GitFlow. | Зафиксировать UK1 как reference dev/demo env; считать `infra.defis.deploy` текущей canonical‑веткой, стабилизировать её через NX‑02/03/06 и после этого мержить в `develop` по GitFlow (main/develop/feature/*, `tasks` только для md‑тасков/агентов).                                     |
| NX roadmap              | Какие NX‑таски делать в ближайшие 2–3 недели и в каком порядке.                   | Неделя 1: NX‑01.m + NX‑02.a + NX‑03.a; Неделя 2: NX‑04.a + NX‑05.a; Неделя 3: NX‑06.a + небольшие срезы NX‑07.s1/NX‑08.s1; все acceptance‑чекпоинты — через UK1+Playwright.                                                                                                                |
| CI/CD & quality gates   | Отсутствие минимальных spec/test‑гейтов, DinD, хаотичные артефакты.               | Внедрить NX‑06.a: добавить в `.gitlab-ci.yml` обязательные стадии lint/spec‑lint/tests/e2e/artefacts, позже (отдельным шагом) начать постепенный уход от DinD → Kaniko/альтернатива.                                                                                                       |
| Docs & repo hygiene     | Смешение `docs/`, `audit/`, `ARCHIVE/`, `memory-bank`, отсутствие карт/индексов.  | За 1–2 дня выполнить набор из §4: root README, README по ключевым папкам, индекс UK1‑runbooks, контекст vs архитектура, оформление `memory-bank` и `tasks/INDEX.md`, явное отделение ARCHIVE/legacy‑артефактов.                                                                            |
| Identity & SMTP         | SMTP/Keycloak работают, но не формализованы как baseline (NX‑05).                 | Оформить NX‑05.a: собрать единый identity‑runbook, выровнять identity service по OpenAPI, зафиксировать NextAuth/roles mapping и привязать к существующим Playwright‑логинам на UK1.                                                                                                       |
| Tests & E2E             | Частично покрытый issuance/registry, но ошибки EF и незамкнутые e2e‑флоу.         | Починить EF и довести issuance.Tests до зелёного (NX‑03.a), затем реализовать минимальный registry‑order‑flow и e2e‑journey (NX‑04.a), используя AsyncAPI/OpenAPI как истину.                                                                                                              |
| Agentification          | Где безопасно использовать агентов, где нет.                                      | Следовать playbook из §5: leaf‑таски (spec‑lint, gateway‑diffs, health/metrics, тесты, Playwright, runbooks, SDK) делегировать с человеческим ревью; trunk‑решения (доменные контракты, DLT, identity‑realm, cross‑service refactors, security/compliance) оставлять под ручным контролем. |

Это и есть твой V3‑master‑контекст: его можно давать Codex/Claude/GPT‑5 как стартовый “AGENTS.md/PROJECT‑CONTEXT‑V3” для дальнейшей работы.


# Prompt 2
Я высказал аудиотранскрипцией свой фидбек
Так, давай по шагам. Я тут по диагонали пробежался по всему, и что я хочу сказать.

Первая ветка, которая у меня названа таким образом, вот эта "infra.defis.deploy", она должна быть названа "feature/deploy" или нет, "feature/before-merge-infra" или нет, "Feature/Demo"? Типа вот она какая-то каноническая, она моя, или я не знаю, "feature/demo-alex"? Да нет, лучше "FeatureDemo" или "feature/pre-develop" назвать, может быть так, потому что она действительно будет "feature/pre-develop".

Дальше я от нее буду ветвиться и сделать первую задачу пробовать, а потом в нее вливаться, а потом уже в DWO. Потому что нужно сначала, вот у меня как-никак что-то там есть рабочее, как оно там будет приводить в порядок. Это нужно отдельно.

Какие порядки я хочу? Ну вот, первая ветку вот эту, как бы да, и дальше от нее вот эти все фичи. Хоть это не совсем, с другой стороны, верно, потому что он может... Александр О, в DWO плите мне тогда надо по цепочке обновлять. Ну, в принципе, могу и обновлять, но это, конечно, добавляет еще одну точку.

Может быть, мне ее все-таки переименовать в фичи первая задача, да, и как бы делать первую задачу? Но что не совсем правильно, потому что я даже не помню, в чем там первая задача, и она там может быть специфическая, да. Мне нужно просто после мерджа стабилизировать мою рабочую ветку, в ней получается дальше наладить, наверное, какие-то системные, как раз такие гварды.

Что я имею в виду? Вот, во-первых, в этом отчете мы видим leaf, мы видим trunk, но мы не видим branch. А в документе была, как бы, история, что у дерева есть ствол, ветви, листья: trunk, branch, leaves. Почему нету branches, где они, я не понимаю, в таблицах?

Да, тут хорошо, что это указано: name, description, example, notes. Да, отлично, по leaves, по trunk: name, description, example, why trunk. Окей, а почему branch? Мне нужно еще branch.

Потом нужно, как бы, это все увязать в единое. И еще мне очень не хватает Mermaid JS-диаграмм. Это must-have requirement, его нужно обновить в agents.md в манифесте, что это важно, потому что с моим ADHD я визуал, мне это нужно.

Дальше, что я тут еще вижу? Возможно, перед тем как решать те задачи, мне все-таки надо определиться самому, сделать agentification и IT architecture for agents based on trunk, branches and leaves. Да, потому что без этого, как будто, дальше будет никуда. Архитектура плюс-минус хорошая уже, как бы, много агентов умных подтвердило. Много агентов умных подтвердило мне, Алексу, это подтвердили умные агенты об архитектуре Александра О.

Да, дальше, по поводу там, по поводу там, в ванги ту веку и фри. Ну, типа, да, вот мы сейчас вид вефри начнем версию, да. Ну, нужно до... вот эти задачи, как бы, доделывать, но сначала подготовить. Что там дальше? Что там дальше?

Дальше я вот читаем второе, текущее состояние. Дальше я читаю, вот у меня... ну, важно, супер факт, что вот это и ки один, это было поднято без до мерджа, точнее, с Александр, вот этими большими изменения в инфа. То есть там сейчас, вот, как бы, если в идеале не на реке один и на том домене поднимать, а мы поднимаем еще одно домоокружение уже на основе текущего смартинного варианта, и как раз там посмотрим.

У нас есть такие один слепо, где там все работает, да? Есть, получается, cfa 1, где вот стоит. Туда, наверное, вернуться, подвязать туда тоже домен, но получается сделать там по-другому. Ну, то есть, вот на основе вот этой ветки, которая будет предыдать, или как правильно, получается можно каким-то одним названием, да?

Вот, чё тут, единый родмап по задачам? Ну, а чё? Ну, как бы, сначала вот нужно сделать... ну, вот, ветка гифау, определиться с стран бренд, и потом сделать на cfa один. Получается, это окружение выбрать там немножко другой поддомен у тебя на серваке, на котором запущен агент, там все настроен Cloudflare CLI, и по аналогии с neighbors просто выбрать какой-то домен другого названия, да?

Не как он там сейчас... как там сейчас есть? Поисней бурс, сейчас я посмотрю. Да, я вижу домен.cfa. Ну, сделать тогда домен.нпк, да? Это еще одно название компании. Вот, вокруг него все построить, и будет, получается, второй этот, или можно назвать cfa ту, да, и будет понятно. Или cfa 1 просто, вот он же 1 называется у нас, чтобы не путаться, будет просто cfa 1, да?

Что еще? Дальше идем. Ну, по задачи уже следующая, понятно, там будем углубляться. Я вот смотрю сейчас, по поводу... дальше читаю отчет и вижу структурные факторы гигиены день во дня. Ну, вот, да, ты мне это и предлагаешь, то есть сделать структуры директории, а ветки окружения на это, не по... да, это ветка.

Я чуть подумал, что имеется в... в плане парадигмы Максима, да? Да, и не только Максима, этой Скотт код систем архитект рекомендовали до аналогию до ствол, ветви, листья, и это нужно сделать там вокруг линтеров, там не знаю, тестов и так далее, и так далее, какие-то скрипт чек на что, какие-то вещи трогать, нет.

Вот я читаю дальше, кейсин 5 разделов койбук и по транс, вижу транс. Ну, да, как я говорю, на нету бренд. Ну что, вот тебе такой мой фидбэк, давай это доработай сейчас наилучшим образом.
# Output 2 TL;DR

* Предлагаю **не переименовывать `infra.defis.deploy` сейчас**, а явно зафиксировать её как временную `integration/pre-develop`‑ветку и уже от неё вести feature‑ветки по NX‑таскам, пока не родится нормальный `develop`. 
* Модель дерева нужно сделать **полной: Trunk + Branches + Leaves**: ствол = архитектура/контракты/NFR; ветви = сервисы/модули/инфра‑каркас; листья = конкретные фичи/тесты/скрипты. Сейчас в твоём отчёте и слайдах явно не хватает уровня Branch.
* В AGENTS/манифесте стоит ввести жёсткое правило: **любая структурная рекомендация → хотя бы одна Mermaid‑диаграмма + таблица Trunk/Branch/Leaf**, чтобы ты глазами видел, где trunk, где ветка, где leaf.

Search‑tool для этого ответа **не запускал** — опираюсь на уже загруженные файлы (Trees/Leaves/Agents, V1/V2‑аудиты, gitflow‑соглашения, UK1‑runbook).

---

## Steps (по факту, что делать с веткой и моделью дерева)

1. **Зафиксировать роль `infra.defis.deploy` как “pre‑develop integration”**

   * Не ренеймить сейчас (слишком много ссылок уже в логах/доках и UK1‑runbook). 
   * В `docs/context/PROJECT-CONTEXT.md` и/или `docs/context/RULES-SUMMARY.md` явно записать:

     > `infra.defis.deploy` = временная ветка **интеграции infra + deploy + UK1**, от неё сейчас живут все NX‑фичи. После стабилизации → срезаем `develop`.
   * От неё уже **ветвиться под задачи**: `feature/NX-05-keycloak-baseline`, `feature/NX-06-ci-gates`, и т.д., а не из `main`.

2. **Привязать это к договорённому gitflow**

   * Александр уже проговорил: `main` → prod, `develop` → Dev/pre‑prod, `tasks` → Markdown‑таски, feature‑ветки под каждую задачу. 
   * В реальности сейчас:

     * `main` — старый мир;
     * `infra` — infra‑мир Александра;
     * `deploy` — твой UK1‑мир;
     * `infra.defis.deploy` — фактический **кандидат в будущий `develop`**.
   * Мой совет: **официальный `develop` потом срезать от `infra.defis.deploy`**, а саму `infra.defis.deploy` потом либо заморозить (tag/архив), либо удалить, когда все MR закроются.

3. **Добавить “Branch” в Trees/Leaves/Agents и связать с ветками Git**

   * Сейчас в твоих TLA‑доках и в моём предыдущем плейбуке явно есть Trunk и Leaves, но **нет уровня Branch**, хотя в оригинальном докладе он был (ствол/ветви/листья).
   * Нужно:

     * дописать таблицу с третьим уровнем Branch;
     * показать, что **Git‑ветки `main/develop` ≈ Trunk**, `infra.defis.deploy`/`release/*` ≈ Branch, `feature/NX-*` ≈ Leaves.

4. **Прописать Mermaid‑диаграммы как обязательное требование для агентов**

   * В `AGENTS.md` (или RULES) добавить пункт вида:

     * “Если ответ касается архитектуры, gitflow, agentification или процессов — **минимум одна Mermaid‑диаграмма + одна таблица Trunk/Branch/Leaf**”.
   * Это чётко снимет боль “по диагонали прошёлся, но не увидел, где у нас branch”.

5. **Сделать 1 маленький doc‑апдейт под это**

   * Один файл типа `docs/context/TREES-LEAVES-AGENTS-OIS.md`:

     * краткое описание Trunk/Branch/Leaf именно для `ois-cfa`;
     * вставить таблицу и диаграммы ниже (можно почти копипастнуть);
     * дать ссылку на этот doc из `AGENTS.md`.

---

## Table — Trunk / Branch / Leaves для `ois-cfa`

> Это закрывает твоё “почему нет branch в таблице?”. Вот она, нормальная тройка для этого репо.

| Level      | Что это в `ois-cfa`                                 | Примеры (конкретно)                                                                                    | Кто трогает                              | Тип задач / риски                                                                                 |
| ---------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | ---------------------------------------- | ------------------------------------------------------------------------------------------------- |
| **Trunk**  | Архитектурное ядро, контракты, NFR, gitflow‑правила | `docs/context/*`, C4/uml, `packages/contracts/*`, `packages/domain`, AsyncAPI, gitflow main/develop    | Только ты + Александр                    | Неправильное изменение = поломка всей системы, regulatory‑риск, миграции по всем сервисам         |
| **Branch** | Скелет модулей/сервисов и инфра‑каркас              | `services/*` структура, `apps/api-gateway`, `ops/*` (Timeweb/k8s, GitOps), ветка `infra.defis.deploy`  | Senior + аккуратные агенты под контролем | Ошибка → ломается целый сегмент (все сервисы, весь gateway, весь CI)                              |
| **Leaves** | Локальные фичи, тесты, UI‑кусочки, скрипты          | Конкретный endpoint, Playwright spec, отдельный React‑экран, migration‑скрипт, `feature/NX-05-*` ветка | Агенты + human review                    | Ошибка локальна, можно перегенерить; техдолг допустим, если его легко перегенерировать/переписать |

---

## Mermaid — 1) Архитектура как дерево

```mermaid
graph TD
    TRUNK["Trunk ↴<br/>Архитектура, контракты, NFR<br/>docs/context, packages/contracts, packages/domain"]:::trunk

    subgraph BRN["Branches ↴<br/>Сервисы + инфра‑каркас"]
        B1["Domain services<br/>services/issuance, registry, settlement, compliance"]:::branch
        B2["Edge / Gateway<br/>apps/api-gateway, Cloudflare/nginx, Keycloak"]:::branch
        B3["Ops / Platform<br/>ops/infra, ops/gitops, .gitlab-ci.yml"]:::branch
    end

    subgraph LEAVES["Leaves ↴<br/>Фичи/тесты/скрипты"]
        L1["Feature NX-03: issuance tests<br/>tests/issuance.Tests/*"]:::leaf
        L2["Feature NX-04: order flow spec<br/>tests/e2e-playwright/*order*"]:::leaf
        L3["UI slice: backoffice KYC<br/>apps/backoffice/*"]:::leaf
        L4["CI job: spectral-lint<br/>.gitlab-ci.yml (один job)"]:::leaf
    end

    TRUNK --> B1 --> L1
    TRUNK --> B2 --> L2
    TRUNK --> B2 --> L3
    TRUNK --> B3 --> L4

    classDef trunk fill:#fdf6e3,stroke:#b58900,stroke-width:2px;
    classDef branch fill:#eee8d5,stroke:#657b83;
    classDef leaf fill:#ffffff,stroke:#93a1a1;
```

---

## Mermaid — 2) Gitflow vs Trunk/Branches/Leaves

```mermaid
graph LR
    subgraph Remote
      MAIN["main<br/>(prod trunk)"]:::trunk
      DEV["develop<br/>(future dev trunk)"]:::trunk
      INTEG["infra.defis.deploy<br/>(integration/pre-develop branch)"]:::branch
    end

    subgraph FeatureWork
      F1["feature/NX-03-issuance-tests"]:::leaf
      F2["feature/NX-04-registry-flow"]:::leaf
      F3["feature/NX-05-identity-baseline"]:::leaf
    end

    MAIN --> DEV
    DEV --> INTEG

    INTEG --> F1
    INTEG --> F2
    INTEG --> F3

    F1 --> INTEG
    F2 --> INTEG
    F3 --> INTEG

    INTEG --> DEV
    DEV --> MAIN

    classDef trunk fill:#fdf6e3,stroke:#b58900,stroke-width:2px;
    classDef branch fill:#eee8d5,stroke:#268bd2;
    classDef leaf fill:#ffffff,stroke:#93a1a1;
```

Интерпретация:

* Сейчас **`infra.defis.deploy` = Branch‑уровень**, который живёт между твоими feature‑ветками и будущим `develop`.
* После стабилизации:

  * `develop` становится постоянным trunk для Dev;
  * `infra.defis.deploy` можно tag’нуть и отправить в ARCHIVE.

---

## Шаблон для `AGENTS.md` (вставка)

Ниже — кусок, который можно почти без правок бросить в `AGENTS.md` / `docs/context/TREES-LEAVES-AGENTS-OIS.md`:

```md
## Trees / Branches / Leaves for ois-cfa

> Модель взаимодействия людей и агентов с кодом.

### Levels

| Level   | Description                                  | Modifications Policy                                        |
|--------|----------------------------------------------|-------------------------------------------------------------|
| Trunk  | Архитектура, контракты, NFR, gitflow rules   | Меняют только Alex A + Aleksandr O, всегда через ADR/MR    |
| Branch | Domain services, gateway, ops skeleton       | Меняем аккуратно, с review, агентам — только мелкие правки |
| Leaves | Фичи, UI‑слайсы, тесты, локальные скрипты    | Можно отдавать агентам, техдолг допустим                   |

### Git mapping

- Trunk branches: `main`, `develop` (в будущем), архитектурные ADR + контракты (`packages/contracts`, `packages/domain`).
- Branch branches: `infra.defis.deploy`, `release/*`, ops‑ветки под перечислимые изменения.
- Leaf branches: `feature/NX-0X-*`, короткоживущие ветки под конкретные NX‑таски.

### Agent rules (обязательные для всех агентов)

1. Если задача касается архитектуры/gitflow/infra:
   - Всегда включать **минимум 1 Mermaid‑диаграмму** и **1 таблицу Trunk/Branch/Leaf**.
2. Агенты **не создают/не переименовывают trunk‑ветки** (`main`, `develop`) и не меняют NFR/контракты без явного запроса человека.
3. Любые правки в Branch‑уровне (структура `services/*`, `ops/*`, gateway) делаются только в маленьких diff’ах + с human‑review.
4. Leaf‑уровень (UI/тесты/мелкие скрипты) — приоритетная зона для агентов; там допускается перегенерация и быстрый рефакторинг.
```

---

## Next actions (чек‑лист для тебя)

✅ = сделай, остальное можно парковать на потом.

1. ✅ **Зафиксировать роль `infra.defis.deploy` в доках**

   * В `docs/context/PROJECT-CONTEXT.md` добавить 2–3 строки, что это временная `integration/pre-develop`‑ветка, от которой сейчас живут NX‑фичи.

2. ✅ **Сделать маленький `TREES-LEAVES-AGENTS-OIS.md`**

   * Вставить таблицу Trunk/Branch/Leaf и обе диаграммы — это будет canonical‑док для всех будущих агентов по этому репо.

3. ✅ **Обновить `AGENTS.md` правилом “Mermaid + Table must‑have”**

   * Вставить предложенный сниппет с правилами для агентов и запретом трогать Trunk без явной просьбы.

4. 🔁 **Дальше работать от `infra.defis.deploy` → feature/NX‑ветки**

   * Не переименовывать ветку пока; просто воспринимать её как Branch‑уровень, из которого рождаются Leaves (feature‑ветки), а потом всё уедет в `develop`.

5. 🔁 **Когда NX‑02/03/04/05/06 стабилизируются — срезать `develop`**

   * Создать `develop` от актуальной `infra.defis.deploy`, договориться с Александром, после merge в main — задокументировать, что `infra.defis.deploy` считается историческим integration‑branch (Архив/тэг).

Если захочешь — дальше могу уже поверх этого дерева разложить конкретный 2–3‑недельный NX‑roadmap ещё раз, но с прямой привязкой: какие `NX-*` — trunk, какие — branch, какие — чистые leaves.

```

`aggregated-gpt5pro-talks/20251117-2103-gpt5pro-step4-all-and-nextsteps.gpt5p.md`:

```md
# Prompt
You are Oracle, a focused one-shot problem solver. Emphasize direct answers, cite any files referenced, and clearly note when the search tool was used.  You are GPT‑5 Pro acting as a senior system/solution architect and meta‑framework designer for an AI‑assisted monorepo.  You are now looking at a **mono‑repo root**:  - macOS path: `/Users/user/__Repositories/prj_Cifra-rwa-exachange-assets` - eywa1 path: `/home/user/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets` - The `ois-cfa` repo is a submodule under:   `repositories/customer-gitlab/ois-cfa`  On both macOS and eywa1 we use **git worktrees** with the pattern:  - `wt__{repo}__{branch}`, where `/` is replaced with `-` - Example on macOS:   - `repositories/customer-gitlab/ois-cfa` (main worktree, branch `infra.defis.deploy`)   - `../wt__ois-cfa__infra`   (branch `infra`)   - `../wt__ois-cfa__deploy`  (branch `deploy`)   - `../wt__ois-cfa__main`    (branch `main`) - Same pattern exists on eywa1.  In `ois-cfa` the `tasks/` folder and `docs/context/*` are the **main handles for future AI agents**.  I have attached:  - `c2p_ois-cfa.txt`: ~4MB code2prompt snapshot of the `ois-cfa` repo on branch `infra.defis.deploy` (structure + key files, including `tasks/NX-*` and `docs/context/*`); - `20251116-1603-gpt5pro-audit-feedback-review.gpt5p.md`: your earlier deep V1‑audit (architecture + recommendations); - `20251117-1747-gpt5pro-next-steps-after-audit-feedback.gpt5p.md`: follow‑up “next steps” report; - `20251117-1748-gpt5pro-next-steps-after-audit-feedback.gpt5p.md`: another “next steps” angle; - `20251117-1927-gpt5pro-step3-all-together-after-audit-feedback.gpt5p.md`: step‑3 consolidation (“all together after audit + feedback”) including my spoken feedback about Trunk/Branches/Leaves, Mermaid, and infra.defis.deploy; - `20251117-1518-conversation-AlexA-AleksandrO.md`: conversation about NX‑tasks and expectations for `tasks/` + `docs/context/`; - `20251114-agreements-gitflow-AlexA-and-AleksandrO.md`: gitflow agreements (main/develop/tasks/feature/*, infra.defis.deploy, etc.); - `20251117-1713-feedback-to-co-3c63-from-eywa1-co-3dd7.md`: explicit feedback from eywa1 about UK1, CFA1 and what your earlier audits missed; - `AGENTS.md` at the monorepo root (current global agent rules); - `WBS-OIS.md` from `ois-cfa/docs/context` (WBS and link to NX‑tasks).  **Reality and constraints you MUST respect:**  - I will work **from the mono‑repo root on eywa1**, not from bare `ois-cfa` root. - For `ois-cfa` we already created worktrees: `wt__ois-cfa__infra`, `wt__ois-cfa__deploy`, `wt__ois-cfa__main` and main worktree on `infra.defis.deploy`. - Branch `infra.defis.deploy` is now the **integration/pre‑develop branch** (infra + deploy + UK1), not yet clean `develop`. - In the Trees/Leaves/Agents model we absolutely need a **full 3‑level tree**:   - Trunk = architecture, contracts, NFRs, gitflow rules;   - Branches = domain services, gateway, ops skeleton, integration branches (like `infra.defis.deploy`);   - Leaves = feature branches, UI slices, tests, scripts, small config changes. - Mermaid diagrams are **must‑have** for me (ADHD, visual thinker). Any serious structural recommendation must include at least one simple Mermaid diagram.  My current need is:  > **Design a coherent Trunk/Branch/Leaf + NX‑00 framework and AGENTS rules for this mono‑repo, so that future agents (Codex/Claude/GPT‑5) can reliably work from the monorepo root and drive `ois-cfa` via tasks/NX‑* in a safe, staged way.**  VERY IMPORTANT PROCESS RULE:  - Before doing NX‑01..NX‑08 tasks inside `ois-cfa`, I want to define and execute **NX‑00-* meta‑tasks** (AGENTS, Trees/Branches/Leaves, diagrams, indices). - Order is: *write NX‑00 tasks → update AGENTS/Docs accordingly → only then execute NX‑01..NX‑08*. - All outputs of this Oracle call will be used as **zero‑shot context** for other agents, without live conversation.  ---  ### What I need from you (V4 “master” framework):  #### 1) Refine and fix the Trunk / Branches / Leaves model  Using all attached GPT‑5 reports and the TLA docs, and especially step‑3 (1927):  - In Russian (with B2‑level English terms), clearly define for this mono‑repo:    - Trunk: what exactly belongs there (which docs, which contracts, which branches);   - Branches: how to map service/infra structure and git branches (main/develop/infra.defis.deploy/release/*) to Branch‑level;   - Leaves: typical leaf‑level changes (tests, small features, scripts, devops jobs, docs updates).  - Output:    - A short narrative (5–8 bullets) with clear definitions.   - A **table** with columns: `Level` / `What it is in this mono-repo` / `Examples` / `Who touches it` / `Risks`.   - At least **two Mermaid diagrams**:     - one for architecture as a tree (Trunk → Branches → Leaves);     - one for gitflow vs Trunk/Branches/Leaves (main/develop/infra.defis.deploy/feature/NX-* + worktrees).  These diagrams should be simple enough to copy‑paste into markdown (no exotic Mermaid features).  #### 2) NX‑00 meta‑tasks: what must be done before NX‑01..NX‑08  Design a **small “NX‑00‑series”** of meta‑tasks that must be done prior to implementing NX‑01..NX‑08 for `ois-cfa`, working from the monorepo root:  - Think of NX‑00‑01, NX‑00‑02, … NX‑00‑N (N ≈ 3–7). - Each NX‑00 task should be something like:   - “Update AGENTS.md with Trunk/Branch/Leaf + Mermaid rules”;   - “Create TREES-LEAVES-AGENTS-OIS.md and link it from docs/context and AGENTS.md”;   - “Add README/INDEX files for `tasks/` and `docs/context/` to explain how agents should use NX‑tasks from mono‑repo root”;   - “Describe git worktrees and naming pattern wt__{repo}__{branch} in docs/AGENTS so agents understand physical layout on macOS/eywa1”;   - etc.  For each NX‑00‑task provide:  - `NX-00-ID` (e.g. NX‑00‑01, NX‑00‑02, …); - `Target location` (which repo/file(s): mono‑repo AGENTS.md, `repositories/customer-gitlab/ois-cfa/docs/context/…`, etc.); - `Goal` (1–2 lines); - `Steps` (3–7 bullet points, fairly concrete); - `Done-when` (3–5 bullet DoD); - `Agent-friendly?` (yes/no/partial + 1‑line why).  Output this as a table; I will then physically create these NX‑00 files and execute them in order.  #### 3) How NX‑00 connects to NX‑01..NX‑08 and git branches/worktrees  Given:  - gitflow agreements (20251114); - conversation about tasks (1518); - the Trunk/Branch/Leaf model you defined in section 1; - the current worktree layout (`wt__ois-cfa__infra`, `wt__ois-cfa__deploy`, `wt__ois-cfa__main`, main `infra.defis.deploy`);  Explain:  - From which branch and **from which worktree** I should:   - apply NX‑00 tasks on eywa1 (monorepo root + submodule worktrees),   - then branch for NX‑01..NX‑08 (`feature/NX-03-issuance-tests`, etc.),   - and where to merge back (into `infra.defis.deploy`, then later into `develop`/`main`). - Provide 5–10 bullets as a **“Branch/Worktree usage guide”** for future agents, with references to Trunk/Branches/Leaves.  If helpful, add one more small Mermaid diagram (git branches vs worktrees).  #### 4) Concrete AGENTS.md / rules updates  Using the attached monorepo `AGENTS.md` and all previous audits:  - Suggest **concrete changes/additions** to AGENTS rules, focusing on:    - Trunk/Branch/Leaf responsibilities;   - mandatory Mermaid + tables for structural/architectural/gilfow/agentification answers;   - rules about worktrees (wt__{repo}__{branch});   - what agents MAY and MAY NOT do in this mono‑repo (e.g. no touching main/develop contracts, no K8s/fabric topology changes, etc.).  - Output as:    - A short “patch‑like” section (list of new paragraphs/sections to insert into AGENTS.md, not actual diff);   - A bullet list explicitly labeled “Rules for all AI agents” that I can paste into AGENTS.md.  #### 5) Final “handoff” for Codex/Claude/GPT‑5 agents  Remember: your output will be used as **zero‑shot master context** for other agents.  At the end of your answer, produce a short section:  - “How other agents should read and use this document” — 5–8 bullets, describing:   - in what order to read sections (Trunk/Branch/Leaf → NX‑00 → NX‑01..NX‑08 → Branch/Worktree guide → AGENTS rules);   - how to decide whether a concrete task is Leaf/Branch/Trunk;   - when they MUST stop and ask for human confirmation.  Style & format:  - Answer in Russian, with senior‑engineer tone; English technical terms/slang OK. - Structure your answer as:    - TL;DR (3–5 bullets),   - Section 1: Trunk/Branches/Leaves clarified,   - Section 2: NX‑00 meta‑tasks (table),   - Section 3: Branch/Worktree usage guide,   - Section 4: AGENTS.md / rules updates,   - Section 5: Handoff for other agents,   - Final compact table: `Area` / `Decision or rule` / `Your recommendation`.  - Do NOT restate full contents of attached files; focus on synthesis, decisions, and **executable** steps that I can implement from the monorepo root on eywa1.

# Output

TL;DR

* Trunk = **AGENTS + манифесты + контракты + NFR + gitflow + ключевые runbook’и (UK1)**; Branch = **сервисы/infra‑каркас + интеграционные ветки (`infra.defis.deploy`, `release/*`)**; Leaves = **feature‑ветки `feature/NX-*`, UI‑слайсы, тесты, скрипты**. `infra.defis.deploy` — НЕ trunk, а integration‑branch. 
* Перед NX‑01..NX‑08 выполняем **5 meta‑тасков NX‑00‑01..05**: T/B/L‑док, апдейт AGENTS, индекс `tasks/`+`docs/context/`, doc по gitflow+worktrees, выравнивание WBS‑OIS+NX по уровням дерева. Это создаёт единый «каркас» для других агентов.
* Рабочая база на сегодня: **monorepo root@`main` + submodule `ois-cfa`@`infra.defis.deploy`**; feature‑ветки `feature/NX-*` заводим **в `ois-cfa` от `infra.defis.deploy`**, мержим обратно в неё, позже — `infra.defis.deploy → develop → main`. `tasks` — только MD‑таски, не база для кода.
* AGENTS‑rules: агентам **запрещено трогать trunk** (контракты, NFR, gitflow, chaincode, топологию K8s/Fabric, критические runbook’и), обязательны **Mermaid + таблица** для любых структурных/архитектурных решений, работа с worktrees строго по шаблону.
* Всё ниже собрано из `c2p_ois-cfa`, V1/V2/V3‑аудитов, WBS‑OIS, gitflow‑agreements, NX‑разговора и UK1‑feedback через `file_search` по репо.

---

## Section 1. Trunk / Branches / Leaves — уточнённая модель

### 1.1. Краткие определения (моно‑репо целиком)

1. **Trunk (ствол)** — устойчивый «каркас проекта»:
   AGENTS/CLAUDE, манифесты (`project.manifest.json`, `repo-structure`, `workflow`), WBS‑OIS, контракты (`packages/contracts`, `packages/domain`), NFR/безопасность/регуляторка, gitflow‑правила, ключевые runbook’и по окружениям (UK1/Cloudflare/SMTP/Playwright).

2. **Trunk‑ветки** — `main` и будущий `develop` в `ois-cfa` и в корне монорепы. Всё, что туда попадает, считается согласованной архитектурой и контрактом с внешним миром (демо/клиент). 

3. **Branches (ветви)** — реализация доменных сервисов и платформенный «каркас»:
   `services/*`, `apps/api-gateway`, `ops/infra`, `ops/gitops`, `.gitlab-ci.yml`, UK1‑docker‑compose, GitLab Runner/Agent, интеграционные ветки типа `infra.defis.deploy`, `release/*`, `hotfix/*`.

4. **`infra.defis.deploy`** — **integration/pre‑develop branch на уровне Branch**, а не новый trunk: туда сведены `infra`+`deploy`+UK1, она выступает как «интеграционный мост» между feature‑ветками и будущим `develop`.

5. **Leaves (листья)** — локальные изменения, которые можно смело отдавать агентам: feature‑ветки `feature/NX-*`, отдельные UI‑кусочки в порталах, Playwright‑спеки, unit/integ‑тесты, небольшие YAML/Helm/CI‑jobs, вспомогательные скрипты и README в подсистемах.

6. **tasks/NX‑*** — интерфейс для Leaves/Branches: каждый NX‑task описывает срез работы (spec‑matrix, gateway, issuance, registry, identity, CI, backoffice) и в WBS привязан к конкретным Milestones M1..M5.

7. **memory‑bank** — **журнал решений и сессий**, не кодовый trunk: туда пишем логи аудитов, UK1‑деплоя, git‑обсуждений, но не воспринимаем как архитектурный контракт; ссылки на важные записи заводим из trunk‑доков.

8. **Точка входа для агентов**: monorepo `AGENTS.md` → `docs/context/PROJECT-CONTEXT.md` → `docs/context/TREES-LEAVES-AGENTS-OIS.md` (будущий) → `WBS-OIS` → нужный `tasks/NX-*`.

### 1.2. Таблица уровней

| Level  | What it is in this mono-repo                                                                                                   | Examples                                                                                                                                                      | Who touches it                                                            | Risks if broken                                                                                                        |
| ------ | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| Trunk  | Архитектурный каркас, контракты, NFR, gitflow, ключевые runbook’и и правила агентов на уровне **всей монорепы и `ois-cfa`**    | `AGENTS.md`, CLAUDE.md, `project.manifest.json`, `WBS-OIS.md`, `docs/context/PROJECT-CONTEXT.md`, `packages/contracts/*`, UK1‑ingress/SMTP runbook            | Alex A, Aleksandr O (+ ревью заказчика); агенты — только как советники    | Поломанный контракт с внешним миром, регуляторные риски, невалидный gitflow, несогласованные NFR по перфу/безопасности |
| Branch | Реализация доменов и платформы: сервисы, gateway, ops‑каркас, интеграционные ветки (включая `infra.defis.deploy`)              | `services/issuance/*`, `services/registry/*`, `apps/api-gateway/*`, `ops/infra/*`, `ops/gitops/*`, `.gitlab-ci.yml`, ветки `infra.defis.deploy`, `release/*`  | Alex A, Aleksandr O, senior‑dev; агенты — только мелкие изменения с ревью | Сломанные flows, деградация observability/CI, дрейф infra, нестабильные демо/UK1                                       |
| Leaf   | Локальные фичи и улучшения поверх каркаса: UI‑слайсы, Playwright‑спеки, unit/integ‑тесты, мелкие YAML/CI‑jobs, скрипты, README | `feature/NX-03-issuance-tests`, `tests/e2e-playwright/*`, изменения в `apps/backoffice/*`, `scripts/smoke-gateway.sh`, job `spectral-lint` в `.gitlab-ci.yml` | Любые dev + агенты (обязательно через MR)                                 | Локальные регрессы; риск небольшой, если есть тесты/ревью                                                              |

(таблица — канон для всех NX‑00/NX‑0X тасков)

### 1.3. Mermaid — архитектура как дерево

```mermaid
graph TD
    TRUNK["Trunk\nАрхитектура, контракты, NFR, gitflow"]:::trunk

    subgraph BRN["Branches ▾\nСервисы + инфра-каркас"]
        B1["Domain services\nservices/issuance, registry, settlement, compliance, identity"]:::branch
        B2["Edge / Gateway\napps/api-gateway, Cloudflare/nginx, Keycloak"]:::branch
        B3["Ops / Platform\nops/infra, ops/gitops, .gitlab-ci.yml"]:::branch
    end

    subgraph LEAVES["Leaves ▾\nФичи/тесты/скрипты"]
        L1["NX-03: issuance tests\ntests/issuance.Tests/*"]:::leaf
        L2["NX-04: order flow e2e\ntests/e2e-playwright/*order*"]:::leaf
        L3["Backoffice KYC slice\napps/backoffice/*"]:::leaf
        L4["CI job: spectral-lint\n.gitlab-ci.yml"]:::leaf
    end

    TRUNK --> B1 --> L1
    TRUNK --> B2 --> L2
    TRUNK --> B2 --> L3
    TRUNK --> B3 --> L4

    classDef trunk fill:#fdf6e3,stroke:#b58900,stroke-width:2px;
    classDef branch fill:#eee8d5,stroke:#657b83;
    classDef leaf fill:#ffffff,stroke:#93a1a1;
```

(адаптировано из V3‑отчёта, но теперь явно используется как canonical‑диаграмма)

### 1.4. Mermaid — gitflow vs Trunk/Branches/Leaves

```mermaid
graph LR
    subgraph Remote
      MAIN["main\n(prod trunk)"]:::trunk
      DEV["develop\n(future dev trunk)"]:::trunk
      INTEG["infra.defis.deploy\n(integration/pre-develop)"]:::branch
    end

    subgraph FeatureWork["Feature work (Leaves)"]
      F1["feature/NX-03-issuance-tests"]:::leaf
      F2["feature/NX-04-registry-flow"]:::leaf
      F3["feature/NX-05-identity-baseline"]:::leaf
    end

    MAIN --> DEV
    DEV --> INTEG

    INTEG --> F1 --> INTEG
    INTEG --> F2 --> INTEG
    INTEG --> F3 --> INTEG

    INTEG --> DEV
    DEV --> MAIN

    classDef trunk fill:#fdf6e3,stroke:#b58900,stroke-width:2px;
    classDef branch fill:#eee8d5,stroke:#268bd2;
    classDef leaf fill:#ffffff,stroke:#93a1a1;
```

*Смысл*: сейчас `infra.defis.deploy` — Branch‑уровень интеграции; feature‑ветки живут поверх неё; позже `develop` станет стабильным trunk, а `infra.defis.deploy` можно будет заархивировать как исторический integration‑слой.
 
---

## Section 2. NX‑00 meta‑tasks (до NX‑01..NX‑08)

Ниже — 5 NX‑00 тасков. Предполагается, что сами MD‑файлы `tasks/NX-00-*.md` будут лежать внутри `repositories/customer-gitlab/ois-cfa/tasks/`, но оперировать они могут и корневым `AGENTS.md`.

### Таблица NX‑00

| NX-00-ID                                   | Target location                                                                                                                                                                      | Goal                                                                                                                  | Steps (3–7)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Done-when (3–5 DoD)                                                                                                                                                                                                                                                                                                                     | Agent-friendly?                                                                                                                       |     |                                                                                                                                         |                                                                                                                                                                                                                                      |                                                                                                                          |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | --- | --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
| **NX-00-01** TLA-core                      | - `repositories/customer-gitlab/ois-cfa/docs/context/TREES-LEAVES-AGENTS-OIS.md` (новый)  - `repositories/customer-gitlab/ois-cfa/docs/context/PROJECT-CONTEXT.md` (обновить ссылку) | Зафиксировать модель Trunk/Branches/Leaves для `ois-cfa` + UK1 как отдельный doc и связать с контекстом.              | • Создать `TREES-LEAVES-AGENTS-OIS.md` с определениями уровней, таблицей (как в Section 1.2) и двумя Mermaid‑диаграммами из Section 1.3–1.4.<br>• В `PROJECT-CONTEXT.md` добавить короткий блок «Текущее состояние (infra.defis.deploy + UK1)» с ссылкой на TLA‑doc.  <br>• Указать, что `infra.defis.deploy` — integration/pre‑develop branch, а не trunk.                                                                                                                                                                                                                                       | • Файл `TREES-LEAVES-AGENTS-OIS.md` существует, проверен на Markdown‑валидность.<br>• В нём есть таблица уровней и две Mermaid‑диаграммы, копируемые без правок.<br>• `PROJECT-CONTEXT.md` ссылается на этот файл и кратко описывает роль `infra.defis.deploy` и UK1.  <br>• В tasks/NX‑00‑01‑*.md зафиксирован статус и ссылка на doc. | **Partial** — агент может сгенерировать doc и диаграммы, но финальную формулировку trunk/risks должен проверить человек.              |     |                                                                                                                                         |                                                                                                                                                                                                                                      |                                                                                                                          |
| **NX-00-02** AGENTS-sync                   | - monorepo root: `AGENTS.md`  - symlink `CLAUDE.md` (только обновить target)                                                                                                         | Встроить T/B/L‑модель и правила агентов в глобальный AGENTS, чтобы все агенты читали единый каркас.                   | • В `AGENTS.md` добавить раздел `## Trees / Branches / Leaves (Cifra RWA monorepo)` и под-раздел `### Gitflow & Branch responsibility` по шаблону из Section 4.  <br>• Добавить блок «Rules for all AI agents» (из Section 4) с явным запретом трогать trunk и топологию K8s/Fabric.  <br>• Убедиться, что CLAUDE‑symlink по‑прежнему указывает на тот же файл.                                                                                                                                                                                                                                   | • В `AGENTS.md` присутствует новый раздел с явными определениями Trunk/Branch/Leaf и ссылкой на `TREES-LEAVES-AGENTS-OIS.md`.<br>• Есть явный список правил для агентов, в т.ч. про Mermaid+таблицы и worktrees.<br>• CLAUDE.md остаётся symlink‑ом к AGENTS.md.                                                                        | **Yes** — агент может внести текстовый блок по шаблону; тебе останется только просмотреть и отредактировать формулировки.             |     |                                                                                                                                         |                                                                                                                                                                                                                                      |                                                                                                                          |
| **NX-00-03** Tasks & Context index         | - `repositories/customer-gitlab/ois-cfa/tasks/README.md` (новый) - `repositories/customer-gitlab/ois-cfa/docs/context/README.md` (новый/обновл.)                                     | Объяснить людям и агентам, как читать `tasks/NX-*` и `docs/context/*` из корня монорепы.                              | • В `tasks/README.md` описать назначение NX‑тасков, naming (`NX-01..08`, NX‑00‑*), правила ссылок на docs/context/WBS и что tasks — не SSOT по задачам (SSOT — внешняя система).  <br>• В `docs/context/README.md` описать состав контекстных файлов (PROJECT/FRONTEND/WBS/RULES/PROMPTS-MAP) и порядок чтения перед NX‑работой.  <br>• Добавить в оба README краткий How-to: «запуск из монорепы (eywa1), переход в submodule, выбор ветки/ветки‑фичи».                                                                                                                                          | • Оба README существуют и объясняют назначение папки, структуру и порядок чтения в 1–2 экранa текста.<br>• Из `tasks/NX-01..08` есть обратные ссылки на README (например, «см. общий README для правил использования NX»).<br>• В AGENTS.md есть ссылка на эти README как на входную точку.                                             | **Yes (~90%)** — идеальная работа для агента: собрать ссылки, сформулировать краткие инструкции, ты только проверяешь корректность.   |     |                                                                                                                                         |                                                                                                                                                                                                                                      |                                                                                                                          |
| **NX-00-04** Gitflow & worktrees           | - `repositories/customer-gitlab/ois-cfa/docs/context/GITFLOW-AND-WORKTREES.md` (новый)                                                                                               | Задокументировать gitflow (main/develop/infra.defis.deploy/tasks/feature) и физическую схему worktrees (macOS/eywa1). | • Свести договорённости по gitflow из чата/agreements в один документ: `main`=prod, `develop`=dev/pre‑prod, `tasks`=MD‑таски, `feature/*` от dev/infra.defis.deploy.  <br>• Явно описать, что **до появления стабильного `develop`** роль dev‑trunk выполняет `infra.defis.deploy`.  <br>• Описать pattern worktrees: `repositories/customer-gitlab/ois-cfa` (infra.defis.deploy) + `../wt__ois-cfa__infra`, `../wt__ois-cfa__deploy`, `../wt__ois-cfa__main` и как ими пользоваться на eywa1/macOS. <br>• Вставить маленькую Mermaid‑диаграмму (см. Section 3) с отображением веток и worktrees. | • Документ существует, содержит схему веток, пример команд (`git checkout -b feature/NX-03... infra.defis.deploy`) и Mermaid‑диаграмму.<br>• В `TREES-LEAVES-AGENTS-OIS.md` и `AGENTS.md` есть ссылка на этот doc как на источник правды по веткам/worktrees.<br>• В tasks/NX‑* нет противоречащих указаний по веткам.                  | **Partial** — текст и диаграмму может собрать агент, но стратегические формулировки и запреты лучше, чтобы финально проверил человек. |     |                                                                                                                                         |                                                                                                                                                                                                                                      |                                                                                                                          |
| **NX-00-05** WBS/OIS + NX + Tree alignment | - `repositories/customer-gitlab/ois-cfa/docs/context/WBS-OIS.md` - `repositories/customer-gitlab/ois-cfa/tasks/NX-01..NX-08-*.md`                                                    | Свести WBS‑OIS, NX‑таски и Tree‑уровни (Trunk/Branch/Leaf), явно пометить уровень и окружение для каждого NX.         | • В `WBS-OIS.md` добавить колонку/список «Tree level» для Milestones M1..M5 и NX‑тасков (M1=M1Trunk/Branch, NX‑01=Trunk/Branch, NX‑07/08=в основном Leaf).  <br>• В каждом `tasks/NX-0X-*` добавить блок frontmatter/таблицу с полем `tree_level: trunk                                                                                                                                                                                                                                                                                                                                           | branch                                                                                                                                                                                                                                                                                                                                  | leaf`и`target_env: dev                                                                                                                | UK1 | k8s`.  <br>• Обновить описание NX‑задач так, чтобы было видно, откуда ветвиться и какой минимум DoD по окружениям (локально, UK1, k8s). | • WBS‑OIS явно показывает, какие NX относятся к Trunk/Branch/Leaf, и это согласовано с этим документом.<br>• В каждом NX‑файле есть level/env‑поля.<br>• AGENTS/TLA doc отсылают к WBS‑OIS как к канонической матрице NX↔Tree↔Track. | **Yes (~70%)** — агент может разнести поля и таблицы; тебе нужно будет подтвердить уровни и окружения для спорных задач. |

---

## Section 3. Как NX‑00 связаны с NX‑01..NX‑08 и ветками/worktrees

### 3.1. Откуда выполнять NX‑00 на eywa1 (ветки и worktrees)

**Контекст работы:**

* Monorepo root на eywa1: `/home/user/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets` (ветка `main`).
* Submodule `ois-cfa` в монорепе: `repositories/customer-gitlab/ois-cfa` — **основной worktree на ветке `infra.defis.deploy`**.
* Доп. worktrees:
  `../wt__ois-cfa__infra` (ветка `infra`),
  `../wt__ois-cfa__deploy` (ветка `deploy`),
  `../wt__ois-cfa__main` (ветка `main`).

**Рекомендация:**

* Все NX‑00, NX‑01..NX‑08, пока нет `develop`, выполняем **в `ois-cfa`@`infra.defis.deploy`** (основной worktree в submodule), а монорепо‑root@`main` — для обновлений AGENTS/manifest.

### 3.2. Где ветвиться для NX‑01..NX‑08 и куда мержить

1. **Пока `develop` не заведен / не стабилен**:

   * Для кода в `ois-cfa`:
     `cd repositories/customer-gitlab/ois-cfa` → `git checkout infra.defis.deploy` → `git pull` → `git checkout -b feature/NX-03-issuance-tests`.
   * Все NX‑feature‑ветки живут *от* `infra.defis.deploy`, туда же и мержатся через MR.

2. **После стабилизации (`NX‑02/03/06` зелёные, CI‑gate есть)**:

   * Создаём `develop` от `infra.defis.deploy` (однократно).
   * Дальше feature‑ветки идут уже от `develop`.
   * `infra.defis.deploy` тегируем и кладём в ARCHIVE как «infra+deploy merge snapshot».

3. **Мерж‑путь** (после появления `develop`):
   `feature/NX-*` → `develop` (MR, CI, Playwright/Smoke) → `main` (когда готов релиз). `tasks` остаётся только как ветка с MD‑тасками, от неё **никогда не ветвимся для кода**.

4. **Моно‑репо root**:

   * Для NX‑00‑02 (AGENTS) и других общих docs работаем из root@`main`, но **не трогаем submodules из root‑коммитов**, пока не закоммитили изменения в самих submodules (`ois-cfa`).

### 3.3. Branch/Worktree usage guide (для агентов)

(то, что можно почти дословно кидать в AGENTS/TLA)

1. **Всегда стартуй из монорепы**: `prj_Cifra-rwa-exachange-assets@main`. Перед началом работы прочитай `AGENTS.md` и `docs/context/PROJECT-CONTEXT.md`.
2. **Для кода/доков в `ois-cfa` используй только основной worktree**: `repositories/customer-gitlab/ois-cfa` на ветке `infra.defis.deploy` (пока нет `develop`). Worktrees `wt__ois-cfa__*` — только как read‑only для сравнения/чтения старых веток.
3. **Feature‑ветки создавай только от dev‑trunk**:

   * до появления `develop` — от `infra.defis.deploy`,
   * после — от `develop`. Никогда не ветвись от `tasks`.
4. **NX‑00‑01..05 должны быть выполнены до любых NX‑01..08‑изменений кода**: пока T/B/L‑doc, AGENTS‑rules, README для tasks/docs и gitflow/worktrees‑doc не готовы, feature‑ветки для NX‑01..08 лучше не открывать.
5. **Trunk/Branch/Leaf mapping обязателен**: для любой задачи в `tasks/NX-*` смотри `tree_level` и `target_env`. Если task помечен как `trunk` — не вноси кодовые изменения без явного человеческого ревью/подтверждения.
6. **Работа с worktrees**: не создавай новые worktrees и не меняй существующие имена; паттерн `wt__{repo}__{branch}` считаем фиксированным. Если нужно, просто `cd ../wt__ois-cfa__main` для чтения кода `main`.
7. **CI/UK1‑верификация**: перед merge любой feature‑ветки в `infra.defis.deploy`/`develop` для NX‑02/03/04/05/06 прогоняй минимум `dotnet test` + `npm test` + Playwright‑smoke против UK1.
8. **Никогда не пушь изменения trunk‑файлов напрямую в `main`**: любые правки AGENTS, contracts, манивестов, security/NFR docs — только через MR (даже если формально работаешь один).

### 3.4. Mermaid — ветки vs worktrees

```mermaid
graph TD
    ROOT["prj_Cifra-rwa-exachange-assets\n(monorepo root @ main)"]:::trunk

    SUB["repositories/customer-gitlab/ois-cfa\nbranch infra.defis.deploy\n(main worktree)"]:::branch

    WTINFRA["../wt__ois-cfa__infra\nbranch infra (read-only)"]:::branch
    WTDEP["../wt__ois-cfa__deploy\nbranch deploy (read-only)"]:::branch
    WTMAIN["../wt__ois-cfa__main\nbranch main (read-only)"]:::trunk

    ROOT --> SUB
    SUB --> WTINFRA
    SUB --> WTDEP
    SUB --> WTMAIN

    classDef trunk fill:#fdf6e3,stroke:#b58900,stroke-width:2px;
    classDef branch fill:#eee8d5,stroke:#268bd2;
```

---

## Section 4. Обновления AGENTS.md / правила

### 4.1. «Patch‑like» предложения по структуре AGENTS.md

Отталкиваясь от текущего `AGENTS.md` (правила именования агентов, манифесты, workflow, repo‑structure, people/roles и т.п.)  — предлагаю добавить:

1. **Новый раздел после блока “Repo-local Addendum (Cifra-RWA Exchange Assets)”**:

   ```md
   ## Trees / Branches / Leaves (Cifra RWA monorepo)

   В этом проекте все изменения делятся на три уровня: Trunk, Branches, Leaves.

   - **Trunk** — архитектура, контракты, NFR, gitflow rules, ключевые runbook’и по окружениям (UK1/CFA1/K8s).
   - **Branches** — доменные сервисы, gateway, ops/infra skeleton, интеграционные ветки (`infra.defis.deploy`, `release/*`, `hotfix/*`).
   - **Leaves** — фичи, UI‑слайсы, тесты, небольшие скрипты и конфиги.

   Подробности и примеры: `repositories/customer-gitlab/ois-cfa/docs/context/TREES-LEAVES-AGENTS-OIS.md`.
   ```

2. **Подраздел “Gitflow & Branch responsibility” (внутри этого же блока):**

   ```md
   ### Gitflow & Branch responsibility

   - `main` — prod trunk; только стабильный, проверенный код и контракты.
   - `develop` — будущий dev trunk; под него будут деплоиться Dev/Pre-Prod контуры.
   - `infra.defis.deploy` — временная integration/pre-develop ветка для сведённых infra+deploy+UK1.
   - `tasks` — только `.md`-файлы задач для агентов, **не база для feature-веток**.
   - `feature/*` — короткоживущие ветки под конкретные задачи (часто NX-*), всегда от `infra.defis.deploy` или `develop`.

   Любые изменения в Trunk-ветках (`main`, `develop`) происходят только через MR с human-review.
   ```

3. **Добавить отдельный раздел ближе к концу:**

   ```md
   ## Worktrees layout (ois-cfa)

   На macOS и eywa1 используем git worktrees для submodule `ois-cfa`:

   - Основной worktree (активная работа): `repositories/customer-gitlab/ois-cfa` @ `infra.defis.deploy`.
   - Дополнительные (read-only):  
     - `../wt__ois-cfa__infra` @ `infra`  
     - `../wt__ois-cfa__deploy` @ `deploy`  
     - `../wt__ois-cfa__main` @ `main`

   Правила:
   - не создавайте новые worktrees без явного запроса человека;
   - не переключайте ветку в существующих worktrees;
   - для кода и docs используйте только основной worktree.
   ```

4. **В конец файла добавить блок “Rules for all AI agents” (см. следующий пункт).**

### 4.2. “Rules for all AI agents” — готовый список

Эти bullets можно вставить в `AGENTS.md` как новый раздел:

```md
## Rules for all AI agents

1. **Всегда определяй уровень задачи: Trunk / Branch / Leaf.**
   - Если не можешь однозначно классифицировать — относись к задаче как к Trunk и проси подтверждения человека.

2. **Trunk (архитектура, контракты, NFR, gitflow, ключевые runbook’и):**
   - Не меняй файлы trunk-уровня (`AGENTS.md`, манифесты, `WBS-OIS.md`, `packages/contracts/*`, `packages/domain/*`, `docs/*security*`, `docs/dlt/*`) без явной человеческой инструкции.
   - Любые правки trunk-доков — только через MR и с понятным changelog’ом.

3. **Branches (сервисы, gateway, ops skeleton, integration branches):**
   - Работай в ветках `infra.defis.deploy`, `develop`, `release/*` только маленькими, изолированными diff’ами.
   - Не меняй топологию K8s/Fabric, GitOps-структуру и критические CI stages (deploy, migrations) без прямого указания человека.

4. **Leaves (фичи, UI, тесты, скрипты, мелкие YAML/CI-jobs):**
   - Это твоя основная зона. Можно:
     - добавлять/расширять Playwright-/unit-/integration-тесты;
     - писать небольшие UI-слайсы в порталах;
     - добавлять spec-lint/coverage jobs в CI;
     - править локальные скрипты/README.
   - Всегда добавляй/обновляй тесты и запускай минимальный smoke (dotnet test, npm test, Playwright, где применимо).

5. **Mermaid + таблицы обязательны для структурных ответов.**
   - Любой ответ по архитектуре, gitflow, инфраструктуре или Trees/Leaves должен содержать минимум:
     - одну Mermaid-диаграмму процесса/структуры;
     - одну компактную таблицу с уровнями/ветками/рисками.

6. **Gitflow и ветки:**
   - Не создавай/не переименовывай Trunk-ветки (`main`, `develop`).
   - Не ветвись от `tasks` — только от `infra.defis.deploy` (пока нет `develop`) или от `develop` после его появления.
   - Имена feature-веток: `feature/NX-0X-short-name` либо `feature/TICKET-ID-short-name`.

7. **Worktrees (ois-cfa):**
   - Используй `repositories/customer-gitlab/ois-cfa` как основной worktree (`infra.defis.deploy`).
   - `../wt__ois-cfa__infra`, `../wt__ois-cfa__deploy`, `../wt__ois-cfa__main` — только для чтения.
   - Не создавай новые worktrees и не меняй их ветки.

8. **Окружения:**
   - UK1 — reference dev/demo env; перед любым merge в Trunk/Branch обязательно прогоняй smoke-тесты против UK1 (health + Playwright).
   - CFA1 и K8s-кластер — вторичные; изменения туда обсуждать отдельно.

9. **Безопасность и регуляторика:**
   - Не ослабляй настройки Postfix/OpenDKIM, Cloudflare, Keycloak-политик, TLS и т.п.
   - Любые изменения в chaincode, DLT-топологии и security-settings считались Trunk-уровнем и требуют ручного контроля.

10. **Источники правды:**
    - По коду/архитектуре: `ois-cfa`@`infra.defis.deploy` + `docs/context/*`.
    - По задачам: YouGile/Jira и `tasks/NX-*` (описание среза, а не полный backlog).
    - По решениям: `memory-bank/*` ссылается из docs, но сам по себе не является контрактом.
```

---

## Section 5. Handoff для других агентов

Как это использовать в zero‑shot режиме.

1. **Порядок чтения**:

   1. `AGENTS.md` (особенно разделы про Trees/Branches/Leaves и “Rules for all AI agents”);
   2. `docs/context/PROJECT-CONTEXT.md` (общая архитектура);
   3. `docs/context/TREES-LEAVES-AGENTS-OIS.md` (детали Trunk/Branch/Leaf);
   4. `docs/context/WBS-OIS.md` (Tracks/Milestones + NX‑таски);
   5. нужный `tasks/NX-*`;
   6. для git/infra — `docs/context/GITFLOW-AND-WORKTREES.md`.

2. **Как решать, Trunk/Branch/Leaf ли конкретная задача:**

   * затрагивает ли она контракты, NFR, gitflow, security/Fabric/Keycloak/UK1‑runbook? → **Trunk**;
   * меняет ли структуру сервисов/gateway/ops/CI или интеграционную ветку (`infra.defis.deploy`, `release/*`)? → **Branch**;
   * добавляет тест/спеку/UI‑фрагмент/скрипт/маленький CI‑job? → **Leaf**.

3. **Когда нужно остановиться и звать человека:**

   * любая задача, помеченная в NX/WBS как `tree_level: trunk`;
   * изменения в `packages/contracts`, `packages/domain`, `docs/*security*`, `docs/dlt/*`, chaincode или K8s‑манифесты, влияющие на топологию;
   * изменения в gitflow (ветки main/develop/tasks/release/hotfix);
   * любые сомнения в регуляторке (KYC/KYB, 5625‑У, AML/санкции).

4. **Как использовать NX‑00/NX‑0X:**

   * сначала проверить статус NX‑00‑01..05; если что-то из этого не выполнено, предложить человеку начать именно с NX‑00;
   * для NX‑01..08 работать строго из соответствующей feature‑ветки `feature/NX-0X-*`, следуя описанным там DoD и `Agent-friendly` статусу.

5. **Документировать результат:**

   * любые существенные выводы или цепочки действий фиксировать в `memory-bank` с правильным именованием и ссылкой из соответствующего NX‑task’а или docs‑файла;
   * не создавать дубликаты docs: обновлять существующие, соблюдая frontmatter и versioning‑правила.

6. **Для сложных задач (Trunk/Branch) всегда добавлять:**

   * хотя бы один Mermaid с процессом или структурой;
   * хотя бы одну таблицу с уровнями/рисками/ветками;
   * короткий чек‑лист DoD.

7. **По git/CI/infra действовать консервативно:**

   * не пытаться «улучшить» текущий K8s/Timeweb/CI beyond NX‑06 без явного запроса;
   * в спорных местах оставлять предложения в виде комментариев/маркдаун‑заметок, а не применять автоматически.

---

## Final table — компактное резюме решений

| Area                   | Decision or rule                                                                                                                 | Your recommendation                                                                                                              |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Tree model (T/B/L)     | Trunk = архитектура/контракты/NFR/gitflow/runbooks; Branch = сервисы+infra‑каркас+integration‑ветки; Leaves = фичи/тесты/скрипты | Зафиксировать модель в `TREES-LEAVES-AGENTS-OIS.md`, AGENTS и WBS‑OIS; использовать таблицу и Mermaid из этого ответа как канон. |
| Gitflow & branches     | `main`/`develop` = trunk; `infra.defis.deploy` = integration/pre‑develop; `tasks` = md‑таски; feature‑ветки от dev‑trunk         | Пока нет `develop`, ветвиться от `infra.defis.deploy`; после стабилизации — от `develop`; `tasks` не использовать для кода.      |
| Worktrees              | Один активный worktree `ois-cfa`@`infra.defis.deploy`; `wt__ois-cfa__*` — read‑only                                              | Жёстко задокументировать layout и запретить агентам создание/изменение worktrees.                                                |
| NX‑00 meta‑tasks       | Перед NX‑01..08 нужны NX‑00‑01..05 (TLA‑doc, AGENTS, README tasks/docs, gitflow+worktrees, WBS+NX+Tree)                          | Завести `tasks/NX-00-*.md` и выполнить их в предложенном порядке, из монорепы@main + `ois-cfa`@`infra.defis.deploy`.             |
| NX‑01..NX‑08 execution | Работать через feature/NX‑ветки с привязкой к Tree‑уровню и окружению                                                            | В каждом NX‑task явно прописать `tree_level` и `target_env`, DoD и Agent-friendly; не выполнять Trunk‑изменения без ревью.       |
| AGENTS.md              | Сейчас описывает общие правила, но без T/B/L и worktrees                                                                         | Добавить разделы Trees/Branches/Leaves, Gitflow & Branch responsibility, Worktrees layout и список “Rules for all AI agents”.    |
| Environments & UK1     | UK1 — основной reference dev/demo, CFA1/K8s вторичны                                                                             | В каждом структурном doc и NX‑task явным текстом указывать UK1 как дефолт для smoke/E2E; не ломать UK1 без явного запроса.       |
| Agent safety & scope   | Риск, что агенты полезут в Trunk/infra/chaincode                                                                                 | Жёстко ограничить scope через AGENTS: разрешать агентам преимущественно Leaf‑работу, Branch/Trunk — только через MR и ревью.     |

Если хочешь, следующим шагом могу помочь прямо разметить скелеты файлов `NX-00-01..05` и TLA‑doc в формате, который можно сразу положить в `tasks/` и `docs/context/`.

```

`aggregated-gpt5pro-talks/20251118-0905-feedback-gpt5pro-step4-all.md`:

```md
# Transcription
```transcription
=3m6s=
Слушай, в целом неплохо. Единственное, нужно учитывать, что есть Monorepo, который ты запустил, а в ней через сабмодули репозитории, но по факту всё, конечно, сводится к одному главному репозиторию OIS-CFA. Понятно, что вся разработка и всё остальное будет там происходить, но важно понимать: эта Monorepo — это моя личная, Alex A, да? От OIS-CFA тут я типа по факту, хоть я и такой AI integration engineer, судя по тому, какой мне сейчас этот Александр O. OIS-CFA закинул отчёт, он типа ожидает от меня быть как разработчика.

Мне это немножко посмешило, ну тем, что я всё время в стартапах работал, тут какой-то enterprise. Только я о нём хорошо отозвался, сейчас я привожу, как я для друга отозвался, который когда-то раньше работал с кастомер Юрия, да? И в целом понимает кухню. Ну короче, ладно, что мне, буду слишком ему делать эти отчёты, хуй с ним. То есть такая, как сказать, ещё одна мета работа, что конечно вручную... ну я там прокомментировал, как делать это, вручную не вручную.

Так, почему я говорю? Я говорю, потому что моя монорепа, если документы фигурируют к этой репе, та репа из OIS-CFA, она типа условно team репа, да? Она не должна знать о монорепе моей ничего, её отсылок не должно быть. То есть вот этот подход с манифестами, как у меня сейчас сделан, там people и прочее, естественно, там не нужно вот такую внутрянку давать им.

Ну, подход к trunk-branch-leaf, да? Ствол, ветви, листья — можно проецировать вот этот мой JSON подход вместо вот этих файликов, например, project_context.md и tree_leaves_agents.md. Выглядит так, что можно какой-то единый роутер сделать. Там, конечно, project_context будет, но вот какой-то типа project_manifest или как-то его называть, там JSON, да? И вот его юзать, и к нему, может быть, тоже привязаться как-то линтерами, проверять что-то, там, что, например, что-то можно проверять.

Ну, а посмотри, ещё я подумал, что хорошо было бы ввести, как сказать, систему тегов — YAML frontmatter в Markdown файлах, чтобы они были структурированы и к ним можно было как-то привязаться. Как-то так.

=2m4s=
Смотри, тут второй вопрос. Я вот сейчас смотрю "Мермейд архитектуры как дерево" и вспомнил, что есть такой подход — репоскан. Я скидывал там репозиторий-пример, типа как вот по каким принципам он разбирается, но, по-моему, там недоволен был до конца результатом.

Я просто могу показать, как на другом проекте всё отсканировано. Грубо говоря, это снимок репозитория. Как знаешь, есть инструменты популярные: DeepWiki, ну типа анализаторы, код-вики, типа у Vglada, DeepWiki у этих, кто делает.

Потом получается, вот эта репоскан от Shotgun, получается там используется CFO, домены, ну в принципе всё как у нас. Просто вот эта идея — что отобразить в едином JSON-файле, который эффективный, там определённое количество токенов есть и как у агентов всегда вот карта такая, да.

Надо, наверное, сделать, оформить это вот как-то таким образом, как ты считаешь? Может быть, даже с концептом, с уровнями Trunk, Branches, Leaves, но я не уверен. Может быть, как лучше ты сам посмотри, подумай. Ну, однозначно, может быть, это отдельный массивчик, там не всё вокруг этого уровня идёт. Я имею в виду отдельный массивчик, вот как там у Reposcan уже хорошо, да, классика, да, а потом ещё сделать, типа, что за что является Trunk, Branch, Leaves там и так далее.

Плюс я ещё высказывал идеи, как я вижу. Вот в задачах там описываются разные детали, типа так. Я вот сейчас, кстати, читаю твои задачи, я по ним отдельные ещё аудио надиктую.

=1m11s=
Я вот еще попутно читаю. Я так понимаю, видишь, как у меня в моем главном манифесте есть индивидуальные мои особенности, чтобы агент знал, какими агентами пользоваться. Но это такой верхнеуровневый советник, а те агенты, которые дуэры, понятно, им эти детали не нужны. Но у них тоже может быть какой-то гид, гидфайл, манифест, да, и так далее. И все эти манифесты они схлопываются, ну, кросс-референс должны быть.

Я услышал у тебя идею по поводу индексов для всего, для тасков и прочее. Эти индексы могут быть как Markdown, так и на самом деле JSON.

Я тебе еще позже скину интересный инструмент, код машин. Я с ним сделал прямо хороший софт, но у него особенность, что ему накидываешь как бы задачи, он их молотит. Ну, правда, я ему накидал глобальную задачу сделать приложение, он делал ее вообще 10 часов. Может быть, если поштучно ему давать задачу, будет легче, я тебе потом об этом расскажу.

Я просто знаю об этом, но, наверное, ничего тут делать не надо. Я дальше читаю таски и даю тебе по ним фидбэк.

=27s=
По поводу еще раз монорепы и вот этой основной репы с кодом, да, OIS-CFA, я даже размышляю над тем, чтобы все-таки агенты запускались прямо не из монорепы, а из той репы. И тогда организовать там тоже свои манифесты, ну как ты уже понял.

Вот, свой репоскан, и тогда, наверное, будет эффективнее. И там свой запуск.

=7m18s=
Еще у меня возникла такая идея. Вот у нас есть продвинутый инструмент CloudCode, у него есть внутри — я тебе скину там отдельный другой отчет L1 Pro, точнее GPT-5 Pro — о том, что этот CloudCode эволюционировал постепенно.

У него сначала были типовые задачи на тему, это команды типа были, да, типа там слэш-команд, и агент просто берет делать. Потом у него была такая история, что были сабагенты у CloudCode, но у Codex их не было. Просто знать об этом, да, я в основном буду, конечно, в Codex запускать, но такая обратная совместимость ничем не помешает и даже все-таки поможет по поводу структурирования ролей. Сейчас я объясню, что я имею в виду.

Так вот, вернусь к CloudCode, и у него раньше было taskTools.agent, где он отдавал как бы будущий основной ран агента, да. Вот, получается, он может сам вызывать еще сабагентов, наделенных тем же контекстом — ну, не тем же контекстом, а тем же размером контекстного окна — которое может на выполнение каких-то делегирования задач. И он их выполнял в каком-то произвольном виде, но потом они добавили папочку Agents.

И ты можешь себе делать там backend-разработчик, evaluator, reviewer и тому подобное. То есть много ролей. И вот как бы один агент заканчивает, второй его артефакты проверяет или воспроизведенный код, там, тесты. Один, не знаю, агент там тесты проверяет. Они могут быть как по типам задач сформированные, так и по ролям, как, знаешь, там backend, архитектор, аудитор, frontend, ну и так далее, да.

Потом, то есть почему не организовать точно так же в папочке .code вот этих агентов, вот эти команды? Потом CloudCode пошел дальше, он сделал хуки. Это типа по каким-то определенным событиям, если какой-то тул вызывает, цеплять что-то дальше или делать какое-то действие скриптовое через хук.

Потом еще CloudCode пошел дальше. Они придумали, что у них было — а, ну MCP и так было, и MCP есть, да. То есть можно в этих у агентов и у команд выдавать, какие они могут типы инструментов использовать, какие могут MCP использовать, tool calls и так далее.

Потом появилась вот эта комбинация команды, агенты, MCP и хуки в виде такого сборки плагина, да. Вот, и написывалась, а потом они еще придумали skills, как работать с документами, docx и там Excel, как работать и так далее, и так далее.

Я вот думаю, что хорошо бы вот эти принципы, идентификацию, как вот делать типовые задачи типовыми ролями, с типовыми какими-то хуками, с типовыми MCP, да. Вот, например, очень часто, как я с тобой и советуюсь, я использую MCP GPT-5 Oracle. То есть это как бы отдельный агент, у которого tool call вот этот Oracle, он наделен какими-то определенными смыслами и будет делать.

Конечно, этот агент не будет, наверное, так использоваться Codex, потому что Codex не поддерживает такие функции. Но CloudCode или другие bash, CLI, SSH и agents, да, могут поддерживать. Можно оставить задел, а для Codex просто прочитай вот этот файлик через собачку и как бы вот следуй вот этому. То есть и для порядка, то есть будут все вот эти папочки.

Это не то, что замена всему предыдущему, что мы говорим. Это вообще просто лишь дополнение моего предложения, да. Как использовать вот этот стандартный функционал, где мы описываем вот эти все там роли агентов. И в голове у нас будет полезно, какие у нас типовые задачи. Вот у нас есть задача номер NX01, NX02, NX03, NX001 и так далее. И можно вот для вот этой задачи нужны вот такие-то вот такие-то там агенты.

Не знаю, будет ли это усложнением или нет, но такой паттерн тоже бы стоило обсудить. Тут есть некоторое, как сказать, не противоречие, а вопрос и дискуссия.

Есть еще отдельный инструмент CloudMachine, который вообще классно делает свою работу. Единожды ты скормил ему доки, он проанализировал все глубоко, выдал у тебя какие-то дополнения, вопросы, противоречия. Ты ему ответил, и дальше он молотит несколько часов. Он там сам организовывает всех сам агентов, все как нужно. Это я тебе тоже отдельно покажу.

То есть прямо я тут много затрагиваю разных вопросов. Мне нужно еще собрать тебе контекст, чтобы ты качественно и грамотно на него ответил на эти все вопросы.

То есть, итого, подытожим. Мне нужно собрать для тебя репосказанный контекст, собрать по поводу CloudCode функции организации в папочке .code и собрать CloudMachine контекст, чтобы ты понял, о чем там основные направления, такие нарративы инструментов.

То есть репосказанный ничего не исключает. А вот использование CloudCode вот этих sub-agents или CloudMachine, они как будто друг друга перекрывают. Но это, наверное, хуже не будет, если мы хотя бы просто для себя структурируем в папочке .code вот это вот все через agents, плагины и так далее.

Будем ли мы это группировать по доменам, по микросервисам, по, не знаю, там, Kafka-специалистам, или, может быть, там, ну, какие у нас там технологии, Fabric-специалист, да, вокруг него там какие-то моменты. У нас же и домены, и сервисы, и технологии есть.

А вот этот CloudMachine выглядит так, что работает офигенно, и оркестрировать пошагово агентов просто, во-первых, непросто и сложно. И самый, наверное, life-changing и killer tool — это CloudMachine.

Единственное, когда я имел опыт с ним, когда он делал мне какие-то задачи, я ему давал очень верхние уровни, он делал большой PRD, и он делал по PRD-документам. Мне нужно, наверное, сделать отдельный дополнительный ресерч на тему, можно ли, если в GitHub issues там такие упоминания, использовать его поштучно-позадачно.

Вот как мой подход — это позадачно двигаться. То есть одна задача, вторая, третья, и там сверять. И чтобы он не over-engineer, а делал только то, что нужно, и не делал это 7 часов. Естественно, эту задачу там с агентом в ручках сделать, ну типа там, не знаю, до часа, а тут он будет что-то делать 7 часов, и эти over-engineer и прочее.

То есть вот его контроль и маленькие кусочки, вот это надо, короче, разобраться. То есть все проанализировать, я прикину контекст по нему и дам.
```

`aggregated-gpt5pro-talks/20251118-1321-gpt5pro-step5-cohere-json-markdown.gpt5p.md`:

```md

# Prompt
You are Oracle, a focused one-shot problem solver. Emphasize direct answers, cite any files referenced, and clearly note when the search tool was used.  You are GPT‑5 Pro acting as a senior meta‑architect for my AI‑assisted workspace.  Context (must internalise before answering): - I have a personal mono‑repo (`prj_Cifra-rwa-exachange-assets`) with manifests, memory-bank, and submodules like `ois-cfa` (customer repo). - `ois-cfa` is the *team* repo where most of the domain code lives; the mono‑repo is **my control plane** (manifests, AGENTS, workflows, AI experiments) and must not leak into customer repos. - I already have several of your previous audits for `ois-cfa` and infra (V1/V2/V3/V4), including Trunk/Branch/Leaf and NX‑00..NX‑08 ideas. - Now I want to step back and design a *global* framework for three things:   1) **RepoScan**: how to keep up‑to‑date, machine‑readable JSON snapshots of repos (code structure, domains, Trunk/Branch/Leaf mapping) for agents;   2) **Agents & Structures**: how to describe agents, their roles and rules (AGENTS.md, manifests, Trees/Branches/Leaves) in a reusable, JSON+Markdown way;   3) **CodeMachine**: how to orchestrate agents + RepoScan + manifests to actually run coding workflows (Codex/Claude/GPT‑5) on macOS/eywa1.  I have attached: - `c2p_20251118-0905-context-reposcan-agents-structure-and-codemachine.txt`: aggregated context (my notes + transcripts) about these three topics; - `c2p_reposcan.txt`: code2prompt snapshot of the current RepoScan approach, examples, and prior experiments; - `c2p_agents-structures.txt`: snapshot of how I currently describe agents, AGENTS.md patterns, Trees/Leaves/Agents, etc.; - `c2p_codemachine.txt`: snapshot of my early CodeMachine ideas (agent orchestrator, pipelines, map/reduce over tasks); - `c2p_ois-cfa.txt`: snapshot of the `ois-cfa` repo (branch `infra.defis.deploy`), to ground examples in a concrete codebase; - `20251116-1603-gpt5pro-audit-feedback-review.gpt5p.md`, `20251117-1747/1748-gpt5pro-*.gpt5p.md`, `20251117-1927-gpt5pro-step3-all-together-after-audit-feedback.gpt5p.md`, `20251117-2103-gpt5pro-step4-all-and-nextsteps.gpt5p.md`, `20251118-0905-feedback-gpt5pro-step4-all.md`: previous GPT‑5 audits + my spoken feedback (especially about Trunk/Branches/Leaves, Mermaid, NX‑00, mono‑repo vs team repo boundaries).  **High-level ask:**  Design a **coherent, JSON+Markdown based framework** that ties together: - RepoScan snapshots (JSON) of repos like `ois-cfa`; - AGENTS/agent‑structures (Markdown + YAML frontmatter + JSON indices); - CodeMachine orchestration (how agents consume RepoScan + manifests + tasks and operate on worktrees on macOS/eywa1).  Think of it as a “Spec‑Driven Dev + Agent‑Driven Dev OS” for my workspace.  What I need from you:  1) **Conceptual model (RepoScan + Agents + CodeMachine)**    - In Russian (B2‑English terms allowed), explain how you would conceptually split responsibilities between:      - RepoScan (what it produces; how often; for which repos; relation to Trunk/Branch/Leaf);      - Agent descriptors/AGENTS (how we describe agents, their capabilities and guardrails);      - CodeMachine (how it orchestrates agents over RepoScan + tasks + worktrees).    - Output 5–10 bullets that describe the “OS level” model.  2) **JSON schemas / structures (high‑level)**    - Propose high‑level JSON structures for three core artefacts:      1. `reposcan.json` (per repo);      2. `agents.json` or `agents.manifest.json` (per workspace/mono‑repo);      3. `codemachine.workflow.json` (per project or per target like `ois-cfa`).    - For each, define:      - required top‑level fields and their meaning;      - how to encode Trunk/Branch/Leaf in a way that is easy for agents to consume;      - how to reference real files/paths (e.g. `repositories/customer-gitlab/ois-cfa/...`).    - You don’t need to give full JSON Schema; focus on key fields and nesting.  3) **YAML frontmatter & tagging strategy for Markdown docs**    - Based on my feedback (I want YAML frontmatter + tags for everything), propose:      - a minimal, consistent frontmatter schema (keys like `type`, `sphere`, `topic`, `tags`, `level: [trunk|branch|leaf]`, etc.);      - tag vocabularies for RepoScan/Agents/CodeMachine/ois‑cfa so that we can later query/filter docs by these tags;      - rules for how RepoScan and CodeMachine should interpret these tags.    - Output as:      - example YAML blocks for 2–3 types of docs (AGENTS.md, project manifest, repo‑level context doc, NX‑task doc);      - short bullet rules “how agents should use these tags”.  4) **CodeMachine execution model (macOS + eywa1 + worktrees)**    - Using the description of worktrees and mono‑repo layout, describe how CodeMachine should:      - locate RepoScan snapshots and manifests;      - decide which worktree to operate on for a given task (e.g. `ois-cfa`@`infra.defis.deploy`, `wt__ois-cfa__infra`, etc.);      - orchestrate agents in a map/reduce way (e.g. RepoScan → GPT‑5 planning → Codex implementation → GPT‑5 review) while respecting Trunk/Branch/Leaf rules.    - Include 1–2 Mermaid diagrams for:      - CodeMachine high‑level pipeline (inputs → planning → execution → review → commit);      - how tasks flow between macOS and eywa1 (where planning happens, where code runs, where RepoScan is stored).  5) **Concrete next steps (1–2 weeks) to start implementing this framework**    - Given all the above and my existing mono‑repo (manifests, memory‑bank, AGENTS, ois‑cfa submodule), propose a **short, actionable plan** for the next 1–2 weeks:      - which JSON manifests to create first and what minimal fields to include;      - which docs to update with YAML frontmatter/Trunk‑Branch‑Leaf tags;      - how to wire the first version of CodeMachine (even if it’s just a set of scripts + small orchestrator).    - Output as a table: `Step` / `Area` / `What to implement` / `Why now` / `Agent-friendly?`.  Style & format: - Answer in Russian, senior‑engineer tone, B2‑English terms OK. - Structure your answer as:   - TL;DR (3–5 bullets),   - Section 1: Conceptual model,   - Section 2: JSON structures,   - Section 3: YAML frontmatter & tags,   - Section 4: CodeMachine execution model,   - Section 5: Next steps (table),   - Final compact table: `Area` / `Decision` / `Your recommendation`. - Do NOT restate all attached files; focus on synthesis and **executable** design.

# Output
TL;DR

* RepoScan = **C4+FS‑снимок репо + Trunk/Branch/Leaf‑метки**, лежит в монорепе (`.cifra/reposcan/*`), не в `ois-cfa`. Агентам он даёт карту кода и доменов.
* AGENTS/agents.manifest = **единый реестр людей/агентов/skills** с их зонами ответственности (Trunk/Branch/Leaf), разрешёнными репо/путями и движками (GPT‑5, Claude, Codex, CodeMachine sub‑agents).
* CodeMachine‑уровень = **workflow‑манифест per‑target (`codemachine.workflow.json`)**, который связывает: RepoScan → NX‑task → агенты → worktree (`wt__ois-cfa__…`) и запускает map/reduce‑пайплайн (planning → context → codegen → review → commit), опираясь на уже существующую модель CodeMachine CLI.
* Вся “магия” живёт в монорепе (`.cifra/*`, `.codemachine/*`), а `ois-cfa` остаётся чистым team‑репо (только код/документация клиента).
* Я использовал `file_search` по `c2p_reposcan`, `c2p_codemachine`, агентным брейнштормам и `gpt5p-ois-cfa.shtgn.reposcan.json`, чтобы заземлить структуру на реальные примеры.

---

## 1. Концептуальная модель (RepoScan + Agents + CodeMachine)

### 1.1. Разделение ответственности

1. **RepoScan (per‑repo snapshot)**
   *Что:* периодический JSON‑снимок репо (структура, домены, C4‑контексты/контейнеры, Trunk/Branch/Leaf‑карта), по образцу `…ois-cfa.shtgn.reposcan.json`. 
   *Где:* в монорепе, например `.cifra/reposcan/ois-cfa/infra.defis.deploy.reposcan.json` (путь к командному репо + ветка).
   *Когда:* по событию (`git pull` в worktree, значимый MR) или раз в день/спринт.
   *Связь с T/B/L:* каждый path/domain в RepoScan помечен `level: trunk|branch|leaf`; плюс глобальные правила `pattern → level`.

2. **Agents & Structures (AGENTS + agents.manifest.json)**
   *Что:* “паспорт” всех агентов (люди, GPT‑5, Claude, Codex, CodeMachine sub‑агенты) и их зон ответственности. Конфигурация похожа на `main.agents.js`/`sub.agents.js` в CodeMachine, но в JSON.
   *Где:* в монорепе:
   `AGENTS.md` (читаемый humans/LLM) + `.cifra/agents.manifest.json` (машиночитаемый индекс).
   *Связь с T/B/L:* у каждого агента есть `level_scope` (например, `["leaf"]` для Codex‑кодера, `["branch","leaf"]` для GPT‑5‑ревьюера) и `allowed_paths` по шаблонам.

3. **CodeMachine / Code OS (per‑target workflows)**
   *Что:* оркестратор, который по манифесту `codemachine.workflow.json` запускает последовательность шагов: планирование → Task breakdown → контекст → код → review → git‑commit → loop, как в стандартном CodeMachine workflow.
   *Где:* в монорепе: `.cifra/workflows/ois-cfa.codemachine.workflow.json` + runtime‑директория `.codemachine/` (под контролем монорепо, не субмодуля).
   *Связь с RepoScan/AGENTS:* workflow читает `reposcan.json` + `agents.manifest.json` + NX‑tasks‑манифест и для каждого шага выбирает:
   ‑ **какой агент**,
   ‑ **на каком уровне T/B/L** он может менять код,
   ‑ **в каком worktree/ветке** вносить изменения.

4. **Mono‑repo как “Control Plane”**
   *Mono‑repo* хранит всё “мета”: RepoScan, workflow‑манифесты, AGENTS, правила T/B/L, CodeMachine‑config; `ois-cfa` как субмодуль — только доменный код/доки, без `.codemachine` и `.cifra`. Это прямо следует из твоего требования не загрязнять customer‑репо инфраструктурой агентов.

5. **Trunk/Branch/Leaf как общий язык**
   *Docs:* через YAML frontmatter (`level: trunk|branch|leaf`).
   *RepoScan:* через `trunk_branch_leaf.rules/overrides`.
   *Agents:* через `level_scope`.
   *CodeMachine:* каждый шаг workflow и каждый task помечены `level`, и оркестратор тупо не даёт Leaf‑агенту лезть в Trunk‑файлы.

6. **NX‑tasks как API к коду**
   *NX‑серия (`tasks/NX-*.md` в `ois-cfa`) — это Leaf/Branch work items, ссылающиеся на Trunk‑доки (PROJECT‑CONTEXT, контракты, RepoScan) и управляемые CodeMachine как очередь задач.

7. **CodeMachine map/reduce поверх NX**
   *Map:* CodeMachine берёт `NX-0x` → бьёт на подзадачи/leaf‑tasks (tests, конфиги, мелкая логика) → параллелит для разных файлов/поддоменов.
   *Reduce:* собирает диффы, гоняет sanity‑check/тесты, и только после этого формирует MR/commit по правилам gitflow (всё — из монорепы, но коммиты вносятся внутри submodule‑worktree).

---

## 2. JSON‑структуры (high‑level)

### 2.1. `reposcan.json` (per‑repo, per‑branch)

**Назначение:** дать агентам “архитектурную карту” репо (C4 + директории + домены + T/B/L). Базируем на текущих `…ois-cfa.shtgn.reposcan.json`, дополняем слоями structure/domains/tbl.

**Предлагаемая структура (упрощённо):**

```jsonc
{
  "meta": {
    "project": "OIS-CFA",
    "repo": "repositories/customer-gitlab/ois-cfa",
    "branch": "infra.defis.deploy",
    "commit": "abc1234",
    "generated_at": "2025-11-18T10:25:34Z",
    "generator": "cifra-reposcan@shtgn-1.1",
    "version": "reposcan-1.0"
  },

  "c4": {
    "contexts": { "...": { "description": "...", "c4_level": "Context" } },
    "containers": { "...": { "name": "...", "technology": "...", "c4_level": "Container" } },
    "components": { /* опционально, если сканер умеет */ }
  },

  "structure": {
    "dirs": [
      {
        "path": "/",
        "entries": [
          { "name": "services", "kind": "dir", "level": "branch", "tags": ["backend", "dotnet"] },
          { "name": "apps", "kind": "dir", "level": "branch", "tags": ["frontend", "nextjs"] },
          { "name": "docs", "kind": "dir", "level": "trunk", "tags": ["docs", "architecture"] },
          { "name": "tests", "kind": "dir", "level": "leaf", "tags": ["tests"] }
        ]
      }
      // … можно детализировать глубже при необходимости
    ]
  },

  "domains": {
    "issuance": {
      "level": "branch",
      "paths": [
        "services/issuance/**",
        "packages/contracts/issuance.yaml",
        "tests/services/issuance.Tests/**"
      ],
      "c4_containers": ["issuance-service"]
    },
    "registry": {
      "level": "branch",
      "paths": ["services/registry/**", "packages/contracts/registry.yaml"]
    }
    // …
  },

  "docs": [
    {
      "id": "ois-cfa-project-context",
      "path": "docs/context/PROJECT-CONTEXT.md",
      "level": "trunk",
      "sphere": "architecture",
      "tags": ["context", "c4", "ois-cfa"]
    },
    {
      "id": "wbs-ois",
      "path": "docs/context/WBS-OIS.md",
      "level": "trunk",
      "sphere": "planning",
      "tags": ["wbs", "nx-tasks"]
    }
  ],

  "trunk_branch_leaf": {
    "rules": [
      { "pattern": "docs/context/**", "level": "trunk" },
      { "pattern": "packages/contracts/**", "level": "trunk" },
      { "pattern": "services/**", "level": "branch" },
      { "pattern": "apps/**", "level": "branch" },
      { "pattern": "tests/**", "level": "leaf" },
      { "pattern": "tools/**", "level": "leaf" }
    ],
    "overrides": [
      { "path": "docs/context/TREES-LEAVES-AGENTS-OIS.md", "level": "trunk" },
      { "path": "docs/context/nx-03-issuance-tests.md", "level": "leaf" }
    ]
  }
}
```

**Ключевые моменты:**

* **Paths** всегда `repo-relative` (без абсолютных путей), чтобы агенты могли применять один и тот же RepoScan и на macOS, и на eywa1 (корни разные, структура внутри репо — одинаковая).
* T/B/L кодируется как: `level` на элементах `dirs`, `domains`, `docs` + глобальный блок `trunk_branch_leaf.rules`.
* По желанию можно добавить `metrics` (строки кода, количество тестов, % C# vs TS и т.п.), но это уже необязательный слой.

---

### 2.2. `agents.manifest.json` (workspace‑level)

**Назначение:** единый реестр агентов (люди + LLM + CodeMachine‑уровень) и связка с T/B/L, репо и движками. Концептуально — JSON‑версия `config/main.agents.js` + `config/sub.agents.js` из CodeMachine, но на уровне монорепо.

**Структура (high‑level):**

```jsonc
{
  "meta": {
    "workspace": "prj_Cifra-rwa-exachange-assets",
    "generated_at": "2025-11-18T12:00:00Z",
    "version": "agents-1.0"
  },

  "agents": [
    {
      "id": "human.alex",
      "kind": "human",
      "name": "Alex A.",
      "roles": ["architect", "tech-lead", "trunk-owner"],
      "level_scope": ["trunk", "branch", "leaf"],
      "repos": ["*"],
      "tags": ["decision-maker"]
    },
    {
      "id": "ai.gpt5.oraculum",
      "kind": "llm",
      "engine": "openai",
      "model": "gpt-5-pro",
      "roles": ["system-architect", "meta-review"],
      "level_scope": ["branch", "trunk-advisory"],
      "repos": ["*"],
      "tags": ["analysis", "design"],
      "constraints": {
        "write_permissions": ["docs/context/**", "AGENTS.md"],
        "must_request_human_for": ["packages/contracts/**", "ops/infra/**"]
      }
    },
    {
      "id": "ai.codemachine.context-manager",
      "kind": "codemachine-agent",
      "engine": "codex",
      "roles": ["context-manager"],
      "prompt_path": "prompts/templates/codemachine/agents/04-context-manager-agent.md",
      "level_scope": ["branch"],
      "repos": ["repositories/customer-gitlab/ois-cfa"],
      "tags": ["context", "nx-tasks"]
    },
    {
      "id": "ai.codemachine.code-generation",
      "kind": "codemachine-agent",
      "engine": "claude",
      "roles": ["code-generation"],
      "level_scope": ["leaf"],
      "repos": ["repositories/customer-gitlab/ois-cfa"],
      "tags": ["implementation"],
      "write_permissions": [
        "services/**",
        "apps/**",
        "tests/**",
        "tools/**"
      ]
    }
    // …
  ],

  "groups": [
    {
      "id": "ois-cfa.nx-pipeline",
      "description": "Default multi-agent stack for NX tasks in ois-cfa",
      "agents": [
        "ai.codemachine.context-manager",
        "ai.codemachine.code-generation",
        "ai.codemachine.task-sanity-check",
        "ai.codemachine.git-commit"
      ]
    }
  ]
}
```

**Ключевые поля:**

* `level_scope`: на каких T/B/L‑уровнях агент может **менять** код. Читать он может всё, но менять — только в своих диапазонах.
* `write_permissions`: glob‑шаблоны путей; при конфликте с RepoScan/T/B/L → побеждает более строгий (Trunk‑запрет).
* `kind`: `human`, `llm`, `codemachine-agent`, `external-tool` (например, Playwright‑runner).
* `groups`: заготовки под CodeMachine workflows (какой стек агентов использовать per‑target).

---

### 2.3. `codemachine.workflow.json` (per‑project / per‑target)

**Назначение:** декларативно описать, как CodeMachine оркестрирует агентов, NX‑таски, RepoScan и worktrees для конкретной цели (например, `ois-cfa` + NX‑таски). Основано на фактическом `codemachine.workflow.js`, но в JSON‑форме.

**Пример для `ois-cfa` (упрощённо):**

```jsonc
{
  "meta": {
    "id": "ois-cfa-nx-workflow",
    "project": "OIS-CFA",
    "version": 1,
    "description": "NX tasks workflow for ois-cfa using CodeMachine"
  },

  "target": {
    "repo": "repositories/customer-gitlab/ois-cfa",
    "default_branch": "infra.defis.deploy",
    "worktrees": {
      "infra.defis.deploy": "repositories/customer-gitlab/ois-cfa",
      "infra": "../wt__ois-cfa__infra",
      "deploy": "../wt__ois-cfa__deploy",
      "main": "../wt__ois-cfa__main"
    }
  },

  "artifacts": {
    "reposcan": ".cifra/reposcan/ois-cfa/infra.defis.deploy.reposcan.json",
    "agents_manifest": ".cifra/agents.manifest.json",
    "tasks_manifest": ".cifra/tasks/ois-cfa.tasks_manifest.json"
  },

  "task_selection": {
    "strategy": "nx-first-open",
    "filters": {
      "level": ["branch", "leaf"],
      "tags_any": ["nx", "ois-cfa"]
    }
  },

  "pipeline": {
    "init": {
      "agent_id": "ai.codemachine.init",
      "level": "branch",
      "inputs": [],
      "outputs": [".codemachine/template.json"],
      "options": { "branch": "codemachine/dev" }
    },

    "planning": {
      "steps": [
        {
          "id": "principal-analyst",
          "agent_id": "ai.codemachine.principal-analyst",
          "level": "trunk-advisory",
          "inputs": ["artifacts.reposcan", "artifacts.tasks_manifest"],
          "outputs": [".codemachine/artifacts/plan/plan_manifest.json"]
        },
        {
          "id": "task-breakdown",
          "agent_id": "ai.codemachine.task-breakdown",
          "level": "branch",
          "inputs": [".codemachine/artifacts/plan/plan_manifest.json"],
          "outputs": [".codemachine/artifacts/tasks/*.json"]
        }
      ]
    },

    "development_cycle": {
      "kind": "map_reduce",
      "map": {
        "step": {
          "id": "context-manager",
          "agent_id": "ai.codemachine.context-manager",
          "level": "branch",
          "inputs": [
            "artifacts.reposcan",
            ".codemachine/artifacts/tasks/*.json",
            "artifacts.agents_manifest"
          ],
          "outputs": [".codemachine/prompts/context.md"]
        },
        "parallel": true,
        "max_concurrent": 3
      },
      "worker": {
        "steps": [
          {
            "id": "code-generation",
            "agent_id": "ai.codemachine.code-generation",
            "level": "leaf",
            "worktree_selector": "by-branch",
            "inputs": [".codemachine/prompts/context.md"],
            "outputs": ["git-working-tree-diff"]
          },
          {
            "id": "task-sanity-check",
            "agent_id": "ai.codemachine.task-sanity-check",
            "level": "leaf",
            "inputs": ["git-working-tree-diff"],
            "outputs": [".codemachine/artifacts/reports/task-check.json"]
          },
          {
            "id": "git-commit",
            "agent_id": "ai.codemachine.git-commit",
            "level": "leaf",
            "inputs": ["git-working-tree-diff"],
            "outputs": ["git-commit-sha"],
            "options": { "branch_from": "infra.defis.deploy" }
          }
        ]
      },
      "reduce": {
        "step": {
          "id": "check-task",
          "agent_id": "ai.codemachine.check-task",
          "level": "meta",
          "inputs": [".codemachine/artifacts/tasks/*.json"],
          "outputs": [".codemachine/memory/behavior.json"]
        },
        "loop": {
          "action": "stepBack",
          "loopSteps": 3,
          "loopMaxIterations": 20
        }
      }
    }
  }
}
```

**Как тут зашит Trunk/Branch/Leaf:**

* `planning` шаги имеют `level: trunk-advisory` → allowed только читать Trunk и писать в `.codemachine/*`, не трогая Trunk‑код.
* `context-manager` работает на `branch`‑уровне (понимает всю архитектуру, но не пишет код).
* `code-generation` + `task-sanity-check` — чистый `leaf` (меняют только файлы, помеченные в RepoScan как `leaf` + разрешённые `write_permissions` агента).
* `git-commit` завязан на feature‑ветки (`branch_from: infra.defis.deploy` + префикс `feature/NX-*` в реальном запуске).

---

## 3. YAML frontmatter & tagging strategy

### 3.1. Минимальный schema для frontmatter

**Общие ключи (для всех Markdown):**

```yaml
---
id: ois-cfa-project-context        # уникальный kebab/id
title: "OIS-CFA Project Context"   # читаемый заголовок
type: project-context              # project-context | repo-context | nx-task | agent-spec | runbook | decision-log | workflow-spec | misc
sphere: architecture               # architecture | domain | infra | ops | tests | ai-orchestration | security | meta
level: trunk                       # trunk | branch | leaf
repo: repositories/customer-gitlab/ois-cfa   # или mono-repo root для AGENTS
path: docs/context/PROJECT-CONTEXT.md        # repo-relative
domains: [issuance, registry]      # если релевантно
nx: NX-03                          # если это таск или связанный doc
tags: [ois-cfa, context, c4, nx]   # произвольные, но из общего словаря
---
```

**Минимальный набор:** `id`, `type`, `sphere`, `level`, `repo`, `path`, `tags`. Остальное — по ситуации.

### 3.2. Tag vocabulary (первый список)

Условная “онтология” тегов (дальше можно расширять):

* **По подсистемам / доменам:**
  `issuance`, `registry`, `settlement`, `compliance`, `identity`, `gateway`, `frontends`, `ops`, `k8s`, `uk1`, `playwright`, `fabric`, `audit`.
* **По роли документа:**
  `context`, `spec`, `contract`, `runbook`, `howto`, `decision`, `nx`, `wbs`, `agents`, `workflow`, `reposcan`, `codemachine`.
* **По уровню ответственности:**
  `trunk-guard`, `branch-impl`, `leaf-task`.
* **По типу работы:**
  `tests`, `e2e`, `ci`, `infra`, `devops`, `refactor`, `feature`.

RepoScan при обходе docs парсит YAML и заносит в `reposcan.json/docs[]` нужные поля (id, type, sphere, level, tags). 

### 3.3. Примеры YAML для разных типов docs

**1) `AGENTS.md` (корень монорепы)**

```yaml
---
id: cifra-global-agents
title: "CIFRA Workspace Agents & Rules"
type: agent-spec
sphere: ai-orchestration
level: trunk
repo: .
path: AGENTS.md
tags: [agents, policy, trunk-guard, codemachine]
---
```

**2) Project‑manifest / context doc (`ois-cfa/docs/context/PROJECT-CONTEXT.md`)**

```yaml
---
id: ois-cfa-project-context
title: "OIS-CFA: Project Context & Architecture"
type: project-context
sphere: architecture
level: trunk
repo: repositories/customer-gitlab/ois-cfa
path: docs/context/PROJECT-CONTEXT.md
domains: [issuance, registry, settlement, compliance, identity]
tags: [ois-cfa, context, c4, reposcan-source]
---
```

**3) Repo‑level context doc (`docs/context/TREES-LEAVES-AGENTS-OIS.md`)**

```yaml
---
id: ois-cfa-tla
title: "Trees / Branches / Leaves / Agents for OIS-CFA"
type: repo-context
sphere: meta
level: trunk
repo: repositories/customer-gitlab/ois-cfa
path: docs/context/TREES-LEAVES-AGENTS-OIS.md
tags: [tla, agents, trunk-guard, nx]
---
```

**4) NX‑task doc (`repositories/customer-gitlab/ois-cfa/tasks/NX-03-issuance-tests.md`)**

```yaml
---
id: nx-03-issuance-tests
title: "NX-03 – Issuance happy-path coverage & tests"
type: nx-task
sphere: tests
level: leaf
repo: repositories/customer-gitlab/ois-cfa
path: tasks/NX-03-issuance-tests.md
domains: [issuance]
nx: NX-03
tags: [nx, tests, issuance, leaf-task, ois-cfa]
---
```

### 3.4. Как RepoScan и CodeMachine должны использовать теги

**RepoScan:**

* При скане docs:

  * Парсит YAML → кладёт `docs[]` в `reposcan.json` (id, path, level, sphere, tags).
  * Отмечает doc как источник контекста для доменов (`domains` → `reposcan.domains[*].docs`).
* Если `type: project-context` `level: trunk` → помечает как “главный контекст”.

**CodeMachine/агенты:**

* **Перед любой серьёзной операцией** агент:

  1. Фильтрует `reposcan.docs` по `level in ['trunk','branch']` и релевантным `sphere/tags`.
  2. Читает минимум: `project-context`, `tla`, `wbs-ois`, соответствующий `nx-task`.
* **При записи:**

  * Leaf‑агент **не имеет права** изменять doc с `level: trunk`; максимум — предложить diff в отдельном Leaf‑doc (напр. `decision-log` с `level: leaf`).
  * Branch‑агент может менять `branch`‑доки (например, сервис‑специфика), но не Trunk.
* **При выборе задач:**

  * CodeMachine ищет `type: nx-task` + `tags` и домены → определяет какие агенты/шаги нужны.
* **При генерации новых docs:**

  * Агент обязан проставить frontmatter по шаблону, иначе манифест и RepoScan не увидят doc.

---

## 4. CodeMachine execution model (macOS + eywa1 + worktrees)

### 4.1. Где что лежит

**Монорепо root** (и macOS, и eywa1):

```txt
prj_Cifra-rwa-exachange-assets
├── .cifra/
│   ├── reposcan/
│   │   └── ois-cfa/
│   │       └── infra.defis.deploy.reposcan.json
│   ├── workflows/
│   │   └── ois-cfa.codemachine.workflow.json
│   └── agents.manifest.json
├── .codemachine/              # runtime CodeMachine артефакты (план, tasks.json, context, logs)
├── AGENTS.md
└── repositories/
    └── customer-gitlab/
        └── ois-cfa/           # основной worktree (infra.defis.deploy)
../wt__ois-cfa__infra
../wt__ois-cfa__deploy
../wt__ois-cfa__main
```

* `.cifra/*` — долгоживущие манифесты/снимки (под контролем монорепо).
* `.codemachine/*` — runtime CodeMachine (можно частично игнорировать в git).

### 4.2. Как CodeMachine находит RepoScan и манифесты

Алгоритм:

1. Стартуем из монорепо root (`codemachine -d /path/to/prj_Cifra…`).
2. `codemachine.workflow.json` для `target=ois-cfa` знает:

   * путь к RepoScan (`artifacts.reposcan`),
   * путь к agents‑manifest,
   * путь к tasks‑manifest.
3. `Context-manager` (аналог `ContextAssembler_v1.1`) читает: RepoScan → определяет домены/контейнеры → строит карту файлов, которые можно менять для конкретного NX‑таска.

### 4.3. Выбор worktree для задачи

Правила:

1. **По умолчанию** все NX‑таски для `ois-cfa` выполняются в worktree `repositories/customer-gitlab/ois-cfa` (ветка `infra.defis.deploy`).
2. Если в NX‑таске в frontmatter/теле указан `branch:` или `target_branch:`:

   * `infra` → `../wt__ois-cfa__infra`;
   * `deploy` → `../wt__ois-cfa__deploy`;
   * `main` → `../wt__ois-cfa__main`.
3. CodeMachine step `git-commit` всегда создаёт feature‑ветку `feature/NX-xx-…` **внутри выбранного worktree**, а не в монорепо.
4. В `codemachine.workflow.json` задаётся `worktree_selector`:

   * `"by-branch"` — выбирает по `target_branch` таска;
   * `"default"` — всегда infra.defis.deploy.
5. На eywa1 и macOS структура одинакова, CodeMachine просто поднимается относительно monorepo root (никаких hard‑coded `/home/user/...`).

### 4.4. Orchestration map/reduce (respecting T/B/L)

**High‑level pipeline (Mermaid)**

```mermaid
flowchart LR
    A[Input: NX-task + target repo] --> B[Load manifests\nreposcan.json + agents.manifest.json + workflow.json]
    B --> C[Planning\nPrincipal Analyst + Task Breakdown]
    C --> D[Task Queue\n.tasks/*.json]

    subgraph MAP[Map: per-task execution]
      D --> E[Context Manager\n(read-only trunk+branch)]
      E --> F[Code Generation\nLeaf agents (Codex/Claude)]
      F --> G[Task Sanity Check\nLeaf-level QA]
      G --> H[Git Commit\nfeature/NX-* branch]
    end

    H --> I[Reduce: Check-task\nbehavior.json]
    I -->|action: loop| D
    I -->|action: stop| J[Summary & MR proposal]

    J --> K[Human Review\n(Trunk owners)]
    K --> L[Merge into infra.defis.deploy\nthen develop/main]
```

* T/B/L соблюдается:

  * E (Context) читает всё, пишет только в `.codemachine`.
  * F/G/H работают на leaf‑уровне (ограничены `write_permissions` + RepoScan rules).
  * Merge в Trunk‑ветки — только после human review.

### 4.5. Поток задач между macOS и eywa1

**Идея:** планирование и тяжёлый контекст (RepoScan, NX‑план, архитектура) можно крутить на macOS; тяжёлые тесты/деплой — на eywa1, используя те же манифесты.

```mermaid
sequenceDiagram
    participant Mac as macOS (mono-repo root)
    participant Repo as prj_Cifra mono-repo
    participant Eywa as eywa1 (mono-repo root)
    participant Sub as ois-cfa worktrees

    Mac->>Repo: Run RepoScan for ois-cfa\n(generate .cifra/reposcan/...)
    Mac->>Repo: Edit AGENTS.md / agents.manifest.json\nEdit codemachine.workflow.json
    Mac->>Repo: Commit + push mono-repo changes

    Eywa->>Repo: git pull (mono-repo)\nupdate .cifra/* + .codemachine/*
    Eywa->>Sub: update submodule ois-cfa\n(checkout infra.defis.deploy)
    Eywa->>Repo: codemachine -d .\n(target=ois-cfa, NX-03)
    Repo->>Sub: CodeMachine writes code in worktree\nfeature/NX-03-...
    Sub->>Eywa: run tests/docker-compose/UK1 smoke
    Eywa->>Sub: push feature branch to ois-cfa remote\n(open MR)
```

* Вся “орchestration‑логика” (манифесты, RepoScan, AGENTS) едина для macOS и eywa1 → ты можешь планировать с ноутбука и исполнять на eywa1 без расхождений.

---

## 5. Next steps (1–2 недели) — что реально сделать

### План как таблица

| Step | Area               | What to implement                                                                                                                                                                                                     | Why now                                                                                                 | Agent-friendly?                                                                          |
| ---- | ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| 1    | RepoScan           | Создать `.cifra/reposcan/ois-cfa/infra.defis.deploy.reposcan.json` на базе текущего `…gpt5p-ois-cfa.shtgn.reposcan.json` + добавить секции `structure`, `domains`, `docs`, `trunk_branch_leaf`.                       | Без этого агентов не к чему привязывать — они не понимают, где Trunk/Branch/Leaf и какие домены есть.   | Да — генерацию/merge JSON можно смело отдать LLM под твоим ревью.                        |
| 2    | Agents             | В корне монорепы завести `.cifra/agents.manifest.json` с 5–10 ключевыми агентами (ты, Aleksandr, GPT‑5 Oracle, Codemachine контекст/код/QA/git). Прописать `level_scope` и `write_permissions` минимум для `ois-cfa`. | Это единая точка правды, кого куда подпускаем; дальше CodeMachine/Claude могут читать только этот файл. | Частично — LLM может сгенерить skeleton, но финальные права должен расставить ты.        |
| 3    | Docs + frontmatter | Добавить YAML frontmatter с `type/sphere/level/tags` в: `AGENTS.md`, `docs/context/PROJECT-CONTEXT.md`, `WBS-OIS.md`, `TREES-LEAVES-AGENTS-OIS.md` (создать), `tasks/NX-0x-*.md`.                                     | Без frontmatter RepoScan не сможет нормально индексировать контекст, а агенты — фильтровать docs.       | Да — LLM может массово добавить frontmatter по шаблону, при условии аккуратной проверки. |
| 4    | Workflow           | Создать `.cifra/workflows/ois-cfa.codemachine.workflow.json` по предложенной схеме (init → planning → map/reduce development_cycle), завести mapping worktrees.                                                       | Даёт один чёткий entrypoint для `codemachine -d . --workflow ois-cfa`, вместо adhoc‑шагов.              | Да — skeleton/JSON легко делегировать, главное — проверить пути/ветки.                   |
| 5    | Tasks‑manifest     | Сгенерировать `.cifra/tasks/ois-cfa.tasks_manifest.json` из существующих `tasks/NX-*.md` (простой Node/TS‑скрипт по образцу `extract_tasks.js` из CodeMachine).                                                       | Чтобы CodeMachine мог работать с JSON‑списком задач, а не парсить Markdown в рантайме.                  | Да — полностью агентский шаг (скрипт+манифест) с минимальным риском.                     |
| 6    | CodeMachine glue   | Написать маленький CLI‑обёртку `tools/cifra-codemachine.ts`: аргументы `--target ois-cfa --nx NX-03`, поднимает нужный workflow, worktree и запускает codemachine CLI.                                                | Удобный UX: один entrypoint для всех агентов и людей; снимает когнитивную нагрузку.                     | Да — реализация обёртки может быть сгенерена LLM.                                        |
| 7    | Policy (AGENTS)    | Обновить `AGENTS.md` текстом правил для всех агентов (см. финальную таблицу), включая обязательные Mermaid+таблицы и запрет на Trunk‑изменения без человека.                                                          | Чтобы любые дальнейшие аудиты/агенты играли по одним и тем же правилам.                                 | Да — текст можно почти целиком вставить из этого ответа.                                 |

---

## Финальная компактная таблица: Area / Decision / Recommendation

| Area        | Decision                                                                                                               | Your recommendation                                                                                             |
| ----------- | ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| RepoScan    | Использовать единый формат `reposcan.json` (на базе `shtgn.reposcan.json`) с слоями C4 + structure + domains + T/B/L.  | Вынести все снимки в `.cifra/reposcan/*`, обновлять по ключевым событиям; не класть их в `ois-cfa`.             |
| Agents      | Ввести `agents.manifest.json` как SSOT по агентам и зонам ответственности (Trunk/Branch/Leaf, paths).                  | Завести минимум 5–10 агентов и `groups` для `ois-cfa`; любые новые агенты добавлять только через этот манифест. |
| Docs/tags   | Обязательный YAML frontmatter (`type`, `sphere`, `level`, `tags`) для AGENTS/contexts/NX‑docs.                         | Стандартизировать шаблоны и заставить RepoScan/агентов всегда читать frontmatter перед анализом текста.         |
| CodeMachine | Workflow описывать в `codemachine.workflow.json` per‑target, без JS‑магии, с явными ссылками на RepoScan/AGENTS/tasks. | Для `ois-cfa` создать один основной workflow и дальше эволюционировать только его, а не плодить варианты.       |
| Worktrees   | Все операции агентов с `ois-cfa` выполнять через `worktrees` (`wt__ois-cfa__*`), выбранные по branch/level.            | В манифесты явно зашить mapping веток → worktrees; не позволять агентам самостоятельно выбирать пути.           |
| T/B/L       | Использовать Trunk/Branch/Leaf как единую ось ответственности во всех артефактах (RepoScan, AGENTS, YAML, workflows).  | Любое новое правило/агент/таск сначала классифицировать по T/B/L, потом уже описывать остальное.                |
| Separation  | Монорепо = control plane (`.cifra`, `.codemachine`, AGENTS, workflows); `ois-cfa` = чистый customer repo.              | Не добавлять CodeMachine/AGENTS/Reposcan‑артефакты внутрь `ois-cfa` субмодуля, только в родительскую монорепу.  |

Если хочешь, следующий шаг — я могу конкретно расписать skeleton файлов (`.cifra/…`) или помочь спроектировать `cifra-codemachine` CLI под твой текущий Node/Nest стек.

```

`aggregated-gpt5pro-talks/20251118-1322-gpt5pro-step5-reposcan.gpt5p.md`:

```md
# Prompt
You are Oracle, a focused one-shot problem solver. Emphasize direct answers, cite any files referenced, and clearly note when the search tool was used.  You are GPT‑5 Pro acting as a senior meta‑architect specifically for **RepoScan v1** in my AI‑assisted workspace.  Context (you already saw parts of it in previous calls, but here we focus on RepoScan only): - I have a personal mono‑repo (`prj_Cifra-rwa-exachange-assets`) with manifests, memory-bank and submodules like `ois-cfa`. - `ois-cfa` is the main team repo where domain code lives; mono‑repo is my control plane (manifests, AGENTS, workflows, AI experiments) and must not leak into customer repos. - I want a **RepoScan v1** that produces compact JSON snapshots per repo (e.g. `ois-cfa`) that agents can use as “map of the territory”: structure, domains, Trunk/Branch/Leaf mapping, key files. - I already experimented with Shotgun‑style SDD/RepoScan and have a lot of context in the attached code2prompt files.  I have attached: - `c2p_20251118-0905-context-reposcan-agents-structure-and-codemachine.txt`: aggregated context for RepoScan+Agents+CodeMachine (read this first for my high‑level intent); - `c2p_reposcan.txt`: snapshot of current RepoScan ideas/experiments (Shotgun‑style, SDD, JSON snapshots); - `c2p_ois-cfa.txt`: snapshot of the `ois-cfa` repo (branch `infra.defis.deploy`) — use it as the main concrete example for RepoScan output; - `20251117-2103-gpt5pro-step4-all-and-nextsteps.gpt5p.md`: your previous V4‑style audit that already touches Trunk/Branches/Leaves and NX‑00..NX‑08; - `20251118-0905-feedback-gpt5pro-step4-all.md`: my spoken feedback where I explicitly mention RepoScan, JSON snapshots, tagging, and the need for a single JSON “map” for agents.  **High-level ask for this call:**  Design **RepoScan v1** as a JSON‑based artefact and a small pipeline that: - can be generated for repos like `ois-cfa` (and later others); - encodes Trunk/Branch/Leaf in a way that is easy for agents to consume; - is compact enough to be used as high‑value context (not full source dump); - fits nicely into the broader OS you already sketched (Trunk/Branches/Leaves, NX‑00..NX‑08, CodeMachine, Agents).  What I need from you:  1) **RepoScan v1 – conceptual goals and constraints**    - In Russian (B2‑English terms OK), summarise in 5–8 bullets:      - what RepoScan v1 SHOULD and SHOULD NOT do;      - how it relates to Trunk/Branches/Leaves and NX‑00..NX‑08 (i.e. whether it is Trunk‑level artefact, how often to regenerate, who can touch it);      - how it should be used by agents vs humans.  2) **High‑level JSON structure for `reposcan.json`**    - Propose a JSON structure for `reposcan.json` (per repo), focusing on key fields only.    - Required parts (adapt/extend as needed):      - repo metadata (id, path, default branch, domains);      - tree of directories/files with minimal attributes (kind, size/class, tags, Trunk/Branch/Leaf level);      - logical groupings (domains, services, frontends, packages, ops, tests);      - references to “anchor” docs (e.g. `docs/context/*`, AGENTS, manifests);      - optional metrics (LOC buckets, test counts, etc.) if useful.    - Express this as a pseudo‑JSON schema (field names, types, nesting) + 1–2 small example fragments for `ois-cfa` (e.g. how `services/issuance` and `apps/backoffice` would appear).  3) **Trunk/Branch/Leaf encoding inside RepoScan**    - Explain how you would embed Trunk/Branch/Leaf semantics into `reposcan.json`:      - per node (field like `level: "trunk"|"branch"|"leaf"`?);      - via tags (e.g. `tags: ["domain:issuance", "level:branch"]`?);      - via separate sections (e.g. `trunk_nodes`, `branch_nodes`, `leaf_nodes`).    - Recommend ONE approach you think is most robust for agents and humans, and justify why.    - Provide 2–3 concrete examples (again using `ois-cfa` paths) that show how agents could:      - find all trunk‑level artefacts;      - find all leaf‑level test files for a given service;      - map a `tasks/NX-*` doc to concrete code locations via RepoScan.  4) **RepoScan generation pipeline (v1)**    - Design a minimal pipeline (CLI/tools/scripts, not full implementation) to generate `reposcan.json` for `ois-cfa` on macOS/eywa1:      - inputs (git repo root, list of ignore patterns, maybe existing SDD/Shotgun JSON);      - steps (scan FS → classify nodes → attach Trunk/Branch/Leaf levels → merge with existing manifests if needed → write `reposcan.json`);      - outputs (where to store `reposcan.json` in mono‑repo, how to version it, how often to regenerate).    - Output as:      - bullet list of steps;      - 1 Mermaid diagram showing the pipeline (FS → scanner → classifier → reposcan.json → agents).  5) **How agents and CodeMachine should consume RepoScan v1**    - Describe 5–10 typical usage patterns for RepoScan v1 by agents:      - planning (GPT‑5)      - implementation (Codex/Claude)      - review (GPT‑5)      - safety checks (where NOT to touch, based on level/tags).    - For each pattern, give:      - short name (e.g. “Find leaf tests for NX‑03”);      - 1–2 sentence description;      - which fields of `reposcan.json` are used.  Style & format: - Answer in Russian, with senior‑engineer tone; B2‑English terms OK. - Structure your answer as:   - TL;DR (3–5 bullets),   - Section 1: RepoScan v1 goals & constraints,   - Section 2: JSON structure for reposcan.json,   - Section 3: Trunk/Branch/Leaf encoding,   - Section 4: Generation pipeline,   - Section 5: Consumption patterns for agents/CodeMachine,   - Final compact table: `Area` / `Decision` / `Your recommendation`. - Do NOT restate all attached files; focus on synthesis and **executable** design.
# Output 
Я уже прогнал внутренний `file_search` по твоим файлам (`c2p_reposcan`, контекст RepoScan+CodeMachine, V3/V4‑отчёты по Trunk/Branch/Leaf, AGENTS/manifest, c2p_ois-cfa). Ниже опираюсь на существующие Shotgun‑репоскан JSON’ы по Hypetrain и `ois-cfa`, твой голосовой фидбэк про “один JSON‑снимок как карту” и T/B/L‑рамку.

---

## TL;DR

* RepoScan v1 = **авто‑генерируемый `reposcan.json` на репо/ветку**, живущий в монорепе, который даёт агентам карту: дерево путей, домены/сервисы/опсы, якорные доки и NX‑линки, с пометкой Trunk/Branch/Leaf по каждому узлу.
* Это **Trunk‑артефакт схемы**, но с содержимым уровня Branch/Leaf: редактировать руками нельзя, только генератор; регенерация — после крупных NX‑срезов и merge’ей, не на каждый коммит.
* Внутри: `meta + repo + summary + nodes + groups + anchors + nx_index`. `nodes` = только ключевые директории/файлы (services/apps/packages/docs/ops/tests), каждый с полями `kind/size_class/level/tags/domain`. NX‑таски явно связаны через `nx_index`.
* Trunk/Branch/Leaf кодируется **per‑node: `level: "trunk"|"branch"|"leaf"` + доп. `tags`**, без отдельных секций; это максимально просто для агентов: один проход по `nodes` для фильтрации.
* Pipeline v1: CLI‑скрипт в монорепе → сканирует рабочий tree `ois-cfa` на нужной ветке, классифицирует пути, вешает T/B/L и домены, строит groups/anchors/nx_index → пишет `snapshots/reposcan/ois-cfa/{branch}.reposcan.json`. Потом это читает CodeMachine/агенты как первичную “карту репо”.

---

## 1. RepoScan v1: цели и ограничения

**Что RepoScan v1 ДОЛЖЕН делать**

1. **Дать агентам “map of territory” одним JSON‑файлом на репо/ветку** — без повторного чтения всего c2p‑дампа. На входы агентов (GPT‑5/Claude/Codex/CodeMachine) всегда можно добавить 5–15к токенов `reposcan.json` как стабильный контекст.
2. **Нормализовать структуру под твой T/B/L‑фреймворк**: явно показывать, какие узлы относятся к Trunk (контракты, ключевые доки, runbook’и), какие к Branch (services/apps/ops‑каркас), какие к Leaf (тесты, UI‑слайсы, скрипты).
3. **Дать групповку по доменам/сервисам/фронтам/опсам/тестам**, чтобы агент мог быстро: “дай всё по issuance”, “дай всё по backoffice”, “какие тесты покрывают registry”.
4. **Связать NX‑таски с кодом и доками**: `nx_index` с привязкой `NX-03 → services/issuance + tests/issuance.Tests + contracts/openapi-issuance.yaml + docs/context/WBS-OIS`.
5. **Выделить “anchor docs”** (PROJECT/FRONTEND/WBS/UK1‑ингресс/SMTP, AGENTS‑правила для этого репо) отдельным списком, чтобы планирующий агент начинал с них, а не шарился по всему `docs/`.
6. **Быть компактным**: держать JSON в “архитектурной” зоне — сервисы/директории/ключевые файлы и агрегированные метрики, но не выгружать каждую строку кода. Shotgun‑SDD останется отдельным тяжёлым артефактом.

**Что RepoScan v1 НЕ ДОЛЖЕН делать**

7. **Не быть SDD/описанием поведения** — он не генерирует “романы” про домены, как Shotgun‑репоскан для Hypetrain/OIS‑CFA; только ссылки и компактные описания.
8. **Не хранить чувствительные данные и монорепо‑внутрянку**: только относительные пути внутри конкретного репо (`ois-cfa` и пр.), без абсолютных путей и без ссылок на твою личную монорепу в тексте. Монорепа хранит `reposcan.json`, но сам JSON ничего не знает о ней.
9. **Не редактироваться руками** — schema‑trunk, содержимое — результат генерации; правки только через изменение кода/структуры + регенерацию.

**Связь с Trunk/Branches/Leaves и NX‑00..NX‑08**

* **Уровень:** схема `reposcan.json` — Trunk‑уровень (часть “каркаса инструментов”), экземпляры (`reposcan.json` для конкретного репо/ветки) — ближе к Branch (отражают текущее состояние кода).
* **Кто трогает:** только ты/топ‑инженер через generator‑CLI и NX‑00‑таски (описание схемы и конфига генерации). Остальные — только читают.
* **Когда регенерировать:** в конце NX‑веток, перед большими MR в `infra.defis.deploy`/`develop`, перед крупными CodeMachine‑прогонами; плюс периодически (например, daily/weekly job) — но не на каждый commit.
* **Роль для агентов:**

  * планирующие GPT‑5 агенты читают `summary/groups/anchors/nx_index` чтобы собрать задачу и список файлов;
  * Codex/Claude Code читает `nodes` и вытаскивает уже конкретные файлы/директории для редактирования;
  * safety‑агент использует `level/tags` чтобы отсечь Trunk‑узлы от автогенерации.
* **Роль для людей:** быстрый “index view”: посмотреть, что генератор считает Trunk/Branch/Leaf, где лежат якорные доки, какие NX связаны с какими участками.

---

## 2. JSON‑структура `reposcan.json`

### 2.1. Общий псевдо‑schema

```jsonc
{
  "schema": "reposcan-1.0",       // версия схемы репосканов
  "repo": {                       // метаданные репозитория
    "id": "ois-cfa",              // короткий id (GitLab name)
    "root": "repositories/customer-gitlab/ois-cfa", // путь внутри монорепы
    "default_branch": "infra.defis.deploy",
    "scanned_ref": "ed44ee6",     // git SHA
    "branch": "infra.defis.deploy",
    "generated_at": "2025-11-18T09:30:00Z",
    "generator": "reposcan-cli@0.1.0"
  },
  "summary": {                    // агрегированные метрики
    "domains": ["identity","issuance","registry","settlement","compliance"],
    "loc": {
      "total": 85000,
      "by_language": { "csharp": 55000, "typescript": 25000, "yaml": 5000 }
    },
    "counts": {
      "services": 5,
      "apps": 4,
      "packages": 4,
      "ops_areas": 3,
      "test_suites": 6
    }
  },
  "nodes": {                      // дерево узлов (только важные dirs/files)
    "services/issuance": {
      "kind": "dir",              // dir | file
      "name": "issuance",
      "level": "branch",          // trunk | branch | leaf
      "domain": "issuance",
      "role": "service",          // service | app | package | ops | tests | doc | config | misc
      "size_class": "L",          // XS/S/M/L/XL по LOC/файлам
      "loc": 8000,
      "tags": ["backend","service","domain:issuance"],
      "children": [
        "services/issuance/Program.cs",
        "services/issuance/IssuanceDbContext.cs"
      ]
    },
    "apps/backoffice": {
      "kind": "dir",
      "name": "backoffice",
      "level": "branch",
      "domain": null,
      "role": "app",
      "size_class": "M",
      "loc": 6000,
      "tags": ["frontend","backoffice","ui"],
      "children": [
        "apps/backoffice/next.config.mjs",
        "apps/backoffice/src/app/page.tsx"
      ]
    },
    "tests/issuance.Tests/IssuanceApiTests.cs": {
      "kind": "file",
      "name": "IssuanceApiTests.cs",
      "level": "leaf",
      "domain": "issuance",
      "role": "tests",
      "size_class": "S",
      "loc": 400,
      "tags": ["xunit","backend","NX-03"]
    }
    // …
  },
  "groups": {                     // логические группировки
    "domains": {
      "issuance": {
        "services": ["services/issuance"],
        "apps": ["apps/portal-issuer"],
        "contracts": ["packages/contracts/openapi-issuance.yaml"],
        "tests": [
          "tests/issuance.Tests",
          "tests/e2e-playwright/issuer-issuance-flow.spec.ts"
        ]
      },
      "registry": {
        "services": ["services/registry"],
        "apps": ["apps/portal-investor"],
        "contracts": ["packages/contracts/openapi-registry.yaml"],
        "tests": ["tests/contracts/pact-consumer/gateway-to-registry.test.ts"]
      }
      // …
    },
    "services": [
      { "name": "issuance", "root": "services/issuance", "domain": "issuance", "level": "branch" },
      { "name": "registry", "root": "services/registry", "domain": "registry", "level": "branch" }
    ],
    "apps": [
      { "name": "portal-issuer", "root": "apps/portal-issuer", "level": "branch" },
      { "name": "backoffice", "root": "apps/backoffice", "level": "branch" }
    ],
    "ops": [
      { "name": "uk1", "root": "docs/deploy/20251113-cloudflare-ingress.md", "level": "trunk" },
      { "name": "k8s-timeweb", "root": "ops/infra/timeweb", "level": "branch" }
    ]
  },
  "anchors": [                    // “якорные” доки и файлы
    {
      "path": "docs/context/PROJECT-CONTEXT.md",
      "role": "project-context",
      "level": "trunk",
      "tags": ["anchor","context"]
    },
    {
      "path": "docs/context/WBS-OIS.md",
      "role": "wbs",
      "level": "trunk",
      "tags": ["anchor","wbs","nx"]
    },
    {
      "path": "docs/deploy/20251113-cloudflare-ingress.md",
      "role": "runbook:uk1",
      "level": "trunk",
      "tags": ["anchor","ops","uk1"]
    },
    {
      "path": "tasks/NX-03-issuance-coverage.md",
      "role": "nx-task",
      "level": "branch",
      "tags": ["nx","issuance"]
    }
  ],
  "nx_index": {                   // явная привязка NX‑тасков
    "NX-01": {
      "title": "Spec validation + API/Event Matrix",
      "task_doc": "tasks/NX-01-spec-matrix.md",
      "level": "branch",
      "domains": ["cross-cutting"],
      "nodes": [
        "packages/contracts",
        "docs/context/WBS-OIS.md",
        "docs/ops/api-event-matrix.md"
      ]
    },
    "NX-03": {
      "title": "Issuance endpoints alignment + tests",
      "task_doc": "tasks/NX-03-issuance-coverage.md",
      "level": "branch",
      "domains": ["issuance"],
      "nodes": [
        "services/issuance",
        "tests/issuance.Tests",
        "packages/contracts/openapi-issuance.yaml"
      ]
    }
    // …
  }
}
```

### 2.2. Примеры для `services/issuance` и `apps/backoffice` (фрагмент)

```jsonc
{
  "nodes": {
    "services/issuance": {
      "kind": "dir",
      "name": "issuance",
      "level": "branch",
      "domain": "issuance",
      "role": "service",
      "size_class": "L",
      "loc": 8000,
      "tags": ["backend","service","domain:issuance"],
      "children": [
        "services/issuance/Program.cs",
        "services/issuance/IssuanceDbContext.cs",
        "services/issuance/Controllers/IssuanceController.cs"
      ]
    },
    "apps/backoffice": {
      "kind": "dir",
      "name": "backoffice",
      "level": "branch",
      "domain": null,
      "role": "app",
      "size_class": "M",
      "loc": 6000,
      "tags": ["frontend","backoffice","admin-ui"],
      "children": [
        "apps/backoffice/next.config.mjs",
        "apps/backoffice/src/app/page.tsx",
        "apps/backoffice/src/app/(kyc)/kyc/page.tsx"
      ]
    }
  },
  "groups": {
    "domains": {
      "issuance": {
        "services": ["services/issuance"],
        "apps": ["apps/portal-issuer"],
        "contracts": ["packages/contracts/openapi-issuance.yaml"],
        "tests": ["tests/issuance.Tests"]
      }
    }
  }
}
```

Это даёт агенту очень быстрый путь: “issuance” → service, spec, tests, UI‑флоу; “backoffice” → app + связанные NX‑таски.

---

## 3. Встраивание Trunk/Branch/Leaf в `reposcan.json`

### 3.1. Варианты

1. **Per‑node поле `level`**

   * Плюсы: одна точка правды; простая фильтрация (`nodes[path].level === "leaf"`).
   * Минусы: нет явного перечня всех trunk/branch/leaf узлов (но можно получить в один проход).

2. **Через `tags` (например, `tags: ["level:branch"]`)**

   * Плюсы: гибко; не надо отдельное поле.
   * Минусы: повышает риск рассинхрона (`tags` сказали одно, `level` другое), требует более сложных запросов для агентов.

3. **Отдельные секции (`trunk_nodes`, `branch_nodes`, `leaf_nodes`)**

   * Плюсы: человеку удобно глазами.
   * Минусы: дублирование узлов, сложнее поддерживать, большие diffs.

### 3.2. Рекомендация

**Выбираем вариант 1: `level` на каждом узле + при желании дублирующий тег.**

Причины:

* Агенты чаще всего будут делать простые запросы: “дай все leaf‑тесты для services/issuance” → фильтр по `level === "leaf"` и `role === "tests"` и `domain === "issuance"`.
* Вся T/B/L‑архитектура у тебя уже оформлена именно как per‑элемент атрибут (см. таблицу уровней и диаграммы).
* Отдельные списки trunk/branch/leaf можно, если нужно, построить на лету или закешировать вне `reposcan.json`.

### 3.3. Примеры использования

#### 3.3.1. Найти все trunk‑артефакты

Псевдо‑запрос для агента:

* **Фильтр:** `nodes[path].level === "trunk"` ИЛИ `path` присутствует в `anchors` с `level: "trunk"`.

Например, получим:

```jsonc
[
  "docs/context/PROJECT-CONTEXT.md",
  "docs/context/WBS-OIS.md",
  "docs/deploy/20251113-cloudflare-ingress.md",
  "packages/contracts/openapi-issuance.yaml",
  "packages/contracts/openapi-registry.yaml"
]
```

Дальше планирующий агент уже знает: сначала читает PROJECT/WBS/контракты, потом идёт на Branch/Leaf.

#### 3.3.2. Найти все leaf‑тесты для конкретного сервиса

Цель: “листовые тесты для `services/issuance`”.

1. По `groups.domains.issuance.tests` получаем список тестовых корней: `"tests/issuance.Tests"`, `"tests/e2e-playwright/issuer-issuance-flow.spec.ts"`.
2. По `nodes` фильтруем все ключи, которые начинаются с этих путей **и** имеют `level: "leaf"` и `role: "tests"`.
3. Результат: конкретные файлы, которые можно добавить в контекст или править:

```jsonc
[
  "tests/issuance.Tests/IssuanceApiTests.cs",
  "tests/e2e-playwright/issuer-issuance-flow.spec.ts"
]
```

#### 3.3.3. Привязать `tasks/NX-*` к коду через RepoScan

Например, NX‑03 (issuance):

1. В `nx_index["NX-03"]` видим `nodes`: `"services/issuance"`, `"tests/issuance.Tests"`, `"packages/contracts/openapi-issuance.yaml"`.
2. Агенты:

   * Planner: берёт `task_doc`, читает постановку задачи + смотрит `nx_index["NX-03"].nodes` и `groups.domains.issuance` для контекста.
   * Implementer: по этим путям берёт нужные файлы (Program.cs, DbContext, тесты) и начинает править, не вылезая за пределы домена.

---

## 4. Pipeline RepoScan v1

### 4.1. Inputs / Outputs

**Inputs**

* `repo_root`: путь к рабочему дереву репо (`…/repositories/customer-gitlab/ois-cfa`).
* `branch`: например, `infra.defis.deploy` (или любой другой checked‑out worktree). 
* `ignore_patterns`: `.git`, `bin`, `obj`, `node_modules`, `dist`, `TestResults`, `coverage`, `memory-bank/*`, `ARCHIVE/*` (настраивается).
* Опционально: путь к существующему Shotgun‑SDD JSON (`*.shtgn.reposcan.json`) — чтобы при желании тянуть описания доменов/контейнеров в `summary`.

**Outputs**

* `snapshots/reposcan/ois-cfa/infra.defis.deploy.reposcan.json` — в корне монорепы (НЕ в самом `ois-cfa`).
* Дополнительно: маленький `index.json` по всем репо/веткам для быстрой навигации агентом.

### 4.2. Шаги pipeline (CLI/скрипт)

1. **Init & Git‑метаданные**

   * Определить `repo.id`, `branch`, `scanned_ref` (через `git rev-parse HEAD` в worktree), `default_branch`.
   * Прочитать базовые домены/сервисы из `docs/context/PROJECT-CONTEXT.md` и `WBS-OIS.md`.

2. **Scan FS**

   * Рекурсивно пройти по `repo_root` с учётом `ignore_patterns`.
   * Для каждого каталога/файла собрать: относительный `path`, `kind`, примерный `loc` (по быстрым heuristics), язык (по расширению).

3. **Classification (role/domain/level)**

   * По пути и имени определить `role`:

     * `services/*` → `role: "service"`, domains по имени (`issuance`, `registry`, …).
     * `apps/*` → `role: "app"`.
     * `packages/contracts/*` → `role: "package"` + domain из имени контракта. 
     * `docs/context/*` → `role: "doc"`.
     * `ops/*` и `docs/deploy/*` → `role: "ops"`.
     * `tests/*` → `role: "tests"`.
   * Назначить `level`:

     * Trunk: контракты, главные контекст‑доки и ключевые runbook’и (UK1, k8s‑baseline, AGENTS‑локальные правила).
     * Branch: сервисные и app‑директории, ops/infra, gitops, CI‑файлы.
     * Leaf: конкретные тестовые файлы, UI‑слайсы, отдельные конфиги и скрипты.

4. **Build groups**

   * Собрать `groups.domains` исходя из `domain`/`role`.
   * Построить списки `services`, `apps`, `ops` (корни).
   * Выделить UK1 и другие окружения как отдельные ops‑entry (`docs/deploy/20251113-cloudflare-ingress.md`, `ops/infra/timeweb/*`).

5. **Detect anchors**

   * По whitelist’у (PROJECT‑CONTEXT, FRONTEND‑CONTEXT, WBS‑OIS, RULES‑SUMMARY, ключевые deploy/ops‑доки, локальный AGENTS для репо) собрать `anchors[]`.

6. **Build `nx_index`**

   * Для каждой `tasks/NX-*.md` прочитать заголовок и ключевые “Scope/Touches” (если уже есть) или вывести из имени.
   * По шаблонам (`NX-03` → issuance; `NX-04` → registry/settlement; `NX-06` → CI) связать с соответствующими `nodes` и доменами.

7. **Serialize & write**

   * Собрать всё в структуру из раздела 2, отсортировать ключи для стабильных diff’ов.
   * Записать в `snapshots/reposcan/ois-cfa/{branch}.reposcan.json`.
   * Добавить мини‑index в `snapshots/reposcan/index.json`.

### 4.3. Mermaid диаграмма pipeline

```mermaid
flowchart LR
    FS[Repo FS\n(ois-cfa@infra.defis.deploy)] --> SCAN[Scanner\n(FS walk + LOC)]
    SCAN --> CLASS[Classifier\nrole/domain/level]
    CLASS --> GROUPS[Groups & Anchors\n(domains/apps/ops/NX)]
    GROUPS --> JSON[reposcan.json\n(per repo/branch)]
    JSON --> AGENTS[Agents & CodeMachine\n(plan/impl/review/safety)]
```

---

## 5. Как агенты / CodeMachine потребляют RepoScan v1

Ниже — паттерны использования; это можно почти копировать в AGENTS/внутренние доки.

| Pattern (short name)              | Description                                                                                                                                  | Fields used                                                               |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **1. Plan NX‑task scope**         | GPT‑5‑планировщик берёт `nx_index[NX-*]`, смотрит связанные `nodes` и `anchors`, чтобы собрать минимальный список файлов/доков для задачи.   | `nx_index`, `nodes`, `groups.domains`, `anchors`                          |
| **2. Domain slice for service**   | Агенту нужно понять “всё по issuance/registry”: он читает `groups.domains[domain]` и строит контекст из сервисов, контрактов, тестов, UI.    | `groups.domains`, `nodes`, `summary.domains`                              |
| **3. Find leaf tests for change** | Перед изменением в `services/issuance` агент запрашивает все `nodes` с `level:"leaf"`, `role:"tests"`, `domain:"issuance"` для smoke‑набора. | `nodes` (level, role, domain), `groups.domains`                           |
| **4. Trunk‑safety filter**        | Safety‑агент проверяет предложенный diff: если он затрагивает `nodes` с `level:"trunk"`, требует явного human‑confirm, иначе допускает.      | `nodes[level]`, `anchors[level]`                                          |
| **5. Minimal context for Codex**  | Codex‑CLI, прежде чем читать c2p, спрашивает `reposcan.json` и выбирает 5–10 узлов (paths) с нужным domain/role, чтобы не тянуть весь репо.  | `nodes`, `groups`, `summary`                                              |
| **6. Gateway / Ops navigation**   | Для NX‑02/NX‑06 агент ищет всё, что связано с gateway и CI: фильтрует `nodes` по `role:"service"/"ops"` и тегам `["gateway","ci"]`.          | `nodes.tags`, `groups.services`, `groups.ops`                             |
| **7. Backoffice vertical slice**  | Для NX‑07/08 агент берёт `apps/backoffice` + домены registry/issuance/compliance из `groups.domains` и соответствующие тесты.                | `nodes["apps/backoffice"]`, `groups.domains`, `nx_index["NX-07"/"NX-08"]` |
| **8. CI coverage suggestion**     | Агент читает `summary.loc` и `groups.services/apps`, смотрит, у каких сервисов нет `role:"tests"`/leaf‑узлов, и предлагает NX‑подзадачи.     | `summary`, `nodes`, `groups`                                              |
| **9. CodeMachine job planning**   | CodeMachine использует `reposcan.json`, чтобы строить job‑граф: из NX‑таска → связанные узлы → конкретные файлы/пакеты для каждой подзадачи. | `nx_index`, `nodes`, `groups`, `anchors`                                  |
| **10. Repo‑aware docs lookup**    | Когда агент пишет runbook, он не сканирует весь `docs/`, а через `anchors` находит релевантные контекст/ops‑доки и ссылается только на них.  | `anchors`, `nodes[role:"doc"]`                                            |

---

## Финальная таблица решений

| Area                          | Decision / Question                                     | Your recommendation (RepoScan v1)                                                                                                                                                                         |          |                                                                                                |
| ----------------------------- | ------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------- |
| Scope RepoScan                | Что описываем и на каком уровне?                        | Один `reposcan.json` на репо/ветку с деревом ключевых узлов (services/apps/packages/docs/ops/tests), доменами, T/B/L, NX‑индексом и anchors; без полного дампа кода.                                      |          |                                                                                                |
| T/B/L encoding                | Как кодируем Trunk/Branch/Leaf?                         | Per‑node `level: "trunk"                                                                                                                                                                                  | "branch" | "leaf"`+ дополнительные теги; никаких отдельных`trunk_nodes`/`leaf_nodes` списков внутри JSON. |
| NX‑связка                     | Как связать `tasks/NX-*` с кодом?                       | Явный `nx_index` (`NX-ID → task_doc + domains + nodes[]`), который генератор строит по шаблонам и, при необходимости, минимальному анализу task‑файлов.                                                   |          |                                                                                                |
| Storage & isolation           | Где хранить `reposcan.json`, чтобы не светить монорепу? | Храним только в монорепе: `snapshots/reposcan/{repo-id}/{branch}.reposcan.json`. Внутри — только относительные пути в чужом репо, без абсолютных путей и личных host‑ов.                                  |          |                                                                                                |
| Generation pipeline           | Какой минимальный pipeline?                             | CLI/скрипт: Git‑метаданные → FS‑скан → классификация (role/domain/level) → groups (domains/services/apps/ops) → anchors → nx_index → запись JSON; запускать по NX‑веткам и перед крупными MR/CodeMachine. |          |                                                                                                |
| Agent consumption             | Как агенты используют артефакт?                         | GPT‑5 планирует и строит scope по `summary/groups/anchors/nx_index`, Codex/Claude берут конкретные `nodes`/paths для работы, safety‑агент фильтрует по `level`.                                           |          |                                                                                                |
| Relation to NX‑00..NX‑08      | RepoScan = отдельный трек или часть NX?                 | Схема/правила RepoScan оформляются как NX‑00‑таск(и); дальнейшие NX‑01..NX‑08 подразумевают, что `reposcan.json` актуален и используется как входной индекс.                                              |          |                                                                                                |
| Human vs agent responsibility | Кто может менять что?                                   | Люди — схема, конфиг генератора и high‑level правила (Trunk). Агенты — только Leaf/частично Branch‑изменения в коде/доках, используя `reposcan.json` как read‑only карту.                                 |          |                                                                                                |

Если хочешь, следующим шагом можно сделать **NX‑00‑Reposcan**: конкретный NX‑00‑таск с DoD “есть скрипт генерации + первый `reposcan.json` для `ois-cfa@infra.defis.deploy`”, опираясь на эту схему.

```

`aggregated-gpt5pro-talks/20251118-1323-gpt5pro-step5-agents-and-codemachine.gpt5p.md`:

```md
# Prompt
````prompt
You are Oracle, a focused one-shot problem solver. Emphasize direct answers, cite any files referenced, and clearly note when the search tool was used.  You are GPT‑5 Pro acting as a senior meta‑architect for **Agents & CodeMachine** in my AI‑assisted workspace.  Context: - I have a personal mono‑repo (`prj_Cifra-rwa-exachange-assets`) that acts as a control plane: manifests, memory-bank, AGENTS, RepoScan snapshots, and submodules like `ois-cfa`. - `ois-cfa` is the main team repo where domain code lives; mono‑repo must not leak into customer repos, but must give agents a clear, safe framework. - We already explored Trunk/Branches/Leaves, gitflow, NX‑00..NX‑08, and high‑level CodeMachine concepts. Now I want to go deeper specifically into **agents/AGENTS and CodeMachine workflows**.  I have attached: - `c2p_20251118-0905-context-reposcan-agents-structure-and-codemachine.txt`: aggregated context for RepoScan+Agents+CodeMachine (read this first); - `c2p_agents-structures.txt`: snapshot of how I currently describe agents (AGENTS.md patterns, Trees/Leaves/Agents, etc.); - `c2p_codemachine.txt`: snapshot of early CodeMachine ideas (roles, pipelines, map/reduce flows, etc.); - `c2p_ois-cfa.txt`: snapshot of `ois-cfa` (branch `infra.defis.deploy`) to ground examples; - `20251117-2103-gpt5pro-step4-all-and-nextsteps.gpt5p.md`: your previous V4‑style audit (Trunk/Branch/Leaf, NX‑00..NX‑08, agent rules); - `20251118-0905-feedback-gpt5pro-step4-all.md`: my spoken feedback (mono‑repo vs team repo, YAML frontmatter/tags, repo boundaries, RepoScan/Agents/CodeMachine expectations); - `AGENTS.md`: current global agent rules at mono‑repo root; - `project.manifest.json`: current project manifest (indices, manifests, roles) as an example of machine‑readable SSOT.  **High-level ask for this call:**  Design a **clear, implementable spec for Agents & CodeMachine** that: - defines how agents (GPT‑5, Codex, Claude, etc.) are described in machine‑readable form (JSON/manifest) and in AGENTS.md; - defines how CodeMachine uses these manifests + RepoScan + tasks to orchestrate agents over worktrees on macOS/eywa1; - respects Trunk/Branches/Leaves and the separation between mono‑repo (control plane) and `ois-cfa` (team repo).  What I need from you:  1) **Agent taxonomy & roles**    - In Russian (B2‑English terms OK), define a small taxonomy of agent roles for this workspace, e.g.:      - Planner (GPT‑5): reads RepoScan/manifests, designs plans.      - Implementer (Codex/Claude): edits code/tests.      - Reviewer (GPT‑5): reviews diffs and plans.      - Ops/Infra helper, Docs/Writer, etc.    - For each role, specify:      - allowed levels (Trunk/Branch/Leaf);      - typical tasks;      - which repos and branches they may touch (mono‑repo root vs `ois-cfa` submodule vs others).  2) **`agents.manifest.json` – high‑level structure**    - Propose a JSON structure (per workspace/mono‑repo) that describes agents and their rules. Include fields like:      - `id`, `name`, `provider` (OpenAI/Anthropic/etc.), `kind` (planner/implementer/reviewer/ops/docs);      - `allowed_levels` (trunk/branch/leaf);      - `repos` (which repos/submodules they may touch);      - `branches`/`worktrees` patterns they may operate on (e.g. `infra.defis.deploy`, `feature/*`, `wt__ois-cfa__*`);      - `tools` (shell, git, code editors);      - `safety_rules` (e.g. “no touching AGENTS.md”, “no Fabric topology changes”).    - Provide a pseudo‑JSON schema + 1–2 example agent entries (Planner GPT‑5, Implementer Codex) grounded in this mono‑repo.  3) **`codemachine.workflow.json` – how to model workflows**    - Design a JSON structure that describes a CodeMachine workflow for a target repo (e.g. `ois-cfa`) and a task (e.g. NX‑03 or NX‑00‑01):      - `id`, `target_repo`, `target_branch`, `worktree_path` pattern;      - `entrypoints` (which NX‑tasks or manifests it uses);      - `steps`: for each step – which agent role runs, what it consumes (RepoScan, tasks, manifests), what it produces (plan, patch, review);      - conditions (when to stop/ask human, when to auto‑continue);      - Trunk/Branch/Leaf constraints per step.    - Provide a concrete example (pseudo‑JSON) of a workflow for:      - NX‑00‑01: “Update AGENTS.md with Trunk/Branch/Leaf + Mermaid rules”; and      - NX‑03‑a: “Fix issuance tests & EF config” (leaf‑heavy task on `ois-cfa`@`infra.defis.deploy`).  4) **Interaction between AGENTS.md (Markdown) and agents.manifest.json (JSON)**    - Explain how you see the split:      - what lives in human‑facing AGENTS.md vs what lives in machine‑facing `agents.manifest.json`;      - how to keep them in sync (e.g. JSON is SSOT, AGENTS.md is “human projection”; or the opposite);      - how YAML frontmatter and tags in AGENTS.md can reference entries in `agents.manifest.json`.    - Output 5–10 bullets + 1–2 small YAML/JSON examples.  5) **CodeMachine orchestration model (focused on agents)**    - Describe, at a high level, how CodeMachine should:      - read `agents.manifest.json`, `reposcan.json`, `project.manifest.json`, and NX‑tasks;      - select the right agent/role and worktree for a given task (Trunk/Branch/Leaf + repo + branch);      - run map/reduce loops (planner → implementer(s) → reviewer → commit) while respecting all safety rules.    - Include 1 Mermaid diagram showing the CodeMachine/agents interaction (from task selection to commit).  6) **Concrete next steps (1–2 weeks) specifically for Agents & CodeMachine**    - Propose a short, actionable plan to:      - define a first `agents.manifest.json` for this mono‑repo;      - update AGENTS.md with the new rules/sections;      - implement a minimal CodeMachine v0 (even as a set of scripts/configs) that uses these manifests.    - Output as a table: `Step` / `Artifact` / `What to implement` / `Why now` / `Agent-friendly?`.  Style & format: - Answer in Russian, senior‑engineer tone, B2‑English terms OK. - Structure your answer as:   - TL;DR (3–5 bullets),   - Section 1: Agent taxonomy & roles,   - Section 2: agents.manifest.json,   - Section 3: codemachine.workflow.json,   - Section 4: AGENTS.md vs agents.manifest.json,   - Section 5: Orchestration model,   - Section 6: Next steps (table),   - Final compact table: `Area` / `Decision` / `Your recommendation`. - Do NOT restate all attached files; focus on synthesis and **executable** design.
````

# Output 
TL;DR

* Я использовал `file_search` по монорепе (AGENTS.md, project.manifest.json, Codemachine docs, agents-structures, reposcan‑контекст; см. цитаты в тексте).
* Агентная таксономия: **Planner / Implementer / Reviewer / Ops / Docs (+ Context/Git system‑агенты)** с жёсткими ограничениями по Trunk/Branch/Leaf и по репам (`monorepo` vs `ois-cfa`).
* `agents.manifest.json` = машинный SSOT для ролей/моделей/политик (уровни дерева, репы, ветки, worktrees, tools, safety‑rules). AGENTS.md = человекочитаемая проекция, привязанная к manifest через id/anchors.
* `codemachine.workflow.json` описывает task‑workflow (NX‑00 / NX‑03‑a): repo+branch+worktree, entrypoints (NX‑task, reposcan, manifests), steps (planner→context→implementer→reviewer→git), условия остановки и human‑gate.
* CodeMachine v0: тонкий оркестратор, который читает `project.manifest.json` + `agents.manifest.json` + `codemachine.workflow.json` и запускает нужные движки (GPT‑5/Codex/Claude) по worktree, уважая Trunk/Branch/Leaf и customer‑границу `ois-cfa`.

---

## Section 1. Agent taxonomy & roles

### 1.1. Базовые роли

(ориентируюсь и на уже существующие роли Codemachine: arch‑agent, plan‑agent, context‑manager, code‑generation, task‑sanity‑check, git‑commit и модули loop/trigger )

| Role (kind)                             | Типичный engine/model                                     | Уровни дерева (допускается писать)              | Репы/ветки, куда можно **писать**                                                    | Основные задачи                                                                                  |
| --------------------------------------- | --------------------------------------------------------- | ----------------------------------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------ |
| **Planner / Architect** (`planner`)     | GPT‑5 Pro / Claude Sonnet (через Codemachine / CloudCode) | Trunk (только docs), Branch                     | Monorepo root (`AGENTS.md`, manifests, docs), `ois-cfa` docs/context **RO**          | Планирование NX‑тасков, декомпозиция, дизайн workflow, high‑level arch‑правки                    |
| **Implementer / Coder** (`implementer`) | Codex CLI / Claude Code / Cursor                          | Leaf (основной), Branch (ограниченно)           | `ois-cfa` feature‑ветки (`feature/NX-*`) в worktrees; monorepo — только scripts v0   | Изменения кода/тестов/скриптов по NX‑таскам, без правки trunk‑контрактов                         |
| **Reviewer / Evaluator** (`reviewer`)   | GPT‑5 Pro / Claude                                        | Leaf, Branch (docs), Trunk (только review‑docs) | Monorepo docs, `ois-cfa` (diff‑обзор, ревью‑отчёты, без прямого пуша в main/develop) | Code review, тест‑ревью, план‑ревью, формирование DoD/решений                                    |
| **Ops / Infra helper** (`ops`)          | Codex CLI / Claude Code                                   | Branch (infra‑каркас), Leaf                     | `ois-cfa/ops/*`, CI/CD configs, Helm/YAML в ветках `infra*`, `feature/*`             | Скрипты деплоя, CI‑jobs, k8s manifests (кроме топологии Fabric/K8s), UK1 runbooks                |
| **Docs / Writer** (`docs`)              | GPT‑5 Pro / Claude / Gemini                               | Trunk (docs), Branch, Leaf                      | Monorepo docs, `docs-cfa-rwa` submodule, `ois-cfa/docs/context/*`                    | Описание архитектуры, AGENTS, README, контекстные доки под NX‑таски                              |
| **Context Manager** (`context`)         | GPT‑5 / Claude (Codemachine context-manager)              | Все уровни **RO**                               | Все репы **read‑only**                                                               | Сбор контекста: чтение reposcan, manifests, задач, генерация `context.md`                        |
| **Git / Commit agent** (`git`)          | Cursor / Codex                                            | Leaf                                            | `ois-cfa` feature‑ветки                                                              | Формирование и применение патчей, локальные коммиты; **никогда** не меняет main/develop напрямую |

### 1.2. Trunk / Branch / Leaf per role

* **Planner**

  * Trunk: может **предлагать** изменения (через MR‑описания, NX‑00 планы), но не пушит в main/develop/`infra.defis.deploy`.
  * Branch: может описывать рефакторинги и изменения сервисов, оставляя реализацию Implementer’у.
  * Leaf: обычно не нужен, кроме локальных планов для конкретной feature‑ветки.

* **Implementer**

  * Leaf: основная зона работы — feature‑ветки `feature/NX-*` в `ois-cfa`.
  * Branch: только мелкие правки, если есть явный NX‑task и human‑gate.
  * Trunk: запрещено (кроме генерить предложения в Markdown).

* **Reviewer**

  * Leaf/Branch: читает diff, но пишет только review‑docs/комментарии, не меняет контракты.
  * Trunk docs: может помочь правками в AGENTS/арх‑доках **по NX‑00 таскам** с human‑approve.

* **Ops**

  * Branch: изменения в `infra.defis.deploy`, `infra`, `deploy`, CI‑pipeline в ветках.
  * Trunk: только предложения в docs; **никаких** прямых правок топологии Fabric/K8s, core‑infra.

* **Docs**

  * Trunk: может обновлять текст в AGENTS.md и контекстных доках по явным NX‑00 задачам.
  * Branch/Leaf: любые пояснения/README, если соответствуют gitflow и не меняют контракты.

* **Context / Git**

  * Context: никогда не пишет в репо, только в `.codemachine/prompts/context.md` или аналог. 
  * Git: создаёт/обновляет Leaf‑ветки, делает коммиты и MR, но не изменяет remote‑конфиги и не пушит в `main/develop`.

### 1.3. Репы и ветки по ролям (граница monorepo vs `ois-cfa`)

С учётом того, что **монорепа — личный control‑plane Alex, а `ois-cfa` — customer/team‑репа и не должна знать о монорепе** :

* Любые **манIFESTы, AGENTS, CodeMachine‑конфиги** — хранятся и живут в монорепе.
* `ois-cfa` видит только свои `tasks/NX-*`, `docs/context/*` и код — **без ссылок** на `prj_Cifra-rwa-exachange-assets`.
* Planner/Docs/Reviewer работают по trunk‑докам и manifests в монорепе и затем оперируют `ois-cfa` через NX‑таски + worktrees.

---

## Section 2. `agents.manifest.json` – структура и примеры

### 2.1. Общая структура (псевдо‑schema)

```jsonc
{
  "schemaVersion": "1.0",
  "project": {
    "id": "prj_Cifra-rwa-exachange-assets",
    "manifest": "./project.manifest.json"
  },
  "repos": [
    {
      "id": "monorepo",
      "path": ".",
      "kind": "control-plane"
    },
    {
      "id": "ois-cfa",
      "path": "repositories/customer-gitlab/ois-cfa",
      "kind": "team-repo",
      "source": "customer-gitlab"
    }
  ],
  "roles": [
    {
      "id": "planner",
      "description": "High-level planning & architecture",
      "allowed_levels": ["trunk", "branch"]
    },
    {
      "id": "implementer",
      "description": "Code/test implementation for NX tasks",
      "allowed_levels": ["leaf"]
    },
    {
      "id": "reviewer",
      "description": "Diff and plan review",
      "allowed_levels": ["leaf", "branch", "trunk-docs"]
    }
    // ...
  ],
  "agents": [
    {
      "id": "planner-gpt5",
      "name": "Planner GPT-5",
      "provider": "openai",
      "model": "gpt-5-pro",
      "kind": "planner",
      "description": "Reads RepoScan, manifests and NX tasks to produce executable plans.",
      "allowed_levels": ["trunk-docs", "branch"],
      "permissions": {
        "repos": [
          {
            "repo_id": "monorepo",
            "read": true,
            "write": ["docs", "agents-rules"],
            "max_level_write": "trunk-docs"
          },
          {
            "repo_id": "ois-cfa",
            "read": true,
            "write": [],
            "max_level_write": null
          }
        ],
        "branch_patterns": {
          "include": ["main", "develop", "infra.defis.deploy", "release/*"],
          "exclude": ["hotfix/*"]
        },
        "worktrees": {
          "pattern": "wt__{repo}__{branch}",
          "allowed": [
            "../wt__ois-cfa__infra",
            "../wt__ois-cfa__deploy",
            "../wt__ois-cfa__main"
          ]
        }
      },
      "tools": ["shell-ro", "git-ro", "reposcan", "codemachine"],
      "safety_rules": [
        "no_edit:manifests/*.json",
        "no_edit:repositories/customer-gitlab/ois-cfa/*",
        "no_force_push",
        "no_k8s_or_fabric_topology"
      ],
      "doc_anchor": "AGENTS.md#planner-gpt-5"
    },

    {
      "id": "impl-codex",
      "name": "Codex Implementer",
      "provider": "codex-cli",
      "model": "gpt-5-code-medium",
      "kind": "implementer",
      "description": "Implements NX tasks in ois-cfa feature branches.",
      "allowed_levels": ["leaf"],
      "permissions": {
        "repos": [
          {
            "repo_id": "ois-cfa",
            "read": true,
            "write": ["code", "tests", "scripts"],
            "max_level_write": "leaf"
          }
        ],
        "branch_patterns": {
          "include": ["feature/NX-*"],
          "require_base": "infra.defis.deploy"
        },
        "worktrees": {
          "pattern": "wt__{repo}__{branch}",
          "allowed_pattern": "../wt__ois-cfa__*"
        }
      },
      "tools": ["shell", "git-local", "editor"],
      "safety_rules": [
        "no_edit:AGENTS.md",
        "no_edit:manifests/*.json",
        "no_edit:ops/k8s/fabric-topology/*.yml",
        "no_push_to:main",
        "no_push_to:develop"
      ],
      "doc_anchor": "AGENTS.md#impl-codex"
    }
  ]
}
```

Ключевые моменты:

* `project.manifest.json` уже SSOT для submodules/реп и окружений  — `agents.manifest.json` просто добавляет поверх слой **policy**.
* `repos` в agents‑manifest — это *view* на те же пути, что и в project.manifest, чтобы не дублировать знания.
* `permissions.branch_patterns` и `permissions.worktrees` жёстко кодируют правила gitflow/worktrees (`wt__{repo}__{branch}`), не давая Codex/Claude выйти за отведённые ветки.
* `safety_rules` — список простых string‑политик; их будет интерпретировать слой CodeMachine v0 или твой CLI‑оракул.

---

## Section 3. `codemachine.workflow.json` – моделирование workflow

### 3.1. Структура workflow

Псевдо‑структура JSON (читается твоим оркестратором и мапится на CodeMachine main/sub‑agents и modules ):

```jsonc
{
  "schemaVersion": "1.0",
  "id": "nx-03a-issuance-tests",
  "kind": "nx-task",
  "tree_level": "leaf",
  "target": {
    "repo_id": "ois-cfa",
    "default_branch": "infra.defis.deploy",
    "feature_branch_pattern": "feature/NX-03-*",
    "worktree_path": "../wt__ois-cfa__infra"
  },
  "entrypoints": {
    "nx_task": "repositories/customer-gitlab/ois-cfa/tasks/NX-03-issuance-tests.md",
    "project_manifest": "./project.manifest.json",
    "agents_manifest": "./manifests/agents.manifest.json",
    "reposcan": "./reposcan/20251111-1325-gpt5p-ois-cfa.shtgn.reposcan.json"
  },
  "steps": [
    {
      "id": "plan",
      "name": "Plan NX-03-a",
      "role": "planner",
      "agent_id": "planner-gpt5",
      "level": "branch",
      "cm_agent": "plan-agent",
      "inputs": ["entrypoints.nx_task", "entrypoints.reposcan", "entrypoints.project_manifest"],
      "outputs": ["artifacts/nx-03a-plan.md"],
      "human_gate": {
        "required": false
      }
    },
    {
      "id": "context",
      "name": "Assemble Context",
      "role": "context",
      "agent_id": "context-gpt5",
      "level": "branch",
      "cm_agent": "context-manager",
      "inputs": ["artifacts/nx-03a-plan.md", "entrypoints.reposcan"],
      "outputs": [".codemachine/prompts/context-nx-03a.md"]
    },
    {
      "id": "implement",
      "name": "Implement tests & EF config",
      "role": "implementer",
      "agent_id": "impl-codex",
      "level": "leaf",
      "cm_agent": "code-generation",
      "branch_policy": {
        "create_feature_if_missing": true,
        "feature_from": "infra.defis.deploy",
        "feature_name": "feature/NX-03-issuance-tests"
      },
      "worktree": "target.worktree_path",
      "inputs": ["artifacts/nx-03a-plan.md", ".codemachine/prompts/context-nx-03a.md"],
      "outputs": ["git_patch", "updated_files"],
      "limits": {
        "max_files_changed": 10,
        "max_loc_changed": 400
      }
    },
    {
      "id": "review",
      "name": "Review implementation",
      "role": "reviewer",
      "agent_id": "review-gpt5",
      "level": "branch",
      "cm_agent": "task-sanity-check",
      "inputs": ["git_diff", "entrypoints.nx_task"],
      "outputs": ["artifacts/nx-03a-review.md"],
      "human_gate": {
        "required": true,
        "block_on": ["tests_failing", "breaking_change_detected"]
      }
    },
    {
      "id": "commit",
      "name": "Commit & conclude",
      "role": "git",
      "agent_id": "git-cursor",
      "level": "leaf",
      "cm_agent": "git-commit",
      "conditions": {
        "require_human_approval_from_step": "review"
      },
      "outputs": ["git_commit_sha"]
    }
  ],
  "completion": {
    "on_success": "MR_TO_INFRA_DEFIS_DEPLOY",
    "on_failure": "STOP_AND_NOTIFY"
  }
}
```

### 3.2. Пример workflow: NX‑00‑01 (Update AGENTS.md T/B/L rules)

Это Trunk‑doc задача в **монорепе**, но всё равно описывается как workflow, чтобы Planner/Docs/Reviewer работали по правилам:

```jsonc
{
  "schemaVersion": "1.0",
  "id": "nx-00-01-agents-tbl",
  "kind": "nx-meta",
  "tree_level": "trunk-docs",
  "target": {
    "repo_id": "monorepo",
    "default_branch": "main",
    "worktree_path": "."
  },
  "entrypoints": {
    "nx_task": "memory-bank/tasks-meta/NX-00-01-agents-tbl.md",
    "project_manifest": "./project.manifest.json",
    "agents_manifest": "./manifests/agents.manifest.json"
  },
  "steps": [
    {
      "id": "plan",
      "role": "planner",
      "agent_id": "planner-gpt5",
      "level": "trunk-docs",
      "cm_agent": "plan-agent",
      "inputs": ["entrypoints.nx_task", "entrypoints.project_manifest"],
      "outputs": ["artifacts/nx-00-01-plan.md"],
      "human_gate": { "required": false }
    },
    {
      "id": "draft-doc",
      "role": "docs",
      "agent_id": "docs-gpt5",
      "level": "trunk-docs",
      "cm_agent": "code-generation",
      "inputs": ["artifacts/nx-00-01-plan.md"],
      "outputs": ["AGENTS.md.patch"],
      "safety": {
        "paths_allowed": ["AGENTS.md"],
        "no_touch": ["manifests/*.json", "repositories/**"]
      }
    },
    {
      "id": "review",
      "role": "reviewer",
      "agent_id": "review-gpt5",
      "level": "trunk-docs",
      "cm_agent": "task-sanity-check",
      "inputs": ["AGENTS.md.patch", "entrypoints.nx_task"],
      "outputs": ["artifacts/nx-00-01-review.md"],
      "human_gate": {
        "required": true,
        "block_on": ["unclear_rules", "trunk_policy_violation"]
      }
    },
    {
      "id": "commit",
      "role": "git",
      "agent_id": "git-cursor",
      "level": "trunk-docs",
      "cm_agent": "git-commit",
      "conditions": { "require_human_approval_from_step": "review" },
      "outputs": ["git_commit_sha"]
    }
  ]
}
```

Главное: **никакие workflow NX‑00 не дают авто‑commit в main без human‑gate**.

---

## Section 4. AGENTS.md vs agents.manifest.json

С учётом текущего AGENTS.md (правила, manifests, people/domains/flows) и того, что `project.manifest.json` уже указывает на AGENTS как конвенцию для агентов :

### 4.1. Разделение ответственности

1. **`agents.manifest.json` = машинный SSOT**

   * идентификаторы агентов (`agent_id`), роли, provider/model, политики доступа (репы, ветки, уровни дерева), safety‑rules;
   * используется CodeMachine, CLI‑скриптами и другими агентами программно.

2. **AGENTS.md = человекочитаемая «проекция»**

   * объясняет, *зачем* такие роли/агенты, как ими пользоваться, примеры;
   * содержит ссылки/anchors на `agents.manifest.json` (по `agent_id` и `doc_anchor`).

3. **Происхождение правды**

   * Если расходятся AGENTS.md и `agents.manifest.json` по правам/уровням — истинным считается **manifest**, AGENTS должен быть выровнен.
   * CI/линтер позже может сравнивать и выдавать предупреждения.

4. **YAML frontmatter в AGENTS.md**

   * указывает путь до manifest и версию синхронизации:

     ```yaml
     ---
     created: 2025-10-30 19:04
     updated: 2025-11-18 10:30
     type: project-rules
     version: 1.4.0
     agents_manifest: ./manifests/agents.manifest.json
     tags: [agents, codemachine, trunk]
     ---
     ```

5. **Связка секций AGENTS с agents.manifest**

   * каждая секция роли/агента получает anchor с id manifest:

     ```md
     ### Planner GPT-5 (`agent_id: planner-gpt5`)

     - kind: planner
     - levels: trunk-docs, branch
     - provider: openai, model: gpt-5-pro
     - см. `agents.manifest.json > agents[].id == "planner-gpt5"`
     ```

6. **Обратная ссылка из manifest**

   * в agents.manifest поле `doc_anchor` хранит ссылку вида `AGENTS.md#planner-gpt-5-agent-id-planner-gpt5` для навигации.

7. **Tags как индекс**

   * frontmatter‑теги уровней дерева: `tags: [agents, trunk, planner]` позволяют RepoScan/индексатору строить быстроту поиска контекста для агентов.

8. **Обновление**

   * при изменении ролей/политик: сначала PR в `agents.manifest.json` + линтер маппинга, затем обновление AGENTS.md по результатам.

---

## Section 5. CodeMachine orchestration model (focused on agents)

Опираюсь на оригинальный Codemachine CLI: main/sub‑agents, modules (loop/trigger), context‑manager и git‑commit/ task‑sanity‑check.

### 5.1. High-level pipeline

1. **Task selection**

   * Оператор или мета‑агент выбирает NX‑таск (например, NX‑03‑a) и соответствующий `codemachine.workflow.json`.
   * Указывается `tree_level` (trunk/branch/leaf) и target (repo/branch/worktree).

2. **Context bootstrap**

   * Оркестратор читает:

     * `project.manifest.json` → где лежат submodules, какие окружения/серверы.
     * `agents.manifest.json` → какие агенты и права.
     * `reposcan/*.shtgn.json` → снимок файла/структуры для целевого repo (аналог Architecture Manifest).
     * NX‑task (`tasks/NX-*`) → постановка задачи.
   * Запускается Codemachine workspace (`.codemachine/`), если его нет — создаётся по дефолтному бутстрапу.

3. **Agent selection**

   * Для каждого `step` в workflow по полям `role` и `agent_id` выбирается:

     * движок (Codex/Claude/GPT‑5/Cursor);
     * соответствующий Codemachine main agent (`plan-agent`, `context-manager`, `code-generation`, `task-sanity-check`, `git-commit` и т.п.). 
   * Проверяется policy: `allowed_levels`, `branch_patterns`, `worktrees`, `safety_rules` → если step нарушает policy, остановка и запрос к человеку.

4. **Execution (map / reduce)**

   * `Planner` (plan‑agent) генерит план → артефакт `plan.md`.
   * `Context Manager` собирает контекст → `.codemachine/prompts/context.md`. 
   * Один или несколько `Implementer`‑шагов (code‑generation) в нужных worktrees создают/обновляют код.
   * `Reviewer` (task‑sanity-check + возможно отдельный GPT‑reviewer) валидирует по DoD и NX‑описанию. 
   * `Modules` (`check-task`, `iteration-checker`) управляeт циклами: повторить шаги, если не достижен DoD или есть ошибки.

5. **Safety gates**

   * Для **trunk‑уровня** шаги с `level: trunk-docs` всегда имеют `human_gate.required = true`.
   * Для Branch‑уровня infra‑шагов `Ops` агент не может менять Fabric/K8s topology — это зашито в `safety_rules`.
   * Для Leaf‑уровня разрешён авто‑commit в feature‑ветки, но с лимитом на размер diff и обязательным review step.

6. **Commit and MR**

   * Git‑agent (git‑commit) только коммитит в feature‑ветку/локальную ветку, не трогает remotes/branch‑policies.
   * Создание MR/PR делается либо человеком, либо отдельным безопасным экшеном, который тоже читает agents‑policies.

### 5.2. Mermaid: CodeMachine + Agents interaction

```mermaid
flowchart LR
    NX["NX task\n(tasks/NX-03-...md)"]
    CFG["codemachine.workflow.json\n+ agents.manifest.json"]
    PM["project.manifest.json\n+ reposcan"]
    CM["CodeMachine Orchestrator"]
    P["Planner agent\n(plan-agent / GPT-5)"]
    Ctx["Context Manager\n(context-manager)"]
    Impl["Implementer\n(code-generation / Codex)"]
    Rev["Reviewer\n(task-sanity-check / GPT-5)"]
    Git["Git agent\n(git-commit)"]
    Repo["Worktree\nwt__ois-cfa__..."]

    NX --> CM
    CFG --> CM
    PM --> CM

    CM --> P
    P --> CM

    CM --> Ctx
    Ctx --> CM

    CM --> Impl
    Impl --> Repo
    Repo --> CM

    CM --> Rev
    Rev --> CM

    CM --> Git
    Git --> Repo

    CM -->|if trunk or policy violated| Human["Human operator\n(Alex / Aleksandr O)"]
```

---

## Section 6. Next steps (1–2 weeks) для Agents & CodeMachine

### 6.1. План как таблица

| Step | Artifact                                          | What to implement                                                                                                                                                                                                | Why now                                                                                                  | Agent-friendly?                                                                                                      |
| ---- | ------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| 1    | `manifests/agents.manifest.json` v0.1             | Создать v0 manifest по предложенной схеме: базовые `roles` + 3–4 агента (planner‑gpt5, impl‑codex, review‑gpt5, git‑cursor) с минимальным набором `permissions` и `safety_rules`.                                | Это новый SSOT для оркестрации; без него CodeMachine не понимает, кого где запускать.                    | ✅ Да: можно поручить Codex/Claude с DoD «валидный JSON + маппинг на текущие CLI/движки».                             |
| 2    | `AGENTS.md` (обновлённый)                         | Добавить frontmatter‑поле `agents_manifest`, раздел «Trees / Branches / Leaves & Agent Roles» и блок «Rules for all AI agents» (см. ниже), сославшись на manifest.                                               | Все агенты уже читают AGENTS как вход; нужно завести туда линки на manifest и правила Trunk/Branch/Leaf. | ✅ Да, с NX‑00‑01: текст может сгенерировать агент, ты ревьюишь.                                                      |
| 3    | `.codemachine/` workspace в монорепе              | Инициализировать Codemachine в корне монорепы (`codemachine -d .`), настроить базовые config/main.agents.js и modules.js, добавив ссылки на существующие план/контекст/код‑агентов из оригинального Codemachine. | Нужен единый entrypoint (CLI + конфиги) для всех дальнейших workflow.                                    | ⚠️ Частично: bootstrap и простые правки может сделать агент, но финальную структуру config’ов лучше собрать вручную. |
| 4    | `codemachine/workflows/nx-00-01.workflow.json`    | Закодировать NX‑00‑01 workflow (обновление AGENTS) в JSON, как в примере; добавить скрипт `scripts/run-workflow.cjs`, который читает JSON и вызывает Codemachine шаги.                                           | Это «обкатка» схемы на безопасной trunk‑doc задаче.                                                      | ✅ Да, кроме написания самого Node‑скрипта, который лучше быстро набросать вручную.                                   |
| 5    | `codemachine/workflows/nx-03a.workflow.json`      | Описать workflow NX‑03‑a (issuance tests & EF config) через planner→context→implementer→reviewer→git с запертой зоной `feature/NX-03-*` worktree.                                                                | Первый реальный Leaf‑workflow, максимально репрезентативный для будущих задач.                           | ✅ Да, после того как manifest/AGENTS и скрипт из шага 4 будут готовы.                                                |
| 6    | Mini‑runbook `docs/context/AGENTS-CODEMACHINE.md` | Краткий doc: «Как запускать CodeMachine‑workflow из монорепы, как читаются manifests, как подключаются NX‑таски».                                                                                                | Чтобы другие агенты/люди могли быстро подключиться к оркестратору с нулевым контекстом.                  | ✅ Да, практически полностью может написать GPT‑5 по этому ответу.                                                    |

---

## Final compact table: Area / Decision / Recommendation

| Area               | Decision                                                                                                                                                                       | Your recommendation                                                                                                                                      |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Agent roles        | Вводим чёткую таксономию: Planner / Implementer / Reviewer / Ops / Docs + Context/Git system‑агенты с жёсткими правами по Trunk/Branch/Leaf и репам.                           | Закрепить в `agents.manifest.json` и AGENTS.md; любая новая роль сначала через PR в manifest.                                                            |
| Repos & boundaries | Монорепа = control‑plane (manifests, AGENTS, Codemachine, RepoScan); `ois-cfa` = customer team‑repo, без ссылок на монорепу.                                                   | Все orchestrator‑конфиги и agents‑rules храним в монорепе; `ois-cfa` только читает свои tasks/docs.                                                      |
| Agents manifest    | `agents.manifest.json` — машинный SSOT для агентов и политик; ссылается на `project.manifest.json` для реп/окружений.                                                          | Сделать v0.1 в ближайшие дни и сразу подключить к простому CLI‑орchestrator’у.                                                                           |
| Workflows          | `codemachine.workflow.json` описывает NX‑таски: target repo/branch/worktree, steps и human‑gates; затем мапится в Codemachine main/sub‑agents.                                 | Сначала реализовать 2 эталонных workflow (NX‑00‑01, NX‑03‑a), потом масштабировать по аналогии.                                                          |
| AGENTS vs manifest | AGENTS.md = human‑projection (описания, правила, UX); `agents.manifest.json` = policy‑SSOT, привязанный через anchors/frontmatter.                                             | Ввести frontmatter‑связку и регулярно прогонять линтер, сверяющий AGENTS.md с manifest.                                                                  |
| Orchestration      | CodeMachine v0 читает project/agents/workflow‑manifests + reposcan, выбирает агентов и гоняет pipeline planner→context→implementer→reviewer→git с respect к Trunk/Branch/Leaf. | Реализовать как минимальный Node/Python‑скрипт, не пытаясь сразу переписать сам Codemachine; сначала «тонкий управляющий слой» над уже существующим CLI. |

Если хочешь, следующим шагом могу выдать конкретный шаблон `scripts/run-workflow.cjs`, который читает `codemachine.workflow.json` и запускает шаги через `codemachine step <agent-id>` с проверкой `agents.manifest.json`.

```