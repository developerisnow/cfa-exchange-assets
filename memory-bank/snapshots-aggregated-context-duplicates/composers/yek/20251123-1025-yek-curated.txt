>>>> services/issuance/Program.cs
using FluentValidation;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Issuance;
using OIS.Issuance.DTOs;
using OIS.Issuance.Services;
using OIS.Issuance.Validators;
using Serilog;
using MassTransit;
using OIS.Contracts.Events;
using OIS.Issuance.Infrastructure;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using System.Diagnostics;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
var otlpEndpoint = builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"] ?? "http://otel-collector:4317";
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("issuance-service")
        .AddAttributes(new Dictionary<string, object> { ["environment"] = builder.Environment.EnvironmentName }))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddOtlpExporter(options => options.Endpoint = new Uri(otlpEndpoint)))
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Prometheus metrics endpoint is added via OpenTelemetry above

// Database
var useInMemoryDb = builder.Configuration.GetValue<bool>("UseInMemoryDatabase", false);
var issuanceMigrationsAssembly = typeof(IssuanceDbContext).Assembly.GetName().Name;

builder.Services.AddDbContext<IssuanceDbContext>(options =>
{
    if (useInMemoryDb)
    {
        var dbName = builder.Configuration.GetValue<string>("InMemoryDatabaseName") ?? "IssuanceTestsDb";
        options.UseInMemoryDatabase(dbName);
    }
    else
    {
        options.UseNpgsql(
            builder.Configuration.GetConnectionString("DefaultConnection"),
            npgsqlOptions => npgsqlOptions.MigrationsAssembly(issuanceMigrationsAssembly));
    }
});

// HTTP Client for Ledger Adapter
builder.Services.AddHttpClient<LedgerIssuanceAdapter>()
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

// Services
builder.Services.AddScoped<ILedgerIssuance, LedgerIssuanceAdapter>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IIssuanceService, IssuanceService>();

// MassTransit + Kafka publish
if (builder.Configuration.GetValue<bool>("Kafka:Enabled", true))
{
    builder.Services.AddMassTransit(x =>
    {
        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092");
            });
        });
    });

    builder.Services.AddHostedService<OIS.Issuance.Background.OutboxPublisher>();
}

// Validation
builder.Services.AddValidatorsFromAssemblyContaining<CreateIssuanceRequestValidator>();
builder.Services.AddFluentValidationAutoValidation();

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        if (!string.IsNullOrEmpty(authority)) options.Authority = authority;
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            RoleClaimType = ClaimTypes.Role
        };
        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx => { MapKeycloakRoles(ctx); return Task.CompletedTask; }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:any-auth", p => p.RequireAuthenticatedUser());
    options.AddPolicy("role:issuer-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("issuer") || ctx.User.IsInRole("backoffice")));
});

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<IssuanceDbContext>();

var app = builder.Build();

// Apply migrations (env MIGRATE_ON_STARTUP overrides RunMigrations flag)
var runMigrations = builder.Configuration.GetValue<bool>("RunMigrations", true);
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    runMigrations = true;
}
else if (string.Equals(migrateOnStartup, "false", StringComparison.OrdinalIgnoreCase))
{
    runMigrations = false;
}

if (runMigrations)
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<IssuanceDbContext>();
    db.Database.Migrate();
}

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

var disableHttpsRedirect = builder.Configuration.GetValue<bool>("DisableHttpsRedirection", false);
if (!disableHttpsRedirect)
{
    app.UseHttpsRedirection();
}
app.UseAuthentication();
app.UseAuthorization();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    // Correlate X-Request-ID
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();

    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Issuances").RequireAuthorization();

api.MapPost("/issuances", async (
    CreateIssuanceRequest request,
    IIssuanceService service,
    ILoggerFactory loggerFactory,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CreateAsync(request, ct);
        return Results.Created($"/v1/issuances/{result.Id}", result);
    }
    catch (FluentValidation.ValidationException vex)
    {
        var logger = loggerFactory.CreateLogger("CreateIssuance");
        logger.LogWarning(vex, "Validation failed for CreateIssuance");
        var errors = vex.Errors
            .GroupBy(e => e.PropertyName)
            .ToDictionary(g => g.Key, g => g.Select(e => e.ErrorMessage).ToArray());
        return Results.ValidationProblem(errors, statusCode: 400, title: "Validation Failed");
    }
    catch (Exception ex)
    {
        var logger = loggerFactory.CreateLogger("CreateIssuance");
        logger.LogError(ex, "CreateIssuance failed");
        return Results.Problem(detail: ex.Message, statusCode: 500, title: "Internal Server Error");
    }
})
.WithName("CreateIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapGet("/issuances/{id:guid}", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    var result = await service.GetByIdAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetIssuance")
.RequireAuthorization("role:any-auth")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/publish", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.PublishAsync(id, ct);
        return result is not null ? Results.Ok(result) : Results.NotFound();
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("PublishIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/close", async (
    Guid id,
    IIssuanceService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CloseAsync(id, ct);
        return result is not null ? Results.Ok(result) : Results.NotFound();
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("CloseIssuance")
.RequireAuthorization("role:issuer")
.WithOpenApi();

api.MapGet("/reports/issuances", async (
    Guid issuerId,
    DateOnly? from,
    DateOnly? to,
    IIssuanceService service,
    CancellationToken ct) =>
{
    var report = await service.GetIssuerIssuancesReportAsync(issuerId, from, to, ct);
    return Results.Ok(report);
})
.WithName("GetIssuerIssuancesReport")
.RequireAuthorization("role:issuer-or-backoffice")
.WithOpenApi();

app.Run();

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { }
}

public partial class Program { }

>>>> services/issuance/Services/IssuanceService.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using OIS.Domain;
using OIS.Issuance.DTOs;
using System.Text.Json;

namespace OIS.Issuance.Services;

public interface IIssuanceService
{
    Task<IssuanceResponse> CreateAsync(CreateIssuanceRequest request, CancellationToken ct);
    Task<IssuanceResponse?> GetByIdAsync(Guid id, CancellationToken ct);
    Task<IssuanceResponse?> PublishAsync(Guid id, CancellationToken ct);
    Task<IssuanceResponse?> CloseAsync(Guid id, CancellationToken ct);
    Task<IssuerIssuancesReportResponse> GetIssuerIssuancesReportAsync(Guid issuerId, DateOnly? from, DateOnly? to, CancellationToken ct);
}

public class IssuanceService : IIssuanceService
{
    private readonly IssuanceDbContext _db;
    private readonly ILogger<IssuanceService> _logger;
    private readonly IOutboxService _outbox;
    private readonly ILedgerIssuance _ledger;

    public IssuanceService(
        IssuanceDbContext db,
        ILogger<IssuanceService> logger,
        IOutboxService outbox,
        ILedgerIssuance ledger)
    {
        _db = db;
        _logger = logger;
        _outbox = outbox;
        _ledger = ledger;
    }

    public async Task<IssuanceResponse> CreateAsync(CreateIssuanceRequest request, CancellationToken ct)
    {
        var issuance = new IssuanceEntity
        {
            Id = Guid.NewGuid(),
            AssetId = request.AssetId,
            IssuerId = request.IssuerId,
            TotalAmount = request.TotalAmount,
            Nominal = request.Nominal,
            IssueDate = request.IssueDate,
            MaturityDate = request.MaturityDate,
            Status = IssuanceStatus.Draft,
            ScheduleJson = request.ScheduleJson != null 
                ? JsonSerializer.Serialize(request.ScheduleJson) 
                : null,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _db.Issuances.Add(issuance);
        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Created issuance {IssuanceId} for asset {AssetId}", issuance.Id, issuance.AssetId);

        return MapToResponse(issuance);
    }

    public async Task<IssuerIssuancesReportResponse> GetIssuerIssuancesReportAsync(
        Guid issuerId,
        DateOnly? from,
        DateOnly? to,
        CancellationToken ct)
    {
        var query = _db.Issuances
            .AsNoTracking()
            .Where(i => i.IssuerId == issuerId);

        if (from.HasValue)
        {
            query = query.Where(i => i.IssueDate >= from.Value);
        }

        if (to.HasValue)
        {
            query = query.Where(i => i.IssueDate <= to.Value);
        }

        var issuances = await query.ToListAsync(ct);

        var items = issuances.Select(i => new IssuerReportRow
        {
            IssuanceId = i.Id,
            AssetCode = i.AssetId.ToString(), // TODO: replace with real asset code when available
            AssetName = i.AssetId.ToString(), // TODO: replace with real asset name from domain/catalog
            TotalAmount = i.TotalAmount,
            SoldAmount = 0m, // TODO: pull real sold amount from registry once available
            InvestorsCount = 0, // TODO: pull investors count from registry once available
            Status = i.Status.ToStringValue(),
            IssueDate = i.IssueDate,
            MaturityDate = i.MaturityDate,
            PublishedAt = i.PublishedAt
        }).ToList();

        var summary = new IssuerIssuancesReportSummary
        {
            TotalIssuances = items.Count,
            TotalAmount = items.Sum(x => x.TotalAmount),
            TotalSold = items.Sum(x => x.SoldAmount),
            TotalInvestors = items.Sum(x => x.InvestorsCount)
        };

        return new IssuerIssuancesReportResponse
        {
            IssuerId = issuerId,
            Period = new IssuerIssuancesReportPeriod
            {
                From = from,
                To = to
            },
            Items = items,
            Summary = summary
        };
    }

    public async Task<IssuanceResponse?> GetByIdAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        return issuance != null ? MapToResponse(issuance) : null;
    }

    public async Task<IssuanceResponse?> PublishAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        if (issuance == null)
        {
            _logger.LogWarning("Publish requested for missing issuance {IssuanceId}", id);
            return null;
        }

        if (issuance.Status != IssuanceStatus.Draft)
            throw new InvalidOperationException($"Cannot publish issuance in status {issuance.Status}");

        // Issue on ledger
        var scheduleJson = issuance.ScheduleJson;
        string txHash;
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        try
        {
            txHash = await _ledger.IssueAsync(
                issuance.Id,
                issuance.AssetId,
                issuance.IssuerId,
                issuance.TotalAmount,
                issuance.Nominal,
                issuance.IssueDate,
                issuance.MaturityDate,
                scheduleJson,
                ct);

            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Issue successful for {IssuanceId}: txHash={TxHash}, duration={Duration}ms",
                issuance.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Issue failed for {IssuanceId} after {Duration}ms",
                issuance.Id, stopwatch.ElapsedMilliseconds);
            throw new InvalidOperationException($"Failed to issue on ledger: {ex.Message}", ex);
        }

        // Update database
        issuance.Status = IssuanceStatus.Published;
        issuance.PublishedAt = DateTime.UtcNow;
        issuance.UpdatedAt = DateTime.UtcNow;
        issuance.DltTxHash = txHash;

        await _db.SaveChangesAsync(ct);

        // Publish event via outbox
        var schedule = scheduleJson != null
            ? JsonSerializer.Deserialize<Dictionary<string, object>>(scheduleJson)
            : null;

        await _outbox.AddAsync("ois.issuance.published", new
        {
            issuanceId = issuance.Id,
            assetId = issuance.AssetId,
            issuerId = issuance.IssuerId,
            totalAmount = issuance.TotalAmount,
            schedule = schedule,
            publishedAt = issuance.PublishedAt,
            dltTxHash = txHash
        }, ct);

        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Published issuance {IssuanceId} with txHash {TxHash}", issuance.Id, txHash);

        return MapToResponse(issuance);
    }

    public async Task<IssuanceResponse?> CloseAsync(Guid id, CancellationToken ct)
    {
        var issuance = await _db.Issuances.FindAsync(new object[] { id }, ct);
        if (issuance == null)
        {
            _logger.LogWarning("Close requested for missing issuance {IssuanceId}", id);
            return null;
        }

        if (issuance.Status != IssuanceStatus.Published)
            throw new InvalidOperationException($"Cannot close issuance in status {issuance.Status}");

        // Close on ledger
        string txHash;
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        try
        {
            txHash = await _ledger.CloseAsync(issuance.Id, ct);

            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Close successful for {IssuanceId}: txHash={TxHash}, duration={Duration}ms",
                issuance.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Close failed for {IssuanceId} after {Duration}ms",
                issuance.Id, stopwatch.ElapsedMilliseconds);
            throw new InvalidOperationException($"Failed to close on ledger: {ex.Message}", ex);
        }

        // Update database
        issuance.Status = IssuanceStatus.Closed;
        issuance.ClosedAt = DateTime.UtcNow;
        issuance.UpdatedAt = DateTime.UtcNow;
        issuance.DltTxHash = txHash; // Update with latest transaction hash

        await _db.SaveChangesAsync(ct);

        await _outbox.AddAsync("ois.issuance.closed", new
        {
            issuanceId = issuance.Id,
            closedAt = issuance.ClosedAt,
            dltTxHash = txHash
        }, ct);

        await _db.SaveChangesAsync(ct);

        _logger.LogInformation("Closed issuance {IssuanceId} with txHash {TxHash}", issuance.Id, txHash);

        return MapToResponse(issuance);
    }

    private static IssuanceResponse MapToResponse(IssuanceEntity entity)
    {
        Dictionary<string, object>? scheduleJson = null;
        if (!string.IsNullOrEmpty(entity.ScheduleJson))
        {
            scheduleJson = JsonSerializer.Deserialize<Dictionary<string, object>>(entity.ScheduleJson);
        }

        return new IssuanceResponse
        {
            Id = entity.Id,
            AssetId = entity.AssetId,
            IssuerId = entity.IssuerId,
            TotalAmount = entity.TotalAmount,
            Nominal = entity.Nominal,
            IssueDate = entity.IssueDate,
            MaturityDate = entity.MaturityDate,
            Status = entity.Status.ToStringValue(),
            ScheduleJson = scheduleJson,
            DltTxHash = entity.DltTxHash,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            PublishedAt = entity.PublishedAt,
            ClosedAt = entity.ClosedAt
        };
    }
}

>>>> services/issuance/DTOs/IssuerIssuancesReportResponse.cs
using System.ComponentModel.DataAnnotations;

namespace OIS.Issuance.DTOs;

public record IssuerIssuancesReportResponse
{
    [Required]
    public Guid IssuerId { get; init; }

    public IssuerIssuancesReportPeriod? Period { get; init; }

    [Required]
    public IReadOnlyList<IssuerReportRow> Items { get; init; } = Array.Empty<IssuerReportRow>();

    public IssuerIssuancesReportSummary? Summary { get; init; }
}

public record IssuerIssuancesReportPeriod
{
    public DateOnly? From { get; init; }
    public DateOnly? To { get; init; }
}

public record IssuerIssuancesReportSummary
{
    public int TotalIssuances { get; init; }
    public decimal TotalAmount { get; init; }
    public decimal TotalSold { get; init; }
    public int TotalInvestors { get; init; }
}

public record IssuerReportRow
{
    public Guid IssuanceId { get; init; }
    public string AssetCode { get; init; } = string.Empty;
    public string AssetName { get; init; } = string.Empty;
    public decimal TotalAmount { get; init; }
    public decimal SoldAmount { get; init; }
    public int InvestorsCount { get; init; }
    public string Status { get; init; } = string.Empty;
    public DateOnly IssueDate { get; init; }
    public DateOnly MaturityDate { get; init; }
    public DateTime? PublishedAt { get; init; }
}


>>>> services/registry/Program.cs
using Microsoft.EntityFrameworkCore;
using FluentValidation;
using OIS.Registry.Validators;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Registry;
using OIS.Registry.DTOs;
using OIS.Registry.Services;
using Serilog;
using System.Diagnostics;
using MassTransit;
using OIS.Contracts.Events;
using OIS.Registry.Infrastructure;
using Microsoft.AspNetCore.RateLimiting;
using System.Threading.RateLimiting;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("registry-service"))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Database
var registryMigrationsAssembly = typeof(RegistryDbContext).Assembly.GetName().Name;
builder.Services.AddDbContext<RegistryDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions => npgsqlOptions.MigrationsAssembly(registryMigrationsAssembly)));

// HTTP Clients
builder.Services.AddHttpClient<IBankNominalService, BankNominalServiceClient>();
builder.Services.AddHttpClient<IComplianceService, ComplianceServiceClient>();
builder.Services.AddHttpClient<LedgerRegistryAdapter>()
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

// Services
builder.Services.AddScoped<ILedgerRegistry, LedgerRegistryAdapter>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IRegistryService, RegistryService>();

// Validation
builder.Services.AddValidatorsFromAssemblyContaining<CreateOrderRequestValidator>();
builder.Services.AddFluentValidationAutoValidation();

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        if (!string.IsNullOrEmpty(authority))
        {
            options.Authority = authority;
        }
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            RoleClaimType = ClaimTypes.Role
        };

        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx =>
            {
                MapKeycloakRoles(ctx);
                return Task.CompletedTask;
            }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:investor", p => p.RequireRole("investor"));
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:broker", p => p.RequireRole("broker"));
    options.AddPolicy("role:backoffice", p => p.RequireRole("backoffice"));
    options.AddPolicy("role:investor-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
    options.AddPolicy("scope:orders.write", p => p.RequireAssertion(HasScope("orders.write")));
    options.AddPolicy("scope:orders.read", p => p.RequireAssertion(HasScope("orders.read")));
});

// MassTransit + Kafka for publishing
if (builder.Configuration.GetValue<bool>("Kafka:Enabled", true))
{
    builder.Services.AddMassTransit(x =>
    {
        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092");
            });
        });
    });

    builder.Services.AddHostedService<OIS.Registry.Background.OutboxPublisher>();
}

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<RegistryDbContext>();

// Rate limiting
builder.Services.AddRateLimiter(options =>
{
    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
    options.AddPolicy("sensitive", httpContext =>
    {
        var key = GetPartitionKey(httpContext);
        return RateLimitPartition.GetTokenBucketLimiter(key, _ => new TokenBucketRateLimiterOptions
        {
            TokenLimit = 20,
            TokensPerPeriod = 20,
            ReplenishmentPeriod = TimeSpan.FromSeconds(1),
            AutoReplenishment = true,
            QueueLimit = 0,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst
        });
    });
});

var app = builder.Build();

// Apply migrations (optional, via MIGRATE_ON_STARTUP=true)
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<RegistryDbContext>();
    db.Database.Migrate();
}

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.UseRateLimiter();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();

    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Registry").RequireAuthorization();

api.MapPost("/orders", async (
    CreateOrderRequest request,
    HttpContext httpContext,
    IRegistryService service,
    CancellationToken ct) =>
{
    // Get idempotency key from header
    if (!httpContext.Request.Headers.TryGetValue("Idempotency-Key", out var idemKeyValues) ||
        !Guid.TryParse(idemKeyValues.FirstOrDefault(), out var idemKeyGuid))
    {
        return Results.Problem(
            detail: "Idempotency-Key header is required and must be a valid UUID",
            statusCode: 400,
            title: "Bad Request");
    }

    var idemKey = idemKeyGuid.ToString();
    var result = await service.PlaceOrderAsync(request, idemKey, ct);
    return Results.Accepted($"/v1/orders/{result.Id}", result);
})
.WithName("PlaceOrder")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapGet("/orders/{id:guid}", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    var result = await service.GetOrderAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetOrder")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapGet("/wallets/{investorId:guid}", async (
    Guid investorId,
    IRegistryService service,
    CancellationToken ct) =>
{
    var result = await service.GetWalletAsync(investorId, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetWallet")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapPost("/issuances/{id:guid}/redeem", async (
    Guid id,
    RedeemRequest request,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.RedeemAsync(id, request, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: 400,
            title: "Bad Request");
    }
})
.WithName("RedeemIssuance")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapPost("/orders/{id:guid}/cancel", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.CancelOrderAsync(id, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? 404 : 400,
            title: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? "Not Found" : "Bad Request");
    }
})
.WithName("CancelOrder")
.RequireAuthorization("role:investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

api.MapPost("/orders/{id:guid}/mark-paid", async (
    Guid id,
    IRegistryService service,
    CancellationToken ct) =>
{
    try
    {
        var result = await service.MarkPaidAsync(id, null, ct);
        return Results.Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return Results.Problem(
            detail: ex.Message,
            statusCode: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? 404 : 400,
            title: ex.Message.Contains("not found", StringComparison.OrdinalIgnoreCase) ? "Not Found" : "Bad Request");
    }
})
.WithName("MarkOrderPaid")
.RequireAuthorization("role:investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

app.Run();
static Func<Microsoft.AspNetCore.Authorization.AuthorizationHandlerContext, bool> HasScope(string scope) => ctx =>
{
    var scp = ctx.User.FindFirst("scope")?.Value ?? ctx.User.FindFirst("scp")?.Value;
    if (string.IsNullOrWhiteSpace(scp)) return false;
    return scp.Split(' ', StringSplitOptions.RemoveEmptyEntries)
        .Any(s => string.Equals(s, scope, StringComparison.OrdinalIgnoreCase));
};

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { /* ignore parsing errors */ }
}

static string GetPartitionKey(HttpContext ctx)
{
    var sub = ctx.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
    if (!string.IsNullOrEmpty(sub)) return $"user:{sub}";
    return $"ip:{ctx.Connection.RemoteIpAddress}";
}

>>>> services/registry/Services/RegistryService.cs
using Microsoft.EntityFrameworkCore;
using OIS.Registry;
using OIS.Registry.DTOs;
using System.Diagnostics;
using System.Text.Json;

namespace OIS.Registry.Services;

public interface IRegistryService
{
    Task<OrderResponse> PlaceOrderAsync(CreateOrderRequest request, string idempotencyKey, CancellationToken ct);
    Task<OrderResponse?> GetOrderAsync(Guid orderId, CancellationToken ct);
    Task<WalletResponse?> GetWalletAsync(Guid investorId, CancellationToken ct);
    Task<RedeemResponse> RedeemAsync(Guid issuanceId, RedeemRequest request, CancellationToken ct);
    Task<OrderResponse> CancelOrderAsync(Guid orderId, CancellationToken ct);
    Task<OrderResponse> MarkPaidAsync(Guid orderId, string? paymentRef, CancellationToken ct);
}

public class RegistryService : IRegistryService
{
    private readonly RegistryDbContext _db;
    private readonly ILogger<RegistryService> _logger;
    private readonly IComplianceService _compliance;
    private readonly IBankNominalService _bank;
    private readonly ILedgerRegistry _ledger;
    private readonly IOutboxService _outbox;

    public RegistryService(
        RegistryDbContext db,
        ILogger<RegistryService> logger,
        IComplianceService compliance,
        IBankNominalService bank,
        ILedgerRegistry ledger,
        IOutboxService outbox)
    {
        _db = db;
        _logger = logger;
        _compliance = compliance;
        _bank = bank;
        _ledger = ledger;
        _outbox = outbox;
    }

    public async Task<OrderResponse> PlaceOrderAsync(CreateOrderRequest request, string idempotencyKey, CancellationToken ct)
    {
        // Check idempotency
        var existingOrder = await _db.Orders
            .FirstOrDefaultAsync(o => o.IdemKey == idempotencyKey, ct);
        
        if (existingOrder != null)
        {
            _logger.LogInformation("Order with idempotency key {IdemKey} already exists: {OrderId}", 
                idempotencyKey, existingOrder.Id);
            return MapToOrderResponse(existingOrder);
        }

        // (a) Validate KYC/qualification
        var kycOk = await _compliance.CheckKycAsync(request.InvestorId, ct);
        if (!kycOk)
            throw new InvalidOperationException($"KYC check failed for investor {request.InvestorId}");

        var qualOk = await _compliance.CheckQualificationAsync(request.InvestorId, request.Amount, ct);
        if (!qualOk)
            throw new InvalidOperationException($"Qualification check failed for investor {request.InvestorId}: limit exceeded or not qualified");

        // Create order (created)
        var order = new OrderEntity
        {
            Id = Guid.NewGuid(),
            InvestorId = request.InvestorId,
            IssuanceId = request.IssuanceId,
            Amount = request.Amount,
            Status = "created",
            IdemKey = idempotencyKey,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _db.Orders.Add(order);
        await _db.SaveChangesAsync(ct);

        // Emit order.created
        await _outbox.AddAsync("ois.order.created", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            createdAt = order.CreatedAt
        }, ct);

        // Emit order.placed (business-level event: order accepted before funds reservation)
        await _outbox.AddAsync("ois.order.placed", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            placedAt = order.CreatedAt
        }, ct);
        await _db.SaveChangesAsync(ct);

        // (b) Reserve funds via bank-nominal (idempotent)
        string transferId;
        try
        {
            transferId = await _bank.ReserveFundsAsync(request.InvestorId, request.Amount, idempotencyKey, ct);
            _logger.LogInformation("Funds reserved: transferId={TransferId}, investor={Investor}, amount={Amount}",
                transferId, OIS.Domain.Security.MaskGuid(request.InvestorId), request.Amount);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to reserve funds for investor {Investor}", OIS.Domain.Security.MaskGuid(request.InvestorId));
            throw new InvalidOperationException($"Failed to reserve funds: {ex.Message}", ex);
        }

        // Update order to reserved
        order.Status = "reserved";
        order.UpdatedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        await _outbox.AddAsync("ois.order.reserved", new
        {
            orderId = order.Id,
            issuanceId = request.IssuanceId,
            investorId = request.InvestorId,
            amount = request.Amount,
            reservedAt = order.UpdatedAt,
            bankTransferId = transferId
        }, ct);

        await _db.SaveChangesAsync(ct);

        return MapToOrderResponse(order);
    }

    public async Task<OrderResponse?> GetOrderAsync(Guid orderId, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct);
        return order != null ? MapToOrderResponse(order) : null;
    }

    public async Task<WalletResponse?> GetWalletAsync(Guid investorId, CancellationToken ct)
    {
        var wallet = await _db.Wallets
            .FirstOrDefaultAsync(w => w.OwnerId == investorId && w.OwnerType == "individual", ct);

        if (wallet == null)
            return null;

        var holdings = await _db.Holdings
            .Where(h => h.InvestorId == investorId)
            .Select(h => new HoldingDto
            {
                IssuanceId = h.IssuanceId,
                Quantity = h.Quantity,
                UpdatedAt = h.UpdatedAt
            })
            .ToListAsync(ct);

        return new WalletResponse
        {
            InvestorId = investorId,
            Balance = wallet.Balance,
            Blocked = wallet.Blocked,
            Holdings = holdings
        };
    }

    public async Task<RedeemResponse> RedeemAsync(Guid issuanceId, RedeemRequest request, CancellationToken ct)
    {
        // TODO: Get investor from context/auth
        var investorId = Guid.NewGuid(); // Placeholder

        var stopwatch = Stopwatch.StartNew();
        string txHash;
        try
        {
            txHash = await _ledger.RedeemAsync(investorId.ToString(), issuanceId, request.Amount, ct);
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Redeem successful: issuanceId={IssuanceId}, txHash={TxHash}, duration={Duration}ms",
                issuanceId, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex, "Ledger Redeem failed for issuance {IssuanceId}", issuanceId);
            throw new InvalidOperationException($"Failed to redeem on ledger: {ex.Message}", ex);
        }

        // Update holding
        var holding = await _db.Holdings
            .FirstOrDefaultAsync(h => h.InvestorId == investorId && h.IssuanceId == issuanceId, ct);
        
        if (holding != null)
        {
            holding.Quantity -= request.Amount;
            holding.UpdatedAt = DateTime.UtcNow;
        }

        await WriteTransactionAsync(Guid.NewGuid(), "redeem", null, null, issuanceId, request.Amount, txHash, ct);
        await _db.SaveChangesAsync(ct);

        return new RedeemResponse
        {
            IssuanceId = issuanceId,
            RedeemedAmount = request.Amount,
            DltTxHash = txHash,
            RedeemedAt = DateTime.UtcNow
        };
    }

    public async Task<OrderResponse> CancelOrderAsync(Guid orderId, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct)
            ?? throw new InvalidOperationException($"Order {orderId} not found");

        if (order.Status is "paid" or "cancelled")
            throw new InvalidOperationException($"Cannot cancel order in status {order.Status}");

        order.Status = "cancelled";
        order.UpdatedAt = DateTime.UtcNow;
        await _db.SaveChangesAsync(ct);

        return MapToOrderResponse(order);
    }

    public async Task<OrderResponse> MarkPaidAsync(Guid orderId, string? paymentRef, CancellationToken ct)
    {
        var order = await _db.Orders.FindAsync(new object[] { orderId }, ct)
            ?? throw new InvalidOperationException($"Order {orderId} not found");

        // Idempotent: if already paid, return current state
        if (order.Status == "paid")
            return MapToOrderResponse(order);

        if (order.Status != "reserved")
            throw new InvalidOperationException($"Order must be in 'reserved' status to mark paid; actual: {order.Status}");

        // (c) Call ledger registry.Transfer
        var stopwatch = Stopwatch.StartNew();
        string txHash;
        try
        {
            txHash = await _ledger.TransferAsync(null, order.InvestorId.ToString(), order.IssuanceId, order.Amount, ct);
            stopwatch.Stop();
            _logger.LogInformation(
                "Ledger Transfer successful: orderId={OrderId}, txHash={TxHash}, duration={Duration}ms",
                order.Id, txHash, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex,
                "Ledger Transfer failed for order {OrderId} after {Duration}ms",
                order.Id, stopwatch.ElapsedMilliseconds);
            // Keep order in 'reserved' status to allow retry; record failure reason transiently
            order.FailureReason = $"Ledger error: {ex.Message}";
            await _db.SaveChangesAsync(ct);
            throw;
        }

        // Update order -> paid
        order.Status = "paid";
        order.DltTxHash = txHash;
        order.ConfirmedAt = DateTime.UtcNow;
        order.UpdatedAt = DateTime.UtcNow;

        // Wallet + holding
        var wallet = await GetOrCreateWalletAsync(order.InvestorId, "individual", ct);
        order.WalletId = wallet.Id;
        await UpdateHoldingAsync(order.InvestorId, order.IssuanceId, order.Amount, ct);

        // Transactions and events
        await WriteTransactionAsync(order.Id, "transfer", null, wallet.Id, order.IssuanceId, order.Amount, txHash, ct);

        await _outbox.AddAsync("ois.order.paid", new
        {
            orderId = order.Id,
            issuanceId = order.IssuanceId,
            investorId = order.InvestorId,
            amount = order.Amount,
            paidAt = order.ConfirmedAt,
            txHash = txHash
        }, ct);

        await _outbox.AddAsync("ois.order.confirmed", new
        {
            orderId = order.Id,
            confirmedAt = order.ConfirmedAt,
            dltTxHash = txHash,
            walletId = wallet.Id
        }, ct);

        await _outbox.AddAsync("ois.registry.transferred", new
        {
            orderId = order.Id,
            issuanceId = order.IssuanceId,
            investorId = order.InvestorId,
            amount = order.Amount,
            txHash = txHash,
            walletId = wallet.Id,
            transferredAt = order.ConfirmedAt
        }, ct);

        await _db.SaveChangesAsync(ct);
        _logger.LogInformation("Order {OrderId} marked as paid with txHash {TxHash}", order.Id, txHash);

        return MapToOrderResponse(order);
    }

    private async Task<WalletEntity> GetOrCreateWalletAsync(Guid ownerId, string ownerType, CancellationToken ct)
    {
        var wallet = await _db.Wallets
            .FirstOrDefaultAsync(w => w.OwnerId == ownerId && w.OwnerType == ownerType, ct);

        if (wallet == null)
        {
            wallet = new WalletEntity
            {
                Id = Guid.NewGuid(),
                OwnerId = ownerId,
                OwnerType = ownerType,
                Balance = 0,
                Blocked = 0,
                UpdatedAt = DateTime.UtcNow
            };
            _db.Wallets.Add(wallet);
            await _db.SaveChangesAsync(ct);
        }

        return wallet;
    }

    private async Task UpdateHoldingAsync(Guid investorId, Guid issuanceId, decimal quantity, CancellationToken ct)
    {
        var holding = await _db.Holdings
            .FirstOrDefaultAsync(h => h.InvestorId == investorId && h.IssuanceId == issuanceId, ct);

        if (holding == null)
        {
            holding = new HoldingEntity
            {
                Id = Guid.NewGuid(),
                InvestorId = investorId,
                IssuanceId = issuanceId,
                Quantity = 0,
                UpdatedAt = DateTime.UtcNow
            };
            _db.Holdings.Add(holding);
        }

        holding.Quantity += quantity;
        holding.UpdatedAt = DateTime.UtcNow;
    }

    private async Task WriteTransactionAsync(
        Guid id,
        string type,
        Guid? fromWalletId,
        Guid? toWalletId,
        Guid? issuanceId,
        decimal amount,
        string txHash,
        CancellationToken ct)
    {
        var tx = new TransactionEntity
        {
            Id = id,
            Type = type,
            FromWalletId = fromWalletId,
            ToWalletId = toWalletId,
            IssuanceId = issuanceId,
            Amount = amount,
            DltTxHash = txHash,
            Status = "confirmed",
            CreatedAt = DateTime.UtcNow,
            ConfirmedAt = DateTime.UtcNow
        };

        _db.Transactions.Add(tx);
    }

    private static OrderResponse MapToOrderResponse(OrderEntity entity)
    {
        return new OrderResponse
        {
            Id = entity.Id,
            InvestorId = entity.InvestorId,
            IssuanceId = entity.IssuanceId,
            Amount = entity.Amount,
            Status = entity.Status,
            WalletId = entity.WalletId,
            DltTxHash = entity.DltTxHash,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            ConfirmedAt = entity.ConfirmedAt,
            FailureReason = entity.FailureReason
        };
    }
}

public interface IOutboxService
{
    Task AddAsync(string topic, object payload, CancellationToken ct);
}

public class OutboxService : IOutboxService
{
    private readonly RegistryDbContext _db;

    public OutboxService(RegistryDbContext db)
    {
        _db = db;
    }

    public async Task AddAsync(string topic, object payload, CancellationToken ct)
    {
        var message = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            Topic = topic,
            Payload = JsonSerializer.Serialize(payload),
            CreatedAt = DateTime.UtcNow
        };

        _db.OutboxMessages.Add(message);
    }
}

>>>> services/compliance/Program.cs
using Microsoft.EntityFrameworkCore;
using FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using System.Collections.Generic;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using OIS.Compliance;
using OIS.Compliance.DTOs;
using OIS.Compliance.Services;
using OIS.Compliance.Infrastructure;
using MassTransit;
using OIS.Contracts.Events;
using Serilog;
using System.Text;
using System.Text.Json;
using Microsoft.AspNetCore.RateLimiting;
using System.Threading.RateLimiting;

var builder = WebApplication.CreateBuilder(args);

// Serilog
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console(new Serilog.Formatting.Json.JsonFormatter()));

// OpenTelemetry
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService("compliance-service"))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter()
        .AddPrometheusExporter()
        .AddMeter(Metrics.MeterName));

// Database
var complianceMigrationsAssembly = typeof(ComplianceDbContext).Assembly.GetName().Name;
builder.Services.AddDbContext<ComplianceDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions => npgsqlOptions.MigrationsAssembly(complianceMigrationsAssembly)));

// Services
builder.Services.AddScoped<IWatchlistsService, WatchlistsServiceStub>();
builder.Services.AddScoped<IQualificationPolicyService, QualificationPolicyService>();
builder.Services.AddScoped<IOutboxService, OutboxService>();
builder.Services.AddScoped<IComplianceService, ComplianceService>();

// API
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks()
    .AddDbContextCheck<ComplianceDbContext>();

// Rate limiting
builder.Services.AddRateLimiter(options =>
{
    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
    options.AddPolicy("sensitive", httpContext =>
    {
        var key = httpContext.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
        if (!string.IsNullOrEmpty(key)) key = $"user:{key}"; else key = $"ip:{httpContext.Connection.RemoteIpAddress}";
        return RateLimitPartition.GetTokenBucketLimiter(key!, _ => new TokenBucketRateLimiterOptions
        {
            TokenLimit = 10,
            TokensPerPeriod = 10,
            ReplenishmentPeriod = TimeSpan.FromSeconds(1),
            AutoReplenishment = true,
            QueueLimit = 0,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst
        });
    });
});

// AuthN/Z
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var authority = builder.Configuration["Keycloak:Authority"];
        if (!string.IsNullOrEmpty(authority)) options.Authority = authority;
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            RoleClaimType = ClaimTypes.Role
        };
        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx => { MapKeycloakRoles(ctx); return Task.CompletedTask; }
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("role:investor", p => p.RequireRole("investor"));
    options.AddPolicy("role:issuer", p => p.RequireRole("issuer"));
    options.AddPolicy("role:backoffice", p => p.RequireRole("backoffice"));
    options.AddPolicy("role:investor-or-backoffice", p =>
        p.RequireAssertion(ctx => ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
    options.AddPolicy("role:issuer-or-investor-or-backoffice", p =>
        p.RequireAssertion(ctx =>
            ctx.User.IsInRole("issuer") || ctx.User.IsInRole("investor") || ctx.User.IsInRole("backoffice")));
});

// MassTransit + Kafka for publishing
if (builder.Configuration.GetValue<bool>("Kafka:Enabled", true))
{
    builder.Services.AddMassTransit(x =>
    {
        x.AddRider(rider =>
        {
            rider.UsingKafka((context, cfg) =>
            {
                cfg.Host(builder.Configuration["Kafka:BootstrapServers"] ?? "localhost:9092");
            });
        });
    });

    builder.Services.AddHostedService<OIS.Compliance.Background.OutboxPublisher>();
}

var app = builder.Build();

// Apply migrations (optional, via MIGRATE_ON_STARTUP=true)
var migrateOnStartup = Environment.GetEnvironmentVariable("MIGRATE_ON_STARTUP");
if (string.Equals(migrateOnStartup, "true", StringComparison.OrdinalIgnoreCase))
{
    using var scope = app.Services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<ComplianceDbContext>();
    db.Database.Migrate();
}

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapHealthChecks("/health");
app.MapPrometheusScrapingEndpoint("/metrics");
app.UseRateLimiter();

// Correlation + request metrics
app.Use(async (ctx, next) =>
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    if (!ctx.Request.Headers.TryGetValue("X-Request-ID", out var reqId) || string.IsNullOrWhiteSpace(reqId))
    {
        reqId = Guid.NewGuid().ToString();
        ctx.Request.Headers["X-Request-ID"] = reqId;
    }
    ctx.Response.Headers["X-Request-ID"] = reqId.ToString();
    try
    {
        await next();
    }
    finally
    {
        sw.Stop();
        var status = ctx.Response.StatusCode;
        var route = ctx.GetEndpoint()?.DisplayName ?? "unknown";
        var tags = new System.Collections.Generic.KeyValuePair<string, object?>[]
        {
            new("route", route),
            new("method", ctx.Request.Method),
            new("status", status.ToString())
        };
        Metrics.RequestDurationMs.Record(sw.Elapsed.TotalMilliseconds, tags);
        if (status >= 500)
        {
            var errTags = new System.Collections.Generic.KeyValuePair<string, object?>[]
            {
                new("route", route),
                new("method", ctx.Request.Method)
            };
            Metrics.RequestErrors.Add(1, errTags);
        }
    }
});

// (Kafka rider configured above)

// API Endpoints
var api = app.MapGroup("/v1").WithTags("Compliance").RequireAuthorization();

api.MapPost("/compliance/kyc/check", async (
    KycCheckRequest request,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.CheckKycAsync(request, ct);
    return Results.Ok(result);
})
.WithName("CheckKyc")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapPost("/compliance/qualification/evaluate", async (
    QualificationEvaluateRequest request,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.EvaluateQualificationAsync(request, ct);
    return Results.Ok(result);
})
.WithName("EvaluateQualification")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

api.MapGet("/compliance/investors/{id:guid}/status", async (
    Guid id,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.GetInvestorStatusAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetInvestorStatus")
.RequireAuthorization("role:issuer-or-investor-or-backoffice")
.WithOpenApi();

var complaintsApi = app.MapGroup("/v1/complaints").WithTags("Complaints").RequireAuthorization();

complaintsApi.MapPost("", async (
    CreateComplaintRequest request,
    HttpContext httpContext,
    IComplianceService service,
    CancellationToken ct) =>
{
    string? idemKey = null;
    if (httpContext.Request.Headers.TryGetValue("Idempotency-Key", out var idemKeyValues))
    {
        idemKey = idemKeyValues.FirstOrDefault();
    }

    var result = await service.CreateComplaintAsync(request, idemKey, ct);
    return Results.Created($"/v1/complaints/{result.Id}", result);
})
.WithName("CreateComplaint")
.RequireAuthorization("role:investor")
.RequireRateLimiting("sensitive")
.WithOpenApi();

complaintsApi.MapGet("/{id:guid}", async (
    Guid id,
    IComplianceService service,
    CancellationToken ct) =>
{
    var result = await service.GetComplaintAsync(id, ct);
    return result != null ? Results.Ok(result) : Results.NotFound();
})
.WithName("GetComplaint")
.RequireAuthorization("role:investor-or-backoffice")
.WithOpenApi();

// KYC endpoints
var kycApi = app.MapGroup("/v1/compliance/kyc").WithTags("KYC");

kycApi.MapPost("", async (
    KycApplicationRequest request,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actorId = TryGetUserId(http);
    var investorId = request.InvestorId ?? actorId;
    if (investorId is null)
    {
        return Results.BadRequest(new { error = "investorId is required" });
    }

    var reasonParts = new List<string>();
    if (!string.IsNullOrWhiteSpace(request.FullName)) reasonParts.Add($"name={request.FullName}");
    if (!string.IsNullOrWhiteSpace(request.DocumentType) || !string.IsNullOrWhiteSpace(request.DocumentNumber))
    {
        var doc = $"{request.DocumentType} {request.DocumentNumber}".Trim();
        if (!string.IsNullOrWhiteSpace(doc)) reasonParts.Add($"doc={doc}");
    }
    if (!string.IsNullOrWhiteSpace(request.Comment)) reasonParts.Add($"comment={request.Comment}");
    var reason = reasonParts.Count > 0 ? string.Join("; ", reasonParts) : "kyc submitted";

    await service.UpdateKycStatusAsync(investorId.Value, "pending", actorId, reason, ct);
    var task = await service.CreateKycTaskAsync(investorId.Value, reason, ct);

    var dto = new KycRequestDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        Status = NormalizeKycStatus(task.Status),
        Reason = task.Reason,
        CreatedAt = task.CreatedAt,
        ResolvedAt = task.ResolvedAt
    };

    return Results.Created($"/v1/compliance/kyc/{dto.Id}", dto);
})
.WithName("SubmitKycApplication")
.RequireAuthorization("role:issuer-or-investor-or-backoffice")
.RequireRateLimiting("sensitive")
.WithOpenApi();

var kycAdminApi = kycApi.RequireAuthorization("role:backoffice");

kycAdminApi.MapPost("/investors/{id:guid}/approve", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actor = TryGetUserId(http);
    var result = await service.UpdateKycStatusAsync(id, "pass", actor, null, ct);
    return Results.Ok(result);
})
.WithName("ApproveKyc")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycAdminApi.MapPost("/investors/{id:guid}/reject", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var actor = TryGetUserId(http);
    var result = await service.UpdateKycStatusAsync(id, "fail", actor, null, ct);
    return Results.Ok(result);
})
.WithName("RejectKyc")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// Backoffice KYC list + decision (UI expects /v1/compliance/kyc and /v1/compliance/kyc/{id}/decision)
kycAdminApi.MapGet("", async (
    string? status,
    IComplianceService service,
    CancellationToken ct) =>
{
    var tasks = await service.ListKycTasksAsync(status switch
    {
        "pending" => "open",
        "approved" => "approved",
        "rejected" => "rejected",
        _ => null
    }, ct);

    var mapped = tasks.Select(t => new KycRequestDto
    {
        Id = t.Id,
        InvestorId = t.InvestorId,
        Status = NormalizeKycStatus(t.Status),
        Reason = t.Reason,
        CreatedAt = t.CreatedAt,
        ResolvedAt = t.ResolvedAt
    }).ToArray();

    return Results.Ok(mapped);
})
.WithName("ListKycRequests")
.WithOpenApi();

kycAdminApi.MapPost("/{id:guid}/decision", async (
    Guid id,
    KycDecisionRequest body,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    var action = body.Decision?.ToLowerInvariant() == "approved" ? "approve" : "reject";
    var actor = TryGetUserId(http);

    var task = await service.ResolveKycTaskAsync(id, action, actor, body.Comment, ct);
    if (task == null) return Results.NotFound();

    var dto = new KycRequestDto
    {
        Id = task.Id,
        InvestorId = task.InvestorId,
        Status = NormalizeKycStatus(task.Status),
        Reason = task.Reason,
        CreatedAt = task.CreatedAt,
        ResolvedAt = task.ResolvedAt
    };
    return Results.Ok(dto);
})
.WithName("ResolveKycRequest")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// KYC tasks queue
var kycTasks = app.MapGroup("/v1/kyc/tasks").WithTags("KYC Tasks").RequireAuthorization("role:backoffice");

kycTasks.MapPost("", async (
    CreateKycTaskRequest req,
    IComplianceService service,
    CancellationToken ct) =>
{
    var task = await service.CreateKycTaskAsync(req.InvestorId, req.Reason, ct);
    return Results.Created($"/v1/kyc/tasks/{task.Id}", task);
})
.WithName("CreateKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycTasks.MapGet("", async (
    string? status,
    IComplianceService service,
    CancellationToken ct) =>
{
    var list = await service.ListKycTasksAsync(status, ct);
    return Results.Ok(list);
})
.WithName("ListKycTasks")
.WithOpenApi();

kycTasks.MapPost("/{id:guid}/approve", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    Guid? actor = http.User.Identity?.IsAuthenticated == true ?
        http.User.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.NameIdentifier)?.Value is string s && Guid.TryParse(s, out var g) ? g : null
        : null;

    var task = await service.ResolveKycTaskAsync(id, "approve", actor, null, ct);
    return task != null ? Results.Ok(task) : Results.NotFound();
})
.WithName("ApproveKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

kycTasks.MapPost("/{id:guid}/reject", async (
    Guid id,
    HttpContext http,
    IComplianceService service,
    CancellationToken ct) =>
{
    Guid? actor = http.User.Identity?.IsAuthenticated == true ?
        http.User.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.NameIdentifier)?.Value is string s && Guid.TryParse(s, out var g) ? g : null
        : null;

    var task = await service.ResolveKycTaskAsync(id, "reject", actor, null, ct);
    return task != null ? Results.Ok(task) : Results.NotFound();
})
.WithName("RejectKycTask")
.RequireRateLimiting("sensitive")
.WithOpenApi();

// Audit reporting (immutable, from outbox write-ahead log)
var auditApi = app.MapGroup("/v1/audit").WithTags("Audit").RequireAuthorization("role:backoffice");

auditApi.MapGet("", async (
    Guid? actor,
    string? action,
    string? entity,
    DateTime? from,
    DateTime? to,
    int? limit,
    int? offset,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var q = db.OutboxMessages
        .Where(m => m.Topic == "ois.audit.logged")
        .OrderByDescending(m => m.CreatedAt)
        .AsEnumerable();

    IEnumerable<OutboxMessage> filtered = q;

    filtered = filtered.Where(m =>
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            var root = doc.RootElement;
            if (actor.HasValue)
            {
                var actorVal = root.TryGetProperty("actor", out var el) ? el.GetString() : null;
                if (!Guid.TryParse(actorVal, out var a) || a != actor.Value) return false;
            }
            if (!string.IsNullOrEmpty(action))
            {
                var act = root.TryGetProperty("action", out var el) ? el.GetString() : null;
                if (!string.Equals(act, action, StringComparison.OrdinalIgnoreCase)) return false;
            }
            if (!string.IsNullOrEmpty(entity))
            {
                var ent = root.TryGetProperty("entity", out var el) ? el.GetString() : null;
                if (!string.Equals(ent, entity, StringComparison.OrdinalIgnoreCase)) return false;
            }
            var ts = root.TryGetProperty("timestamp", out var tsEl) && tsEl.ValueKind == JsonValueKind.String
                ? DateTime.Parse(tsEl.GetString()!)
                : m.CreatedAt;
            if (from.HasValue && ts < from.Value) return false;
            if (to.HasValue && ts > to.Value) return false;
            return true;
        }
        catch
        {
            return false;
        }
    });

    var take = Math.Clamp(limit ?? 20, 1, 100);
    var skip = Math.Max(offset ?? 0, 0);
    var page = filtered.Skip(skip).Take(take).Select(m => MapAudit(m)).ToList();

    return Results.Ok(new { items = page });
})
.WithName("GetAuditEvents")
.WithOpenApi();

auditApi.MapGet("/{id:guid}", async (
    Guid id,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var msg = await db.OutboxMessages
        .Where(m => m.Topic == "ois.audit.logged")
        .OrderByDescending(m => m.CreatedAt)
        .ToListAsync(ct);

    foreach (var m in msg)
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            if (doc.RootElement.TryGetProperty("id", out var idEl) && idEl.ValueKind == JsonValueKind.String)
            {
                if (Guid.TryParse(idEl.GetString(), out var aid) && aid == id)
                    return Results.Ok(MapAudit(m));
            }
        }
        catch { }
    }
    return Results.NotFound();
})
.WithName("GetAuditEvent")
.WithOpenApi();

auditApi.MapGet("/export.csv", async (
    Guid? actor,
    string? action,
    string? entity,
    DateTime? from,
    DateTime? to,
    ComplianceDbContext db,
    CancellationToken ct) =>
{
    var sb = new StringBuilder();
    // Stable header
    sb.AppendLine("id,actor,actorName,action,entity,entityId,result,timestamp,ip,userAgent");

    var rows = db.OutboxMessages
        .Where(m => m.Topic == "ois.audit.logged")
        .OrderBy(m => m.CreatedAt) // chronological for exports
        .AsEnumerable();

    foreach (var m in rows)
    {
        try
        {
            using var doc = JsonDocument.Parse(m.Payload);
            var r = doc.RootElement;
            var idStr = r.TryGetProperty("id", out var idEl) ? idEl.GetString() : null;
            var actorStr = r.TryGetProperty("actor", out var actEl) ? actEl.GetString() : null;
            var actorName = r.TryGetProperty("actorName", out var anEl) ? anEl.GetString() : null;
            var actionStr = r.TryGetProperty("action", out var acEl) ? acEl.GetString() : null;
            var entityStr = r.TryGetProperty("entity", out var enEl) ? enEl.GetString() : null;
            var entityId = r.TryGetProperty("entityId", out var eiEl) ? eiEl.GetString() : null;
            var result = r.TryGetProperty("result", out var resEl) ? resEl.GetString() : null;
            var ts = r.TryGetProperty("timestamp", out var tsEl) ? tsEl.GetString() : m.CreatedAt.ToString("O");
            var ip = r.TryGetProperty("ip", out var ipEl) ? ipEl.GetString() : null;
            var ua = r.TryGetProperty("userAgent", out var uaEl) ? uaEl.GetString() : null;

            // Filter checks
            if (actor.HasValue && (!Guid.TryParse(actorStr, out var a) || a != actor.Value)) continue;
            if (!string.IsNullOrEmpty(action) && !string.Equals(actionStr, action, StringComparison.OrdinalIgnoreCase)) continue;
            if (!string.IsNullOrEmpty(entity) && !string.Equals(entityStr, entity, StringComparison.OrdinalIgnoreCase)) continue;
            if (from.HasValue && DateTime.Parse(ts) < from.Value) continue;
            if (to.HasValue && DateTime.Parse(ts) > to.Value) continue;

            sb.AppendLine(string.Join(',', new[]
            {
                Csv(idStr), Csv(actorStr), Csv(actorName), Csv(actionStr), Csv(entityStr), Csv(entityId), Csv(result), Csv(ts), Csv(ip), Csv(ua)
            }));
        }
        catch { }
    }

    return Results.Text(sb.ToString(), "text/csv", Encoding.UTF8);
})
.WithName("ExportAuditCsv")
.WithOpenApi();

static string Csv(string? s)
{
    if (s is null) return "";
    var needsQuotes = s.Contains(',') || s.Contains('"') || s.Contains('\n') || s.Contains('\r');
    var escaped = s.Replace("\"", "\"\"");
    return needsQuotes ? $"\"{escaped}\"" : escaped;
}

static object MapAudit(OutboxMessage m)
{
    try
    {
        using var doc = JsonDocument.Parse(m.Payload);
        var r = doc.RootElement;
        return new
        {
            id = Guid.TryParse(r.TryGetProperty("id", out var idEl) ? idEl.GetString() : null, out var aid) ? aid : m.Id,
            actor = r.TryGetProperty("actor", out var actEl) ? actEl.GetString() : null,
            actorName = r.TryGetProperty("actorName", out var anEl) ? anEl.GetString() : null,
            action = r.TryGetProperty("action", out var acEl) ? acEl.GetString() : null,
            entity = r.TryGetProperty("entity", out var enEl) ? enEl.GetString() : null,
            entityId = r.TryGetProperty("entityId", out var eiEl) ? eiEl.GetString() : null,
            payload = r.TryGetProperty("payload", out var pEl) ? pEl : default(JsonElement?),
            ip = r.TryGetProperty("ip", out var ipEl) ? ipEl.GetString() : null,
            userAgent = r.TryGetProperty("userAgent", out var uaEl) ? uaEl.GetString() : null,
            timestamp = r.TryGetProperty("timestamp", out var tsEl) ? tsEl.GetString() : m.CreatedAt.ToString("O"),
            result = r.TryGetProperty("result", out var resEl) ? resEl.GetString() : null
        };
    }
    catch
    {
        return new { id = m.Id, timestamp = m.CreatedAt.ToString("O") };
    }
}

app.Run();

static string NormalizeKycStatus(string status) => status switch
{
    "open" => "pending",
    "approved" => "approved",
    "rejected" => "rejected",
    _ => "pending"
};

static Guid? TryGetUserId(HttpContext http)
{
    var raw =
        http.User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value ??
        http.User.Claims.FirstOrDefault(c => c.Type == "sub")?.Value;
    return Guid.TryParse(raw, out var id) ? id : null;
}

static void MapKeycloakRoles(TokenValidatedContext ctx)
{
    try
    {
        if (ctx.Principal?.Identity is not ClaimsIdentity identity) return;
        var realmAccessJson = identity.FindFirst("realm_access")?.Value;
        if (!string.IsNullOrEmpty(realmAccessJson))
        {
            using var doc = System.Text.Json.JsonDocument.Parse(realmAccessJson);
            if (doc.RootElement.TryGetProperty("roles", out var rolesEl) && rolesEl.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var r in rolesEl.EnumerateArray())
                {
                    var role = r.GetString();
                    if (!string.IsNullOrEmpty(role))
                        identity.AddClaim(new Claim(ClaimTypes.Role, role));
                }
            }
        }
    }
    catch { }
}

public partial class Program { }

>>>> services/compliance/DTOs/KycRequestDto.cs
namespace OIS.Compliance.DTOs;

public record KycRequestDto
{
    public Guid Id { get; init; }
    public Guid InvestorId { get; init; }
    public string Status { get; init; } = "pending"; // pending | approved | rejected
    public string? Reason { get; init; }
    public DateTime CreatedAt { get; init; }
    public DateTime? ResolvedAt { get; init; }
}

public record KycDecisionRequest
{
    public string Decision { get; init; } = string.Empty; // approved | rejected
    public string? Comment { get; init; }
}

>>>> services/identity/Program.cs
using Microsoft.EntityFrameworkCore;
using Serilog;
using System.Collections.Generic;
using System.Linq;

var builder = WebApplication.CreateBuilder(args);

builder.Host.UseSerilog((ctx, lc) => lc
    .WriteTo.Console()
    .ReadFrom.Configuration(ctx.Configuration));

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks();
builder.Services.AddDbContext<IdentityDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.MapHealthChecks("/health");

app.MapGet("/.well-known/openid-configuration", () => Results.Ok(new
{
    issuer = builder.Configuration["Keycloak:Authority"],
    authorization_endpoint = $"{builder.Configuration["Keycloak:Authority"]}/protocol/openid-connect/auth",
    token_endpoint = $"{builder.Configuration["Keycloak:Authority"]}/protocol/openid-connect/token",
    userinfo_endpoint = "/userinfo",
    response_types_supported = new[] { "code" },
    scopes_supported = new[] { "openid", "profile", "email" }
}));

app.MapGet("/userinfo", () => Results.Ok(new
{
    sub = Guid.NewGuid().ToString(),
    email = "test@example.com",
    email_verified = true,
    name = "Test User"
}));

// Simple in-memory registry for backoffice UI until real Keycloak/registry integration is ready
var seededUsers = new List<User>
{
    new() { Id = Guid.Parse("11111111-1111-1111-1111-111111111111"), Email = "issuer@example.com", Role = "issuer", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-5) },
    new() { Id = Guid.Parse("22222222-2222-2222-2222-222222222222"), Email = "backoffice@example.com", Role = "backoffice", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-10) },
    new() { Id = Guid.Parse("33333333-3333-3333-3333-333333333333"), Email = "investor@example.com", Role = "investor", Status = "active", CreatedAt = DateTime.UtcNow.AddDays(-15) }
};

app.MapGet("/users", () => Results.Ok(seededUsers.Select(MapUser)));
app.MapGet("/users/{id:guid}", (Guid id) =>
{
    var user = seededUsers.FirstOrDefault(u => u.Id == id);
    return user is null ? Results.NotFound() : Results.Ok(MapUser(user));
});

app.MapGet("/v1/identity/users", (string? query) =>
{
    var filtered = string.IsNullOrWhiteSpace(query)
        ? seededUsers
        : seededUsers.Where(u => u.Email.Contains(query, StringComparison.OrdinalIgnoreCase) || u.Role.Contains(query, StringComparison.OrdinalIgnoreCase)).ToList();
    return Results.Ok(filtered.Select(MapUser));
});

app.Run();

static object MapUser(User u) => new
{
    id = u.Id,
    email = u.Email,
    roles = new[] { u.Role },
    status = u.Status,
    createdAt = u.CreatedAt
};

// Minimal DbContext for now
public class IdentityDbContext : DbContext
{
    public IdentityDbContext(DbContextOptions<IdentityDbContext> options) : base(options) { }
    public DbSet<User> Users => Set<User>();
}

public class User
{
    public Guid Id { get; set; }
    public string Email { get; set; } = string.Empty;
    public string Role { get; set; } = string.Empty;
    public string Status { get; set; } = "active";
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

>>>> apps/backoffice/src/app/audit/page.tsx
'use client';

import { useMemo, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import Link from 'next/link';
import { getAuditLogs } from '@/lib/api/audit';
import type { AuditEvent, AuditFilters } from '@/lib/api/audit';

const actionOptions = [
  { label: 'All actions', value: '' },
  { label: 'KYC', value: 'kyc' },
  { label: 'Auth', value: 'login' },
  { label: 'Issuance', value: 'issuance' },
];

export default function AuditPage() {
  const [from, setFrom] = useState('');
  const [to, setTo] = useState('');
  const [action, setAction] = useState('');
  const [actor, setActor] = useState('');
  const [selectedEvent, setSelectedEvent] = useState<AuditEvent | null>(null);

  const filters = useMemo<AuditFilters>(
    () => ({
      from: from || undefined,
      to: to || undefined,
      action: action || undefined,
      actor: actor || undefined,
    }),
    [from, to, action, actor],
  );

  const {
    data: events = [],
    isLoading,
    refetch,
  } = useQuery({
    queryKey: ['audit-logs', filters],
    queryFn: () => getAuditLogs(filters),
  });

  const resetFilters = () => {
    setFrom('');
    setTo('');
    setAction('');
    setActor('');
    setSelectedEvent(null);
    refetch();
  };

  return (
    <main className="mx-auto max-w-6xl space-y-8 px-6 py-10">
      <header className="space-y-2">
        <p className="text-sm text-gray-500">Audit Explorer</p>
        <h1 className="text-3xl font-semibold text-gray-900">Audit Log</h1>
        <p className="text-sm text-gray-600">
          Inspect issuer/backoffice actions. Filters are applied at API level with mock fallback when backend .
        </p>
      </header>

      <section className="rounded-xl border border-gray-200 bg-white p-5 shadow-sm">
        <div className="grid gap-4 md:grid-cols-4">
          <label className="flex flex-col gap-1 text-sm text-gray-600">
            From
            <input
              type="date"
              value={from}
              onChange={(event) => setFrom(event.target.value)}
              className="rounded-md border border-gray-300 px-3 py-2 text-gray-900 focus:border-blue-500 focus:outline-none"
            />
          </label>
          <label className="flex flex-col gap-1 text-sm text-gray-600">
            To
            <input
              type="date"
              value={to}
              onChange={(event) => setTo(event.target.value)}
              className="rounded-md border border-gray-300 px-3 py-2 text-gray-900 focus:border-blue-500 focus:outline-none"
            />
          </label>
          <label className="flex flex-col gap-1 text-sm text-gray-600">
            Action
            <select
              value={action}
              onChange={(event) => setAction(event.target.value)}
              className="rounded-md border border-gray-300 px-3 py-2 text-gray-900 focus:border-blue-500 focus:outline-none"
            >
              {actionOptions.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </label>
          <label className="flex flex-col gap-1 text-sm text-gray-600">
            Actor
            <input
              type="text"
              value={actor}
              placeholder="issuer.portal"
              onChange={(event) => setActor(event.target.value)}
              className="rounded-md border border-gray-300 px-3 py-2 text-gray-900 focus:border-blue-500 focus:outline-none"
            />
          </label>
        </div>
        <div className="mt-4 flex items-center gap-3">
          <button
            type="button"
            onClick={() => refetch()}
            className="rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50"
            disabled={isLoading}
          >
            Apply Filters
          </button>
          <button
            type="button"
            onClick={resetFilters}
            className="rounded-md border border-gray-300 px-4 py-2 text-sm text-gray-600 hover:bg-gray-50"
          >
            Reset
          </button>
        </div>
      </section>

      <section className="rounded-xl border border-gray-200 bg-white shadow-sm">
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200 text-sm">
            <thead className="bg-gray-50 text-left text-xs font-semibold uppercase tracking-wider text-gray-500">
              <tr>
                <th className="px-4 py-3">Timestamp</th>
                <th className="px-4 py-3">Actor</th>
                <th className="px-4 py-3">Action</th>
                <th className="px-4 py-3">Entity</th>
                <th className="px-4 py-3 text-right">Status</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-100">
              {isLoading && (
                <tr>
                  <td colSpan={5} className="px-4 py-6 text-center text-gray-500">
                    Loading audit events
                  </td>
                </tr>
              )}
              {!isLoading && events.length === 0 && (
                <tr>
                  <td colSpan={5} className="px-4 py-6 text-center text-gray-400">
                    No events for selected filters.
                  </td>
                </tr>
              )}
              {events.map((event) => (
                <tr key={event.id} className="hover:bg-gray-50">
                  <td className="px-4 py-3 align-top text-sm text-gray-900">
                    {new Date(event.timestamp).toLocaleString()}
                  </td>
                  <td className="px-4 py-3">
                    <div className="font-medium text-gray-900">{event.actorName ?? event.actor}</div>
                    {event.ip && <div className="text-xs text-gray-500">{event.ip}</div>}
                  </td>
                  <td className="px-4 py-3 text-gray-800">
                    <div className="font-medium">{event.action}</div>
                    {event.payload && (
                      <button
                        type="button"
                        className="text-xs text-blue-600 hover:underline"
                        onClick={() => setSelectedEvent(event)}
                      >
                        View payload
                      </button>
                    )}
                  </td>
                  <td className="px-4 py-3 text-gray-700">
                    <div>{event.entity}</div>
                    {event.entityId && <div className="text-xs text-gray-500">{event.entityId}</div>}
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex flex-col items-end gap-2 text-sm">
                      <span className="rounded-full bg-gray-100 px-2 py-0.5 text-xs capitalize text-gray-700">
                        {event.result ?? 'pending'}
                      </span>
                      <Link href={`/audit/${event.id}`} className="text-xs font-medium text-blue-600 hover:underline">
                        Details
                      </Link>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </section>

      {selectedEvent && (
        <section className="rounded-xl border border-blue-200 bg-white p-5 shadow-sm">
          <div className="flex items-start justify-between">
            <div>
              <p className="text-sm text-gray-500">Payload preview</p>
              <h2 className="text-xl font-semibold text-gray-900">{selectedEvent.action}</h2>
              <p className="text-sm text-gray-600">
                Event ID: <span className="font-mono">{selectedEvent.id}</span>
              </p>
            </div>
            <button
              type="button"
              className="text-sm text-gray-500 hover:text-gray-700"
              onClick={() => setSelectedEvent(null)}
            >
              Close
            </button>
          </div>
          <pre className="mt-4 max-h-64 overflow-auto rounded-lg bg-gray-900 p-4 text-xs text-green-200">
            {JSON.stringify(selectedEvent.payload ?? {}, null, 2)}
          </pre>
        </section>
      )}
    </main>
  );
}

>>>> apps/backoffice/src/app/audit/[id]/page.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { getAuditEvent } from '@/lib/api/audit';
import type { AuditEvent } from '@/lib/api/audit';
import { AppShell, PageHeader, EmptyState, Skeleton } from '../../../../../shared-ui/src';
import { useSession } from 'next-auth/react';
import { useRouter, useParams } from 'next/navigation';
import { useEffect } from 'react';
import Link from 'next/link';
import { ArrowLeft } from 'lucide-react';

export default function AuditEventDetailPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const params = useParams();
  const eventId = params.id as string;

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const { data: event, isLoading } = useQuery<AuditEvent | null>({
    queryKey: ['audit-event', eventId],
    queryFn: () => getAuditEvent(eventId),
    enabled: !!eventId && status === 'authenticated',
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  if (isLoading) {
    return (
      <AppShell
        user={session.user}
        sidebar={{
          items: [
            { label: 'Dashboard', href: '/' },
            { label: 'KYC', href: '/kyc' },
            { label: 'Qualification', href: '/qualification' },
            { label: 'Audit', href: '/audit' },
            { label: 'Payouts', href: '/payouts' },
          ],
        }}
      >
        <Skeleton className="h-64 w-full" variant="rectangular" />
      </AppShell>
    );
  }

  if (!event) {
    return (
      <AppShell
        user={session.user}
        sidebar={{
          items: [
            { label: 'Dashboard', href: '/' },
            { label: 'KYC', href: '/kyc' },
            { label: 'Qualification', href: '/qualification' },
            { label: 'Audit', href: '/audit' },
            { label: 'Payouts', href: '/payouts' },
          ],
        }}
      >
        <EmptyState
          title="Audit event not found"
          description="The audit event you're looking for doesn't exist"
        />
      </AppShell>
    );
  }

  return (
    <AppShell
      user={session.user}
      sidebar={{
        items: [
          { label: 'Dashboard', href: '/' },
          { label: 'KYC', href: '/kyc' },
          { label: 'Qualification', href: '/qualification' },
          { label: 'Audit', href: '/audit' },
          { label: 'Payouts', href: '/payouts' },
        ],
      }}
    >
      <PageHeader
        title={`Audit Event ${eventId.slice(0, 8)}`}
        description="Audit event details"
        breadcrumbs={[
          { label: 'Audit', href: '/audit' },
          { label: eventId.slice(0, 8) },
        ]}
        actions={
          <Link
            href="/audit"
            className="flex items-center gap-2 px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover"
          >
            <ArrowLeft className="h-4 w-4" />
            Back
          </Link>
        }
      />

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-surface border border-border rounded-lg p-6">
          <h2 className="text-lg font-semibold text-text-primary mb-4">Event Information</h2>
          <div className="space-y-3 text-sm">
            <div className="flex justify-between">
              <span className="text-text-secondary">ID:</span>
              <span className="text-text-primary font-mono">{event.id}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-text-secondary">Timestamp:</span>
              <span className="text-text-primary">
                {new Date(event.timestamp).toLocaleString()}
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-text-secondary">Actor:</span>
              <span className="text-text-primary">{event.actorName || event.actor}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-text-secondary">Action:</span>
              <span className="text-text-primary font-medium">{event.action}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-text-secondary">Entity:</span>
              <span className="text-text-primary">{event.entity}</span>
            </div>
            {event.entityId && (
              <div className="flex justify-between">
                <span className="text-text-secondary">Entity ID:</span>
                <span className="text-text-primary font-mono">{event.entityId}</span>
              </div>
            )}
            {event.result && (
              <div className="flex justify-between">
                <span className="text-text-secondary">Result:</span>
                <span className="text-text-primary">{event.result}</span>
              </div>
            )}
          </div>
        </div>

        <div className="bg-surface border border-border rounded-lg p-6">
          <h2 className="text-lg font-semibold text-text-primary mb-4">Request Details</h2>
          <div className="space-y-3 text-sm">
            {event.ip && (
              <div className="flex justify-between">
                <span className="text-text-secondary">IP Address:</span>
                <span className="text-text-primary font-mono">{event.ip}</span>
              </div>
            )}
            {event.userAgent && (
              <div className="flex flex-col">
                <span className="text-text-secondary mb-1">User Agent:</span>
                <span className="text-text-primary text-xs break-all">{event.userAgent}</span>
              </div>
            )}
          </div>
        </div>
      </div>

      {event.payload && Object.keys(event.payload).length > 0 && (
        <div className="mt-6 bg-surface border border-border rounded-lg p-6">
          <h2 className="text-lg font-semibold text-text-primary mb-4">Payload</h2>
          <pre className="bg-background p-4 rounded-md overflow-auto text-sm text-text-primary font-mono">
            {JSON.stringify(event.payload, null, 2)}
          </pre>
        </div>
      )}
    </AppShell>
  );
}

>>>> apps/backoffice/src/app/kyc/page.tsx
'use client';

import { useState } from 'react';
import { useQuery, useMutation } from '@tanstack/react-query';
import { listKycRequests, submitKycDecision, KycRequest } from '@/lib/api/compliance';

export default function KycPage() {
  const [activeStatus, setActiveStatus] = useState<'pending' | 'approved' | 'rejected'>('pending');
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const [comment, setComment] = useState('');

  const {
    data: requests,
    isLoading,
    refetch,
  } = useQuery({
    queryKey: ['kyc-requests', activeStatus],
    queryFn: () => listKycRequests(activeStatus),
  });

  const decisionMutation = useMutation({
    mutationFn: ({ id, decision }: { id: string; decision: 'approved' | 'rejected' }) =>
      submitKycDecision(id, decision, comment),
    onSuccess: () => {
      setComment('');
      setSelectedId(null);
      refetch();
    },
  });

  const selected = requests?.find((req) => req.id === selectedId);

  return (
    <main className="mx-auto max-w-5xl px-6 py-10 space-y-8">
      <header>
        <h1 className="text-3xl font-semibold">KYC Applications</h1>
        <p className="text-sm text-gray-500">
          Review investor applications and record decisions. Data is loaded from Compliance API
          (temporarily mocked if backend ).
        </p>
      </header>

      <section className="flex items-center gap-2">
        {(['pending', 'approved', 'rejected'] as const).map((status) => (
          <button
            key={status}
            onClick={() => setActiveStatus(status)}
            className={`rounded-md border px-4 py-2 text-sm ${
              activeStatus === status ? 'border-blue-600 text-blue-600' : 'border-gray-300 text-gray-600'
            }`}
          >
            {status.toUpperCase()}
          </button>
        ))}
      </section>

      <section className="overflow-x-auto rounded-lg border border-gray-200 bg-white">
        <table className="min-w-full divide-y divide-gray-200 text-sm">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Investor</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Status</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Created</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Actions</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-100">
            {isLoading && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-center text-gray-500">
                  Loading applications
                </td>
              </tr>
            )}
            {!isLoading && (requests?.length ?? 0) === 0 && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-center text-gray-400">
                  No applications for this filter.
                </td>
              </tr>
            )}
            {requests?.map((request: KycRequest) => (
              <tr key={request.id} className={selectedId === request.id ? 'bg-blue-50' : undefined}>
                <td className="px-4 py-2">
                  <div className="font-medium">{request.investorId}</div>
                  {request.amlFlags && (
                    <div className="text-xs text-red-600">AML flags: {request.amlFlags.join(', ')}</div>
                  )}
                </td>
                <td className="px-4 py-2 capitalize">{request.status}</td>
                <td className="px-4 py-2">{new Date(request.createdAt).toLocaleString()}</td>
                <td className="px-4 py-2 space-x-2">
                  <button
                    className="text-sm text-blue-600 underline"
                    onClick={() => setSelectedId(request.id)}
                  >
                    Details
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </section>

      {selected && (
        <section className="rounded-lg border border-gray-200 bg-white p-4 space-y-3">
          <h2 className="text-lg font-semibold">Decision for {selected.investorId}</h2>
          <p className="text-sm text-gray-500">
            Status: <span className="font-medium">{selected.status}</span>
          </p>
          {selected.reason && (
            <p className="text-sm text-gray-500">
              Reason: <span className="font-medium">{selected.reason}</span>
            </p>
          )}
          {selected.resolvedAt && (
            <p className="text-xs text-gray-400">
              Resolved at: {new Date(selected.resolvedAt).toLocaleString()}
            </p>
          )}
          <textarea
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm"
            placeholder="Decision comment"
            value={comment}
            onChange={(e) => setComment(e.target.value)}
          />
          <div className="flex gap-2">
            <button
              className="rounded-md bg-green-600 px-4 py-2 text-sm text-white disabled:opacity-40"
              disabled={decisionMutation.isPending}
              onClick={() => decisionMutation.mutate({ id: selected.id, decision: 'approved' })}
            >
              Approve
            </button>
            <button
              className="rounded-md bg-red-600 px-4 py-2 text-sm text-white disabled:opacity-40"
              disabled={decisionMutation.isPending}
              onClick={() => decisionMutation.mutate({ id: selected.id, decision: 'rejected' })}
            >
              Reject
            </button>
          </div>
        </section>
      )}
    </main>
  );
}

>>>> apps/backoffice/src/app/payouts/page.tsx
'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import { getPayoutsReport, runSettlement } from '@/lib/api/reports';
import type { PayoutReport } from '@/lib/api/reports';

export default function PayoutsPage() {
  const queryClient = useQueryClient();

  const { data: report, isLoading } = useQuery<PayoutReport>({
    queryKey: ['payouts-report'],
    queryFn: async () => {
      const to = new Date();
      const from = new Date();
      from.setDate(from.getDate() - 30);
      return getPayoutsReport({
        from: from.toISOString().slice(0, 10),
        to: to.toISOString().slice(0, 10),
      });
    },
  });

  const runSettlementMutation = useMutation({
    mutationFn: (date?: string) => runSettlement(date ? { date } : undefined),
    onSuccess: () => {
      toast.success('Settlement started');
      queryClient.invalidateQueries({ queryKey: ['payouts-report'] });
    },
    onError: (error: unknown) => {
      const message = error instanceof Error ? error.message : 'Failed to run settlement';
      toast.error(message);
    },
  });

  const summary: PayoutReport =
    report ?? {
      totalAmount: 0,
      totalItems: 0,
      items: [],
    };

  return (
    <div className="container mx-auto p-8 space-y-6">
      <div className="flex flex-wrap items-center justify-between gap-4">
        <div>
          <p className="text-sm text-gray-500">Issuer Settlement</p>
          <h1 className="text-3xl font-bold text-gray-900">Payouts</h1>
        </div>
        <button
          onClick={() => runSettlementMutation.mutate(undefined)}
          disabled={runSettlementMutation.isPending}
          className="rounded-lg bg-blue-600 px-6 py-3 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50"
        >
          {runSettlementMutation.isPending ? 'Running' : 'Run Settlement'}
        </button>
      </div>

      {isLoading && <div>Loading report</div>}

      {!isLoading && (
        <div className="rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <h2 className="text-xl font-semibold mb-4 text-gray-900">Last 30 days</h2>
          <div className="grid gap-4 sm:grid-cols-2">
            <div>
              <p className="text-sm text-gray-500">Total Amount</p>
              <p className="text-2xl font-bold text-gray-900">{summary.totalAmount.toLocaleString()}</p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Items Count</p>
              <p className="text-2xl font-bold text-gray-900">{summary.totalItems}</p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Executed</p>
              <p className="text-2xl font-semibold text-emerald-600">
                {summary.items.filter((item) => item.status === 'executed').length}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Failed</p>
              <p className="text-2xl font-semibold text-red-600">
                {summary.items.filter((item) => item.status === 'failed').length}
              </p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

>>>> apps/backoffice/src/app/users/page.tsx
'use client';

import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { listUsers, UserRecord } from '@/lib/api/compliance';

export default function UsersPage() {
  const [query, setQuery] = useState('');

  const { data: users, isLoading } = useQuery({
    queryKey: ['backoffice-users', query],
    queryFn: () => listUsers(query),
  });

  return (
    <main className="mx-auto max-w-5xl px-6 py-10 space-y-6">
      <header className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
        <div>
          <h1 className="text-3xl font-semibold">User Registry</h1>
          <p className="text-sm text-gray-500">Search and review platform users.</p>
        </div>
        <input
          className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm sm:w-64"
          placeholder="Search by email or ID"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
      </header>

      <section className="overflow-x-auto rounded-lg border border-gray-200 bg-white">
        <table className="min-w-full divide-y divide-gray-200 text-sm">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-4 py-2 text-left font-medium text-gray-600">User</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Roles</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Status</th>
              <th className="px-4 py-2 text-left font-medium text-gray-600">Created</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-100">
            {isLoading && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-center text-gray-500">
                  Loading users
                </td>
              </tr>
            )}
            {!isLoading && (users?.length ?? 0) === 0 && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-center text-gray-400">
                  No users found.
                </td>
              </tr>
            )}
            {users?.map((user: UserRecord) => (
              <tr key={user.id}>
                <td className="px-4 py-2">
                  <div className="font-medium">{user.email ?? user.id}</div>
                  <div className="text-xs text-gray-500">{user.id}</div>
                </td>
                <td className="px-4 py-2 text-sm text-gray-700">{user.roles.join(', ')}</td>
                <td className="px-4 py-2 capitalize">{user.status}</td>
                <td className="px-4 py-2">{new Date(user.createdAt).toLocaleDateString()}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </section>
    </main>
  );
}

>>>> apps/portal-issuer/src/app/dashboard/page.tsx
'use client';

import { useSession } from 'next-auth/react';
import { redirect } from 'next/navigation';
import { AppShell, PageHeader, KPIGrid, Skeleton } from '@ois/shared-ui';
import { FileText, DollarSign, Users } from 'lucide-react';
import Link from 'next/link';
import { useQuery } from '@tanstack/react-query';
import { getIssuerReports } from '@/lib/api/issuances';
import { issuerNav } from '@/lib/nav';

export default function DashboardPage() {
  const { data: session, status } = useSession();

  const issuerId =
    (session?.user as any)?.issuerId || (session?.user as any)?.id || '';

  const {
    data: issuancesReport,
    isLoading: reportLoading,
    isError: reportError,
    error,
  } = useQuery({
    queryKey: ['issuer-dashboard-report', issuerId],
    queryFn: async () => getIssuerReports(issuerId),
    enabled: status === 'authenticated' && !!issuerId,
    retry: 0,
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    redirect('/auth/signin');
  }

  const roles = (session.user as any)?.roles || [];
  if (!roles.includes('issuer')) {
    return <div className="p-8">Access denied. Issuer role required.</div>;
  }

  const summary = issuancesReport?.summary;
  const formatCurrency = (value?: number) =>
    typeof value === 'number'
      ? new Intl.NumberFormat('ru-RU', {
          style: 'currency',
          currency: 'RUB',
          maximumFractionDigits: 0,
        }).format(value)
      : '-';

  const kpiData = [
    {
      title: 'Total Issuances',
      value: summary ? summary.totalIssuances.toString() : '-',
      description: 'All issuances for this issuer',
      icon: FileText,
    },
    {
      title: 'Total Amount',
      value: formatCurrency(summary?.totalAmount),
      description: 'Aggregated nominal',
      icon: DollarSign,
    },
    {
      title: 'Investors',
      value: summary ? summary.totalInvestors.toString() : '-',
      description: 'Investors across issuances',
      icon: Users,
    },
  ];

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: issuerNav }}
    >
      <PageHeader
        title="Dashboard"
        description="Overview of your issuances and activity"
      />

      {reportLoading ? (
        <div className="grid grid-cols-1 gap-4 mb-8 md:grid-cols-3">
          {[0, 1, 2].map((i) => (
            <Skeleton key={i} className="h-32 w-full rounded-xl" />
          ))}
        </div>
      ) : (
        <KPIGrid items={kpiData} columns={3} className="mb-8" />
      )}

      {reportError && (
        <div className="mb-4 rounded-md border border-red-200 bg-red-50 p-4 text-sm text-red-800">
          Failed to load dashboard data: {(error as Error)?.message ?? 'Unknown error'}
        </div>
      )}

      <div className="space-y-4">
        <Link
          href="/issuances"
          className="inline-block bg-primary-600 text-white px-6 py-3 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
        >
          View Issuances
        </Link>
        <Link
          href="/issuances/create"
          className="inline-block bg-success-600 text-white px-6 py-3 rounded-md hover:bg-success-700 focus:outline-none focus:ring-2 focus:ring-success-500 focus:ring-offset-2 ml-4"
        >
          Create New Issuance
        </Link>
      </div>
    </AppShell>
  );
}

>>>> apps/portal-issuer/src/app/issuances/page.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import Link from 'next/link';
import { useSession } from 'next-auth/react';
import { redirect } from 'next/navigation';

export default function IssuancesPage() {
  const { data: session, status } = useSession();

  const { data: issuances, isLoading, error } = useQuery({
    queryKey: ['issuances'],
    queryFn: async () => {
      // TODO: Add endpoint to list issuances
      return [];
    },
    enabled: status === 'authenticated',
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    redirect('/auth/signin');
  }

  return (
    <div className="container mx-auto p-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Issuances</h1>
        <Link
          href="/issuances/create"
          className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700"
        >
          Create New
        </Link>
      </div>

      {isLoading && <div>Loading issuances...</div>}
      {error && <div className="text-red-600">Error loading issuances</div>}
      
      {issuances && issuances.length === 0 && (
        <div className="text-gray-500">No issuances found. Create your first issuance.</div>
      )}

      {issuances && issuances.length > 0 && (
        <div className="space-y-4">
          {issuances.map((issuance: any) => (
            <div key={issuance.id} className="bg-white p-6 rounded-lg shadow">
              <div className="flex justify-between items-center">
                <div>
                  <h2 className="text-xl font-semibold">Issuance {issuance.id}</h2>
                  <p className="text-gray-600">Status: {issuance.status}</p>
                  <p className="text-gray-600">Amount: {issuance.totalAmount}</p>
                </div>
                <div className="space-x-2">
                  <Link
                    href={`/issuances/${issuance.id}`}
                    className="bg-gray-200 text-gray-800 px-4 py-2 rounded hover:bg-gray-300"
                  >
                    View
                  </Link>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

>>>> apps/portal-issuer/src/app/reports/page.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { getIssuerReports } from '@/lib/api/issuances';
import type { IssuerReportRow, IssuerPayoutsReportResponse } from '@ois/api-client';
import {
  AppShell,
  PageHeader,
  DataTable,
  BarChart,
  LineChart,
  ChartContainer,
  EmptyState,
  Skeleton,
} from '@ois/shared-ui';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';
import { ColumnDef } from '@tanstack/react-table';
import { Download } from 'lucide-react';
import { toast } from 'sonner';
import * as XLSX from 'xlsx';
import { issuerNav } from '@/lib/nav';

// Using types from SDK

export default function ReportsPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<'issuances' | 'payouts'>('issuances');
  const [dateRange, setDateRange] = useState({
    from: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    to: new Date().toISOString().split('T')[0],
  });
  const [granularity, setGranularity] = useState<'day' | 'week' | 'month' | 'year'>('month');

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  const issuerId =
    (session?.user as any)?.issuerId || (session?.user as any)?.id || '';

  const { data: issuancesReport, isLoading: issuancesLoading } = useQuery({
    queryKey: ['issuer-issuances-report', issuerId, dateRange.from, dateRange.to],
    queryFn: async () => getIssuerReports(issuerId, dateRange),
    enabled: status === 'authenticated' && activeTab === 'issuances' && !!issuerId,
    retry: 0,
  });

  const { data: payoutsReport, isLoading: payoutsLoading } = useQuery({
    queryKey: ['issuer-payouts-report', issuerId, dateRange.from, dateRange.to, granularity],
    queryFn: async () => {
      const response = await apiClient.getIssuerPayoutsReport({
        issuerId,
        from: dateRange.from,
        to: dateRange.to,
        granularity,
      });
      return response.data;
    },
    enabled: status === 'authenticated' && activeTab === 'payouts' && !!issuerId,
    retry: 0,
  });

  if (status === 'loading') {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  const issuancesColumns: ColumnDef<IssuerReportRow>[] = [
    {
      accessorKey: 'assetCode',
      header: 'Asset Code',
      cell: ({ row }) => (
        <span className="text-sm font-medium text-text-primary">
          {row.original.assetCode}
        </span>
      ),
    },
    {
      accessorKey: 'assetName',
      header: 'Asset Name',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.assetName}</span>
      ),
    },
    {
      accessorKey: 'totalAmount',
      header: 'Total Amount',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">
          {row.original.totalAmount.toLocaleString()}
        </span>
      ),
    },
    {
      accessorKey: 'soldAmount',
      header: 'Sold Amount',
      cell: ({ row }) => (
        <span className="text-sm font-medium text-text-primary">
          {row.original.soldAmount.toLocaleString()}
        </span>
      ),
    },
    {
      accessorKey: 'investorsCount',
      header: 'Investors',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">
          {row.original.investorsCount}
        </span>
      ),
    },
    {
      accessorKey: 'status',
      header: 'Status',
      cell: ({ row }) => {
        const status = row.original.status;
        const colors: Record<string, string> = {
          published: 'bg-success-100 text-success-700 dark:bg-success-900 dark:text-success-300',
          draft: 'bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300',
          closed: 'bg-warning-100 text-warning-700 dark:bg-warning-900 dark:text-warning-300',
          redeemed: 'bg-info-100 text-info-700 dark:bg-info-900 dark:text-info-300',
        };
        return (
          <span
            className={`px-2 py-1 text-xs font-medium rounded ${colors[status] || ''}`}
          >
            {status}
          </span>
        );
      },
    },
    {
      accessorKey: 'publishedAt',
      header: 'Published',
      cell: ({ row }) => (
        <span className="text-xs text-text-tertiary">
          {row.original.publishedAt
            ? new Date(row.original.publishedAt).toLocaleDateString()
            : '-'}
        </span>
      ),
    },
  ];

  type PayoutReportRow = IssuerPayoutsReportResponse['items'][number];

  const payoutColumns: ColumnDef<PayoutReportRow>[] = [
    {
      accessorKey: 'period',
      header: 'Period',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.period}</span>
      ),
    },
    {
      accessorKey: 'totalAmount',
      header: 'Total Amount',
      cell: ({ row }) => (
        <span className="text-sm font-medium text-text-primary">
          {row.original.totalAmount.toLocaleString()}
        </span>
      ),
    },
    {
      accessorKey: 'payoutCount',
      header: 'Payout Count',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.payoutCount}</span>
      ),
    },
    {
      accessorKey: 'investorsCount',
      header: 'Investors',
      cell: ({ row }) => (
        <span className="text-sm text-text-primary">{row.original.investorsCount}</span>
      ),
    },
  ];

  const exportToCSV = (data: any[], filename: string) => {
    if (!data || data.length === 0) return;

    const headers = activeTab === 'issuances'
      ? ['Asset Code', 'Asset Name', 'Total Amount', 'Sold Amount', 'Investors', 'Status', 'Published']
      : ['Period', 'Total Amount', 'Payout Count', 'Investors Count'];

    const rows = data.map((item) => {
      if (activeTab === 'issuances') {
        return [
          item.assetCode,
          item.assetName,
          item.totalAmount,
          item.soldAmount,
          item.investorsCount,
          item.status,
          item.publishedAt ? new Date(item.publishedAt).toLocaleDateString() : '-',
        ];
      } else {
        return [
          item.period,
          item.totalAmount,
          item.payoutCount,
          item.investorsCount,
        ];
      }
    });

    const csv = [headers, ...rows]
      .map((row) => row.map((cell) => `"${cell}"`).join(','))
      .join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const exportToXLSX = () => {
    const data = activeTab === 'issuances'
      ? issuancesReport?.items || []
      : payoutsReport?.items || [];

    if (data.length === 0) {
      toast.error('No data to export');
      return;
    }

    try {
      const headers = activeTab === 'issuances'
        ? ['Issuance ID', 'Asset Code', 'Asset Name', 'Total Amount', 'Sold Amount', 'Investors', 'Status', 'Issue Date', 'Maturity Date']
        : ['Period', 'Total Amount', 'Payout Count', 'Investors Count'];

      const rows = data.map((item: any) => {
        if (activeTab === 'issuances') {
          return [
            item.issuanceId,
            item.assetCode,
            item.assetName,
            item.totalAmount,
            item.soldAmount,
            item.investorsCount,
            item.status,
            new Date(item.issueDate).toLocaleDateString(),
            new Date(item.maturityDate).toLocaleDateString(),
          ];
        } else {
          return [
            item.period,
            item.totalAmount,
            item.payoutCount,
            item.investorsCount,
          ];
        }
      });

      const worksheet = XLSX.utils.aoa_to_sheet([headers, ...rows]);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, activeTab === 'issuances' ? 'Issuances' : 'Payouts');
      XLSX.writeFile(workbook, `${activeTab}-report-${new Date().toISOString().split('T')[0]}.xlsx`);
      toast.success('XLSX exported successfully');
    } catch (error: any) {
      toast.error(`Export failed: ${error.message}`);
    }
  };

  return (
    <AppShell
      user={session.user}
      sidebar={{ items: issuerNav }}
    >
      <PageHeader
        title="Reports"
        description="Issuances and payouts analytics"
        actions={
          <div className="flex gap-2">
            <button
              onClick={() =>
                exportToCSV(
                  activeTab === 'issuances'
                    ? issuancesReport?.items || []
                    : payoutsReport?.items || [],
                  activeTab === 'issuances' ? 'issuances-report' : 'payouts-report'
                )
              }
              className="flex items-center gap-2 px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
              disabled={
                activeTab === 'issuances'
                  ? !issuancesReport?.items?.length
                  : !payoutsReport?.items?.length
              }
            >
              <Download className="h-4 w-4" />
              Export CSV
            </button>
            <button
              onClick={exportToXLSX}
              className="flex items-center gap-2 px-4 py-2 border border-border rounded-md bg-surface text-text-primary hover:bg-surface-hover focus:outline-none focus:ring-2 focus:ring-primary-500"
              disabled={
                activeTab === 'issuances'
                  ? !issuancesReport?.items?.length
                  : !payoutsReport?.items?.length
              }
            >
              <Download className="h-4 w-4" />
              Export XLSX
            </button>
          </div>
        }
      />

      {/* Filters */}
      <div className="mb-6 flex flex-wrap gap-4 items-end">
        <div>
          <label
            htmlFor="from"
            className="block text-sm font-medium text-text-primary mb-1"
          >
            From
          </label>
          <input
            id="from"
            type="date"
            value={dateRange.from}
            onChange={(e) =>
              setDateRange({ ...dateRange, from: e.target.value })
            }
            className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
          />
        </div>
        <div>
          <label
            htmlFor="to"
            className="block text-sm font-medium text-text-primary mb-1"
          >
            To
          </label>
          <input
            id="to"
            type="date"
            value={dateRange.to}
            onChange={(e) =>
              setDateRange({ ...dateRange, to: e.target.value })
            }
            className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
          />
        </div>
        {activeTab === 'payouts' && (
          <div>
            <label
              htmlFor="granularity"
              className="block text-sm font-medium text-text-primary mb-1"
            >
              Granularity
            </label>
            <select
              id="granularity"
              value={granularity}
              onChange={(e) =>
                setGranularity(e.target.value as 'day' | 'week' | 'month' | 'year')
              }
              className="px-4 py-2 border border-border rounded-md bg-surface text-text-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              <option value="day">Day</option>
              <option value="week">Week</option>
              <option value="month">Month</option>
              <option value="year">Year</option>
            </select>
          </div>
        )}
      </div>

      {/* Tabs */}
      <div className="mb-6 border-b border-border">
        <div className="flex gap-4">
          <button
            onClick={() => setActiveTab('issuances')}
            className={`px-4 py-2 font-medium border-b-2 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 rounded-t ${
              activeTab === 'issuances'
                ? 'border-primary-600 text-primary-600'
                : 'border-transparent text-text-secondary hover:text-text-primary'
            }`}
          >
            Issuances
          </button>
          <button
            onClick={() => setActiveTab('payouts')}
            className={`px-4 py-2 font-medium border-b-2 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 rounded-t ${
              activeTab === 'payouts'
                ? 'border-primary-600 text-primary-600'
                : 'border-transparent text-text-secondary hover:text-text-primary'
            }`}
          >
            Payouts
          </button>
        </div>
      </div>

      {/* Issuances Tab */}
      {activeTab === 'issuances' && (
        <>
          {issuancesLoading && (
            <Skeleton className="h-64 w-full" variant="rectangular" />
          )}
          {!issuancesLoading && issuancesReport && (
            <>
              {/* Summary Cards */}
              {issuancesReport.summary && (
                <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Issuances</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {issuancesReport.summary.totalIssuances}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Amount</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {issuancesReport.summary.totalAmount.toLocaleString()}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Sold</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {issuancesReport.summary.totalSold.toLocaleString()}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Investors</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {issuancesReport.summary.totalInvestors}
                    </p>
                  </div>
                </div>
              )}

              {/* Chart */}
              {issuancesReport.items && issuancesReport.items.length > 0 && (
                <div className="mb-6">
                  <ChartContainer title="Sold vs Total Amount">
                    <BarChart
                      data={issuancesReport.items.map((item: IssuerReportRow) => ({
                        name: item.assetCode,
                        total: item.totalAmount,
                        sold: item.soldAmount,
                      }))}
                      bars={[
                        { dataKey: 'total', name: 'Total', color: '#3b82f6' },
                        { dataKey: 'sold', name: 'Sold', color: '#22c55e' },
                      ]}
                      height={300}
                    />
                  </ChartContainer>
                </div>
              )}

              {/* Table */}
              <DataTable
                columns={issuancesColumns}
                data={issuancesReport.items || []}
                searchable
                searchPlaceholder="Search issuances..."
                pageSize={10}
              />
            </>
          )}
          {!issuancesLoading && (!issuancesReport || issuancesReport.items?.length === 0) && (
            <EmptyState
              title="No issuances found"
              description="Your issuances will appear here"
            />
          )}
        </>
      )}

      {/* Payouts Tab */}
      {activeTab === 'payouts' && (
        <>
          {payoutsLoading && (
            <Skeleton className="h-64 w-full" variant="rectangular" />
          )}
          {!payoutsLoading && payoutsReport && (
            <>
              {/* Summary */}
              {payoutsReport.summary && (
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Amount</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {payoutsReport.summary.totalAmount.toLocaleString()}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Total Payouts</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {payoutsReport.summary.totalPayouts}
                    </p>
                  </div>
                  <div className="bg-surface border border-border rounded-lg p-4">
                    <p className="text-sm text-text-secondary mb-1">Investors</p>
                    <p className="text-2xl font-bold text-text-primary">
                      {payoutsReport.summary.totalInvestors}
                    </p>
                  </div>
                </div>
              )}

              {/* Chart */}
              {payoutsReport.items && payoutsReport.items.length > 0 && (
                <div className="mb-6">
                  <ChartContainer
                    title={`Payouts Over Time (${granularity})`}
                    description="Payout amounts by period"
                  >
                    <LineChart
                      data={(payoutsReport.items as PayoutReportRow[]).map((item) => ({
                        name: item.period,
                        amount: item.totalAmount,
                        count: item.payoutCount,
                      }))}
                      lines={[
                        {
                          dataKey: 'amount',
                          name: 'Amount',
                          color: '#3b82f6',
                        },
                        {
                          dataKey: 'count',
                          name: 'Count',
                          color: '#22c55e',
                        },
                      ]}
                      height={300}
                    />
                  </ChartContainer>
                </div>
              )}

              {/* Table */}
              {payoutsReport.items && payoutsReport.items.length > 0 && (
                <DataTable
                  columns={payoutColumns}
                  data={payoutsReport.items as PayoutReportRow[]}
                  searchable={false}
                  pageSize={10}
                />
              )}

              {(!payoutsReport.items || payoutsReport.items.length === 0) && (
                <EmptyState
                  title="No payouts found"
                  description="Your payout history will appear here"
                />
              )}
            </>
          )}
        </>
      )}
    </AppShell>
  );
}

>>>> apps/portal-issuer/src/app/issuances/[id]/page.tsx
'use client';

import { useQuery, useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { extractScheduleItems, PayoutScheduleItem } from '@/lib/api/issuances';
import { useParams, useRouter } from 'next/navigation';
import { toast } from 'sonner';

export default function IssuanceDetailPage() {
  const params = useParams();
  const router = useRouter();
  const id = params.id as string;

  const { data: issuance, isLoading } = useQuery({
    queryKey: ['issuance', id],
    queryFn: async () => {
      const response = await apiClient.getIssuance(id);
      return response.data;
    },
    enabled: !!id,
  });

  const publishMutation = useMutation({
    mutationFn: async () => {
      await apiClient.publishIssuance(id);
    },
    onSuccess: () => {
      toast.success('Issuance published');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to publish');
    },
  });

  const closeMutation = useMutation({
    mutationFn: async () => {
      await apiClient.closeIssuance(id);
    },
    onSuccess: () => {
      toast.success('Issuance closed');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to close');
    },
  });

  if (isLoading) {
    return <div className="p-8">Loading...</div>;
  }

  if (!issuance) {
    return <div className="p-8">Issuance not found</div>;
  }

  const scheduleItems = extractScheduleItems(issuance.scheduleJson);

  return (
    <div className="container mx-auto p-8 space-y-6">
      <h1 className="text-3xl font-bold">Issuance {id}</h1>
      
      <div className="bg-white p-6 rounded-lg shadow">
        <div className="space-y-2">
          <p><strong>Status:</strong> {issuance.status}</p>
          <p><strong>Total Amount:</strong> {issuance.totalAmount}</p>
          <p><strong>Nominal:</strong> {issuance.nominal}</p>
          <p><strong>Issue Date:</strong> {issuance.issueDate}</p>
          <p><strong>Maturity Date:</strong> {issuance.maturityDate}</p>
        </div>
      </div>

      <section className="bg-white p-6 rounded-lg shadow space-y-4">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold">Payout Schedule</h2>
            <p className="text-sm text-gray-500">
              Read-only view, powered by <code>scheduleJson</code>. API from NX-06 SPEC is pending.
            </p>
          </div>
          <button
            type="button"
            disabled
            title="Coming soon (Backend API pending)"
            className="px-4 py-2 rounded-md bg-gray-200 text-gray-500 cursor-not-allowed"
          >
            Manage Schedule
          </button>
        </div>

        {scheduleItems.length > 0 ? (
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200 text-sm">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-4 py-2 text-left font-medium text-gray-600">Date</th>
                  <th className="px-4 py-2 text-left font-medium text-gray-600">Amount</th>
                  <th className="px-4 py-2 text-left font-medium text-gray-600">Status</th>
                  <th className="px-4 py-2 text-left font-medium text-gray-600">Note</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-100 bg-white">
                {scheduleItems.map((item: PayoutScheduleItem) => (
                  <tr key={item.id}>
                    <td className="px-4 py-2">{new Date(item.date).toLocaleDateString()}</td>
                    <td className="px-4 py-2">
                      {item.amount.toLocaleString(undefined, { maximumFractionDigits: 2 })}
                    </td>
                    <td className="px-4 py-2 capitalize">{item.status}</td>
                    <td className="px-4 py-2 text-gray-500">{item.note ?? ''}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ) : (
          <div className="rounded-md border border-dashed border-gray-300 p-4 text-sm text-gray-500">
            No payout schedule defined yet. Use Manage Schedule when NX-06 backend endpoints are available.
          </div>
        )}
      </section>

      <div className="space-x-4">
        {issuance.status === 'draft' && (
          <button
            onClick={() => publishMutation.mutate()}
            disabled={publishMutation.isPending}
            className="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 disabled:opacity-50"
          >
            {publishMutation.isPending ? 'Publishing...' : 'Publish'}
          </button>
        )}
        {issuance.status === 'published' && (
          <button
            onClick={() => closeMutation.mutate()}
            disabled={closeMutation.isPending}
            className="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 disabled:opacity-50"
          >
            {closeMutation.isPending ? 'Closing...' : 'Close'}
          </button>
        )}
        <button
          onClick={() => router.back()}
          className="bg-gray-200 text-gray-800 px-6 py-3 rounded-lg hover:bg-gray-300"
        >
          Back
        </button>
      </div>
    </div>
  );
}

>>>> packages/contracts/openapi-gateway.yaml
openapi: 3.1.0
info:
  title: OIS Gateway API
  version: 1.0.0
  description: API Gateway     
  contact:
    name: OIS Support
servers:
  - url: http://localhost:5000
    description: Development
  - url: https://api.ois.example.com
    description: Production

paths:
  /health:
    get:
      summary: Health check
      operationId: healthCheck
      tags:
        - Health
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthStatus'
  
  /issuances:
    post:
      summary: Create draft issuance
      operationId: createIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateIssuanceRequest'
      responses:
        '201':
          description: Issuance created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
  
  /issuances/{id}:
    get:
      summary: Get issuance by ID
      operationId: getIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '404':
          $ref: '#/components/responses/NotFound'
    
  /issuances/{id}/publish:
    post:
      summary: Publish issuance
      operationId: publishIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance published
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /issuances/{id}/close:
    post:
      summary: Close issuance
      operationId: closeIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      responses:
        '200':
          description: Issuance closed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuanceResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/orders:
    post:
      summary: Place buy order
      operationId: placeOrder
      tags:
        - Orders
      security:
        - BearerAuth: []
      parameters:
        - name: Idempotency-Key
          in: header
          required: true
          schema:
            type: string
            format: uuid
          description: Idempotency key to prevent duplicate orders
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        '202':
          description: Order accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '409':
          description: Order with this idempotency key already exists
  
  /orders/{id}:
    get:
      summary: Get order by ID
      operationId: getOrder
      tags:
        - Orders
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Order details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/wallets/{investorId}:
    get:
      summary: Get wallet portfolio
      operationId: getWallet
      tags:
        - Wallets
      security:
        - BearerAuth: []
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Wallet portfolio
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WalletResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/issuances/{id}/redeem:
    post:
      summary: Redeem issuance
      operationId: redeemIssuance
      tags:
        - Issuances
      security:
        - BearerAuth: []
      parameters:
        - $ref: '#/components/parameters/IssuanceId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RedeemRequest'
      responses:
        '200':
          description: Issuance redeemed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RedeemResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/settlement/run:
    post:
      summary: Run settlement for a specific date
      operationId: runSettlement
      tags:
        - Settlement
      security:
        - BearerAuth: []
      parameters:
        - name: date
          in: query
          schema:
            type: string
            format: date
          description: Date to run settlement for (YYYY-MM-DD). Defaults to today.
      responses:
        '202':
          description: Settlement accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SettlementResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/kyc/check:
    post:
      summary: Check KYC status
      operationId: checkKyc
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycCheckRequest'
      responses:
        '200':
          description: KYC check result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/qualification/evaluate:
    post:
      summary: Evaluate qualification
      operationId: evaluateQualification
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QualificationEvaluateRequest'
      responses:
        '200':
          description: Qualification result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QualificationResult'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/compliance/investors/{id}/status:
    get:
      summary: Get investor compliance status
      operationId: getInvestorStatus
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Investor status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InvestorStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

  /v1/compliance/kyc:
    get:
      summary: List KYC requests (tasks)
      operationId: listKycRequests
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: status
          in: query
          required: false
          schema:
            type: string
            enum: [pending, approved, rejected]
          description: Filter by status
      responses:
        '200':
          description: List of KYC requests
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/KycRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
    post:
      summary: Submit KYC application (investor/issuer)
      operationId: submitKycApplication
      tags:
        - Compliance
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycApplicationRequest'
      responses:
        '201':
          description: KYC application created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycRequest'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/compliance/kyc/{id}/decision:
    post:
      summary: Resolve KYC request (approve/reject)
      operationId: resolveKycRequest
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: KYC task identifier
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycDecisionRequest'
      responses:
        '200':
          description: Updated KYC request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycRequest'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/complaints:
    post:
      summary: Create complaint
      operationId: createComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: Idempotency-Key
          in: header
          required: false
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateComplaintRequest'
      responses:
        '201':
          description: Complaint created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
  
  /v1/complaints/{id}:
    get:
      summary: Get complaint
      operationId: getComplaint
      tags:
        - Complaints
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Complaint details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComplaintResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /v1/reports/payouts:
    get:
      summary: Get payouts report
      operationId: getPayoutsReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Payouts report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PayoutsReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'

  /v1/market/issuances:
    get:
      summary: List market issuances
      operationId: listMarketIssuances
      tags:
        - Market
      security:
        - BearerAuth: []
      parameters:
        - name: status
          in: query
          schema:
            type: string
            enum: [open, closed, all]
            default: open
          description: Filter by status
        - name: sort
          in: query
          schema:
            type: string
            enum: [-yield, yield, -maturityDate, maturityDate, -totalAmount, totalAmount]
            default: -yield
          description: Sort order (prefix - for descending)
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
          description: Page size
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
          description: Page offset
      responses:
        '200':
          description: Market issuances list
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MarketIssuancesResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/market/issuances/{id}:
    get:
      summary: Get market issuance details
      operationId: getMarketIssuance
      tags:
        - Market
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Issuance ID
      responses:
        '200':
          description: Market issuance details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MarketIssuanceCard'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/investors/{id}/transactions:
    get:
      summary: Get investor transaction history
      operationId: getInvestorTransactions
      tags:
        - Investors
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
        - name: type
          in: query
          schema:
            type: string
            enum: [transfer, redeem, issue, all]
            default: all
          description: Filter by transaction type
      responses:
        '200':
          description: Transaction history
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TransactionHistoryResponse'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/investors/{id}/payouts:
    get:
      summary: Get investor payout history
      operationId: getInvestorPayouts
      tags:
        - Investors
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Payout history
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PayoutHistoryResponse'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/reports/issuances:
    get:
      summary: Get issuer report for issuances
      operationId: getIssuerIssuancesReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: issuerId
          in: query
          required: true
          schema:
            type: string
            format: uuid
          description: Issuer ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
      responses:
        '200':
          description: Issuer issuances report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuerIssuancesReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/reports/issuer/payouts:
    get:
      summary: Get issuer payouts report
      operationId: getIssuerPayoutsReport
      tags:
        - Reports
      security:
        - BearerAuth: []
      parameters:
        - name: issuerId
          in: query
          required: true
          schema:
            type: string
            format: uuid
          description: Issuer ID
        - name: from
          in: query
          schema:
            type: string
            format: date
          description: Start date (YYYY-MM-DD)
        - name: to
          in: query
          schema:
            type: string
            format: date
          description: End date (YYYY-MM-DD)
        - name: granularity
          in: query
          schema:
            type: string
            enum: [day, week, month, year]
            default: month
          description: Report granularity
      responses:
        '200':
          description: Issuer payouts report
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IssuerPayoutsReportResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /v1/audit:
    get:
      summary: Get audit events
      operationId: getAuditEvents
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: actor
          in: query
          schema:
            type: string
            format: uuid
          description: Filter by actor ID
        - name: action
          in: query
          schema:
            type: string
          description: Filter by action type
        - name: entity
          in: query
          schema:
            type: string
          description: Filter by entity type
        - name: from
          in: query
          schema:
            type: string
            format: date-time
          description: Start datetime
        - name: to
          in: query
          schema:
            type: string
            format: date-time
          description: End datetime
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
          description: Page size
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
          description: Page offset
      responses:
        '200':
          description: Audit events list
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuditEventsResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/audit/export.csv:
    get:
      summary: Export audit events as CSV
      operationId: exportAuditCsv
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: actor
          in: query
          schema:
            type: string
            format: uuid
        - name: action
          in: query
          schema:
            type: string
        - name: entity
          in: query
          schema:
            type: string
        - name: from
          in: query
          schema:
            type: string
            format: date-time
        - name: to
          in: query
          schema:
            type: string
            format: date-time
      responses:
        '200':
          description: CSV export
          content:
            text/csv:
              schema:
                type: string
                format: binary
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/audit/{id}:
    get:
      summary: Get audit event by ID
      operationId: getAuditEvent
      tags:
        - Audit
      security:
        - BearerAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Audit event ID
      responses:
        '200':
          description: Audit event details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuditEvent'
        '404':
          $ref: '#/components/responses/NotFound'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/identity/users:
    get:
      summary: List users (Identity registry stub)
      operationId: listIdentityUsers
      tags:
        - Identity
      parameters:
        - name: query
          in: query
          required: false
          schema:
            type: string
          description: Filter by email/role
      responses:
        '200':
          description: List of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/IdentityUser'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/kyc/{investorId}/decision:
    post:
      summary: Make KYC decision
      operationId: makeKycDecision
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/KycDecisionRequest'
      responses:
        '200':
          description: KYC decision made
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycDecisionResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

  /v1/kyc/{investorId}/documents:
    post:
      summary: Upload KYC documents
      operationId: uploadKycDocuments
      tags:
        - Compliance
      security:
        - BearerAuth: []
      parameters:
        - name: investorId
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: Investor ID
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              required:
                - files
              properties:
                files:
                  type: array
                  items:
                    type: string
                    format: binary
                documentType:
                  type: string
                  enum: [passport, inn, snils, address_proof, income_proof, other]
                comment:
                  type: string
                  description: Optional comment
      responses:
        '201':
          description: Documents uploaded
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KycDocumentsResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  parameters:
    IssuanceId:
      name: id
      in: path
      required: true
      schema:
        type: string
        format: uuid
      description: Issuance ID
  
  schemas:
    HealthStatus:
      type: object
      properties:
        status:
          type: string
          enum: [healthy, unhealthy]
        timestamp:
          type: string
          format: date-time
    
    CreateIssuanceRequest:
      type: object
      required:
        - assetId
        - issuerId
        - totalAmount
        - nominal
        - issueDate
        - maturityDate
      properties:
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        nominal:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        scheduleJson:
          type: object
          description: Payout schedule (optional)
    
    IssuanceResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        assetId:
          type: string
          format: uuid
        issuerId:
          type: string
          format: uuid
        totalAmount:
          type: number
          format: decimal
        nominal:
          type: number
          format: decimal
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        status:
          type: string
          enum: [draft, published, closed, redeemed]
        scheduleJson:
          type: object
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    RedeemRequest:
      type: object
      required:
        - amount
      properties:
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    RedeemResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        status:
          type: string
          enum: [redeemed, partial]
        redeemedAmount:
          type: number
          format: decimal
        remainingAmount:
          type: number
          format: decimal

    # Cross-file references to service schemas
    SettlementResponse:
      $ref: 'openapi-settlement.yaml#/components/schemas/SettlementResponse'
    KycCheckRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/KycCheckRequest'
    KycResult:
      $ref: 'openapi-compliance.yaml#/components/schemas/KycResult'
    QualificationEvaluateRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/QualificationEvaluateRequest'
    QualificationResult:
      $ref: 'openapi-compliance.yaml#/components/schemas/QualificationResult'
    InvestorStatusResponse:
      $ref: 'openapi-compliance.yaml#/components/schemas/InvestorStatusResponse'
    CreateComplaintRequest:
      $ref: 'openapi-compliance.yaml#/components/schemas/CreateComplaintRequest'
    ComplaintResponse:
      $ref: 'openapi-compliance.yaml#/components/schemas/ComplaintResponse'
    
    CreateOrderRequest:
      type: object
      required:
        - investorId
        - issuanceId
        - amount
      properties:
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true
    
    OrderResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [created, reserved, paid, failed, cancelled]
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    WalletResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        ownerType:
          type: string
          enum: [individual, legal_entity]
        ownerId:
          type: string
          format: uuid
        balance:
          type: number
          format: decimal
        blocked:
          type: number
          format: decimal
        holdings:
          type: array
          items:
            $ref: '#/components/schemas/Holding'
    
    Holding:
      type: object
      properties:
        assetId:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        amount:
          type: number
          format: decimal
    
    PayoutsReportResponse:
      type: object
      properties:
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        items:
          type: array
          items:
            $ref: '#/components/schemas/PayoutItem'
        totalAmount:
          type: number
          format: decimal
    
    PayoutItem:
      type: object
      properties:
        id:
          type: string
          format: uuid
        batchId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, executed, failed]
        executedAt:
          type: string
          format: date-time

    MarketIssuanceCard:
      type: object
      properties:
        id:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        issuerName:
          type: string
        totalAmount:
          type: number
          format: decimal
        nominal:
          type: number
          format: decimal
        availableAmount:
          type: number
          format: decimal
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        yield:
          type: number
          format: decimal
          description: Annual yield percentage
        status:
          type: string
          enum: [open, closed]
        publishedAt:
          type: string
          format: date-time
        scheduleJson:
          type: object
          description: Payout schedule

    MarketIssuancesResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/MarketIssuanceCard'
        total:
          type: integer
          description: Total count
        limit:
          type: integer
        offset:
          type: integer

    TxHistoryItem:
      type: object
      properties:
        id:
          type: string
          format: uuid
        type:
          type: string
          enum: [transfer, redeem, issue]
        issuanceId:
          type: string
          format: uuid
        issuanceCode:
          type: string
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, confirmed, failed]
        dltTxHash:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        confirmedAt:
          type: string
          format: date-time
          nullable: true

    TransactionHistoryResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/TxHistoryItem'
        total:
          type: integer

    PayoutHistoryResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/PayoutItem'
        total:
          type: integer
        totalAmount:
          type: number
          format: decimal

    IssuerReportRow:
      type: object
      properties:
        issuanceId:
          type: string
          format: uuid
        assetCode:
          type: string
        assetName:
          type: string
        totalAmount:
          type: number
          format: decimal
        soldAmount:
          type: number
          format: decimal
        investorsCount:
          type: integer
        status:
          type: string
          enum: [draft, published, closed, redeemed]
        issueDate:
          type: string
          format: date
        maturityDate:
          type: string
          format: date
        publishedAt:
          type: string
          format: date-time
          nullable: true

    IssuerIssuancesReportResponse:
      type: object
      properties:
        issuerId:
          type: string
          format: uuid
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        items:
          type: array
          items:
            $ref: '#/components/schemas/IssuerReportRow'
        summary:
          type: object
          properties:
            totalIssuances:
              type: integer
            totalAmount:
              type: number
              format: decimal
            totalSold:
              type: number
              format: decimal
            totalInvestors:
              type: integer

    IssuerPayoutsReportResponse:
      type: object
      properties:
        issuerId:
          type: string
          format: uuid
        period:
          type: object
          properties:
            from:
              type: string
              format: date
            to:
              type: string
              format: date
        granularity:
          type: string
          enum: [day, week, month, year]
        items:
          type: array
          items:
            type: object
            properties:
              period:
                type: string
                description: Period label (depends on granularity)
              totalAmount:
                type: number
                format: decimal
              payoutCount:
                type: integer
              investorsCount:
                type: integer
        summary:
          type: object
          properties:
            totalAmount:
              type: number
              format: decimal
            totalPayouts:
              type: integer
            totalInvestors:
              type: integer

    BrokerClient:
      type: object
      required: [id, name, email, kycStatus, qualificationStatus]
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
          description: Client name
        email:
          type: string
          format: email
        inn:
          type: string
          description: Tax ID (for legal entities)
        type:
          type: string
          enum: [individual, legal_entity]
        kycStatus:
          type: string
          enum: [pending, approved, rejected]
        qualificationStatus:
          type: string
          enum: [none, qualified, unqualified]
        createdAt:
          type: string
          format: date-time
        lastActivityAt:
          type: string
          format: date-time
          nullable: true

    BrokerClientsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/BrokerClient'
        total:
          type: integer
        limit:
          type: integer
        offset:
          type: integer

    CreateBrokerOrderRequest:
      type: object
      required: [clientId, issuanceId, amount]
      properties:
        clientId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
          minimum: 0
          exclusiveMinimum: true

    BrokerOrderResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        clientId:
          type: string
          format: uuid
        issuanceId:
          type: string
          format: uuid
        amount:
          type: number
          format: decimal
        status:
          type: string
          enum: [pending, confirmed, failed, cancelled]
        commission:
          type: number
          format: decimal
          description: Commission amount
        createdAt:
          type: string
          format: date-time

    CommissionRow:
      type: object
      properties:
        period:
          type: string
          description: Period label (YYYY-MM or YYYY-MM-DD)
        totalAmount:
          type: number
          format: decimal
          description: Total order amount
        commissionAmount:
          type: number
          format: decimal
          description: Commission earned
        ordersCount:
          type: integer
          description: Number of orders
        clientsCount:
          type: integer
          description: Number of unique clients

    CommissionsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/CommissionRow'
        total:
          type: integer
        totalAmount:
          type: number
          format: decimal
        totalCommission:
          type: number
          format: decimal

    FeedItem:
      type: object
      required: [id, type, timestamp]
      properties:
        id:
          type: string
          format: uuid
        type:
          type: string
          enum: [order, transfer, payout, kyc, qualification]
        title:
          type: string
          description: Event title
        description:
          type: string
          description: Event description
        clientId:
          type: string
          format: uuid
          nullable: true
        clientName:
          type: string
          nullable: true
        issuanceId:
          type: string
          format: uuid
          nullable: true
        amount:
          type: number
          format: decimal
          nullable: true
        status:
          type: string
          enum: [pending, completed, failed]
          nullable: true
        timestamp:
          type: string
          format: date-time
        metadata:
          type: object
          description: Additional event data
          additionalProperties: true

    FeedResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/FeedItem'
        total:
          type: integer
        hasMore:
          type: boolean

    AuditEvent:
      type: object
      required: [id, actor, action, entity, timestamp]
      properties:
        id:
          type: string
          format: uuid
        actor:
          type: string
          format: uuid
          description: User/system that performed the action
        actorName:
          type: string
          description: Actor name or identifier
        action:
          type: string
          description: Action type (e.g., 'create', 'update', 'delete', 'approve', 'reject')
        entity:
          type: string
          description: Entity type (e.g., 'issuance', 'order', 'kyc', 'investor')
        entityId:
          type: string
          format: uuid
          nullable: true
          description: Entity ID
        payload:
          type: object
          description: Additional event data
          additionalProperties: true
        ip:
          type: string
          format: ipv4
          nullable: true
          description: IP address
        userAgent:
          type: string
          nullable: true
          description: User agent string
        timestamp:
          type: string
          format: date-time
        result:
          type: string
          enum: [success, failure, pending]
          nullable: true
          description: Action result

    AuditEventsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/AuditEvent'
        total:
          type: integer
        limit:
          type: integer
        offset:
          type: integer

    KycDecisionRequest:
      type: object
      required: [decision]
      properties:
        decision:
          type: string
          enum: [approved, rejected]
          description: KYC decision status
        comment:
          type: string
          description: Optional decision comment/reason

    KycDecisionResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [approved, rejected]
        comment:
          type: string
        decisionBy:
          type: string
          format: uuid
          description: User who made the decision
        decisionAt:
          type: string
          format: date-time

    KycApplicationRequest:
      type: object
      properties:
        investorId:
          type: string
          format: uuid
          description: Optional investorId; will default to authenticated user
        fullName:
          type: string
          description: Full name of applicant
        documentType:
          type: string
          description: Document type (passport/inn/other)
        documentNumber:
          type: string
          description: Document number
        comment:
          type: string
          description: Additional comment for backoffice

    KycRequest:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        status:
          type: string
          enum: [pending, approved, rejected]
        reason:
          type: string
          nullable: true
        createdAt:
          type: string
          format: date-time
        resolvedAt:
          type: string
          format: date-time
          nullable: true
    KycDocument:
      type: object
      properties:
        id:
          type: string
          format: uuid
        investorId:
          type: string
          format: uuid
        documentType:
          type: string
          enum: [passport, inn, snils, address_proof, income_proof, other]
        fileName:
          type: string
        fileSize:
          type: integer
          description: File size in bytes
        mimeType:
          type: string
        storageUrl:
          type: string
          format: uri
          description: S3/MinIO storage URL
        uploadedAt:
          type: string
          format: date-time
        uploadedBy:
          type: string
          format: uuid
        comment:
          type: string
          nullable: true

    KycDocumentsResponse:
      type: object
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/KycDocument'
        total:
          type: integer

    IdentityUser:
      type: object
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        roles:
          type: array
          items:
            type: string
        status:
          type: string
          description: User status (active/blocked/invited)
        createdAt:
          type: string
          format: date-time
    
    ProblemDetails:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
          example:
            type: "https://tools.ietf.org/html/rfc7807"
            title: "Bad Request"
            status: 400
            detail: "Invalid request parameters"
    
    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
    
    Forbidden:
      description: Forbidden
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'

>>>> docs/deploy/docker-compose-at-vps/02-env-and-compose.md
---
created: 2025-11-11 15:21
updated: 2025-11-11 15:21
type: runbook
sphere: [devops]
topic: [env, compose]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [compose, env]
---

# 02   `.env`  Compose 

  
- [ ]    `/opt/ois-cfa`
- [ ]  Compose:
  - `docker-compose.yml` ()
  - `docker-compose.override.yml` (/  `.env`)
  - `docker-compose.kafka.override.yml` (Kafka   dev)
  - `docker-compose.services.yml` (.NET  + API gateway)
  - `docker-compose.apps.yml` (:  Next.js)

  (`.env`)
- [ ]  `./ois-cfa/.env`  :
  - [ ]  : `GATEWAY_HOST_PORT=55000`, `IDENTITY_HOST_PORT=55001`, `ISSUANCE_HOST_PORT=55005`, `REGISTRY_HOST_PORT=55006`, `SETTLEMENT_HOST_PORT=55007`, `COMPLIANCE_HOST_PORT=55008`
  - [ ] : `POSTGRES_HOST_PORT=55432`, `KAFKA_HOST_PORT=59092`, `ZOOKEEPER_HOST_PORT=52181`, `KEYCLOAK_HOST_PORT=58080`, `MINIO_HOST_PORT=59000`, `MINIO_CONSOLE_PORT=59001`
  - [ ] : `SERVICE_DB_CONN=Host=postgres;Port=5432;Database=ois;Username=ois;Password=ois_dev_password`
  - [ ] Kafka bootstrap: `KAFKA_BOOTSTRAP=kafka:9092`
  - [ ] (  ) `API_PUBLIC_URL`, `KEYCLOAK_PUBLIC_URL`, `KEYCLOAK_REALM`, `ISSUER_HOST_PORT`, `INVESTOR_HOST_PORT`, `BACKOFFICE_HOST_PORT`

Git/   VPS
- [ ]      : 
  ```bash
  rsync -az --delete --exclude '.git' --exclude 'node_modules' ././ois-cfa/ cfa1:/opt/ois-cfa/
  ```


>>>> docs/deploy/docker-compose-at-vps/05-gateway.md
---
created: 2025-11-11 15:22
updated: 2025-11-11 15:22
type: runbook
sphere: [devops]
topic: [gateway, yarp]
author: alex-a
agentID: co-3a68
partAgentID: [co-3a68]
version: 1.0.0
tags: [yarp, reverse-proxy]
---

# 05  API Gateway (YARP)

  
- [ ] ```bash
  cd /opt/ois-cfa
  C="-f docker-compose.yml -f docker-compose.override.yml -f docker-compose.kafka.override.yml -f docker-compose.services.yml"
  docker compose $C build api-gateway && docker compose $C up -d api-gateway
  curl -sS -o /dev/null -w "%{http_code}\n" http://localhost:55000/health
  ```

  
- [ ]    `apps/api-gateway/appsettings.json` ( `ReverseProxy`)
- [ ]   redeem: `"/v1/issuances/{id}/redeem"` (catchall   )


- [ ] `/health`  200
- [ ]   `/v1/orders/{id}`, `/v1/wallets/{investorId}`  404 (NotFound),       


>>>> docs/deploy/docker-compose-at-vps/10-eywa1-control-plane-runbook.md
---
created: 2025-11-19 18:30
updated: 2025-11-19 21:10
type: runbook
sphere: [devops]
topic: [deploy, control-plane, vps]
author: alex-a
agentID: co-76ca
partAgentID: [co-76ca, co-7b1b]
version: 0.3.0
tags: [eywa1, tmux, ssh, cloudflare, docker-compose]
---

# OISCFA  Eywa1 Control Plane  MultiVPS Runbook

:  `eywa1`    (Control Plane)    OISCFA  VPS (`cfa1`, `fin2`, `germ1`, ),    UK1.

## Scope
- Workspace: `eywa1`,   `~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets`.
- :  `worktree` `repositories/customer-gitlab/wt__ois-cfa__NX01` ( `tasks/NX-01-spec-validate-and-matrix` / `infra.defis.deploy`).
-  : `cfa1`, `fin2`, `germ1`,  (UK1    ,  ).
- DNS: Cloudflare  `*.cfa.llmneighbors.com`, `*.cfa{1,2,3}.llmneighbors.com`.

## TL;DR
- Eywa1   Control Plane:     SSH + `tmux`   ,     `p-cfa`.
-   VPS   `user`  sudo,   (Docker, Node 20, tmux, nginx, postfix)   `/srv/cfa`.
-        `wt__ois-cfa__NX01`: `ops/scripts/deploy/provision-node.sh` (bootstrap)  `ops/scripts/deploy/deploy-node.sh` ( ).
- UK1    (. `docs/deploy/20251113-cloudflare-ingress.md`  `docker-compose-at-vps/*`);        .
-  NX05/06      `wt__ois-cfa__NX01`,    UI/flows   VPS,    runbook.

## Architecture (HighLevel)

```mermaid
flowchart LR
  subgraph Eywa1["eywa1  Control Plane"]
    Agent[CLI agent / user]
    Repo[prj_Cifra-rwa-exachange-assets\nwt__ois-cfa__NX01]
    CF[Cloudflare CLI/API]
    SSHKeys[SSH keys]
  end

  subgraph Nodes["Target VPS nodes"]
    subgraph Node1["cfa1"]
      User1[user sudo]
      Tmux1[tmux session\np-cfa]
      Stack1[OIS-CFA stack\nDocker + PM2]
    end
    subgraph Node2["fin2"]
      User2[user sudo]
      Tmux2[tmux session\np-cfa]
      Stack2[OIS-CFA stack\nDocker + PM2]
    end
  end

  Agent --> Repo
  Agent --> CF
  Agent --> SSHKeys

  SSHKeys --> User1
  SSHKeys --> User2

  Agent -->|provision-node.sh| Node1
  Agent -->|deploy-node.sh| Node1
  Agent -->|provision-node.sh| Node2
  Agent -->|deploy-node.sh| Node2
```

## Phases Overview

1. **Phase 0  Rules & Safety**:     UK1  ,  `user`,  `/srv/cfa`).
2. **Phase 1  Prepare Eywa1**: ,   SSH, Cloudflare CLI,  `wt__ois-cfa__NX01`.
3. **Phase 2  Provision Node**:  VPS (user, SSH,  , tmux, `/srv/cfa`,  `p-cfa`).
4. **Phase 3  Deploy OISCFA Stack**:  `ois-cfa`,  dockercompose,    PM2  nginx.
5. **Phase 4  Verify & Handover**: health, smoke,     memorybank.

---

## Phase 0  Rules & Safety

Why  
-            .

What  
-  ,  /    .

How  
-     / .

Result  
-    bootstrap/deploy        .

### Invariants
- **UK1  **      (. `docs/deploy/20251113-cloudflare-ingress.md`  `docker-compose-at-vps/*`).
- **  `user`**     (   `root`).
- **  **: `/srv/cfa`   .
- **  **    `tmux` `p-cfa`   VPS.
- **  **:    `infra.defis.deploy` (   ),   NX05/06   `wt__ois-cfa__NX01`.

---

## Phase 1  Prepare Eywa1 (Control Plane)

Why  
-     `eywa1`   bootstrap .

What  
-   SSH, Cloudflare,     .

How  
-   +  .

Result  
- `eywa1`     `cfa1`/`fin2`   DNS.

### Checklist
- [ ] SSH `~/.ssh/id_rsa` ( )   `root`/`user`   VPS (`ssh cfa1`, `ssh fin2`   ).
- [ ]  `~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets`  `git pull`  .
- [ ]  `repositories/customer-gitlab/wt__ois-cfa__NX01`     `infra.defis.deploy` / `tasks/NX-01-spec-...`.
- [ ]  `eywa1`  Cloudflare CLI   `curl` + `.env`  `CLOUDFLARE_API_TOKEN` (. `docs/deploy/20251113-cloudflare-ingress.md`).
- [ ]   : `jq`, `tmux`, `git`, `docker` ( `eywa1`   ).

---

## Phase 2  Provision Node (Bootstrap VPS)

Why  
-     ,         VPS .

What  
-  `ops/scripts/deploy/provision-node.sh`  bootstrap:  `user`, , Docker, Node, tmux, `p-cfa`.

How  
-    `eywa1`,   SSH   VPS.

Result  
-  `cfa1`/`fin2`   ,      OISCFA.

### Minimal usage

```bash
cd ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets/repositories/customer-gitlab/wt__ois-cfa__NX01
ops/scripts/deploy/provision-node.sh cfa1
ops/scripts/deploy/provision-node.sh fin2
```

### What it standardizes
-  ( )  `user`   `sudo`.
-   : `curl`, `git`, `tmux`, `jq`, `ufw`, `docker`, `docker-compose-plugin`, `nginx`, `postfix`.
-  Node.js 20  `user` ( `nvm`   ,   ).
-  `/srv/cfa`,   `user:user`.
-   `~user/.tmux.conf`  `set-option -g history-limit 1000000`.
-  ( ) `tmux` `p-cfa`,   `/srv/cfa`.

---

## Phase 3  Deploy OISCFA Stack

Why  
-       ,     .

What  
-  `ops/scripts/deploy/deploy-node.sh`  `ois-cfa`,     dockercompose + .

How  
-  `eywa1`     ;     `tmux` `p-cfa`  VPS.

Result  
-   VPS   OISCFA,   smoke NX05/06.

### Minimal usage

```bash
cd ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets/repositories/customer-gitlab/wt__ois-cfa__NX01
OIS_CFA_BRANCH=infra.defis.deploy ops/scripts/deploy/deploy-node.sh cfa1
OIS_CFA_BRANCH=infra.defis.deploy ops/scripts/deploy/deploy-node.sh fin2
```

### Notes
-     `git@git.telex.global:npk/ois-cfa.git`   `infra.defis.deploy` (   ).
-  **  **  `.env`     (. `docs/deploy/docker-compose-at-vps/02-env-and-compose.md`).
-   (Next.js)    scaffold   `tmux`,   `pm2`  `env.local`    UK1 (.  `co-3dd7`  `20251113-cloudflare-ingress.md`).

---

## Phase 4  Verify & Handover

Why  
-   health     ,   ,  .

What  
-  `/health`   UI,    .

How  
-  curl,  UI walkthrough,    Playwright e2e.

Result  
- ,      .

### Basic health
- [ ] `curl http://<host>:55000/health` (gateway)  `200 OK`.
- [ ] `curl http://<host>:55005/health` (issuance), `55006` (registry), `55007` (settlement), `55008` (compliance).
- [ ] Keycloak   HTTP (  ingress/TLS).

### Smokeflows ()
- [ ] Issuer   (     nginx/Cloudflare).
- [ ]  issuanceflow (     payout schedule).
- [ ]   `/reports` ( NX05 implementation).

### Memorybank / Logging
- [ ]    `memory-bank/Scrum/<date>/<timestamp>-<host>-bootstrap.session.md`        tmux.

---

## Troubleshooting / Lessons Learned

- **   (`chown -R user:user`).**  
    `/opt/ois-cfa`     `root`  (Next.js)  `npm install`  `user`   `EACCES`  `package-lock.json`/`node_modules`.  
  :  bootstrap/    :
  -  Control Plane: `chown -R user:user /srv/cfa/ois-cfa` (  ).  
  -   UK1 (  cfa1): `chown -R user:user /opt/ois-cfa`.

- **NEXTAUTH_URL  Redirect URIs  Keycloak.**  
   `NEXTAUTH_URL`/ URL  (`issuer|investor|backoffice.cfa{N}.llmneighbors.com`)    `redirectUris`/`webOrigins`  Keycloak, /  (loop, `invalid redirect`,  ).  
  :
  -   `portal-issuer`, `portal-investor`, `backoffice`  realm `ois-dev` :
    - `rootUrl = https://<app>.cfa{N}.llmneighbors.com`
    - `redirectUris = ["https://<app>.cfa{N}.llmneighbors.com/*"]`
    - `webOrigins = ["https://<app>.cfa{N}.llmneighbors.com"]`
  -  `.env.local`  `NEXTAUTH_URL`       httpsURL.

- **Playwright   smoke  ingress.**  
  E2E (`tests/e2e-playwright`)   `issuer|investor|backoffice.cfa1.llmneighbors.com`    Keycloak   ,    (DNS/TLS/nginx + backend +  + )  endtoend.    `artifacts/tests/e2e/playwright/*.e2e.png`  timestamp  run id.

---

## Definition of Done (DoD)

### 1. Control Plane & Scripts
- [x] Runbook `10-eywa1-control-plane-runbook.md`   `ops/scripts/deploy/*`     (`deploy`/`tasks/NX-01-*`)    `README`/manifests.
- [x]   `cfa1`  `fin2`   Phases 13 (Control Plane baseline):
  - [x]   `user` (sudo + docker),  SSH  .
  - [x]   `/srv/cfa`,  `tmux` `p-cfa`.
  - [x]  `npk/ois-cfa`   `/srv/cfa/ois-cfa`    (work3)    UK1.
- [ ]  UK1 ** **    (   ).

### 2. Parity  UK1  docker-compose runbook (0009)
    (`uk1`, `cfa1`, `cfa2`/`fin2`)      `docker-compose-at-vps`:

- [ ] 0002: `00-overview.md`, `01-prereqs-and-host-prep.md`, `02-env-and-compose.md`  , `.env`  compose .
- [ ] 0304: `03-infra.md`, `04-services.md`    (Postgres, Kafka, Minio)  .NET   `docker compose`.
- [ ] 0506: `05-gateway.md`, `06-keycloak.md`  API gateway  Keycloak , health   .
- [ ] 0708: `07-frontends*.md`, `08-smoke-tests.md`   (Issuer/Investor/Backoffice)  (PM2  dev), basic UX  e2e smoke .

       DoD/  `memory-bank` (, `*-cfa1-fin2-deploy-DoD.md`),      .

### 3. DNS, TLS  Ingress (Cloudflare + nginx)
- [ ]  UK1:   `auth|issuer|investor|backoffice|api.cfa.llmneighbors.com`  wildcard `*.cfa.llmneighbors.com` (. `20251113-cloudflare-ingress.md`).
- [x]  `cfa1`:  A  Cloudflare `auth|issuer|investor|backoffice|api.cfa1.llmneighbors.com`  IP `cfa1`;    LE `*.cfa1.llmneighbors.com`, nginx .
- [ ]  `cfa2` (fin2):  `cfa1`,    `*.cfa2.llmneighbors.com`  IP `fin2`,   UK1  .
- [ ]      `Service  URL  Health endpoint  Notes` ( docs/ memorybank).

### 3a. Multiaccount Cloudflare / domains
- [ ]    (, `cfa1`  `cfa2/fin2`)   **** Cloudflare   (. `docs/deploy/MULTI_ACCOUNT_SETUP.md`),      `*.cfa{N}.llmneighbors.com`   .

### 4. NX05 / NX06 Readiness
- [x] ,    (`uk1`, `cfa1`, `cfa2/fin2`)      NX05/NX06 (issuer dashboard, reports, payout schedule).
- [x]    ( `cfa1`) :
  - [x]  issuer     (`issuer.cfa1.llmneighbors.com`).
  - [x]  issuance   `/reports`,   runbook `08-smoke-tests.md`  e2e Playwright.
  - [x]   (  realm/URL/)    backend/FE    (. e2e `.env`  memorybank DoD  cfa1).

### CFA1    (20251119)
- [x] Control Plane: `user` + `/srv/cfa` + `tmux p-cfa` +  `ois-cfa` (work3).
- [x] Backend: Postgres, Kafka/ZK, Minio, Keycloak,  .NET  API Gateway ;  `/health`  `200`.
- [x] Ingress: DNS/TLS/nginx   `auth|issuer|investor|backoffice|api.cfa1.llmneighbors.com`; `https://api.cfa1.../health`  `200`.
- [x] Frontends: Issuer/Investor/Backoffice   dev PM2; `curl -I https://issuer|investor|backoffice.cfa1...`  30x  .
- [x] E2E: Playwright (`public-auth`, `backoffice-auth`, `self-registration`)   cfa1;     `artifacts/tests/e2e/playwright`.

---

## Agent Kickoff Prompt (Codex/Claude/Gemini)

     CLI,    runbook  `wt__ois-cfa__NX01`.       (,  cfa1   fin2  NX05/06).

```text
You are a DevOps/Backend engineer working on the OIS-CFA project.

Workspace:
- You are running on host "eywa1".
- Local repo: ~/__Repositories/yury-customer/prj_Cifra-rwa-exachange-assets
- Main backend worktree: repositories/customer-gitlab/wt__ois-cfa__NX01 (branch tasks/NX-01-spec-validate-and-matrix / infra.defis.deploy)

Goal:
- Provision and deploy the OIS-CFA stack to a target VPS (e.g. cfa1 or fin2)
  using the "Eywa1 Control Plane" approach described in:
  - docs/deploy/docker-compose-at-vps/00-overview.md
  - docs/deploy/docker-compose-at-vps/10-eywa1-control-plane-runbook.md

Hard rules:
- DO NOT touch or modify the existing UK1 environment (prod demo).
- Use only the "user" account with sudo on target nodes (no root-only services).
- Use /srv/cfa as the project root on all nodes.
- Run all long-running commands inside tmux session "p-cfa" on the target node.
- For code changes and NX-05/06 work, treat wt__ois-cfa__NX01 as the primary tree.

Phases:
1) Phase 1  validate Eywa1: SSH keys, Cloudflare token, local repo state.
2) Phase 2  run ops/scripts/deploy/provision-node.sh <host> to bootstrap the node.
3) Phase 3  run ops/scripts/deploy/deploy-node.sh <host> with the correct branch.
4) Phase 4  run health checks (/health, Keycloak, portals) and record results in memory-bank.

Output expectations:
- Follow Why  What  How  Result structure.
- Use numbered steps and small tables where helpful.
- Explicitly call out any deviations from the runbook (SPEC DIFF-like).
```

>>>> ops/scripts/deploy/deploy-node.sh
#!/bin/bash
set -euo pipefail

# OIS-CFA  Deploy Node Script
# Usage:
#   ./ops/scripts/deploy/deploy-node.sh <host>
#
# Responsibilities:
#   - Ensure tmux session "p-cfa" exists on target host
#   - Clone or update ois-cfa repo under /srv/cfa (or REMOTE_PROJECT_ROOT)
#   - Checkout desired branch (infra.defis.deploy by default)
#   - Run docker compose to start backend stack
#   - Prepare basic commands for frontends (Next.js + PM2) inside tmux
#   - Hint: after clone, ensure the project tree is writable by SSH_USER (e.g. chown -R user:user /srv/cfa/ois-cfa)
#   - Optional: set DEPLOY_FIX_PERMS=1 to force chown even if already cloned (avoids npm/pm2 EACCES)

usage() {
  echo "Usage: $0 <host>" >&2
  echo "Environment (optional):" >&2
  echo "  SSH_USER             - SSH user for connection (default: user)" >&2
  echo "  REMOTE_PROJECT_ROOT  - Project root on target (default: /srv/cfa)" >&2
  echo "  OIS_CFA_GIT_URL      - Git URL for ois-cfa (default: git@git.telex.global:npk/ois-cfa.git)" >&2
  echo "  OIS_CFA_BRANCH       - Branch to checkout (default: infra.defis.deploy)" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

TARGET_HOST="${1:-}"
if [ -z "$TARGET_HOST" ]; then
  usage
fi

SSH_USER="${SSH_USER:-user}"
REMOTE_PROJECT_ROOT="${REMOTE_PROJECT_ROOT:-/srv/cfa}"
OIS_CFA_GIT_URL="${OIS_CFA_GIT_URL:-git@git.telex.global:npk/ois-cfa.git}"
OIS_CFA_BRANCH="${OIS_CFA_BRANCH:-infra.defis.deploy}"
SSH_OPTS="-o StrictHostKeyChecking=accept-new"
FIX_PERMS="${DEPLOY_FIX_PERMS:-0}"

echo ">>> Deploying OIS-CFA to host '${TARGET_HOST}' as ${SSH_USER}"
echo "    REMOTE_PROJECT_ROOT=${REMOTE_PROJECT_ROOT}"
echo "    OIS_CFA_GIT_URL=${OIS_CFA_GIT_URL}"
echo "    OIS_CFA_BRANCH=${OIS_CFA_BRANCH}"

SSH_CMD="ssh -A ${SSH_OPTS} ${SSH_USER}@${TARGET_HOST}"

$SSH_CMD bash -s << EOF
set -euo pipefail

echo ">>> [\$(hostname)] Phase 3  Deploy OIS-CFA Stack"

if ! command -v tmux >/dev/null 2>&1; then
  echo "ERROR: tmux is not installed. Run provision-node.sh first." >&2
  exit 1
fi

mkdir -p "${REMOTE_PROJECT_ROOT}"
cd "${REMOTE_PROJECT_ROOT}"

if ! tmux has-session -t p-cfa 2>/dev/null; then
  echo ">>> Creating tmux session 'p-cfa'"
  tmux new-session -d -s p-cfa -c "${REMOTE_PROJECT_ROOT}"
else
  echo ">>> Reusing existing tmux session 'p-cfa'"
fi

tmux send-keys -t p-cfa "set -euo pipefail" C-m
tmux send-keys -t p-cfa "cd '${REMOTE_PROJECT_ROOT}'" C-m

if [ ! -d "${REMOTE_PROJECT_ROOT}/ois-cfa/.git" ]; then
  echo ">>> Cloning ois-cfa repo"
  tmux send-keys -t p-cfa "git clone '${OIS_CFA_GIT_URL}' ois-cfa" C-m
  tmux send-keys -t p-cfa "cd ois-cfa" C-m
else
  echo ">>> Updating existing ois-cfa repo"
  tmux send-keys -t p-cfa "cd ois-cfa" C-m
fi

tmux send-keys -t p-cfa "git fetch origin" C-m
tmux send-keys -t p-cfa "git checkout '${OIS_CFA_BRANCH}'" C-m
tmux send-keys -t p-cfa "git pull --ff-only origin '${OIS_CFA_BRANCH}'" C-m

if [ "$FIX_PERMS" = "1" ]; then
  tmux send-keys -t p-cfa "echo '>>> Fixing permissions for ${SSH_USER} on ${REMOTE_PROJECT_ROOT}/ois-cfa (DEPLOY_FIX_PERMS=1)'" C-m
  tmux send-keys -t p-cfa "sudo chown -R ${SSH_USER}:${SSH_USER} '${REMOTE_PROJECT_ROOT}/ois-cfa' || echo 'WARNING: chown failed, check permissions or sudo rights'" C-m
else
  tmux send-keys -t p-cfa "echo '>>> NOTE: permissions not changed (set DEPLOY_FIX_PERMS=1 to force chown if npm/pm2 EACCES)'" C-m
fi

tmux send-keys -t p-cfa "echo '>>> NOTE: ensure .env files are prepared as per docs/deploy/docker-compose-at-vps/02-env-and-compose.md'" C-m

tmux send-keys -t p-cfa "docker compose -f docker-compose.yml -f docker-compose.override.yml up -d" C-m

tmux send-keys -t p-cfa "echo '>>> Backend stack started. Next steps: configure Keycloak, nginx, and PM2 frontends as per docs/deploy/docker-compose-at-vps/* and 20251113-cloudflare-ingress.md'" C-m

echo ">>> Commands sent to tmux session 'p-cfa'. Attach with: tmux attach -t p-cfa"
EOF

echo ">>> Deploy commands dispatched to host '${TARGET_HOST}'"

>>>> ops/scripts/deploy/provision-node.sh
#!/bin/bash
set -euo pipefail

# OIS-CFA  Provision Node Script
# Usage:
#   ./ops/scripts/deploy/provision-node.sh <host>
#
# Responsibilities (idempotent as much as possible):
#   - Ensure sudo user "user" exists on target host
#   - Install base packages (curl, git, tmux, jq, docker, docker-compose plugin, nginx, postfix)
#   - Install Node.js 20 for "user" (via nvm or system package)
#   - Create /srv/cfa and set ownership to user:user
#   - Configure tmux history-limit (1_000_000) for user
#   - Create tmux session "p-cfa" with working dir /srv/cfa

usage() {
  echo "Usage: $0 <host>" >&2
  echo "Environment (optional):" >&2
  echo "  SSH_USER         - SSH user for initial connection (default: root)" >&2
  echo "  REMOTE_USER      - App user to create/use (default: user)" >&2
  echo "  REMOTE_PROJECT_ROOT - Project root on target (default: /srv/cfa)" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

TARGET_HOST="${1:-}"
if [ -z "$TARGET_HOST" ]; then
  usage
fi

SSH_USER="${SSH_USER:-root}"
REMOTE_USER="${REMOTE_USER:-user}"
REMOTE_PROJECT_ROOT="${REMOTE_PROJECT_ROOT:-/srv/cfa}"

SSH_OPTS="-o StrictHostKeyChecking=accept-new"

echo ">>> Provisioning host '${TARGET_HOST}' via ${SSH_USER}"

ssh $SSH_OPTS "${SSH_USER}@${TARGET_HOST}" \
  REMOTE_USER="$REMOTE_USER" REMOTE_PROJECT_ROOT="$REMOTE_PROJECT_ROOT" bash -s << 'EOF'
set -euo pipefail

echo ">>> [$(hostname)] Phase 2  Provision Node"
echo "    REMOTE_USER=${REMOTE_USER}"
echo "    REMOTE_PROJECT_ROOT=${REMOTE_PROJECT_ROOT}"

if ! id "${REMOTE_USER}" >/dev/null 2>&1; then
  echo ">>> Creating user '${REMOTE_USER}' with sudo"
  useradd -m -s /bin/bash "${REMOTE_USER}"
  usermod -aG sudo "${REMOTE_USER}"
else
  echo ">>> User '${REMOTE_USER}' already exists, skipping creation"
fi

echo ">>> Propagating SSH authorized_keys to '${REMOTE_USER}' (if available)"
SRC_AUTH_KEYS=""
if [ -f /root/.ssh/authorized_keys ]; then
  SRC_AUTH_KEYS="/root/.ssh/authorized_keys"
fi

if [ -n "$SRC_AUTH_KEYS" ]; then
  install -d -m 700 "/home/${REMOTE_USER}/.ssh"
  cp "$SRC_AUTH_KEYS" "/home/${REMOTE_USER}/.ssh/authorized_keys"
  chown -R "${REMOTE_USER}:${REMOTE_USER}" "/home/${REMOTE_USER}/.ssh"
  chmod 700 "/home/${REMOTE_USER}/.ssh"
  chmod 600 "/home/${REMOTE_USER}/.ssh/authorized_keys"
else
  echo ">>> WARNING: no source authorized_keys found, SSH key-based login for '${REMOTE_USER}' must be configured manually" >&2
fi

echo ">>> Installing base packages (curl, git, tmux, jq, ufw, docker, nginx, postfix)"
export DEBIAN_FRONTEND=noninteractive
apt-get update -y
apt-get install -y \
  ca-certificates curl git tmux jq ufw \
  nginx postfix

if ! command -v docker >/dev/null 2>&1; then
  echo ">>> Installing Docker Engine + compose plugin"
  install -m 0755 -d /etc/apt/keyrings
  if [ ! -f /etc/apt/keyrings/docker.gpg ]; then
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg
  fi
  . /etc/os-release
  echo "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  "$VERSION_CODENAME" stable" >/etc/apt/sources.list.d/docker.list
  apt-get update -y
  apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
  systemctl enable --now docker
else
  echo ">>> Docker already installed, skipping"
fi

echo ">>> Ensuring '${REMOTE_USER}' is in 'docker' group"
if getent group docker >/dev/null 2>&1; then
  usermod -aG docker "${REMOTE_USER}" || echo ">>> WARNING: failed to add ${REMOTE_USER} to docker group" >&2
else
  echo ">>> WARNING: docker group not found; Docker permissions for ${REMOTE_USER} may need manual adjustment" >&2
fi

echo ">>> Ensuring ${REMOTE_PROJECT_ROOT} exists"
mkdir -p "${REMOTE_PROJECT_ROOT}"
chown -R "${REMOTE_USER}:${REMOTE_USER}" "${REMOTE_PROJECT_ROOT}"

echo ">>> Installing Node.js 20 for ${REMOTE_USER} (via nvm if not present)"
su - "${REMOTE_USER}" -c 'bash -s' << 'EONVM'
set -euo pipefail
if [ ! -d "$HOME/.nvm" ]; then
  echo ">>> Installing nvm for ${USER}"
  curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
fi

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"

if ! nvm ls 20 >/dev/null 2>&1; then
  echo ">>> Installing Node.js 20 via nvm"
  nvm install 20
fi
nvm alias default 20
EONVM

TMUX_CONF="/home/${REMOTE_USER}/.tmux.conf"
if [ -f "\$TMUX_CONF" ]; then
  if ! grep -q 'history-limit' "\$TMUX_CONF"; then
    echo "set-option -g history-limit 1000000" >> "\$TMUX_CONF"
  fi
else
  echo "set-option -g history-limit 1000000" > "\$TMUX_CONF"
fi
chown "${REMOTE_USER}:${REMOTE_USER}" "\$TMUX_CONF"

echo ">>> Creating tmux session 'p-cfa' (if not exists)"
su - "${REMOTE_USER}" -c "tmux has-session -t p-cfa 2>/dev/null || tmux new-session -d -s p-cfa -c '${REMOTE_PROJECT_ROOT}'"

echo ">>> Provisioning done on \$(hostname)"
EOF

echo ">>> Host '${TARGET_HOST}' provisioned successfully"

>>>> ops/scripts/auth/fix-redirects.sh
#!/bin/bash
set -euo pipefail

# OIS-CFA  Keycloak redirects/webOrigins fixer for cfa1
# Runs inside the ois-keycloak container via kcadm.sh
#
# Usage:
#   BASE_DOMAIN=cfa1.llmneighbors.com ./ops/scripts/auth/fix-redirects.sh
#
# Env (optional):
#   KC_CONTAINER   - keycloak container name (default: ois-keycloak)
#   KC_URL         - Keycloak admin URL (default: http://localhost:8080)
#   KC_USER        - admin user (default: admin)
#   KC_PASS        - admin password (default: admin123)
#   REALM          - target realm (default: ois-dev)
#   BASE_DOMAIN    - base domain (default: cfa1.llmneighbors.com)

KC_CONTAINER="${KC_CONTAINER:-ois-keycloak}"
KC_URL="${KC_URL:-http://localhost:8080}"
KC_USER="${KC_USER:-admin}"
KC_PASS="${KC_PASS:-admin123}"
REALM="${REALM:-ois-dev}"
BASE_DOMAIN="${BASE_DOMAIN:-cfa1.llmneighbors.com}"

echo ">>> Fix Keycloak redirects for realm='${REALM}' domain='${BASE_DOMAIN}' in container='${KC_CONTAINER}'"

docker exec \
  -e KC_URL="$KC_URL" \
  -e KC_USER="$KC_USER" \
  -e KC_PASS="$KC_PASS" \
  -e REALM="$REALM" \
  -e BASE_DOMAIN="$BASE_DOMAIN" \
  "${KC_CONTAINER}" bash -lc '
set -euo pipefail

KC_URL="${KC_URL:-http://localhost:8080}"
KC_USER="${KC_USER:-admin}"
KC_PASS="${KC_PASS:-admin123}"
REALM="${REALM:-ois-dev}"
BASE_DOMAIN="${BASE_DOMAIN:-cfa1.llmneighbors.com}"
KCADM=/opt/keycloak/bin/kcadm.sh

clients=(
  "portal-issuer:issuer"
  "portal-investor:investor"
  "backoffice:backoffice"
)

echo ">> Authenticating to ${KC_URL} (realm master) ..."
"${KCADM}" config credentials --server "${KC_URL}" --realm master --user "${KC_USER}" --password "${KC_PASS}"

update_client() {
  local client_id="$1"
  local host_prefix="$2"
  local host="${host_prefix}.${BASE_DOMAIN}"
  local root_url="https://${host}"
  local redirects="[\"${root_url}/*\"]"
  local origins="[\"${root_url}\"]"

  local rid
  rid=$("${KCADM}" get clients -r "${REALM}" -q clientId="${client_id}" | sed -n '\''s/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p'\'' | head -1 || true)
  if [ -z "${rid:-}" ]; then
    echo "WARN: client_id=${client_id} not found in realm ${REALM}, skipping"
    return
  fi

  echo ">> Updating ${client_id} for host ${host}"
  "${KCADM}" update "clients/${rid}" -r "${REALM}" \
    -s "rootUrl=${root_url}" \
    -s "redirectUris=${redirects}" \
    -s "webOrigins=${origins}"
}

for entry in "${clients[@]}"; do
  IFS=":" read -r cid prefix <<< "${entry}"
  update_client "${cid}" "${prefix}"
done

echo ">> Done."
'

echo ">>> Keycloak client redirect/webOrigins update completed."

>>>> ops/scripts/cloudflare-dns-upsert.sh
#!/bin/bash
set -euo pipefail

# OIS-CFA  Cloudflare DNS Upsert Helper
#
# Purpose:
#   Upsert A-records for a given host label set in a Cloudflare zone.
#   Used from eywa1 to configure DNS for cfa1/cfa2/etc with different accounts/domains.
#
# Usage:
#   ./ops/scripts/cloudflare-dns-upsert.sh <config-env-file> <ip-address>
#
# Where <config-env-file> exports:
#   CF_ZONE_NAME     - Cloudflare zone name (e.g. llmneighbors.com)
#   CF_ZONE_ID       - Cloudflare zone id
#   CF_API_TOKEN     - API token with DNS edit permission for this zone
#   CF_HOST_PREFIXES - Comma-separated host prefixes (e.g. "auth,issuer,investor,backoffice,api")
#   CF_BASE_LABEL    - Base label for this environment (e.g. "cfa1" => auth.cfa1.<zone>)
#
# Example:
#   ./ops/scripts/cloudflare-dns-upsert.sh \
#     /home/user/__Repositories/cloudflare__developerisnow/.env.cfa1 \
#     87.249.49.56

usage() {
  echo "Usage: $0 <config-env-file> <ip-address>" >&2
  exit 1
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  usage
fi

CONFIG_FILE="${1:-}"
TARGET_IP="${2:-}"

if [ -z "$CONFIG_FILE" ] || [ -z "$TARGET_IP" ]; then
  usage
fi

if [ ! -f "$CONFIG_FILE" ]; then
  echo "ERROR: config-env-file '$CONFIG_FILE' not found" >&2
  exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
  echo "ERROR: jq is required for parsing Cloudflare responses (apt-get install jq)" >&2
  exit 1
fi

# shellcheck disable=SC1090
set -a && source "$CONFIG_FILE" && set +a

: "${CF_ZONE_NAME:?CF_ZONE_NAME is required in config-env-file}"
: "${CF_ZONE_ID:?CF_ZONE_ID is required in config-env-file}"
: "${CF_API_TOKEN:?CF_API_TOKEN is required in config-env-file}"
: "${CF_HOST_PREFIXES:?CF_HOST_PREFIXES is required in config-env-file}"
: "${CF_BASE_LABEL:?CF_BASE_LABEL is required in config-env-file}"

echo ">>> Cloudflare DNS upsert"
echo "    Zone:   ${CF_ZONE_NAME} (${CF_ZONE_ID})"
echo "    IP:     ${TARGET_IP}"
echo "    Prefix: ${CF_HOST_PREFIXES}"
echo "    Label:  ${CF_BASE_LABEL}"

CF_API_BASE="https://api.cloudflare.com/client/v4"

create_or_update() {
  local HOST_PREFIX="$1"
  local NAME="${HOST_PREFIX}.${CF_BASE_LABEL}"
  local FQDN="${NAME}.${CF_ZONE_NAME}"

  echo "-- upsert ${FQDN} -> ${TARGET_IP}"

  local EXIST_ID
  EXIST_ID=$(
    curl -s -X GET "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records?type=A&name=${FQDN}" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" |
      jq -r '.result[0].id // empty'
  )

  local PAYLOAD
  PAYLOAD=$(jq -n \
    --arg type "A" \
    --arg name "${FQDN}" \
    --arg content "${TARGET_IP}" \
    --argjson ttl 1 \
    --argjson proxied false \
    '{type: $type, name: $name, content: $content, ttl: $ttl, proxied: $proxied}')

  if [ -n "$EXIST_ID" ] && [ "$EXIST_ID" != "null" ]; then
    curl -s -X PATCH "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records/${EXIST_ID}" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" \
      --data "$PAYLOAD" >/dev/null
  else
    curl -s -X POST "${CF_API_BASE}/zones/${CF_ZONE_ID}/dns_records" \
      -H "Authorization: Bearer ${CF_API_TOKEN}" \
      -H "Content-Type: application/json" \
      --data "$PAYLOAD" >/dev/null
  fi
}

IFS=',' read -r -a PREFIXES <<<"$CF_HOST_PREFIXES"
for prefix in "${PREFIXES[@]}"; do
  prefix_trimmed="${prefix//[[:space:]]/}"
  [ -z "$prefix_trimmed" ] && continue
  create_or_update "$prefix_trimmed"
done

echo ">>> DNS upsert completed."


>>>> scripts/git/zip_branches.sh
#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <branches-file> [base-branch]" >&2
  exit 1
fi

branches_file="$1"
base_branch="${2:-infra.defis.deploy}"

if [[ ! -f "$branches_file" ]]; then
  echo "Branch list file not found: $branches_file" >&2
  exit 1
fi

repo_root="$(git rev-parse --show-toplevel)"
cd "$repo_root"

git fetch origin --prune >/dev/null 2>&1 || true

cleanup_worktree() {
  local branch="$1"
  local path
  path=$(git worktree list --porcelain | awk -v b="$branch" '
    $1 == "worktree" { wt=$2 }
    $1 == "branch" {
      gsub("refs/heads/", "", $2)
      if ($2 == b) {
        print wt
      }
    }
  ' | head -n1)

  if [[ -n "$path" ]]; then
    if [[ -n "$(git -C "$path" status --porcelain)" ]]; then
      echo "[SKIP] Worktree $path for $branch has uncommitted changes" >&2
      return 1
    fi
    git worktree remove "$path"
  fi
  return 0
}

while IFS= read -r raw_branch || [[ -n "$raw_branch" ]]; do
  branch="$(echo "$raw_branch" | xargs)"
  [[ -z "$branch" || "$branch" =~ ^# ]] && continue

  echo "--- Archiving $branch ---"

  if ! git show-ref --verify --quiet "refs/heads/$branch"; then
    if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
      git fetch origin "$branch:$branch"
    else
      echo "[SKIP] Branch $branch not found locally or on origin" >&2
      continue
    fi
  fi

  if ! git show-ref --verify --quiet "refs/heads/$base_branch"; then
    git fetch origin "$base_branch:$base_branch"
  fi

  if ! git merge-base --is-ancestor "$branch" "$base_branch"; then
    echo "[SKIP] $branch is not merged into $base_branch" >&2
    continue
  fi

  if ! cleanup_worktree "$branch"; then
    continue
  fi

  tag_name="zip/$branch"
  if git rev-parse --verify --quiet "refs/tags/$tag_name"; then
    echo "[INFO] Tag $tag_name already exists, skipping tag creation"
  else
    git tag "$tag_name" "$branch"
    git push origin "$tag_name"
  fi

  if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
    git push origin --delete "$branch" || true
  fi

  git branch -D "$branch"
  echo "[DONE] $branch archived as $tag_name"
done < "$branches_file"

